;; Object semanticdb-project-database-file-cfe260
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file-cfe260"
  :tables
  (list
    (semanticdb-table "semanticdb-table-cfe200"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("easy-mmode-pretty-mode-name" function (:arguments ("mode" "lighter")) nil [2075 3574])
            ("easy-mmode--arg-docstring" variable
               (:constant-flag t
                :default-value "

If called interactively, enable %s if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.")
                nil [3576 3847])
            ("easy-mmode--mode-docstring" function (:arguments ("doc" "mode-pretty-name" "keymap-sym")) nil [3849 4341])
            ("defalias" code nil nil [4358 4417])
            ("define-minor-mode" function (:arguments ("mode" "doc" "init-value" "lighter" "keymap" "body")) nil [4433 15048])
            ("defalias" code nil nil [15102 15173])
            ("defalias" code nil nil [15189 15255])
            ("define-globalized-minor-mode" function (:arguments ("global-mode" "mode" "turn-on" "keys")) nil [15271 21157])
            ("easy-mmode-set-keymap-parents" function (:arguments ("m" "parents")) nil [21190 21330])
            ("easy-mmode-define-keymap" function (:arguments ("bs" "name" "m" "args")) nil [21347 23058])
            ("easy-mmode-defmap" function (:arguments ("m" "bs" "doc" "args")) nil [23075 23430])
            ("easy-mmode-define-syntax" function (:arguments ("css" "args")) nil [23468 23910])
            ("easy-mmode-defsyntax" function (:arguments ("st" "css" "doc" "args")) nil [23927 24263])
            ("easy-mmode-define-navigation" function (:arguments ("base" "re" "name" "endfun" "narrowfun" "body")) nil [24310 27256])
            ("easy-mmode" package nil nil [27259 27280]))          
      :file "easy-mmode.el.gz"
      :pointmax 27310
      :fsize 8826
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-cfe220"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("cl-lib" include nil nil [1547 1564])
            ("macroexp" include nil nil [1565 1584])
            ("gv" include nil nil [1660 1673])
            ("cl--pop2" function (:arguments ("place")) nil [1675 1803])
            ("cl--optimize-safety" variable nil nil [1805 1833])
            ("cl--optimize-speed" variable nil nil [1834 1861])
            ("cl--compiler-macro-list*" function (:arguments ("_form" "arg" "others")) nil [2068 2279])
            ("define-obsolete-function-alias" code nil nil [2464 2561])
            ("cl--simple-funcs" variable
               (:constant-flag t
                :default-value '(car cdr nth aref elt if and or + - 1+ 1- min max car-safe cdr-safe progn prog1 prog2))
                nil [2707 2829])
            ("cl--safe-funcs" variable
               (:constant-flag t
                :default-value '(* / % length memq list vector vectorp < > <= >= = error))
                nil [2830 2919])
            ("cl--simple-expr-p" function (:arguments ("x" "size")) nil [2921 3424])
            ("cl--simple-exprs-p" function (:arguments ("xs")) nil [3426 3539])
            ("cl--safe-expr-p" function (:arguments ("x")) nil [3541 3917])
            ("cl--const-expr-p" function (:arguments ("x")) nil [3982 4240])
            ("cl--const-expr-val" function (:arguments ("x")) nil [4242 4607])
            ("cl--expr-contains" function (:arguments ("x" "y")) nil [4609 5254])
            ("cl--expr-contains-any" function (:arguments ("x" "y")) nil [5256 5357])
            ("cl--expr-depends-p" function (:arguments ("x" "y")) nil [5359 5551])
            ("cl--gensym-counter" variable nil nil [5567 5596])
            ("cl-gensym" function (:arguments ("prefix")) nil [5612 5969])
            ("cl--gentemp-counter" variable nil nil [5971 6001])
            ("cl-gentemp" function (:arguments ("prefix")) nil [6017 6385])
            ("def-edebug-spec" code nil nil [6412 6481])
            ("def-edebug-spec" code nil nil [6483 6561])
            ("def-edebug-spec" code nil nil [6563 6916])
            ("def-edebug-spec" code nil nil [6918 7003])
            ("def-edebug-spec" code nil nil [7005 7105])
            ("def-edebug-spec" code nil nil [7107 7166])
            ("def-edebug-spec" code nil nil [7168 7612])
            ("def-edebug-spec" code nil nil [7614 7649])
            ("cl--lambda-list-keywords" variable
               (:constant-flag t
                :default-value '(&optional &rest &key &allow-other-keys &aux &whole &body &environment))
                nil [7651 7761])
            ("cl--bind-block" variable nil nil [8409 8432])
            ("cl--bind-defs" variable nil nil [8489 8511])
            ("cl--bind-enquote" variable nil nil [8568 8593])
            ("cl--bind-lets" variable nil nil [8648 8670])
            ("cl--bind-forms" variable nil nil [8671 8694])
            ("cl--transform-lambda" function (:arguments ("form" "bind-block")) nil [8696 13463])
            ("cl-defun" function (:arguments ("name" "args" "body")) nil [13480 14730])
            ("cl-iter-defun" function (:arguments ("name" "args" "body")) nil [14747 15552])
            ("def-edebug-spec" code nil nil [15718 16233])
            ("def-edebug-spec" code nil nil [16235 16292])
            ("def-edebug-spec" code nil nil [16294 16817])
            ("cl-defmacro" function (:arguments ("name" "args" "body")) nil [16834 17901])
            ("def-edebug-spec" code nil nil [17903 18063])
            ("def-edebug-spec" code nil nil [18117 18371])
            ("cl-function" function (:arguments ("func")) nil [18388 18829])
            ("cl--make-usage-var" function (:arguments ("x")) nil [18831 19027])
            ("cl--make-usage-args" function (:arguments ("arglist")) nil [19029 20866])
            ("cl--do-&aux" function (:arguments ("args")) nil [20868 21357])
            ("cl--do-arglist" function (:arguments ("args" "expr" "num")) nil [21359 27458])
            ("cl--arglist-args" function (:arguments ("args")) nil [27460 27919])
            ("cl-destructuring-bind" function (:arguments ("args" "expr" "body")) nil [27936 28451])
            ("cl--not-toplevel" variable nil nil [28484 28513])
            ("cl-eval-when" function (:arguments ("when" "body")) nil [28530 29415])
            ("cl--compile-time-too" function (:arguments ("form")) nil [29417 29933])
            ("cl-load-time-value" function (:arguments ("form" "_read-only")) nil [29950 31125])
            ("cl-case" function (:arguments ("expr" "clauses")) nil [31180 32663])
            ("cl-ecase" function (:arguments ("expr" "clauses")) nil [32680 32928])
            ("cl-typecase" function (:arguments ("expr" "clauses")) nil [32945 34013])
            ("cl-etypecase" function (:arguments ("expr" "clauses")) nil [34030 34291])
            ("cl-block" function (:arguments ("name" "body")) nil [34332 35079])
            ("cl-return" function (:arguments ("result")) nil [35096 35294])
            ("cl-return-from" function (:arguments ("name" "result")) nil [35311 35816])
            ("cl--loop-args" variable nil nil [35845 35867])
            ("cl--loop-accum-var" variable nil nil [35868 35895])
            ("cl--loop-accum-vars" variable nil nil [35896 35924])
            ("cl--loop-bindings" variable nil nil [35925 35951])
            ("cl--loop-body" variable nil nil [35952 35974])
            ("cl--loop-finally" variable nil nil [35975 36000])
            ("cl--loop-finish-flag" variable nil nil [36001 36030])
            ("cl--loop-first-flag" variable nil nil [36078 36106])
            ("cl--loop-initially" variable nil nil [36107 36134])
            ("cl--loop-iterator-function" variable nil nil [36135 36170])
            ("cl--loop-name" variable nil nil [36171 36193])
            ("cl--loop-result" variable nil nil [36194 36218])
            ("cl--loop-result-explicit" variable nil nil [36219 36252])
            ("cl--loop-result-var" variable nil nil [36253 36281])
            ("cl--loop-steps" variable nil nil [36282 36305])
            ("cl--loop-symbol-macs" variable nil nil [36306 36335])
            ("cl--loop-guard-cond" variable nil nil [36336 36364])
            ("cl--loop-set-iterator-function" function (:arguments ("kind" "iterator")) nil [36366 36638])
            ("cl-loop" function (:arguments ("loop-args")) nil [36655 43633])
            ("cl--parse-loop-clause" function nil nil [48202 67595])
            ("cl--unused-var-p" function (:arguments ("sym")) nil [67597 67680])
            ("cl--loop-let" function (:arguments ("specs" "body" "par")) nil [67682 70040])
            ("cl--loop-handle-accum" function (:arguments ("def" "func")) nil [70042 70667])
            ("cl--loop-build-ands" function (:arguments ("clauses")) nil [70669 71864])
            ("cl-do" function (:arguments ("steps" "endtest" "body")) nil [71923 72269])
            ("cl-do*" function (:arguments ("steps" "endtest" "body")) nil [72286 72504])
            ("cl--expand-do-loop" function (:arguments ("steps" "endtest" "body" "star")) nil [72506 73213])
            ("cl-dolist" function (:arguments ("spec" "body")) nil [73230 73725])
            ("cl-dotimes" function (:arguments ("spec" "body")) nil [73742 74177])
            ("cl--tagbody-alist" variable nil nil [74179 74209])
            ("cl-tagbody" function (:arguments ("labels-or-stmts")) nil [74226 76382])
            ("cl--prog" function (:arguments ("binder" "bindings" "body")) nil [76384 76622])
            ("cl-prog" function (:arguments ("bindings" "body")) nil [76639 76837])
            ("cl-prog*" function (:arguments ("bindings" "body")) nil [76854 77055])
            ("cl-do-symbols" function (:arguments ("spec" "body")) nil [77072 77585])
            ("cl-do-all-symbols" function (:arguments ("spec" "body")) nil [77602 77869])
            ("cl-psetq" function (:arguments ("args")) nil [77905 78192])
            ("cl-progv" function (:arguments ("symbols" "values" "body")) nil [78243 79211])
            ("cl--labels-magic" variable
               (:constant-flag t
                :default-value (make-symbol "cl--labels-magic"))
                nil [79213 79273])
            ("cl--labels-convert-cache" variable nil nil [79275 79312])
            ("cl--labels-convert" function (:arguments ("f")) nil [79314 80212])
            ("cl-flet" function (:arguments ("bindings" "body")) nil [80229 82081])
            ("cl-flet*" function (:arguments ("bindings" "body")) nil [82098 82493])
            ("cl-labels" function (:arguments ("bindings" "body")) nil [82510 83754])
            ("cl-macrolet" function (:arguments ("bindings" "body")) nil [83860 84677])
            ("cl--sm-macroexpand" function (:arguments ("orig-fun" "exp" "env")) nil [84679 90972])
            ("cl-symbol-macrolet" function (:arguments ("bindings" "body")) nil [90989 92535])
            ("cl-multiple-value-bind" function (:arguments ("vars" "form" "body")) nil [92574 93305])
            ("cl-multiple-value-setq" function (:arguments ("vars" "form")) nil [93322 94277])
            ("cl-locally" function (:arguments ("body")) nil [94314 94418])
            ("cl-the" function (:arguments ("type" "form")) nil [94434 94940])
            ("cl--proclaim-history" variable (:default-value t) nil [94942 94973])
            ("cl--declare-stack" variable (:default-value t) nil [95000 95028])
            ("cl--do-proclaim" function (:arguments ("spec" "hist")) nil [95059 96567])
            ("cl--proclaims-deferred" variable nil nil [96631 96662])
            ("let" code nil nil [96663 96783])
            ("cl-declare" function (:arguments ("specs")) nil [96800 97193])
            ("cl-psetf" function (:arguments ("args")) nil [97299 98148])
            ("cl-remf" function (:arguments ("place" "tag")) nil [98165 98632])
            ("cl-shiftf" function (:arguments ("place" "args")) nil [98649 99136])
            ("cl-rotatef" function (:arguments ("args")) nil [99153 100065])
            ("cl--letf" function (:arguments ("bindings" "simplebinds" "binds" "body")) nil [100235 102566])
            ("cl-letf" function (:arguments ("bindings" "body")) nil [102583 103589])
            ("cl-letf*" function (:arguments ("bindings" "body")) nil [103606 103971])
            ("cl-callf" function (:arguments ("func" "place" "args")) nil [103988 104443])
            ("cl-callf2" function (:arguments ("func" "arg1" "place" "args")) nil [104460 105108])
            ("cl-defsubst" function (:arguments ("name" "args" "body")) nil [105125 106627])
            ("cl--defsubst-expand" function (:arguments ("argns" "body" "simple" "whole" "_unsafe" "argvs")) nil [106629 107755])
            ("cl--sublis" function (:arguments ("alist" "tree")) nil [107757 108029])
            ("cl--find-class" function (:arguments ("type")) nil [108048 108106])
            ("cl--struct-default-parent" variable nil nil [108218 108256])
            ("cl-defstruct" function (:arguments ("struct" "descs")) nil [108273 121745])
            ("cl--struct-all-parents" function (:arguments ("class")) nil [121783 122156])
            ("pcase-defmacro" code nil nil [122173 123009])
            ("cl--defstruct-predicate" function (:arguments ("type")) nil [123011 123269])
            ("cl--pcase-mutually-exclusive-p" function (:arguments ("orig" "pred1" "pred2")) nil [123271 124628])
            ("advice-add" code nil nil [124629 124723])
            ("cl-struct-sequence-type" function (:arguments ("struct-type")) nil [124726 125057])
            ("cl-struct-slot-info" function (:arguments ("struct-type")) nil [125059 126038])
            ("define-error" code nil nil [126040 126105])
            ("cl-struct-slot-offset" function (:arguments ("struct-type" "slot-name")) nil [126107 126644])
            ("byte-compile-function-environment" variable nil nil [126646 126688])
            ("byte-compile-macro-environment" variable nil nil [126689 126728])
            ("cl--macroexp-fboundp" function (:arguments ("sym")) nil [126730 127083])
            ("put" code nil nil [127085 127125])
            ("put" code nil nil [127126 127166])
            ("put" code nil nil [127167 127210])
            ("put" code nil nil [127211 127257])
            ("put" code nil nil [127258 127309])
            ("put" code nil nil [127310 127358])
            ("define-inline" code nil nil [127376 129884])
            ("cl-check-type" function (:arguments ("form" "type" "string")) nil [129902 130468])
            ("cl-assert" function (:arguments ("form" "show-args" "string" "args")) nil [130485 131569])
            ("cl-define-compiler-macro" function (:arguments ("func" "args" "body")) nil [131608 133132])
            ("cl-compiler-macroexpand" function (:arguments ("form")) nil [133149 133803])
            ("cl--active-block-names" variable nil nil [133846 133881])
            ("cl-define-compiler-macro" code nil nil [133883 134487])
            ("cl-define-compiler-macro" code nil nil [134489 134682])
            ("cl--compiler-macro-member" function (:arguments ("form" "a" "list" "keys")) nil [134759 135073])
            ("cl--compiler-macro-assoc" function (:arguments ("form" "a" "list" "keys")) nil [135075 135480])
            ("cl--compiler-macro-adjoin" function (:arguments ("form" "a" "list" "keys")) nil [135497 135714])
            ("cl--compiler-macro-get" function (:arguments ("_form" "sym" "prop" "def")) nil [135716 135858])
            ("dolist" code nil nil [135860 136410])
            ("cl-proclaim" code nil nil [136440 136563])
            ("mapc" code nil nil [136603 136862])
            ("mapc" code nil nil [136912 137074])
            ("cl-deftype" function (:arguments ("name" "arglist" "body")) nil [137118 137472])
            ("cl-deftype" code nil nil [137474 137536])
            ("define-inline" code nil nil [137643 138444])
            ("run-hooks" code nil nil [138446 138476])
            ("cl-macs" package nil nil [138579 138597]))          
      :file "cl-macs.el.gz"
      :pointmax 138624
      :fsize 34916
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-cfe240"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("defalias" code nil nil [1121 1571])
            ("function-put" code nil nil [1572 1614])
            ("function-put" code nil nil [1615 1663])
            ("macro-declaration-function" variable (:default-value nil) nil [1784 2116])
            ("defalias" code nil nil [2118 3260])
            ("defun-declarations-alist" variable (:default-value (list (list 'advertised-calling-convention #'(lambda (f _args arglist when) (list 'set-advertised-calling-convention (list 'quote f) (list 'quote arglist) (list 'quote when)))) (list 'obsolete #'(lambda (f _args new-name when) (list 'make-obsolete (list 'quote f) (list 'quote new-name) (list 'quote when)))) (list 'interactive-only #'(lambda (f _args instead) (list 'function-put (list 'quote f) ''interactive-only (list 'quote instead)))) (list 'pure #'(lambda (f _args val) (list 'function-put (list 'quote f) ''pure (list 'quote val))) "If non-nil, the compiler can replace calls with their return value.
This may shift errors from run-time to compile-time.") (list 'side-effect-free #'(lambda (f _args val) (list 'function-put (list 'quote f) ''side-effect-free (list 'quote val))) "If non-nil, calls can be ignored if their value is unused.
If `error-free', drop calls even if `byte-compile-delete-errors' is nil.") (list 'compiler-macro #'(lambda (f args compiler-function) (if (not (eq (car-safe compiler-function) 'lambda)) `(eval-and-compile (function-put ',f 'compiler-macro #',compiler-function)) (let ((cfname (intern (concat (symbol-name f) "--anon-cmacro"))) (data (cdr compiler-function))) `(progn (eval-and-compile (function-put ',f 'compiler-macro #',cfname)) :autoload-end (eval-and-compile (defun ,cfname (,@(car data) ,@args) ,@(cdr data)))))))) (list 'doc-string #'(lambda (f _args pos) (list 'function-put (list 'quote f) ''doc-string-elt (list 'quote pos)))) (list 'indent #'(lambda (f _args val) (list 'function-put (list 'quote f) ''lisp-indent-function (list 'quote val)))))) nil [3516 6606])
            ("macro-declarations-alist" variable (:default-value (cons (list 'debug #'(lambda (name _args spec) (list 'progn :autoload-end (list 'put (list 'quote name) ''edebug-form-spec (list 'quote spec))))) (cons (list 'no-font-lock-keyword #'(lambda (name _args val) (list 'function-put (list 'quote name) ''no-font-lock-keyword (list 'quote val)))) defun-declarations-alist))) nil [6608 7383])
            ("defalias" code nil nil [7385 9638])
            ("defun" function (:arguments ("name" "arglist" "docstring" "body")) nil [9687 12270])
            ("defalias" code nil nil [12352 12538])
            ("defsubst" function (:arguments ("name" "arglist" "body")) nil [13549 14021])
            ("advertised-signature-table" variable (:default-value (make-hash-table :test 'eq :weakness 'key)) nil [14023 14101])
            ("set-advertised-calling-convention" function (:arguments ("function" "signature" "_when")) nil [14103 14473])
            ("make-obsolete" function (:arguments ("obsolete-name" "current-name" "when")) nil [14475 15368])
            ("define-obsolete-function-alias" function (:arguments ("obsolete-name" "current-name" "when" "docstring")) nil [15370 16337])
            ("make-obsolete-variable" function (:arguments ("obsolete-name" "current-name" "when" "access-type")) nil [16339 17170])
            ("define-obsolete-variable-alias" function (:arguments ("obsolete-name" "current-name" "when" "docstring")) nil [17173 19014])
            ("define-obsolete-face-alias" function (:arguments ("obsolete-face" "current-face" "when")) nil [19344 19780])
            ("dont-compile" function (:arguments ("body")) nil [19782 20091])
            ("eval-when-compile" function (:arguments ("body")) nil [20334 20827])
            ("eval-and-compile" function (:arguments ("body")) nil [20829 21415])
            ("with-no-warnings" function (:arguments ("body")) nil [21417 21625])
            ("make-obsolete-variable" code nil nil [22920 23029])
            ("make-obsolete" code nil nil [23030 23121]))          
      :file "byte-run.el.gz"
      :pointmax 23149
      :fsize 6800
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189d580"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("defun-prompt-regexp" variable (:documentation "If non-nil, a regexp to ignore before a defun.
This is only necessary if the opening paren or brace is not in column 0.
See function `beginning-of-defun'.") nil [1098 1347])
            ("make-variable-buffer-local" code nil nil [1348 1397])
            ("parens-require-spaces" variable
               (:documentation "If non-nil, add whitespace as needed when inserting parentheses.
This affects `insert-parentheses' and `insert-pair'."
                :default-value t)
                nil [1399 1588])
            ("forward-sexp-function" variable (:documentation "If non-nil, `forward-sexp' delegates to this function.
Should take the same arguments and behave similarly to `forward-sexp'.") nil [1590 2091])
            ("forward-sexp" function
               (:documentation "Move forward across one balanced expression (sexp).
With ARG, do it that many times.  Negative arg -N means move
backward across N balanced expressions.  This command assumes
point is not in a string or comment.  Calls
`forward-sexp-function' to do the work, if that is non-nil.  If
unable to move over a sexp, signal `scan-error' with three
arguments: a message, the start of the obstacle (usually a
parenthesis or list marker of some kind), and end of the
obstacle."
                :user-visible-flag t
                :arguments ("arg"))
                nil [2093 2823])
            ("backward-sexp" function
               (:documentation "Move backward across one balanced expression (sexp).
With ARG, do it that many times.  Negative arg -N means
move forward across N balanced expressions.
This command assumes point is not in a string or comment.
Uses `forward-sexp' to do the work."
                :user-visible-flag t
                :arguments ("arg"))
                nil [2825 3183])
            ("mark-sexp" function
               (:documentation "Set mark ARG sexps from point.
The place mark goes is the same place \\[forward-sexp] would
move to with the same argument.
Interactively, if this command is repeated
or (in Transient Mark mode) if the mark is active,
it marks the next ARG sexps after the ones already marked.
This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg" "allow-extend"))
                nil [3185 4010])
            ("forward-list" function
               (:documentation "Move forward across one balanced group of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.
With ARG, do it that many times.
Negative arg -N means move backward across N groups of parentheses.
This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg"))
                nil [4012 4478])
            ("backward-list" function
               (:documentation "Move backward across one balanced group of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.
With ARG, do it that many times.
Negative arg -N means move forward across N groups of parentheses.
This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg"))
                nil [4480 4909])
            ("down-list" function
               (:documentation "Move forward down one level of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.
With ARG, do this that many times.
A negative argument means move backward but still go down a level.
This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg"))
                nil [4911 5457])
            ("backward-up-list" function
               (:documentation "Move backward out of one level of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.  With ARG, do this that
many times.  A negative argument means move forward but still to
a less deep spot.  If ESCAPE-STRINGS is non-nil (as it is
interactively), move out of enclosing strings as well.  If
NO-SYNTAX-CROSSING is non-nil (as it is interactively), prefer to
break out of any enclosing string instead of moving to the start
of a list broken across multiple strings.  On error, location of
point is unspecified."
                :user-visible-flag t
                :arguments ("arg" "escape-strings" "no-syntax-crossing"))
                nil [5459 6200])
            ("up-list" function
               (:documentation "Move forward out of one level of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.  With ARG, do this that
many times.  A negative argument means move backward but still to
a less deep spot.  If ESCAPE-STRINGS is non-nil (as it is
interactively), move out of enclosing strings as well. If
NO-SYNTAX-CROSSING is non-nil (as it is interactively), prefer to
break out of any enclosing string instead of moving to the start
of a list broken across multiple strings.  On error, location of
point is unspecified."
                :user-visible-flag t
                :arguments ("arg" "escape-strings" "no-syntax-crossing"))
                nil [6202 9555])
            ("kill-sexp" function
               (:documentation "Kill the sexp (balanced expression) following point.
With ARG, kill that many sexps after point.
Negative arg -N means kill N sexps before point.
This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg"))
                nil [9557 9908])
            ("backward-kill-sexp" function
               (:documentation "Kill the sexp (balanced expression) preceding point.
With ARG, kill that many sexps before point.
Negative arg -N means kill N sexps after point.
This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg"))
                nil [9910 10209])
            ("kill-backward-up-list" function
               (:documentation "Kill the form containing the current sexp, leaving the sexp itself.
A prefix argument ARG causes the relevant number of surrounding
forms to be removed.
This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg"))
                nil [10227 10725])
            ("beginning-of-defun-function" variable (:documentation "If non-nil, function for `beginning-of-defun-raw' to call.
This is used to find the beginning of the defun instead of using the
normal recipe (see `beginning-of-defun').  Major modes can define this
if defining `defun-prompt-regexp' is not sufficient to handle the mode's
needs.

The function takes the same argument as `beginning-of-defun' and should
behave similarly, returning non-nil if it found the beginning of a defun.
Ideally it should move to a point right before an open-paren which encloses
the body of the defun.") nil [10728 11297])
            ("beginning-of-defun" function
               (:documentation "Move backward to the beginning of a defun.
With ARG, do it that many times.  Negative ARG means move forward
to the ARGth following beginning of defun.

If search is successful, return t; point ends up at the beginning
of the line where the search succeeded.  Otherwise, return nil.

When `open-paren-in-column-0-is-defun-start' is non-nil, a defun
is assumed to start where there is a char with open-parenthesis
syntax at the beginning of a line.  If `defun-prompt-regexp' is
non-nil, then a string which matches that regexp may also precede
the open-parenthesis.  If `defun-prompt-regexp' and
`open-paren-in-column-0-is-defun-start' are both nil, this
function instead finds an open-paren at the outermost level.

If the variable `beginning-of-defun-function' is non-nil, its
value is called as a function, with argument ARG, to find the
defun's beginning.

Regardless of the values of `defun-prompt-regexp' and
`beginning-of-defun-function', point always moves to the
beginning of the line whenever the search is successful."
                :user-visible-flag t
                :arguments ("arg"))
                nil [11299 12625])
            ("beginning-of-defun-raw" function
               (:documentation "Move point to the character that starts a defun.
This is identical to function `beginning-of-defun', except that point
does not move to the beginning of the line when `defun-prompt-regexp'
is non-nil.

If variable `beginning-of-defun-function' is non-nil, its value
is called as a function to find the defun's beginning."
                :user-visible-flag t
                :arguments ("arg"))
                nil [12627 16182])
            ("beginning-of-defun--in-emptyish-line-p" function (:documentation "Return non-nil if the point is in an \"emptyish\" line.
This means a line that consists entirely of comments and/or
whitespace.") nil [16184 16743])
            ("beginning-of-defun-comments" function
               (:documentation "Move to the beginning of ARGth defun, including comments."
                :user-visible-flag t
                :arguments ("arg"))
                nil [16745 17710])
            ("end-of-defun-function" variable
               (:documentation "Function for `end-of-defun' to call.
This is used to find the end of the defun at point.
It is called with no argument, right after calling `beginning-of-defun-raw'.
So the function can assume that point is at the beginning of the defun body.
It should move point to the first position after the defun."
                :default-value (lambda nil (forward-sexp 1)))
                nil [17712 18080])
            ("buffer-end" function
               (:documentation "Return the \"far end\" position of the buffer, in direction ARG.
If ARG is positive, that's the end of the buffer.
Otherwise, that's the beginning of the buffer."
                :arguments ("arg"))
                nil [18082 18313])
            ("end-of-defun" function
               (:documentation "Move forward to next end of defun.
With argument, do it that many times.
Negative argument -N means move back to Nth preceding end of defun.

An end of a defun occurs right after the close-parenthesis that
matches the open-parenthesis that starts a defun; see function
`beginning-of-defun'.

If variable `end-of-defun-function' is non-nil, its value
is called as a function to find the defun's end."
                :user-visible-flag t
                :arguments ("arg"))
                nil [18315 20621])
            ("mark-defun" function
               (:documentation "Put mark at end of this defun, point at beginning.
The defun marked is the one that contains point or follows point.
With positive ARG, mark this and that many next defuns; with negative
ARG, change the direction of marking.

If the mark is active, it marks the next or previous defun(s) after
the one(s) already marked."
                :user-visible-flag t
                :arguments ("arg"))
                nil [20623 23367])
            ("narrow-to-defun-include-comments" variable (:documentation "If non-nil, `narrow-to-defun' will also show comments preceding the defun.") nil [23369 23493])
            ("narrow-to-defun" function
               (:documentation "Make text outside current defun invisible.
The current defun is the one that contains point or follows point.
Preceding comments are included if INCLUDE-COMMENTS is non-nil.
Interactively, the behavior depends on `narrow-to-defun-include-comments'."
                :user-visible-flag t
                :arguments ("include-comments"))
                nil [23495 25587])
            ("insert-pair-alist" variable
               (:documentation "Alist of paired characters inserted by `insert-pair'.
Each element looks like (OPEN-CHAR CLOSE-CHAR) or (COMMAND-CHAR
OPEN-CHAR CLOSE-CHAR).  The characters OPEN-CHAR and CLOSE-CHAR
of the pair whose key is equal to the last input character with
or without modifiers, are inserted by `insert-pair'.

If COMMAND-CHAR is specified, it is a character that triggers the
insertion of the open/close pair, and COMMAND-CHAR itself isn't
inserted."
                :default-value '((40 41) (91 93) (123 125) (60 62) (34 34) (39 39) (96 39)))
                nil [25589 26134])
            ("insert-pair" function
               (:documentation "Enclose following ARG sexps in a pair of OPEN and CLOSE characters.
Leave point after the first character.
A negative ARG encloses the preceding ARG sexps instead.
No argument is equivalent to zero: just insert characters
and leave point between.
If `parens-require-spaces' is non-nil, this command also inserts a space
before and after, depending on the surrounding characters.
If region is active, insert enclosing characters at region boundaries.

If arguments OPEN and CLOSE are nil, the character pair is found
from the variable `insert-pair-alist' according to the last input
character with or without modifiers.  If no character pair is
found in the variable `insert-pair-alist', then the last input
character is inserted ARG times.

This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg" "open" "close"))
                nil [26136 28405])
            ("insert-parentheses" function
               (:documentation "Enclose following ARG sexps in parentheses.
Leave point after open-paren.
A negative ARG encloses the preceding ARG sexps instead.
No argument is equivalent to zero: just insert `()' and leave point between.
If `parens-require-spaces' is non-nil, this command also inserts a space
before and after, depending on the surrounding characters.
If region is active, insert enclosing characters at region boundaries.

This command assumes point is not in a string or comment."
                :user-visible-flag t
                :arguments ("arg"))
                nil [28407 28971])
            ("delete-pair" function
               (:documentation "Delete a pair of characters enclosing the sexp that follows point."
                :user-visible-flag t)
                nil [28973 29153])
            ("raise-sexp" function
               (:documentation "Raise ARG sexps higher up the tree."
                :user-visible-flag t
                :arguments ("arg"))
                nil [29155 29611])
            ("move-past-close-and-reindent" function
               (:documentation "Move past next `)', delete indentation before it, then indent after it."
                :user-visible-flag t)
                nil [29613 30610])
            ("check-parens" function
               (:documentation "Check for unbalanced parentheses in the current buffer.
More accurately, check the narrowed part of the buffer for unbalanced
expressions (\"sexps\") in general.  This is done according to the
current syntax table and will find unbalanced brackets or quotes as
appropriate.  (See Info node `(emacs)Parentheses'.)  If imbalance is
found, an error is signaled and point is left at the first unbalanced
character."
                :user-visible-flag t)
                nil [30612 31525])
            ("field-complete" function (:arguments ("table" "predicate")) nil [31528 32072])
            ("lisp-complete-symbol" function
               (:documentation "Perform completion on Lisp symbol preceding point.
Compare that symbol against the known Lisp symbols.
If no characters can be completed, display a list of possible completions.
Repeating the command at that point scrolls the list.

The context determines which symbols are considered.  If the
symbol starts just after an open-parenthesis, only symbols with
function definitions are considered.  Otherwise, all symbols with
function definitions, values or properties are considered."
                :arguments ("_predicate"))
                nil [32074 33061]))          
      :file "lisp.el.gz"
      :pointmax 33085
      :fsize 9168
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189d5a0"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("cl-lib" include nil nil [1048 1065])
            ("macroexp" include nil nil [1066 1085])
            ("gv" include nil nil [1086 1099])
            ("cl-unload-function" function (:documentation "Stop unloading of the Common Lisp extensions.") nil [3595 3753])
            ("dolist" code nil nil [3790 4503])
            ("dolist" code nil nil [4505 9132])
            ("cl--wrap-in-nil-block" function (:arguments ("fun" "args")) nil [9134 9216])
            ("advice-add" code nil nil [9217 9269])
            ("advice-add" code nil nil [9270 9323])
            ("cl--pass-args-to-cl-declare" function (:arguments ("specs")) nil [9325 9413])
            ("advice-add" code nil nil [9414 9472])
            ("cl-closure-vars" variable nil nil [9632 9660])
            ("cl--function-convert-cache" variable nil nil [9661 9700])
            ("cl--function-convert" function
               (:documentation "Special macro-expander for special cases of (function F).
The two cases that are handled are:
- closure-conversion of lambda expressions for `lexical-let'.
- renaming of F when it's a function defined via `cl-labels' or `labels'."
                :arguments ("f"))
                nil [9702 11817])
            ("lexical-let" function
               (:documentation "Like `let', but lexically scoped.
The main visible difference is that lambdas inside BODY will create
lexical closures as in Common Lisp.

(fn BINDINGS BODY)"
                :arguments ("bindings" "body"))
                nil [11819 13830])
            ("lexical-let*" function
               (:documentation "Like `let*', but lexically scoped.
The main visible difference is that lambdas inside BODY, and in
successive bindings within BINDINGS, will create lexical closures
as in Common Lisp.  This is similar to the behavior of `let*' in
Common Lisp.

(fn BINDINGS BODY)"
                :arguments ("bindings" "body"))
                nil [13832 14362])
            ("flet" function
               (:documentation "Make temporary overriding function definitions.
This is an analogue of a dynamically scoped `let' that operates on the function
cell of FUNCs rather than their value cell.
If you want the Common-Lisp style of `flet', you should use `cl-flet'.
The FORMs are evaluated with the specified function definitions in place,
then the definitions are undone (the FUNCs go back to their previous
definitions, or lack thereof).

(fn ((FUNC ARGLIST BODY...) ...) FORM...)"
                :arguments ("bindings" "body"))
                nil [14441 16195])
            ("labels" function
               (:documentation "Make temporary function bindings.
Like `cl-labels' except that the lexical scoping is handled via `lexical-let'
rather than relying on `lexical-binding'."
                :arguments ("bindings" "body"))
                nil [16197 17364])
            ("cl--gv-adapt" function (:arguments ("cl-gv" "do")) nil [17560 18450])
            ("define-setf-expander" function
               (:documentation "Define a `setf' method.
This method shows how to handle `setf's to places of the form
(NAME ARGS...).  The argument forms ARGS are bound according to
ARGLIST, as if NAME were going to be expanded as a macro, then
the BODY forms are executed and must return a list of five elements:
a temporary-variables list, a value-forms list, a store-variables list
(of length one), a store-form, and an access- form.

See `gv-define-expander', and `gv-define-setter' for better and
simpler ways to define setf-methods."
                :arguments ("name" "arglist" "body"))
                nil [18452 19355])
            ("defsetf" function
               (:documentation "Define a `setf' method.
This macro is an easy-to-use substitute for `define-setf-expander'
that works well for simple place forms.

In the simple `defsetf' form, `setf's of the form (setf (NAME
ARGS...) VAL) are transformed to function or macro calls of the
form (FUNC ARGS... VAL).  For example:

  (defsetf aref aset)

You can replace this form with `gv-define-simple-setter'.

Alternate form: (defsetf NAME ARGLIST (STORE) BODY...).

Here, the above `setf' call is expanded by binding the argument
forms ARGS according to ARGLIST, binding the value form VAL to
STORE, then executing BODY, which must return a Lisp form that
does the necessary `setf' operation.  Actually, ARGLIST and STORE
may be bound to temporary variables which are introduced
automatically to preserve proper execution order of the arguments.
For example:

  (defsetf nth (n x) (v) \\=`(setcar (nthcdr ,n ,x) ,v))

You can replace this form with `gv-define-setter'.

(fn NAME [FUNC | ARGLIST (STORE) BODY...])"
                :arguments ("name" "arg1" "args"))
                nil [19357 20975])
            ("make-obsolete" code nil nil [22889 22941])
            ("declare-function" code nil nil [22943 22995])
            ("define-modify-macro" function
               (:documentation "Define a `setf'-like modify macro.
If NAME is called, it combines its PLACE argument with the other
arguments from ARGLIST using FUNC.  For example:

  (define-modify-macro incf (&optional (n 1)) +)

You can replace this macro with `gv-letplace'."
                :arguments ("name" "arglist" "func" "doc"))
                nil [22997 23819])
            ("define-obsolete-function-alias" code nil nil [23921 23989])
            ("define-obsolete-variable-alias" code nil nil [23990 24082])
            ("define-obsolete-function-alias" code nil nil [24083 24159])
            ("cl-not-hash-table" function (:arguments ("x" "y" "_z")) nil [24297 24446])
            ("cl-builtin-gethash" variable (:default-value (symbol-function 'gethash)) nil [24448 24502])
            ("make-obsolete-variable" code nil nil [24503 24558])
            ("cl-builtin-remhash" variable (:default-value (symbol-function 'remhash)) nil [24559 24613])
            ("make-obsolete-variable" code nil nil [24614 24669])
            ("cl-builtin-clrhash" variable (:default-value (symbol-function 'clrhash)) nil [24670 24724])
            ("make-obsolete-variable" code nil nil [24725 24780])
            ("cl-builtin-maphash" variable (:default-value (symbol-function 'maphash)) nil [24781 24835])
            ("make-obsolete-variable" code nil nil [24837 24892])
            ("define-obsolete-function-alias" code nil nil [24893 24959])
            ("define-obsolete-function-alias" code nil nil [24960 25024])
            ("define-obsolete-function-alias" code nil nil [25025 25085])
            ("define-obsolete-function-alias" code nil nil [25086 25146])
            ("define-obsolete-function-alias" code nil nil [25147 25207])
            ("define-obsolete-function-alias" code nil nil [25208 25268])
            ("define-obsolete-function-alias" code nil nil [25269 25329])
            ("define-obsolete-function-alias" code nil nil [25330 25406])
            ("define-obsolete-function-alias" code nil nil [25407 25477])
            ("define-obsolete-function-alias" code nil nil [25478 25556])
            ("define-obsolete-function-alias" code nil nil [25558 25654])
            ("define-obsolete-function-alias" code nil nil [25655 25731])
            ("define-obsolete-function-alias" code nil nil [25732 25805])
            ("define-obsolete-function-alias" code nil nil [25806 25872])
            ("cl-maclisp-member" function (:arguments ("item" "list")) nil [25874 26029])
            ("cl-struct-setf-expander" function (:arguments ("x" "name" "accessor" "pred-form" "pos")) nil [26080 27014])
            ("cl" package nil nil [27016 27029])
            ("run-hooks" code nil nil [27031 27056]))          
      :file "cl.el.gz"
      :pointmax 27078
      :fsize 7966
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189d5c0"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("cl-lib" include nil nil [6301 6318])
            ("subr-x" include nil nil [6338 6355])
            ("epg" include nil nil [6376 6390])
            ("seq" include nil nil [6418 6432])
            ("tabulated-list" include nil nil [6434 6459])
            ("macroexp" include nil nil [6460 6479])
            ("url-handlers" include nil nil [6480 6503])
            ("package" customgroup
               (:documentation "Manager for Emacs Lisp packages."
                :user-visible-flag t)
                nil [6505 6605])
            ("package-enable-at-startup" variable
               (:documentation "Whether to make installed packages available when Emacs starts.
If non-nil, packages are made available before reading the init
file (but after reading the early init file).  This means that if
you wish to set this variable, you must do so in the early init
file.  Regardless of the value of this variable, packages are not
made available if `user-init-file' is nil (e.g. Emacs was started
with \"-q\").

Even if the value is nil, you can type \\[package-initialize] to
make installed packages available at any time, or you can
call (package-initialize) in your init-file."
                :default-value t)
                nil [6650 7301])
            ("package-load-list" variable
               (:documentation "List of packages for `package-initialize' to make available.
Each element in this list should be a list (NAME VERSION), or the
symbol `all'.  The symbol `all' says to make available the latest
installed versions of all packages not specified by other
elements.

For an element (NAME VERSION), NAME is a package name (a symbol).
VERSION should be t, a string, or nil.
If VERSION is t, the most recent version is made available.
If VERSION is a string, only that version is ever made available.
 Any other version, even if newer, is silently ignored.
 Hence, the package is \"held\" at that version.
If VERSION is nil, the package is not made available (it is \"disabled\")."
                :default-value '(all))
                nil [7303 8440])
            ("package-archives" variable
               (:documentation "An alist of archives from which to fetch.
The default value points to the GNU Emacs package repository.

Each element has the form (ID . LOCATION).
 ID is an archive name, as a string.
 LOCATION specifies the base location for the archive.
  If it starts with \"http(s):\", it is treated as an HTTP(S) URL;
  otherwise it should be an absolute directory name.
  (Other types of URL are currently not supported.)

Only add locations that you trust, since fetching and installing
a package can run arbitrary code."
                :default-value `(("gnu" \, (format "http%s://elpa.gnu.org/packages/" (if (gnutls-available-p) "s" "")))))
                nil [8442 9298])
            ("package-menu-hide-low-priority" variable
               (:documentation "If non-nil, hide low priority packages from the packages menu.
A package is considered low priority if there's another version
of it available such that:
    (a) the archive of the other package is higher priority than
    this one, as per `package-archive-priorities';
  or
    (b) they both have the same archive priority but the other
    package has a higher version number.

This variable has three possible values:
    nil: no packages are hidden;
    `archive': only criterion (a) is used;
    t: both criteria are used.

This variable has no effect if `package-menu--hide-packages' is
nil, so it can be toggled with \\<package-menu-mode-map> \\[package-menu-toggle-hiding]."
                :default-value 'archive)
                nil [9335 10317])
            ("package-archive-priorities" variable (:documentation "An alist of priorities for packages.

Each element has the form (ARCHIVE-ID . PRIORITY).

When installing packages, the package with the highest version
number from the archive with the highest priority is
selected.  When higher versions are available from archives with
lower priorities, the user has to select those manually.

Archives not in this list have the priority 0.

See also `package-menu-hide-low-priority'.") nil [10319 10939])
            ("package-pinned-packages" variable (:documentation "An alist of packages that are pinned to specific archives.
This can be useful if you have multiple package archives enabled,
and want to control which archive a given package gets installed from.

Each element of the alist has the form (PACKAGE . ARCHIVE), where:
 PACKAGE is a symbol representing a package
 ARCHIVE is a string representing an archive (it should be the car of
an element in `package-archives', e.g. \"gnu\").

Adding an entry to this variable means that only ARCHIVE will be
considered as a source for PACKAGE.  If other archives provide PACKAGE,
they are ignored (for this package).  If ARCHIVE does not contain PACKAGE,
the package will be unavailable.") nil [10941 12052])
            ("package-user-dir" variable
               (:documentation "Directory containing the user's Emacs Lisp packages.
The directory name should be absolute.
Apart from this directory, Emacs also looks for system-wide
packages in `package-directory-list'."
                :default-value (locate-user-emacs-file "elpa"))
                nil [12054 12356])
            ("package-directory-list" variable
               (:documentation "List of additional directories containing Emacs Lisp packages.
Each directory name should be absolute.

These directories contain packages intended for system-wide; in
contrast, `package-user-dir' contains packages for personal use."
                :default-value (let (result) (dolist (f load-path) (and (stringp f) (equal (file-name-nondirectory f) "site-lisp") (push (expand-file-name "elpa" f) result))) (nreverse result)))
                nil [12358 12949])
            ("declare-function" code nil nil [12951 13067])
            ("package-gnupghome-dir" variable
               (:documentation "Directory containing GnuPG keyring or nil.
This variable specifies the GnuPG home directory used by package.
That directory is passed via the option \"--homedir\" to GnuPG.
If nil, do not use the option \"--homedir\", but stick with GnuPG's
default directory."
                :default-value (expand-file-name "gnupg" package-user-dir))
                nil [13069 13768])
            ("package-check-signature" variable
               (:documentation "Non-nil means to check package signatures when installing.
The value `allow-unsigned' means to still install a package even if
it is unsigned.

This also applies to the \"archive-contents\" file that lists the
contents of the archive."
                :default-value (if (and (require 'epg-config) (epg-find-configuration 'OpenPGP)) 'allow-unsigned))
                nil [13770 14327])
            ("package-unsigned-archives" variable (:documentation "List of archives where we do not check for package signatures.") nil [14329 14513])
            ("package-selected-packages" variable (:documentation "Store here packages installed explicitly by user.
This variable is fed automatically by Emacs when installing a new package.
This variable is used by `package-autoremove' to decide
which packages are no longer needed.
You can use it to (re)install packages on other machines
by running `package-install-selected-packages'.

To check if a package is contained in this list here, use
`package--user-selected-p', as it may populate the variable with
a sane initial value.") nil [14515 15072])
            ("package-menu-async" variable
               (:documentation "If non-nil, package-menu will use async operations when possible.
Currently, only the refreshing of archive contents supports
asynchronous operations.  Package transactions are still done
synchronously."
                :default-value t)
                nil [15074 15348])
            ("package--default-summary" variable (:default-value "No description available.") nil [15743 15804])
            ("cl-defstruct" code nil nil [15806 18574])
            ("package--from-builtin" function (:arguments ("bi-desc")) nil [18576 18830])
            ("package-version-join" function
               (:documentation "Return the version string corresponding to the list VLIST.
This is, approximately, the inverse of `version-to-list'.
(Actually, it returns only one of the possible inverses, since
`version-to-list' is a many-to-one operation.)"
                :arguments ("vlist"))
                nil [18850 19982])
            ("package-desc-full-name" function (:arguments ("pkg-desc")) nil [19984 20148])
            ("package-desc-suffix" function (:arguments ("pkg-desc")) nil [20150 20330])
            ("package-desc--keywords" function (:arguments ("pkg-desc")) nil [20332 20530])
            ("package-desc-priority" function
               (:documentation "Return the priority of the archive of package-desc object P."
                :arguments ("p"))
                nil [20532 20684])
            ("cl-defstruct" code nil nil [20760 20919])
            ("package--builtins" variable (:documentation "Alist of built-in packages.
The actual value is initialized by loading the library
`finder-inf'; this is not done until it is needed, e.g. by the
function `package-built-in-p'.

Each element has the form (PKG . PACKAGE-BI-DESC), where PKG is a package
name (a symbol) and DESC is a `package--bi-desc' structure.") nil [21237 21583])
            ("put" code nil nil [21584 21632])
            ("package-alist" variable (:documentation "Alist of all packages available for activation.
Each element has the form (PKG . DESCS), where PKG is a package
name (a symbol) and DESCS is a non-empty list of `package-desc' structure,
sorted by decreasing versions.

This variable is set automatically by `package-load-descriptor',
called via `package-initialize'.  To change which packages are
loaded and/or activated, customize `package-load-list'.") nil [21634 22067])
            ("put" code nil nil [22068 22112])
            ("package-activated-list" variable (:documentation "List of the names of currently activated packages.") nil [22114 22269])
            ("put" code nil nil [22270 22323])
            ("package-process-define-package" function (:arguments ("exp")) nil [22520 23383])
            ("package-load-descriptor" function
               (:documentation "Load the description file in directory PKG-DIR."
                :arguments ("pkg-dir"))
                nil [23385 24146])
            ("package-load-all-descriptors" function (:documentation "Load descriptors for installed Emacs Lisp packages.
This looks for package subdirectories in `package-user-dir' and
`package-directory-list'.  The variable `package-load-list'
controls which package subdirectories may be loaded.

In each valid package subdirectory, this function loads the
description file containing a call to `define-package', which
updates `package-alist'.") nil [24148 24901])
            ("define-package" function
               (:documentation "Define a new package.
NAME-STRING is the name of the package, as a string.
VERSION-STRING is the version of the package, as a string.
DOCSTRING is a short description of the package, a string.
REQUIREMENTS is a list of dependencies on other packages.
 Each requirement is of the form (OTHER-PACKAGE OTHER-VERSION),
 where OTHER-VERSION is a string.

EXTRA-PROPERTIES is currently unused."
                :arguments ("_name-string" "_version-string" "_docstring" "_requirements" "_extra-properties"))
                nil [24903 25551])
            ("package-disabled-p" function
               (:documentation "Return whether PKG-NAME at VERSION can be activated.
The decision is made according to `package-load-list'.
Return nil if the package can be activated.
Return t if the package is completely disabled.
Return the max version (as a string) if the package is held at a lower version."
                :arguments ("pkg-name" "version"))
                nil [25642 26371])
            ("package-built-in-p" function
               (:documentation "Return non-nil if PACKAGE is built-in to Emacs.
Optional arg MIN-VERSION, if non-nil, should be a version list
specifying the minimum acceptable version."
                :arguments ("package" "min-version"))
                nil [26373 26980])
            ("package--autoloads-file-name" function
               (:documentation "Return the absolute name of the autoloads file, sans extension.
PKG-DESC is a `package-desc' object."
                :arguments ("pkg-desc"))
                nil [26982 27242])
            ("package--activate-autoloads-and-load-path" function
               (:documentation "Load the autoloads file and add package dir to `load-path'.
PKG-DESC is a `package-desc' object."
                :arguments ("pkg-desc"))
                nil [27244 27934])
            ("Info-directory-list" variable nil nil [27936 27964])
            ("declare-function" code nil nil [27965 28009])
            ("package--quickstart-pkgs" variable
               (:documentation "If set to a list, we're computing the set of pkgs to activate."
                :default-value t)
                nil [28011 28113])
            ("package--load-files-for-activation" function
               (:documentation "Load files for activating a package given by PKG-DESC.
Load the autoloads file, and ensure `load-path' is setup.  If
RELOAD is non-nil, also load all files in the package that
correspond to previously loaded files."
                :arguments ("pkg-desc" "reload"))
                nil [28115 29322])
            ("package-activate-1" function
               (:documentation "Activate package given by PKG-DESC, even if it was already active.
If DEPS is non-nil, also activate its dependencies (unless they
are already activated).
If RELOAD is non-nil, also `load' any files inside the package which
correspond to previously loaded files (those returned by
`package--list-loaded-files')."
                :arguments ("pkg-desc" "reload" "deps"))
                nil [29324 30938])
            ("declare-function" code nil nil [30940 30998])
            ("package--list-loaded-files" function
               (:documentation "Recursively list all files in DIR which correspond to loaded features.
Returns the `file-name-sans-extension' of each file, relative to
DIR, sorted by most recently loaded last."
                :arguments ("dir"))
                nil [31000 32750])
            ("package-activate" function
               (:documentation "Activate the package named PACKAGE.
If FORCE is true, (re-)activate it if it's already activated.
Newer versions are always activated, regardless of FORCE."
                :arguments ("package" "force"))
                nil [32946 33954])
            ("tar-parse-info" variable nil nil [34225 34248])
            ("declare-function" code nil nil [34249 34298])
            ("declare-function" code nil nil [34299 34359])
            ("declare-function" code nil nil [34360 34425])
            ("package-untar-buffer" function
               (:documentation "Untar the current buffer.
This uses `tar-untar-buffer' from Tar mode.  All files should
untar into a directory named DIR; otherwise, signal an error."
                :arguments ("dir"))
                nil [34427 35297])
            ("package--alist-to-plist-args" function (:arguments ("alist")) nil [35299 35473])
            ("package-unpack" function
               (:documentation "Install the contents of the current buffer as a package."
                :arguments ("pkg-desc"))
                nil [35474 38005])
            ("package-generate-description-file" function
               (:documentation "Create the foo-pkg.el file for single-file packages."
                :arguments ("pkg-desc" "pkg-file"))
                nil [38007 39074])
            ("declare-function" code nil nil [39090 39165])
            ("package-autoload-ensure-default-file" function
               (:documentation "Make sure that the autoload file FILE exists and if not create it."
                :arguments ("file"))
                nil [39167 39429])
            ("generated-autoload-file" variable nil nil [39431 39463])
            ("autoload-timestamps" variable nil nil [39464 39492])
            ("version-control" variable nil nil [39493 39517])
            ("package-generate-autoloads" function (:arguments ("name" "pkg-dir")) nil [39519 40234])
            ("package--make-autoloads-and-stuff" function
               (:documentation "Generate autoloads, description file, etc.. for PKG-DESC installed at PKG-DIR."
                :arguments ("pkg-desc" "pkg-dir"))
                nil [40236 40728])
            ("warning-minimum-level" variable nil nil [40747 40777])
            ("package--compile" function
               (:documentation "Byte-compile installed package PKG-DESC.
This assumes that `pkg-desc' has already been activated with
`package-activate-1'."
                :arguments ("pkg-desc"))
                nil [40778 41115])
            ("package-read-from-string" function
               (:documentation "Read a Lisp expression from STR.
Signal an error if the entire string was not used."
                :arguments ("str"))
                nil [41160 41562])
            ("package--prepare-dependencies" function
               (:documentation "Turn DEPS into an acceptable list of dependencies.

Any parts missing a version string get a default version string
of \"0\" (meaning any version) and an appropriate level of lists
is wrapped around any parts requiring it."
                :arguments ("deps"))
                nil [41564 42256])
            ("declare-function" code nil nil [42258 42306])
            ("declare-function" code nil nil [42307 42365])
            ("declare-function" code nil nil [42366 42426])
            ("declare-function" code nil nil [42427 42484])
            ("package-buffer-info" function (:documentation "Return a `package-desc' describing the package in the current buffer.

If the buffer does not contain a conforming package, signal an
error.  If there is a package, narrow the buffer to the file's
boundaries.") nil [42486 44275])
            ("package--read-pkg-desc" function
               (:documentation "Read a `define-package' form in current buffer.
Return the pkg-desc, with desc-kind set to KIND."
                :arguments ("kind"))
                nil [44277 44796])
            ("declare-function" code nil nil [44798 44858])
            ("declare-function" code nil nil [44859 44914])
            ("package-tar-file-info" function (:documentation "Find package information for a tar file.
The return result is a `package-desc'.") nil [44916 45635])
            ("package-dir-info" function (:documentation "Find package information for a directory.
The return result is a `package-desc'.") nil [45637 46613])
            ("package--write-file-no-coding" function (:arguments ("file-name")) nil [46738 46905])
            ("declare-function" code nil nil [46907 46965])
            ("package--archive-file-exists-p" function (:arguments ("location" "file")) nil [46967 47248])
            ("declare-function" code nil nil [47250 47499])
            ("declare-function" code nil nil [47500 47635])
            ("declare-function" code nil nil [47636 47698])
            ("declare-function" code nil nil [47699 47758])
            ("declare-function" code nil nil [47759 47819])
            ("package--display-verify-error" function (:arguments ("context" "sig-file")) nil [47821 48466])
            ("package--with-work-buffer" function
               (:documentation "Run BODY in a buffer containing the contents of FILE at LOCATION.
LOCATION is the base location of a package archive, and should be
one of the URLs (or file names) specified in `package-archives'.
FILE is the name of a file relative to that base location.

This macro retrieves FILE from LOCATION into a temporary buffer,
and evaluates BODY while that buffer is current.  This work
buffer is killed afterwards.  Return the last value in BODY."
                :arguments ("location" "file" "body"))
                nil [48468 49418])
            ("cl-defmacro" code nil nil [49420 52885])
            ("define-error" code nil nil [52887 52945])
            ("package--check-signature-content" function
               (:documentation "Check signature CONTENT against STRING.
SIG-FILE is the name of the signature file, used when signaling
errors."
                :arguments ("content" "string" "sig-file"))
                nil [52947 54370])
            ("package--check-signature" function
               (:documentation "Check signature of the current buffer.
Download the signature file from LOCATION by appending \".sig\"
to FILE.
GnuPG keyring location depends on `package-gnupghome-dir'.
STRING is the string to verify, it defaults to `buffer-string'.
If ASYNC is non-nil, the download of the signature file is
done asynchronously.

If the signature does not verify, signal an error.
If the signature is verified and CALLBACK was provided, `funcall'
CALLBACK with the list of good signatures as argument (the list
can be empty).
If no signatures file is found, and `package-check-signature' is
`allow-unsigned', call CALLBACK with a nil argument.
Otherwise, an error is signaled.

UNWIND, if provided, is a function to be called after everything
else, even if an error is signaled."
                :arguments ("location" "file" "string" "async" "callback" "unwind"))
                nil [54372 56218])
            ("package-archive-version" variable
               (:documentation "Version number of the package archive understood by this file.
Lower version numbers than this will probably be understood as well."
                :constant-flag t
                :default-value 1)
                nil [56610 56782])
            ("package-archive-contents" variable (:documentation "Cache of the contents of the Emacs Lisp Package Archive.
This is an alist mapping package names (symbols) to
non-empty lists of `package-desc' structures.") nil [56847 57043])
            ("put" code nil nil [57044 57099])
            ("package--compatibility-table" variable (:documentation "Hash table connecting package names to their compatibility.
Each key is a symbol, the name of a package.

The value is either nil, representing an incompatible package, or
a version list, representing the highest compatible version of
that package which is available.

A package is considered incompatible if it requires an Emacs
version higher than the one being used.  To check for package
(in)compatibility, don't read this table directly, use
`package--incompatible-p' which also checks dependencies.") nil [57101 57652])
            ("package--build-compatibility-table" function (:documentation "Build `package--compatibility-table' with `package--mapc'.") nil [57654 57978])
            ("package--add-to-compatibility-table" function
               (:documentation "If PKG is compatible (without dependencies), add to the compatibility table.
PKG is a package-desc object.
Only adds if its version is higher than what's already stored in
the table."
                :arguments ("pkg"))
                nil [57980 58592])
            ("cl-defstruct" code nil nil [58756 58969])
            ("package--append-to-alist" function
               (:documentation "Append an entry for PKG-DESC to the start of ALIST and return it.
This entry takes the form (`package-desc-name' PKG-DESC).

If ALIST already has an entry with this name, destructively add
PKG-DESC to the cdr of this entry instead, sorted by version
number."
                :arguments ("pkg-desc" "alist"))
                nil [58971 59925])
            ("package--add-to-archive-contents" function
               (:documentation "Add the PACKAGE from the given ARCHIVE if necessary.
PACKAGE should have the form (NAME . PACKAGE--AC-DESC).
Also, add the originating archive to the `package-desc' structure."
                :arguments ("package" "archive"))
                nil [59927 61121])
            ("package--read-archive-file" function
               (:documentation "Re-read archive file FILE, if it exists.
Will return the data from the file, or nil if the file does not exist.
Will throw an error if the archive version is too new."
                :arguments ("file"))
                nil [61123 61806])
            ("package-read-archive-contents" function
               (:documentation "Re-read archive contents for ARCHIVE.
If successful, set the variable `package-archive-contents'.
If the archive version is too new, signal an error."
                :arguments ("archive"))
                nil [61808 62347])
            ("package--old-archive-priorities" variable (:documentation "Store currently used `package-archive-priorities'.
This is the value of `package-archive-priorities' last time
`package-read-all-archive-contents' was called.  It can be used
by arbitrary functions to decide whether it is necessary to call
it again.") nil [62349 62647])
            ("package-read-all-archive-contents" function (:documentation "Re-read `archive-contents', if it exists.
If successful, set `package-archive-contents'.") nil [62649 62980])
            ("package--initialized" variable nil nil [63164 63197])
            ("package-initialize" function
               (:documentation "Load Emacs Lisp packages, and activate them.
The variable `package-load-list' controls which packages to load.
If optional arg NO-ACTIVATE is non-nil, don't activate packages.
If called as part of loading `user-init-file', set
`package-enable-at-startup' to nil, to prevent accidentally
loading packages twice.

It is not necessary to adjust `load-path' or `require' the
individual packages after calling `package-initialize' -- this is
taken care of by `package-initialize'.

If `package-initialize' is called twice during Emacs startup,
signal a warning, since this is a bad idea except in highly
advanced use cases.  To suppress the warning, remove the
superfluous call to `package-initialize' from your init-file.  If
you have code which must run before `package-initialize', put
that code in the early init-file."
                :user-visible-flag t
                :arguments ("no-activate"))
                nil [63214 64626])
            ("package-quickstart-file" variable nil nil [64628 64660])
            ("package-activate-all" function (:documentation "Activate all installed packages.
The variable `package-load-list' controls which packages to load.") nil [64677 65499])
            ("package--downloads-in-progress" variable (:documentation "List of in-progress asynchronous downloads.") nil [65675 65766])
            ("declare-function" code nil nil [65768 65833])
            ("package-import-keyring" function
               (:documentation "Import keys from FILE."
                :user-visible-flag t
                :arguments ("file"))
                nil [65850 66391])
            ("package--post-download-archives-hook" variable (:documentation "Hook run after the archive contents are downloaded.
Don't run this hook directly.  It is meant to be run as part of
`package--update-downloads-in-progress'.") nil [66393 66603])
            ("put" code nil nil [66604 66671])
            ("package--update-downloads-in-progress" function
               (:documentation "Remove ENTRY from `package--downloads-in-progress'.
Once it's empty, run `package--post-download-archives-hook'."
                :arguments ("entry"))
                nil [66673 67335])
            ("package--download-one-archive" function
               (:documentation "Retrieve an archive file FILE from ARCHIVE, and cache it.
ARCHIVE should be a cons cell of the form (NAME . LOCATION),
similar to an entry in `package-alist'.  Save the cached copy to
\"archives/NAME/FILE\" in `package-user-dir'."
                :arguments ("archive" "file" "async"))
                nil [67337 69086])
            ("package--download-and-read-archives" function
               (:documentation "Download descriptions of all `package-archives' and read them.
This populates `package-archive-contents'.  If ASYNC is non-nil,
perform the downloads asynchronously."
                :arguments ("async"))
                nil [69088 69787])
            ("package-refresh-contents" function
               (:documentation "Download descriptions of all configured ELPA packages.
For each archive configured in the variable `package-archives',
inform Emacs about the latest versions of all packages it offers,
and make them available for download.
Optional argument ASYNC specifies whether to perform the
downloads in the background."
                :user-visible-flag t
                :arguments ("async"))
                nil [69804 70712])
            ("package-compute-transaction" function
               (:documentation "Return a list of packages to be installed, including PACKAGES.
PACKAGES should be a list of `package-desc'.

REQUIREMENTS should be a list of additional requirements; each
element in this list should have the form (PACKAGE VERSION-LIST),
where PACKAGE is a package name and VERSION-LIST is the required
version of that package.

This function recursively computes the requirements of the
packages in REQUIREMENTS, and returns a list of all the packages
that must be installed.  Packages that are already installed are
not included in this list.

SEEN is used internally to detect infinite recursion."
                :arguments ("packages" "requirements" "seen"))
                nil [70971 75182])
            ("package--find-non-dependencies" function (:documentation "Return a list of installed packages which are not dependencies.
Finds all packages in `package-alist' which are not dependencies
of any other packages.
Used to populate `package-selected-packages'.") nil [75184 75746])
            ("package--save-selected-packages" function
               (:documentation "Set and save `package-selected-packages' to VALUE."
                :arguments ("value"))
                nil [75748 76140])
            ("package--user-selected-p" function
               (:documentation "Return non-nil if PKG is a package was installed by the user.
PKG is a package name.
This looks into `package-selected-packages', populating it first
if it is still empty."
                :arguments ("pkg"))
                nil [76142 76511])
            ("package--get-deps" function (:arguments ("pkg" "only")) nil [76513 77250])
            ("package--user-installed-p" function
               (:documentation "Return non-nil if PACKAGE is a user-installed package.
PACKAGE is the package name, a symbol.  Check whether the package
was installed into `package-user-dir' where we assume to have
control over."
                :arguments ("package"))
                nil [77252 77644])
            ("package--removable-packages" function (:documentation "Return a list of names of packages no longer needed.
These are packages which are neither contained in
`package-selected-packages' nor a dependency of one that is.") nil [77646 78336])
            ("package--used-elsewhere-p" function
               (:documentation "Non-nil if PKG-DESC is a dependency of a package in PKG-LIST.
Return the first package found in PKG-LIST of which PKG is a
dependency.  If ALL is non-nil, return all such packages instead.

When not specified, PKG-LIST defaults to `package-alist'
with PKG-DESC entry removed."
                :arguments ("pkg-desc" "pkg-list" "all"))
                nil [78338 79212])
            ("package--sort-deps-in-alist" function
               (:documentation "Return a list of dependencies for PACKAGE sorted by dependency.
PACKAGE is included as the first element of the returned list.
ONLY is an alist associating package names to package objects.
Only these packages will be in the return value and their cdrs are
destructively set to nil in ONLY."
                :arguments ("package" "only"))
                nil [79214 79873])
            ("package--sort-by-dependence" function
               (:documentation "Return PACKAGE-LIST sorted by dependence.
That is, any element of the returned list is guaranteed to not
directly depend on any elements that come before it.

PACKAGE-LIST is a list of `package-desc' objects.
Indirect dependencies are guaranteed to be returned in order only
if all the in-between dependencies are also in PACKAGE-LIST."
                :arguments ("package-list"))
                nil [79875 80728])
            ("package-archive-base" function
               (:documentation "Return the archive containing the package NAME."
                :arguments ("desc"))
                nil [81122 81270])
            ("package-install-from-archive" function
               (:documentation "Download and install a tar package."
                :arguments ("pkg-desc"))
                nil [81272 83490])
            ("package-installed-p" function
               (:documentation "Return non-nil if PACKAGE, of MIN-VERSION or newer, is installed.
If PACKAGE is a symbol, it is the package name and MIN-VERSION
should be a version list.

If PACKAGE is a `package-desc' object, MIN-VERSION is ignored."
                :arguments ("package" "min-version"))
                nil [83492 84553])
            ("package-download-transaction" function
               (:documentation "Download and install all the packages in PACKAGES.
PACKAGES should be a list of `package-desc'.
This function assumes that all package requirements in
PACKAGES are satisfied, i.e. that PACKAGES is computed
using `package-compute-transaction'."
                :arguments ("packages"))
                nil [84555 84898])
            ("package-install" function
               (:documentation "Install the package PKG.
PKG can be a `package-desc' or a symbol naming one of the available packages
in an archive in `package-archives'.  Interactively, prompt for its name.

If called interactively or if DONT-SELECT nil, add PKG to
`package-selected-packages'.

If PKG is a `package-desc' and it is already installed, don't try
to install it but still mark it as selected."
                :user-visible-flag t
                :arguments ("pkg" "dont-select"))
                nil [84915 86813])
            ("package-strip-rcs-id" function
               (:documentation "Strip RCS version ID from the version string STR.
If the result looks like a dotted numeric version, return it.
Otherwise return nil."
                :arguments ("str"))
                nil [86815 87164])
            ("declare-function" code nil nil [87166 87224])
            ("package-install-from-buffer" function
               (:documentation "Install a package from the current buffer.
The current buffer is assumed to be a single .el or .tar file or
a directory.  These must follow the packaging guidelines (see
info node `(elisp)Packaging').

Specially, if current buffer is a directory, the -pkg.el
description file is not mandatory, in which case the information
is derived from the main .el file in the directory.

Downloads and installs required packages as needed."
                :user-visible-flag t)
                nil [87241 88740])
            ("package-install-file" function
               (:documentation "Install a package from a file.
The file can either be a tar file, an Emacs Lisp file, or a
directory."
                :user-visible-flag t
                :arguments ("file"))
                nil [88757 89204])
            ("package-install-selected-packages" function
               (:documentation "Ensure packages in `package-selected-packages' are installed.
If some packages are not installed propose to install them."
                :user-visible-flag t)
                nil [89221 90500])
            ("package--newest-p" function
               (:documentation "Return non-nil if PKG is the newest package with its name."
                :arguments ("pkg"))
                nil [90525 90694])
            ("package-delete" function
               (:documentation "Delete package PKG-DESC.

Argument PKG-DESC is a full description of package as vector.
Interactively, prompt the user for the package name and version.

When package is used elsewhere as dependency of another package,
refuse deleting it and return an error.
If prefix argument FORCE is non-nil, package will be deleted even
if it is used elsewhere.
If NOSAVE is non-nil, the package is not removed from
`package-selected-packages'."
                :user-visible-flag t
                :arguments ("pkg-desc" "force" "nosave"))
                nil [90696 94307])
            ("package-reinstall" function
               (:documentation "Reinstall package PKG.
PKG should be either a symbol, the package name, or a `package-desc'
object."
                :user-visible-flag t
                :arguments ("pkg"))
                nil [94324 94820])
            ("package-autoremove" function
               (:documentation "Remove packages that are no more needed.

Packages that are no more needed by other packages in
`package-selected-packages' and their dependencies
will be deleted."
                :user-visible-flag t)
                nil [94837 95834])
            ("describe-package" function
               (:documentation "Display the full documentation of PACKAGE (a symbol)."
                :user-visible-flag t
                :arguments ("package"))
                nil [95887 97326])
            ("package-help-section-name" variable
               (:documentation "Face used on section names in package description buffers."
                :default-value '((t :inherit (bold font-lock-function-name-face)))
                :type "face")
                nil [97328 97498])
            ("package--print-help-section" function
               (:documentation "Print \"NAME: \", right aligned to the 13th column.
If more STRINGS are provided, insert them followed by a newline.
Otherwise no newline is inserted."
                :arguments ("name" "strings"))
                nil [97500 97947])
            ("declare-function" code nil nil [97949 98009])
            ("describe-package-1" function (:arguments ("pkg")) nil [98011 107491])
            ("package-install-button-action" function (:arguments ("button")) nil [107493 107823])
            ("package-delete-button-action" function (:arguments ("button")) nil [107825 108148])
            ("package-keyword-button-action" function (:arguments ("button")) nil [108150 108310])
            ("package-make-button" function (:arguments ("text" "props")) nil [108312 108781])
            ("package-menu-mode-map" variable
               (:documentation "Local keymap for `package-menu-mode' buffers."
                :default-value (let ((map (make-sparse-keymap))) (set-keymap-parent map tabulated-list-mode-map) (define-key map "" 'package-menu-describe-package) (define-key map "u" 'package-menu-mark-unmark) (define-key map "" 'package-menu-backup-unmark) (define-key map "d" 'package-menu-mark-delete) (define-key map "i" 'package-menu-mark-install) (define-key map "U" 'package-menu-mark-upgrades) (define-key map "r" 'package-menu-refresh) (define-key map "f" 'package-menu-filter) (define-key map "~" 'package-menu-mark-obsolete-for-deletion) (define-key map "x" 'package-menu-execute) (define-key map "h" 'package-menu-quick-help) (define-key map "H" #'package-menu-hide-package) (define-key map "?" 'package-menu-describe-package) (define-key map "(" #'package-menu-toggle-hiding) map))
                nil [108810 109728])
            ("easy-menu-define" code nil nil [109730 111542])
            ("package-menu--new-package-list" variable (:documentation "List of newly-available packages since `list-packages' was last called.") nil [111544 111663])
            ("package-menu--transaction-status" variable (:documentation "Mode-line status of ongoing package transaction.") nil [111665 111763])
            ("define-derived-mode" code nil nil [111765 112697])
            ("package--push" function
               (:documentation "Convenience macro for `package-menu--generate'.
If the alist stored in the symbol LISTNAME lacks an entry for a
package PKG-DESC, add one.  The alist is keyed with PKG-DESC."
                :arguments ("pkg-desc" "status" "listname"))
                nil [112699 113067])
            ("package-list-unversioned" variable (:documentation "If non-nil include packages that don't have a version in `list-package'.") nil [113069 113183])
            ("package-list-unsigned" variable (:documentation "If non-nil, mention in the list which packages were installed w/o signature.") nil [113185 113300])
            ("package--emacs-version-list" variable
               (:documentation "`emacs-version', as a list."
                :default-value (version-to-list emacs-version))
                nil [113302 113402])
            ("package--incompatible-p" function
               (:documentation "Return non-nil if PKG has no chance of being installable.
PKG is a `package-desc' object.

If SHALLOW is non-nil, this only checks if PKG depends on a
higher `emacs-version' than the one being used.  Otherwise, also
checks the viability of dependencies, according to
`package--compatibility-table'.

If PKG requires an incompatible Emacs version, the return value
is this version (as a string).
If PKG requires incompatible packages, the return value is a list
of these dependencies, similar to the list returned by
`package-desc-reqs'."
                :arguments ("pkg" "shallow"))
                nil [113404 114574])
            ("package-desc-status" function (:arguments ("pkg-desc")) nil [114576 116238])
            ("package-menu--hide-packages" variable
               (:documentation "Whether available obsolete packages should be hidden.
Can be toggled with \\<package-menu-mode-map> \\[package-menu-toggle-hiding].
Installed obsolete packages are always displayed."
                :default-value t)
                nil [116240 116464])
            ("package-menu-toggle-hiding" function
               (:documentation "Toggle visibility of obsolete available packages."
                :user-visible-flag t)
                nil [116466 116923])
            ("package--remove-hidden" function
               (:documentation "Filter PKG-LIST according to `package-archive-priorities'.
PKG-LIST must be a list of `package-desc' objects, all with the
same name, sorted by decreasing `package-desc-priority-version'.
Return a list of packages tied for the highest priority according
to their archives."
                :arguments ("pkg-list"))
                nil [116925 118870])
            ("package-hidden-regexps" variable (:documentation "List of regexps matching the name of packages to hide.
If the name of a package matches any of these regexps it is
omitted from the package menu.  To toggle this, type \\[package-menu-toggle-hiding].

Values can be interactively added to this list by typing
\\[package-menu-hide-package] on a package") nil [118872 119300])
            ("package-menu--refresh" function
               (:documentation "Re-populate the `tabulated-list-entries'.
PACKAGES should be nil or t, which means to display all known packages.
KEYWORDS should be nil or a list of keywords."
                :arguments ("packages" "keywords"))
                nil [119302 121497])
            ("package-all-keywords" function (:documentation "Collect all package keywords") nil [121499 121762])
            ("package--mapc" function
               (:documentation "Call FUNCTION for all known PACKAGES.
PACKAGES can be nil or t, which means to display all known
packages, or a list of packages.

Built-in packages are converted with `package--from-builtin'."
                :arguments ("function" "packages"))
                nil [121764 123023])
            ("package--has-keyword-p" function
               (:documentation "Test if package DESC has any of the given KEYWORDS.
When none are given, the package matches."
                :arguments ("desc" "keywords"))
                nil [123025 123615])
            ("package-menu--generate" function
               (:documentation "Populate the Package Menu.
 If REMEMBER-POS is non-nil, keep point on the same entry.
PACKAGES should be t, which means to display all known packages,
or a list of package names (symbols) to display.

With KEYWORDS given, only packages with those keywords are
shown."
                :arguments ("remember-pos" "packages" "keywords"))
                nil [123617 124417])
            ("package-menu--print-info" function
               (:documentation "Return a package entry suitable for `tabulated-list-entries'.
PKG has the form (PKG-DESC . STATUS).
Return (PKG-DESC [NAME VERSION STATUS DOC])."
                :arguments ("pkg"))
                nil [124419 124652])
            ("make-obsolete" code nil nil [124653 124749])
            ("package-name" variable
               (:documentation "Face used on package names in the package menu."
                :default-value '((t :inherit link))
                :type "face")
                nil [124776 124891])
            ("package-description" variable
               (:documentation "Face used on package description summaries in the package menu."
                :default-value '((t :inherit default))
                :type "face")
                nil [124893 125034])
            ("package-status-built-in" variable
               (:documentation "Face used on the status and version of built-in packages."
                :default-value '((t :inherit font-lock-builtin-face))
                :type "face")
                nil [125112 125266])
            ("package-status-external" variable
               (:documentation "Face used on the status and version of external packages."
                :default-value '((t :inherit package-status-built-in))
                :type "face")
                nil [125268 125423])
            ("package-status-available" variable
               (:documentation "Face used on the status and version of available packages."
                :default-value '((t :inherit default))
                :type "face")
                nil [125425 125566])
            ("package-status-new" variable
               (:documentation "Face used on the status and version of new packages."
                :default-value '((t :inherit (bold package-status-available)))
                :type "face")
                nil [125568 125721])
            ("package-status-held" variable
               (:documentation "Face used on the status and version of held packages."
                :default-value '((t :inherit font-lock-constant-face))
                :type "face")
                nil [125723 125870])
            ("package-status-disabled" variable
               (:documentation "Face used on the status and version of disabled packages."
                :default-value '((t :inherit font-lock-warning-face))
                :type "face")
                nil [125872 126026])
            ("package-status-installed" variable
               (:documentation "Face used on the status and version of installed packages."
                :default-value '((t :inherit font-lock-comment-face))
                :type "face")
                nil [126028 126184])
            ("package-status-dependency" variable
               (:documentation "Face used on the status and version of dependency packages."
                :default-value '((t :inherit package-status-installed))
                :type "face")
                nil [126186 126346])
            ("package-status-unsigned" variable
               (:documentation "Face used on the status and version of unsigned packages."
                :default-value '((t :inherit font-lock-warning-face))
                :type "face")
                nil [126348 126502])
            ("package-status-incompat" variable
               (:documentation "Face used on the status and version of incompat packages."
                :default-value '((t :inherit error))
                :type "face")
                nil [126504 126641])
            ("package-status-avail-obso" variable
               (:documentation "Face used on the status and version of avail-obso packages."
                :default-value '((t :inherit package-status-incompat))
                :type "face")
                nil [126643 126802])
            ("package-menu--print-info-simple" function
               (:documentation "Return a package entry suitable for `tabulated-list-entries'.
PKG is a `package-desc' object.
Return (PKG-DESC [NAME VERSION STATUS DOC])."
                :arguments ("pkg"))
                nil [126832 128530])
            ("package-menu--old-archive-contents" variable (:documentation "`package-archive-contents' before the latest refresh.") nil [128532 128637])
            ("package-menu-refresh" function
               (:documentation "Download the Emacs Lisp package archive.
This fetches the contents of each archive specified in
`package-archives', and then refreshes the package menu."
                :user-visible-flag t)
                nil [128639 129111])
            ("package-menu-hide-package" function
               (:documentation "Hide a package under point.
If optional arg BUTTON is non-nil, describe its associated package."
                :user-visible-flag t)
                nil [129113 130270])
            ("package-menu-describe-package" function
               (:documentation "Describe the current package.
If optional arg BUTTON is non-nil, describe its associated package."
                :user-visible-flag t
                :arguments ("button"))
                nil [130273 130649])
            ("package-menu-mark-delete" function
               (:documentation "Mark a package for deletion and move to the next line."
                :user-visible-flag t
                :arguments ("_num"))
                nil [130677 130967])
            ("package-menu-mark-install" function
               (:documentation "Mark a package for installation and move to the next line."
                :user-visible-flag t
                :arguments ("_num"))
                nil [130969 131247])
            ("package-menu-mark-unmark" function
               (:documentation "Clear any marks on a package and move to the next line."
                :user-visible-flag t
                :arguments ("_num"))
                nil [131249 131411])
            ("package-menu-backup-unmark" function
               (:documentation "Back up one line and clear any marks on that package."
                :user-visible-flag t)
                nil [131413 131575])
            ("package-menu-mark-obsolete-for-deletion" function
               (:documentation "Mark all obsolete packages for deletion."
                :user-visible-flag t)
                nil [131577 131882])
            ("package--quick-help-keys" variable (:default-value '(("install," "delete," "unmark," ("execute" . 1)) ("next," "previous") ("Hide-package," "(-toggle-hidden") ("refresh-contents," "g-redisplay," "filter," "help"))) nil [131884 132094])
            ("package--prettify-quick-help-key" function
               (:documentation "Prettify DESC to be displayed as a help menu."
                :arguments ("desc"))
                nil [132096 132597])
            ("package-menu-quick-help" function
               (:documentation "Show short key binding help for `package-menu-mode'.
The full list of keys can be viewed with \\[describe-mode]."
                :user-visible-flag t)
                nil [132599 132877])
            ("define-obsolete-function-alias" code nil nil [132879 132981])
            ("package-menu-get-status" function nil nil [132983 133171])
            ("package-archive-priority" function
               (:documentation "Return the priority of ARCHIVE.

The archive priorities are specified in
`package-archive-priorities'. If not given there, the priority
defaults to 0."
                :arguments ("archive"))
                nil [133173 133434])
            ("package-desc-priority-version" function
               (:documentation "Return the version PKG-DESC with the archive priority prepended.

This allows for easy comparison of package versions from
different archives if archive priorities are meant to be taken in
consideration."
                :arguments ("pkg-desc"))
                nil [133436 133774])
            ("package-menu--find-upgrades" function nil nil [133776 134777])
            ("package-menu--mark-upgrades-pending" variable (:documentation "Whether mark-upgrades is waiting for a refresh to finish.") nil [134779 134889])
            ("package-menu--mark-upgrades-1" function (:documentation "Mark all upgradable packages in the Package Menu.
Implementation of `package-menu-mark-upgrades'.") nil [134891 135850])
            ("package-menu-mark-upgrades" function
               (:documentation "Mark all upgradable packages in the Package Menu.
For each installed package with a newer version available, place
an (I)nstall flag on the available version and a (D)elete flag on
the installed version.  A subsequent \\[package-menu-execute]
call will upgrade the package.

If there's an async refresh operation in progress, the flags will
be placed as part of `package-menu--post-refresh' instead of
immediately."
                :user-visible-flag t)
                nil [135853 136505])
            ("package-menu--list-to-prompt" function
               (:documentation "Return a string listing PACKAGES that's usable in a prompt.
PACKAGES is a list of `package-desc' objects.
Formats the returned string to be usable in a minibuffer
prompt (see `package-menu--prompt-transaction-p')."
                :arguments ("packages"))
                nil [136507 136983])
            ("package-menu--prompt-transaction-p" function
               (:documentation "Prompt the user about DELETE, INSTALL, and UPGRADE.
DELETE, INSTALL, and UPGRADE are lists of `package-desc' objects.
Either may be nil, but not all."
                :arguments ("delete" "install" "upgrade"))
                nil [136986 137551])
            ("package-menu--partition-transaction" function
               (:documentation "Return an alist describing an INSTALL DELETE transaction.
Alist contains three entries, upgrade, delete, and install, each
with a list of package names.

The upgrade entry contains any `package-desc' objects in INSTALL
whose name coincides with an object in DELETE.  The delete and
the install entries are the same as DELETE and INSTALL with such
objects removed."
                :arguments ("install" "delete"))
                nil [137554 138257])
            ("package-menu--perform-transaction" function
               (:documentation "Install packages in INSTALL-LIST and delete DELETE-LIST."
                :arguments ("install-list" "delete-list"))
                nil [138259 139359])
            ("package--update-selected-packages" function
               (:documentation "Update the `package-selected-packages' list according to ADD and REMOVE.
ADD and REMOVE must be disjoint lists of package names (or
`package-desc' objects) to be added and removed to the selected
packages list, respectively."
                :arguments ("add" "remove"))
                nil [139361 140029])
            ("package-menu-execute" function
               (:documentation "Perform marked Package Menu actions.
Packages marked for installation are downloaded and installed;
packages marked for deletion are removed.
Optional argument NOQUERY non-nil means do not ask the user to confirm."
                :user-visible-flag t
                :arguments ("noquery"))
                nil [140031 142216])
            ("package-menu--version-predicate" function (:arguments ("A" "B")) nil [142218 142452])
            ("package-menu--status-predicate" function (:arguments ("A" "B")) nil [142454 143553])
            ("package-menu--description-predicate" function (:arguments ("A" "B")) nil [143555 143758])
            ("package-menu--name-predicate" function (:arguments ("A" "B")) nil [143760 143909])
            ("package-menu--archive-predicate" function (:arguments ("A" "B")) nil [143911 144057])
            ("package-menu--populate-new-package-list" function (:documentation "Decide which packages are new in `package-archives-contents'.
Store this list in `package-menu--new-package-list'.") nil [144059 144523])
            ("package-menu--find-and-notify-upgrades" function (:documentation "Notify the user of upgradable packages.") nil [144525 144862])
            ("package-menu--post-refresh" function (:documentation "If there's a *Packages* buffer, revert it and check for new packages and upgrades.
Do nothing if there's no *Packages* buffer.

This function is called after `package-refresh-contents' and it
is added to `post-command-hook' by any function which alters the
package database (`package-install' and `package-delete').  When
run, it removes itself from `post-command-hook'.") nil [144865 145593])
            ("package-menu--mark-or-notify-upgrades" function (:documentation "If there's a *Packages* buffer, check for upgrades and possibly mark them.
Do nothing if there's no *Packages* buffer.  If there are
upgrades, mark them if `package-menu--mark-upgrades-pending' is
non-nil, otherwise just notify the user that there are upgrades.
This function is called after `package-refresh-contents'.") nil [145595 146216])
            ("list-packages" function
               (:documentation "Display a list of packages.
This first fetches the updated list of packages before
displaying, unless a prefix argument NO-FETCH is specified.
The list is displayed in a buffer named `*Packages*', and
includes the package's version, availability status, and a
short description."
                :user-visible-flag t
                :arguments ("no-fetch"))
                nil [146233 147497])
            ("defalias" code nil nil [147514 147562])
            ("package-show-package-list" function
               (:documentation "Display PACKAGES in a *Packages* buffer.
This is similar to `list-packages', but it does not fetch the
updated list of packages, and it only displays packages with
names in PACKAGES (which should be a list of symbols).

When KEYWORDS are given, only packages with those KEYWORDS are
shown."
                :user-visible-flag t
                :arguments ("packages" "keywords"))
                nil [147585 148256])
            ("package-menu-filter" function
               (:documentation "Filter the *Packages* buffer.
Show only those items that relate to the specified KEYWORD.
KEYWORD can be a string or a list of strings.  If it is a list, a
package will be displayed if it matches any of the keywords.
Interactively, it is a list of strings separated by commas.

To restore the full package list, type `q'."
                :user-visible-flag t
                :arguments ("keyword"))
                nil [148371 148997])
            ("package-list-packages-no-fetch" function
               (:documentation "Display a list of packages.
Does not fetch the updated list of packages before displaying.
The list is displayed in a buffer named `*Packages*'."
                :user-visible-flag t)
                nil [148999 149225])
            ("package-quickstart" variable (:documentation "Precompute activation actions to speed up startup.
This requires the use of `package-quickstart-refresh' every time the
activations need to be changed, such as when `package-load-list' is modified.") nil [149941 150212])
            ("package-quickstart-file" variable
               (:documentation "Location of the file used to speed up activation of packages at startup."
                :default-value (locate-user-emacs-file "package-quickstart.el"))
                nil [150214 150409])
            ("package--quickstart-maybe-refresh" function nil nil [150411 150649])
            ("package-quickstart-refresh" function
               (:documentation "(Re)Generate the `package-quickstart-file'."
                :user-visible-flag t)
                nil [150651 153247])
            ("package" package nil nil [153249 153267]))          
      :file "package.el"
      :pointmax 153294
      :fsize 153295
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax '((close-paren 6390 . 6391) (symbol 6358 . 6375) (open-paren 6357 . 6358) (close-paren 6355 . 6356) (symbol 6320 . 6337) (open-paren 6319 . 6320)))
    (semanticdb-table "semanticdb-table-189d5e0"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("Helper-return-blurb" variable nil nil [1127 1159])
            ("Helper-help-map" variable nil nil [1388 1416])
            ("if" code nil nil [1417 2065])
            ("Helper-help-scroller" function nil nil [2067 2996])
            ("Helper-help-options" function
               (:documentation "Describe help options."
                :user-visible-flag t)
                nil [2998 3226])
            ("Helper-describe-key-briefly" function
               (:documentation "Briefly describe binding of KEY."
                :user-visible-flag t
                :arguments ("key"))
                nil [3228 3391])
            ("Helper-describe-key" function
               (:documentation "Describe binding of KEY."
                :user-visible-flag t
                :arguments ("key"))
                nil [3393 3559])
            ("Helper-describe-function" function
               (:documentation "Describe a function.  Name read interactively."
                :user-visible-flag t)
                nil [3561 3754])
            ("Helper-describe-variable" function
               (:documentation "Describe a variable.  Name read interactively."
                :user-visible-flag t)
                nil [3756 3949])
            ("Helper-describe-mode" function
               (:documentation "Describe the current mode."
                :user-visible-flag t)
                nil [3951 4316])
            ("Helper-describe-bindings" function
               (:documentation "Describe local key bindings of current mode."
                :user-visible-flag t)
                nil [4333 4541])
            ("Helper-help" function
               (:documentation "Provide help for current mode."
                :user-visible-flag t)
                nil [4558 5008])
            ("helper" package nil nil [5010 5027]))          
      :file "helper.el.gz"
      :pointmax 5053
      :fsize 1823
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189d600"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("eieio-version" variable
               (:documentation "Current version of EIEIO."
                :default-value "1.4")
                nil [1798 1856])
            ("eieio-version" function
               (:documentation "Display the current version of EIEIO."
                :user-visible-flag t)
                nil [1858 1966])
            ("eieio-core" include nil nil [1968 1989])
            ("defclass" function
               (:documentation "Define NAME as a new class derived from SUPERCLASS with SLOTS.
OPTIONS-AND-DOC is used as the class' options and base documentation.
SUPERCLASSES is a list of superclasses to inherit from, with SLOTS
being the slots residing in that class definition.  Supported tags are:

  :initform   - Initializing form.
  :initarg    - Tag used during initialization.
  :accessor   - Tag used to create a function to access this slot.
  :allocation - Specify where the value is stored.
                Defaults to `:instance', but could also be `:class'.
  :writer     - A function symbol which will `write' an object's slot.
  :reader     - A function symbol which will `read' an object.
  :type       - The type of data allowed in this slot (see `typep').
  :documentation
              - A string documenting use of this slot.

The following are extensions on CLOS:
  :custom     - When customizing an object, the custom :type.  Public only.
  :label      - A text string label used for a slot when customizing.
  :group      - Name of a customization group this slot belongs in.
  :printer    - A function to call to print the value of a slot.
                See `eieio-override-prin1' as an example.

A class can also have optional options.  These options happen in place
of documentation (including a :documentation tag), in addition to
documentation, or not at all.  Supported options are:

  :documentation - The doc-string used for this class.

Options added to EIEIO:

  :allow-nil-initform - Non-nil to skip typechecking of null initforms.
  :custom-groups      - List of custom group names.  Organizes slots into
                        reasonable groups for customizations.
  :abstract           - Non-nil to prevent instances of this class.
                        If a string, use as an error string if someone does
                        try to make an instance.
  :method-invocation-order
                      - Control the method invocation order if there is
                        multiple inheritance.  Valid values are:
                         :breadth-first - The default.
                         :depth-first

Options in CLOS not supported in EIEIO:

  :metaclass - Class to use in place of `standard-class'
  :default-initargs - Initargs to use when initializing new objects of
                      this class.

Due to the way class options are set up, you can add any tags you wish,
and reference them using the function `class-option'."
                :arguments ("name" "superclasses" "slots" "options-and-doc"))
                nil [2021 11671])
            ("oref" function
               (:documentation "Retrieve the value stored in OBJ in the slot named by SLOT.
Slot is the name of the slot when created by `defclass' or the label
created by the :initarg tag."
                :arguments ("obj" "slot"))
                nil [11709 11967])
            ("defalias" code nil nil [11969 12003])
            ("defalias" code nil nil [12004 12042])
            ("make-obsolete" code nil nil [12043 12121])
            ("oref-default" function
               (:documentation "Get the default value of OBJ (maybe a class) for SLOT.
The default value is the value installed in a class with the :initform
tag.  SLOT can be the slot name, or the tag specified by the :initarg
tag in the `defclass' call."
                :arguments ("obj" "slot"))
                nil [12123 12463])
            ("with-slots" function
               (:documentation "Bind SPEC-LIST lexically to slot values in OBJECT, and execute BODY.
This establishes a lexical environment for referring to the slots in
the instance named by the given slot-names as though they were
variables.  Within such a context the value of the slot can be
specified by using its slot name, as if it were a lexically bound
variable.  Both setf and setq can be used to set the value of the
slot.

SPEC-LIST is of a form similar to `let'.  For example:

  ((VAR1 SLOT1)
    SLOT2
    SLOTN
   (VARN+1 SLOTN+1))

Where each VAR is the local variable given to the associated
SLOT.  A slot specified without a variable name is given a
variable name of the same name as the slot."
                :arguments ("spec-list" "object" "body"))
                nil [12490 13709])
            ("eieio-pcase-slot-index-table" function
               (:documentation "Return some data structure from which can be extracted the slot offset."
                :arguments ("obj"))
                nil [13822 13995])
            ("eieio-pcase-slot-index-from-index-table" function
               (:documentation "Find the index to pass to `aref' to access SLOT."
                :arguments ("index-table" "slot"))
                nil [13997 14247])
            ("pcase-defmacro" code nil nil [14249 15547])
            ("define-obsolete-function-alias" code nil nil [15656 15737])
            ("eieio--object-names" variable
               (:constant-flag t
                :default-value (make-hash-table :test #'eq :weakness 'key))
                nil [16122 16196])
            ("cl-defgeneric" code nil nil [16198 16390])
            ("define-obsolete-function-alias" code nil nil [16392 16480])
            ("eieio-object-name" function
               (:documentation "Return a printed representation for object OBJ.
If EXTRA, include that in the string returned to represent the symbol."
                :arguments ("obj" "extra"))
                nil [16482 16784])
            ("define-obsolete-function-alias" code nil nil [16785 16857])
            ("cl-defgeneric" code nil nil [16859 17152])
            ("define-obsolete-function-alias" code nil nil [17153 17248])
            ("eieio-object-class" function
               (:documentation "Return the class struct defining OBJ."
                :arguments ("obj"))
                nil [17250 17479])
            ("define-obsolete-function-alias" code nil nil [17480 17554])
            ("define-obsolete-function-alias" code nil nil [17576 17646])
            ("eieio-object-class-name" function
               (:documentation "Return a Lisp like symbol name for OBJ's class."
                :arguments ("obj"))
                nil [17648 17819])
            ("define-obsolete-function-alias" code nil nil [17820 17905])
            ("eieio-class-parents" function
               (:documentation "Return parent classes to CLASS.  (overload of variable).

The CLOS function `class-direct-superclasses' is aliased to this function."
                :arguments ("class"))
                nil [17907 18132])
            ("define-obsolete-function-alias" code nil nil [18134 18210])
            ("eieio-class-children" function
               (:documentation "Return child classes to CLASS.
The CLOS function `class-direct-subclasses' is aliased to this function."
                :arguments ("class"))
                nil [18212 18435])
            ("define-obsolete-function-alias" code nil nil [18436 18516])
            ("define-obsolete-function-alias" code nil nil [18546 18636])
            ("define-obsolete-function-alias" code nil nil [18637 18726])
            ("eieio-class-parent" function
               (:documentation "Return first parent class to CLASS.  (overload of variable)."
                :arguments ("class"))
                nil [18728 18868])
            ("define-obsolete-function-alias" code nil nil [18869 18942])
            ("same-class-p" function
               (:documentation "Return t if OBJ is of class-type CLASS."
                :arguments ("obj" "class"))
                nil [18944 19174])
            ("object-of-class-p" function
               (:documentation "Return non-nil if OBJ is an instance of CLASS or CLASS' subclasses."
                :arguments ("obj" "class"))
                nil [19176 19415])
            ("defalias" code nil nil [19443 19488])
            ("child-of-class-p" function
               (:documentation "Return non-nil if CHILD class is a subclass of CLASS."
                :arguments ("child" "class"))
                nil [19490 20102])
            ("eieio-slot-descriptor-name" function (:arguments ("slot")) nil [20104 20179])
            ("eieio-class-slots" function
               (:documentation "Return list of slots available in instances of CLASS."
                :arguments ("class"))
                nil [20181 20492])
            ("object-slots" function
               (:documentation "Return list of slot names available in OBJ."
                :arguments ("obj"))
                nil [20494 20738])
            ("eieio--class-slot-initarg" function
               (:documentation "Fetch from CLASS, SLOT's :initarg."
                :arguments ("class" "slot"))
                nil [20740 21045])
            ("oset" function
               (:documentation "Set the value in OBJ for slot SLOT to VALUE.
SLOT is the slot name as specified in `defclass' or the tag created
with in the :initarg slot.  VALUE can be any Lisp object."
                :arguments ("obj" "slot" "value"))
                nil [21072 21361])
            ("oset-default" function
               (:documentation "Set the default slot in CLASS for SLOT to VALUE.
The default value is usually set with the :initform tag during class
creation.  This allows users to change the default behavior of classes
after they are created."
                :arguments ("class" "slot" "value"))
                nil [21363 21714])
            ("slot-boundp" function
               (:documentation "Return non-nil if OBJECT's SLOT is bound.
Setting a slot's value makes it bound.  Calling `slot-makeunbound' will
make a slot unbound.
OBJECT can be an instance or a class."
                :arguments ("object" "slot"))
                nil [21759 22344])
            ("slot-makeunbound" function
               (:documentation "In OBJECT, make SLOT unbound."
                :arguments ("object" "slot"))
                nil [22346 22459])
            ("slot-exists-p" function
               (:documentation "Return non-nil if OBJECT-OR-CLASS has SLOT."
                :arguments ("object-or-class" "slot"))
                nil [22461 23145])
            ("find-class" function
               (:documentation "Return the class that SYMBOL represents.
If there is no class, nil is returned if ERRORP is nil.
If ERRORP is non-nil, `wrong-argument-type' is signaled."
                :arguments ("symbol" "errorp"))
                nil [23147 23505])
            ("object-assoc" function
               (:documentation "Return an object if KEY is `equal' to SLOT's value of an object in LIST.
LIST is a list of objects whose slots are searched.
Objects in LIST do not need to have a slot named SLOT, nor does
SLOT need to be bound.  If these errors occur, those objects will
be ignored."
                :arguments ("key" "slot" "list"))
                nil [23566 24104])
            ("object-assoc-list" function
               (:documentation "Return an association list with the contents of SLOT as the key element.
LIST must be a list of objects with SLOT in it.
This is useful when you need to do completing read on an object group."
                :arguments ("slot" "list"))
                nil [24106 24564])
            ("object-assoc-list-safe" function
               (:documentation "Return an association list with the contents of SLOT as the key element.
LIST must be a list of objects, but those objects do not need to have
SLOT in it.  If it does not, then that element is left out of the association
list."
                :arguments ("slot" "list"))
                nil [24566 25105])
            ("object-add-to-list" function
               (:documentation "In OBJECT's SLOT, add ITEM to the list of elements.
Optional argument APPEND indicates we need to append to the list.
If ITEM already exists in the list in SLOT, then it is not added.
Comparison is done with `equal' through the `member' function call.
If SLOT is unbound, bind it to the list containing ITEM."
                :arguments ("object" "slot" "item" "append"))
                nil [25107 25912])
            ("object-remove-from-list" function
               (:documentation "In OBJECT's SLOT, remove occurrences of ITEM.
Deletion is done with `delete', which deletes by side effect,
and comparisons are done with `equal'.
If SLOT is unbound, do nothing."
                :arguments ("object" "slot" "item"))
                nil [25914 26264])
            ("gv-define-simple-setter" code nil nil [26544 26591])
            ("eieio-default-superclass" type
               (:documentation "Default parent class for classes with no specified parent class.
Its slots are automatically adopted by classes with no specified parents.
This class is not stored in the `parent' slot of a class vector."
                :type "class")
                nil [26976 27243])
            ("setq" code nil nil [27245 27319])
            ("define-obsolete-function-alias" code nil nil [27321 27404])
            ("cl-defgeneric" code nil nil [27406 27701])
            ("define-obsolete-function-alias" code nil nil [27703 27771])
            ("cl-defmethod" code nil nil [27773 28765])
            ("cl-defgeneric" code nil nil [28813 28964])
            ("cl-defmethod" code nil nil [28966 29453])
            ("cl-defgeneric" code nil nil [29501 29609])
            ("cl-defmethod" code nil nil [29611 31167])
            ("cl-defgeneric" code nil nil [31169 31724])
            ("cl-defgeneric" code nil nil [31726 31858])
            ("cl-defmethod" code nil nil [31860 32666])
            ("cl-defgeneric" code nil nil [32668 32931])
            ("cl-defmethod" code nil nil [32933 33308])
            ("cl-defgeneric" code nil nil [33310 33486])
            ("cl-defgeneric" code nil nil [33488 33813])
            ("cl-defmethod" code nil nil [33815 34433])
            ("cl-defmethod" code nil nil [34436 34628])
            ("eieio-print-depth" variable (:documentation "The current indentation depth while printing.
Ignored if `eieio-print-indentation' is nil.") nil [34630 34753])
            ("eieio-print-indentation" variable
               (:documentation "When non-nil, indent contents of printed objects."
                :default-value t)
                nil [34755 34843])
            ("eieio-print-object-name" variable
               (:documentation "When non-nil write the object name in `object-write'.
Does not affect objects subclassing `eieio-named'.  Note that
Emacs<26 requires that object names be present."
                :default-value t)
                nil [34845 35047])
            ("cl-defgeneric" code nil nil [35049 35218])
            ("cl-defmethod" code nil nil [35220 37721])
            ("eieio-override-prin1" function
               (:documentation "Perform a `prin1' on THING taking advantage of object knowledge."
                :arguments ("thing"))
                nil [37723 38489])
            ("eieio-list-prin1" function
               (:documentation "Display LIST where list may contain objects."
                :arguments ("list"))
                nil [38491 39085])
            ("eieio-change-class" function
               (:documentation "Change the class of OBJ to type CLASS.
This may create or delete slots, but does not affect the return value
of `eq'."
                :arguments ("_obj" "_class"))
                nil [39130 39343])
            ("define-obsolete-function-alias" code nil nil [39344 39417])
            ("add-hook" code nil nil [39637 39709])
            ("eieio" package nil nil [39711 39727]))          
      :file "eieio.el.gz"
      :pointmax 39749
      :fsize 12103
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189d620"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("advice--where-alist" variable
               (:documentation "List of descriptions of how to add a function.
Each element has the form (WHERE BYTECODE STACK) where:
  WHERE is a keyword indicating where the function is added.
  BYTECODE is the corresponding byte-code that will be used.
  STACK is the amount of stack space needed by the byte-code."
                :default-value '((:around "\300\301\302#\207" 5) (:before "\300\301\"\210\300\302\"\207" 4) (:after "\300\302\"\300\301\"\210\207" 5) (:override "\300\301\"\207" 4) (:after-until "\300\302\"\206 \300\301\"\207" 4) (:after-while "\300\302\"\205 \300\301\"\207" 4) (:before-until "\300\301\"\206 \300\302\"\207" 4) (:before-while "\300\301\"\205 \300\302\"\207" 4) (:filter-args "\300\302\301!\"\207" 5) (:filter-return "\301\300\302\"!\207" 5)))
                nil [1629 2507])
            ("advice--bytecodes" variable (:default-value (mapcar #'cadr advice--where-alist)) nil [2509 2571])
            ("advice--p" function (:arguments ("object")) nil [2573 2799])
            ("advice--car" function (:arguments ("f")) nil [2801 2849])
            ("advice--cdr" function (:arguments ("f")) nil [2850 2898])
            ("advice--props" function (:arguments ("f")) nil [2899 2947])
            ("advice--cd*r" function (:arguments ("f")) nil [2949 3030])
            ("advice--where" function (:arguments ("f")) nil [3032 3220])
            ("advice--make-docstring" function
               (:documentation "Build the raw docstring for FUNCTION, presumably advised."
                :arguments ("function"))
                nil [3222 5482])
            ("advice-eval-interactive-spec" function
               (:documentation "Evaluate the interactive spec SPEC."
                :arguments ("spec"))
                nil [5484 6074])
            ("advice--interactive-form" function (:arguments ("function")) nil [6076 6446])
            ("advice--make-interactive-form" function (:arguments ("function" "main")) nil [6448 7021])
            ("advice--make-1" function
               (:documentation "Build a function value that adds FUNCTION to MAIN."
                :arguments ("byte-code" "stack-depth" "function" "main" "props"))
                nil [7023 7587])
            ("advice--make" function
               (:documentation "Build a function value that adds FUNCTION to MAIN at WHERE.
WHERE is a symbol to select an entry in `advice--where-alist'."
                :arguments ("where" "function" "main" "props"))
                nil [7589 8405])
            ("advice--member-p" function (:arguments ("function" "use-name" "definition")) nil [8407 8917])
            ("advice--tweak" function (:arguments ("flist" "tweaker")) nil [8919 9427])
            ("advice--remove-function" function (:arguments ("flist" "function")) nil [9444 9806])
            ("advice--buffer-local-function-sample" variable (:documentation "keeps an example of the special \"run the default value\" functions.
These functions play the same role as t in buffer-local hooks, and to recognize
them, we keep a sample here against which to compare.  Each instance is
different, but `function-equal' will hopefully ignore those differences.") nil [9808 10155])
            ("advice--set-buffer-local" function (:arguments ("var" "val")) nil [10157 10336])
            ("advice--buffer-local" function
               (:documentation "Buffer-local value of VAR, presumed to contain a function."
                :arguments ("var"))
                nil [10353 10741])
            ("advice--normalize-place" function (:arguments ("place")) nil [10763 11023])
            ("add-function" function
               (:documentation "Add a piece of advice on the function stored at PLACE.
FUNCTION describes the code to add.  WHERE describes where to add it.
WHERE can be explained by showing the resulting new function, as the
result of combining FUNCTION and the previous value of PLACE, which we
call OLDFUN here:
`:before'	(lambda (&rest r) (apply FUNCTION r) (apply OLDFUN r))
`:after'	(lambda (&rest r) (prog1 (apply OLDFUN r) (apply FUNCTION r)))
`:around'	(lambda (&rest r) (apply FUNCTION OLDFUN r))
`:override'	(lambda (&rest r) (apply FUNCTION r))
`:before-while'	(lambda (&rest r) (and (apply FUNCTION r) (apply OLDFUN r)))
`:before-until'	(lambda (&rest r) (or  (apply FUNCTION r) (apply OLDFUN r)))
`:after-while'	(lambda (&rest r) (and (apply OLDFUN r) (apply FUNCTION r)))
`:after-until'	(lambda (&rest r) (or  (apply OLDFUN r) (apply FUNCTION r)))
`:filter-args'	(lambda (&rest r) (apply OLDFUN (funcall FUNCTION r)))
`:filter-return'(lambda (&rest r) (funcall FUNCTION (apply OLDFUN r)))
If FUNCTION was already added, do nothing.
PROPS is an alist of additional properties, among which the following have
a special meaning:
- `name': a string or symbol.  It can be used to refer to this piece of advice.
- `depth': a number indicating a preference w.r.t ordering.
  The default depth is 0.  By convention, a depth of 100 means that
  the advice  should be innermost (i.e. at the end of the list),
  whereas a depth of -100 means that the advice should be outermost.

If PLACE is a symbol, its `default-value' will be affected.
Use (local \\='SYMBOL) if you want to apply FUNCTION to SYMBOL buffer-locally.
Use (var VAR) if you want to apply FUNCTION to the (lexical) VAR.
If you are trying to modify an existing named function rather
than a function value, you probably want to use `advice-add'
instead (see Info node `(elisp) Advising Named Functions').

If one of FUNCTION or OLDFUN is interactive, then the resulting function
is also interactive.  There are 3 cases:
- FUNCTION is not interactive: the interactive spec of OLDFUN is used.
- The interactive spec of FUNCTION is itself a function: it should take one
  argument (the interactive spec of OLDFUN, which it can pass to
  `advice-eval-interactive-spec') and return the list of arguments to use.
- Else, use the interactive spec of FUNCTION and ignore the one of OLDFUN."
                :arguments ("where" "place" "function" "props"))
                nil [11041 14190])
            ("advice--add-function" function (:arguments ("where" "ref" "function" "props")) nil [14207 14695])
            ("remove-function" function
               (:documentation "Remove the FUNCTION piece of advice from PLACE.
If FUNCTION was not added to PLACE, do nothing.
Instead of FUNCTION being the actual function, it can also be the `name'
of the piece of advice."
                :arguments ("place" "function"))
                nil [14712 15242])
            ("advice-function-mapc" function
               (:documentation "Apply F to every advice function in FUNCTION-DEF.
F is called with two arguments: the function that was added, and the
properties alist that was specified when it was added."
                :arguments ("f" "function-def"))
                nil [15244 15625])
            ("advice-function-member-p" function
               (:documentation "Return non-nil if ADVICE is already in FUNCTION-DEF.
Instead of ADVICE being the actual function, it can also be the `name'
of the piece of advice."
                :arguments ("advice" "function-def"))
                nil [15627 15884])
            ("advice--subst-main" function (:arguments ("old" "new")) nil [15962 16088])
            ("advice--normalize" function (:arguments ("symbol" "def")) nil [16090 16657])
            ("advice--strip-macro" function (:arguments ("x")) nil [16659 16735])
            ("advice--symbol-function" function (:arguments ("symbol")) nil [16737 17685])
            ("advice--defalias-fset" function (:arguments ("fsetfun" "symbol" "newdef")) nil [17687 19103])
            ("advice-add" function
               (:documentation "Like `add-function' but for the function named SYMBOL.
Contrary to `add-function', this will properly handle the cases where SYMBOL
is defined as a macro, alias, command, ..."
                :arguments ("symbol" "where" "function" "props"))
                nil [19120 20600])
            ("advice-remove" function
               (:documentation "Like `remove-function' but for the function named SYMBOL.
Contrary to `remove-function', this also works when SYMBOL is a macro
or an autoload and it preserves `fboundp'.
Instead of the actual function to remove, FUNCTION can also be the `name'
of the piece of advice."
                :arguments ("symbol" "function"))
                nil [20617 21682])
            ("define-advice" function
               (:documentation "Define an advice and add it to function named SYMBOL.
See `advice-add' and `add-function' for explanation on the
arguments.  Note if NAME is nil the advice is anonymous;
otherwise it is named `SYMBOL@NAME'.

(fn SYMBOL (WHERE LAMBDA-LIST &optional NAME DEPTH) &rest BODY)"
                :arguments ("symbol" "args" "body"))
                nil [21699 22874])
            ("advice-mapc" function
               (:documentation "Apply FUN to every advice function in SYMBOL.
FUN is called with a two arguments: the function that was added, and the
properties alist that was specified when it was added."
                :arguments ("fun" "symbol"))
                nil [22876 23148])
            ("advice-member-p" function
               (:documentation "Return non-nil if ADVICE has been added to SYMBOL.
Instead of ADVICE being the actual function, it can also be the `name'
of the piece of advice."
                :arguments ("advice" "symbol"))
                nil [23165 23423])
            ("add-hook" code nil nil [23842 23932])
            ("advice--called-interactively-skip" function (:arguments ("origi" "frame1" "frame2")) nil [23933 26009])
            ("nadvice" package nil nil [26012 26030]))          
      :file "nadvice.el.gz"
      :pointmax 26056
      :fsize 8016
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax '((close-paren 11023 . 11024) (symbol 10744 . 10760) (open-paren 10743 . 10744)))
    (semanticdb-table "semanticdb-table-189d640"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("easy-menu-precalculate-equivalent-keybindings" variable (:documentation "Determine when equivalent key bindings are computed for easy-menu menus.
It can take some time to calculate the equivalent key bindings that are shown
in a menu.  If the variable is on, then this calculation gives a (maybe
noticeable) delay when a mode is first entered.  If the variable is off, then
this delay will come when a menu is displayed the first time.  If you never use
menus, turn this variable off, otherwise it is probably better to keep it on.") nil [1136 1657])
            ("make-obsolete-variable" code nil nil [1658 1741])
            ("easy-menu-intern" function (:arguments ("s")) nil [1743 1806])
            ("easy-menu-define" function
               (:documentation "Define a pop-up menu and/or menu bar menu specified by MENU.
If SYMBOL is non-nil, define SYMBOL as a function to pop up the
submenu defined by MENU, with DOC as its doc string.

MAPS, if non-nil, should be a keymap or a list of keymaps; add
the submenu defined by MENU to the keymap or each of the keymaps,
as a top-level menu bar item.

The first element of MENU must be a string.  It is the menu bar
item name.  It may be followed by the following keyword argument
pairs:

 :filter FUNCTION
    FUNCTION must be a function which, if called with one
    argument---the list of the other menu items---returns the
    items to actually display.

 :visible INCLUDE
    INCLUDE is an expression.  The menu is visible if the
    expression evaluates to a non-nil value.  `:included' is an
    alias for `:visible'.

 :active ENABLE
    ENABLE is an expression.  The menu is enabled for selection
    if the expression evaluates to a non-nil value.  `:enable' is
    an alias for `:active'.

The rest of the elements in MENU are menu items.
A menu item can be a vector of three elements:

  [NAME CALLBACK ENABLE]

NAME is a string--the menu item name.

CALLBACK is a command to run when the item is chosen, or an
expression to evaluate when the item is chosen.

ENABLE is an expression; the item is enabled for selection if the
expression evaluates to a non-nil value.

Alternatively, a menu item may have the form:

   [ NAME CALLBACK [ KEYWORD ARG ]... ]

where NAME and CALLBACK have the same meanings as above, and each
optional KEYWORD and ARG pair should be one of the following:

 :keys KEYS
    KEYS is a string; a keyboard equivalent to the menu item.
    This is normally not needed because keyboard equivalents are
    usually computed automatically.  KEYS is expanded with
    `substitute-command-keys' before it is used.

 :key-sequence KEYS
    KEYS is a hint for speeding up Emacs's first display of the
    menu.  It should be nil if you know that the menu item has no
    keyboard equivalent; otherwise it should be a string or
    vector specifying a keyboard equivalent for the menu item.

 :active ENABLE
    ENABLE is an expression; the item is enabled for selection
    whenever this expression's value is non-nil.  `:enable' is an
    alias for `:active'.

 :visible INCLUDE
    INCLUDE is an expression; this item is only visible if this
    expression has a non-nil value.  `:included' is an alias for
    `:visible'.

 :label FORM
    FORM is an expression that is dynamically evaluated and whose
    value serves as the menu item's label (the default is NAME).

 :suffix FORM
    FORM is an expression that is dynamically evaluated and whose
    value is concatenated with the menu entry's label.

 :style STYLE
    STYLE is a symbol describing the type of menu item; it should
    be `toggle' (a checkbox), or `radio' (a radio button), or any
    other value (meaning an ordinary menu item).

 :selected SELECTED
    SELECTED is an expression; the checkbox or radio button is
    selected whenever the expression's value is non-nil.

 :help HELP
    HELP is a string, the help to display for the menu item.

Alternatively, a menu item can be a string.  Then that string
appears in the menu as unselectable text.  A string consisting
solely of dashes is displayed as a menu separator.

Alternatively, a menu item can be a list with the same format as
MENU.  This is a submenu."
                :arguments ("symbol" "maps" "doc" "menu"))
                nil [1823 5444])
            ("easy-menu-binding" function
               (:documentation "Return a binding suitable to pass to `define-key'.
This is expected to be bound to a mouse event."
                :arguments ("menu" "item-name"))
                nil [5446 6208])
            ("easy-menu-do-define" function (:arguments ("symbol" "maps" "doc" "menu")) nil [6225 7170])
            ("easy-menu-filter-return" function
               (:documentation "Convert MENU to the right thing to return from a menu filter.
MENU is a menu as computed by `easy-menu-define' or `easy-menu-create-menu' or
a symbol whose value is such a menu.
In Emacs a menu filter must return a menu (a keymap), in XEmacs a filter must
return a menu items list (without menu name and keywords).
This function returns the right thing in the two cases.
If NAME is provided, it is used for the keymap."
                :arguments ("menu" "name"))
                nil [7172 7958])
            ("easy-menu-avoid-duplicate-keys" variable
               (:documentation "Dynamically scoped var to register already used keys in a menu.
If it holds a list, this is expected to be a list of keys already seen in the
menu we're processing.  Else it means we're not processing a menu."
                :default-value t)
                nil [7960 8214])
            ("easy-menu-create-menu" function
               (:documentation "Create a menu called MENU-NAME with items described in MENU-ITEMS.
MENU-NAME is a string, the name of the menu.  MENU-ITEMS is a list of items
possibly preceded by keyword pairs as described in `easy-menu-define'."
                :arguments ("menu-name" "menu-items"))
                nil [8231 10303])
            ("easy-menu-button-prefix" variable (:default-value '((radio . :radio) (toggle . :toggle))) nil [10329 10402])
            ("easy-menu-converted-items-table" variable (:default-value (make-hash-table :test 'equal)) nil [10404 10475])
            ("easy-menu-convert-item" function
               (:documentation "Memoize the value returned by `easy-menu-convert-item-1' called on ITEM.
This makes key-shortcut-caching work a *lot* better when this
conversion is done from within a filter.
This also helps when the NAME of the entry is recreated each time:
since the menu is built and traversed separately, the lookup
would always fail because the key is `equal' but not `eq'."
                :arguments ("item"))
                nil [10477 11915])
            ("easy-menu-convert-item-1" function
               (:documentation "Parse an item description and convert it to a menu keymap element.
ITEM defines an item as in `easy-menu-define'."
                :arguments ("item"))
                nil [11917 16301])
            ("easy-menu-define-key" function
               (:documentation "Add binding in MENU for KEY => ITEM.  Similar to `define-key-after'.
If KEY is not nil then delete any duplications.
If ITEM is nil, then delete the definition of KEY.

Optional argument BEFORE is nil or a key in MENU.  If BEFORE is not nil,
put binding before the item in MENU named BEFORE; otherwise,
if a binding for KEY is already present in MENU, just change it;
otherwise put the new binding last in MENU.
BEFORE can be either a string (menu item name) or a symbol
(the fake function key for the menu item).
KEY does not have to be a symbol, and comparison is done with equal."
                :arguments ("menu" "key" "item" "before"))
                nil [16303 18052])
            ("easy-menu-name-match" function
               (:documentation "Return t if NAME is the name of menu item ITEM.
NAME can be either a string, or a symbol.
ITEM should be a keymap binding of the form (KEY . MENU-ITEM)."
                :arguments ("name" "item"))
                nil [18054 18650])
            ("easy-menu-always-true-p" function
               (:documentation "Return true if form X never evaluates to nil."
                :arguments ("x"))
                nil [18652 18825])
            ("easy-menu-item-count" variable nil nil [18827 18858])
            ("easy-menu-make-symbol" function
               (:documentation "Return a unique symbol with CALLBACK as function value.
When non-nil, NOEXP indicates that CALLBACK cannot be an expression
(i.e. does not need to be turned into a function)."
                :arguments ("callback" "noexp"))
                nil [18860 19489])
            ("easy-menu-change" function
               (:documentation "Change menu found at PATH as item NAME to contain ITEMS.
PATH is a list of strings for locating the menu that
should contain a submenu named NAME.
ITEMS is a list of menu items, as in `easy-menu-define'.
These items entirely replace the previous items in that submenu.

If MAP is specified, it should normally be a keymap; nil stands for the local
menu-bar keymap.  It can also be a symbol, which has earlier been used as the
first argument in a call to `easy-menu-define', or the value of such a symbol.

If the menu located by PATH has no submenu named NAME, add one.
If the optional argument BEFORE is present, add it just before
the submenu named BEFORE, otherwise add it at the end of the menu.

To implement dynamic menus, either call this from
`menu-bar-update-hook' or use a menu filter."
                :arguments ("path" "name" "items" "before" "map"))
                nil [19506 20443])
            ("defalias" code nil nil [20636 20863])
            ("defalias" code nil nil [20865 21276])
            ("add-submenu" function
               (:documentation "Add submenu SUBMENU in the menu at MENU-PATH.
If BEFORE is non-nil, add before the item named BEFORE.
If IN-MENU is non-nil, follow MENU-PATH in IN-MENU.
This is a compatibility function; use `easy-menu-add-item'."
                :arguments ("menu-path" "submenu" "before" "in-menu"))
                nil [21278 21676])
            ("easy-menu-add-item" function
               (:documentation "To the submenu of MAP with path PATH, add ITEM.

If an item with the same name is already present in this submenu,
then ITEM replaces it.  Otherwise, ITEM is added to this submenu.
In the latter case, ITEM is normally added at the end of the submenu.
However, if BEFORE is a string and there is an item in the submenu
with that name, then ITEM is added before that item.

MAP should normally be a keymap; nil stands for the local menu-bar keymap.
It can also be a symbol, which has earlier been used as the first
argument in a call to `easy-menu-define', or the value of such a symbol.

PATH is a list of strings for locating the submenu where ITEM is to be
added.  If PATH is nil, MAP itself is used.  Otherwise, the first
element should be the name of a submenu directly under MAP.  This
submenu is then traversed recursively with the remaining elements of PATH.

ITEM is either defined as in `easy-menu-define' or a non-nil value returned
by `easy-menu-item-present-p' or `easy-menu-remove-item' or a menu defined
earlier by `easy-menu-define' or `easy-menu-create-menu'."
                :arguments ("map" "path" "item" "before"))
                nil [21678 23570])
            ("easy-menu-item-present-p" function
               (:documentation "In submenu of MAP with path PATH, return non-nil if item NAME is present.
MAP and PATH are defined as in `easy-menu-add-item'.
NAME should be a string, the name of the element to be looked for."
                :arguments ("map" "path" "name"))
                nil [23572 23878])
            ("easy-menu-remove-item" function
               (:documentation "From submenu of MAP with path PATH remove item NAME.
MAP and PATH are defined as in `easy-menu-add-item'.
NAME should be a string, the name of the element to be removed."
                :arguments ("map" "path" "name"))
                nil [23880 24266])
            ("easy-menu-return-item" function
               (:documentation "In menu MENU try to look for menu item with name NAME.
If a menu item is found, return (NAME . item), otherwise return nil.
If item is an old format item, a new format item is returned."
                :arguments ("menu" "name"))
                nil [24268 25880])
            ("easy-menu-lookup-name" function
               (:documentation "Lookup menu item NAME in keymap MAP.
Like `lookup-key' except that NAME is not an array but just a single key
and that NAME can be a string representing the menu item's name."
                :arguments ("map" "name"))
                nil [25882 26675])
            ("easy-menu-get-map" function
               (:documentation "Return a sparse keymap in which to add or remove an item.
MAP and PATH are as defined in `easy-menu-add-item'.

TO-MODIFY, if non-nil, is the name of the item the caller
wants to modify in the map that we return.
In some cases we use that to select between the local and global maps."
                :arguments ("map" "path" "to-modify"))
                nil [26677 28241])
            ("easymenu" package nil nil [28243 28262]))          
      :file "easymenu.el.gz"
      :pointmax 28290
      :fsize 9106
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189d980"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("cl-lib" include nil nil [1327 1344])
            ("internal--thread-argument" function
               (:documentation "Internal implementation for `thread-first' and `thread-last'.
When Argument FIRST? is non-nil argument is threaded first, else
last.  FORMS are the expressions to be threaded."
                :arguments ("first?" "forms"))
                nil [1348 1830])
            ("thread-first" function
               (:documentation "Thread FORMS elements as the first argument of their successor.
Example:
    (thread-first
      5
      (+ 20)
      (/ 25)
      -
      (+ 40))
Is equivalent to:
    (+ (- (/ (+ 5 20) 25)) 40)
Note how the single `-' got converted into a list before
threading."
                :arguments ("forms"))
                nil [1832 2265])
            ("thread-last" function
               (:documentation "Thread FORMS elements as the last argument of their successor.
Example:
    (thread-last
      5
      (+ 20)
      (/ 25)
      -
      (+ 40))
Is equivalent to:
    (+ 40 (- (/ 25 (+ 20 5))))
Note how the single `-' got converted into a list before
threading."
                :arguments ("forms"))
                nil [2267 2656])
            ("internal--listify" function
               (:documentation "Wrap ELT in a list if it is not one.
If ELT is of the form ((EXPR)), listify (EXPR) with a dummy symbol."
                :arguments ("elt"))
                nil [2658 2916])
            ("internal--check-binding" function
               (:documentation "Check BINDING is properly formed."
                :arguments ("binding"))
                nil [2918 3133])
            ("internal--build-binding-value-form" function
               (:documentation "Build the conditional value form for BINDING using PREV-VAR."
                :arguments ("binding" "prev-var"))
                nil [3135 3338])
            ("internal--build-binding" function
               (:documentation "Check and build a single BINDING with PREV-VAR."
                :arguments ("binding" "prev-var"))
                nil [3340 3573])
            ("internal--build-bindings" function
               (:documentation "Check and build conditional value forms for BINDINGS."
                :arguments ("bindings"))
                nil [3575 3897])
            ("if-let*" function
               (:documentation "Bind variables according to VARLIST and eval THEN or ELSE.
This is like `if-let' but doesn't handle a VARLIST of the form
(SYMBOL SOMETHING) specially."
                :arguments ("varlist" "then" "else"))
                nil [3899 4392])
            ("when-let*" function
               (:documentation "Bind variables according to VARLIST and conditionally eval BODY.
This is like `when-let' but doesn't handle a VARLIST of the form
(SYMBOL SOMETHING) specially."
                :arguments ("varlist" "body"))
                nil [4394 4687])
            ("and-let*" function
               (:documentation "Bind variables according to VARLIST and conditionally eval BODY.
Like `when-let*', except if BODY is empty and all the bindings
are non-nil, then the result is non-nil."
                :arguments ("varlist" "body"))
                nil [4689 5231])
            ("if-let" function
               (:documentation "Bind variables according to SPEC and eval THEN or ELSE.
Each binding is evaluated in turn, and evaluation stops if a
binding value is nil.  If all are non-nil, the value of THEN is
returned, or the last form in ELSE is returned.

Each element of SPEC is a list (SYMBOL VALUEFORM) which binds
SYMBOL to the value of VALUEFORM.  An element can additionally be
of the form (VALUEFORM), which is evaluated and checked for nil;
i.e. SYMBOL can be omitted if only the test result is of
interest.  It can also be of the form SYMBOL, then the binding of
SYMBOL is checked for nil.

As a special case, a SPEC of the form (SYMBOL SOMETHING) is
interpreted like ((SYMBOL SOMETHING)). This exists for backward
compatibility with the old syntax that accepted only one
binding."
                :arguments ("spec" "then" "else"))
                nil [5233 6395])
            ("when-let" function
               (:documentation "Bind variables according to SPEC and conditionally eval BODY.
Each binding is evaluated in turn, and evaluation stops if a
binding value is nil.  If all are non-nil, the value of the last
form in BODY is returned.

The variable list SPEC is the same as in `if-let'."
                :arguments ("spec" "body"))
                nil [6397 6786])
            ("hash-table-empty-p" function
               (:documentation "Check whether HASH-TABLE is empty (has 0 elements)."
                :arguments ("hash-table"))
                nil [6788 6926])
            ("hash-table-keys" function
               (:documentation "Return a list of keys in HASH-TABLE."
                :arguments ("hash-table"))
                nil [6928 7070])
            ("hash-table-values" function
               (:documentation "Return a list of values in HASH-TABLE."
                :arguments ("hash-table"))
                nil [7072 7220])
            ("string-empty-p" function
               (:documentation "Check whether STRING is empty."
                :arguments ("string"))
                nil [7222 7313])
            ("string-join" function
               (:documentation "Join all STRINGS using SEPARATOR."
                :arguments ("strings" "separator"))
                nil [7315 7448])
            ("define-obsolete-function-alias" code nil nil [7450 7514])
            ("string-trim-left" function
               (:documentation "Trim STRING of leading string matching REGEXP.

REGEXP defaults to \"[ \\t\\n\\r]+\"."
                :arguments ("string" "regexp"))
                nil [7516 7789])
            ("string-trim-right" function
               (:documentation "Trim STRING of trailing string matching REGEXP.

REGEXP defaults to  \"[ \\t\\n\\r]+\"."
                :arguments ("string" "regexp"))
                nil [7791 8094])
            ("string-trim" function
               (:documentation "Trim STRING of leading and trailing strings matching TRIM-LEFT and TRIM-RIGHT.

TRIM-LEFT and TRIM-RIGHT default to \"[ \\t\\n\\r]+\"."
                :arguments ("string" "trim-left" "trim-right"))
                nil [8096 8366])
            ("string-blank-p" function
               (:documentation "Check whether STRING is either empty or only whitespace."
                :arguments ("string"))
                nil [8368 8508])
            ("string-remove-prefix" function
               (:documentation "Remove PREFIX from STRING if present."
                :arguments ("prefix" "string"))
                nil [8510 8690])
            ("string-remove-suffix" function
               (:documentation "Remove SUFFIX from STRING if present."
                :arguments ("suffix" "string"))
                nil [8692 8894])
            ("subr-x" package nil nil [8896 8913]))          
      :file "subr-x.el.gz"
      :pointmax 8939
      :fsize 3034
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax '((close-paren 1344 . 1345) (symbol 1309 . 1326) (open-paren 1308 . 1309)))
    (semanticdb-table "semanticdb-table-189d9a0"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("cl-lib" include nil nil [1074 1091])
            ("cl-defstruct" code nil nil [1094 1846])
            ("timerp" function
               (:documentation "Return t if OBJECT is a timer."
                :arguments ("object"))
                nil [1848 1953])
            ("timer--check" function (:arguments ("timer")) nil [1955 2060])
            ("timer--time-setter" function (:arguments ("timer" "time")) nil [2062 2496])
            ("timer--time" function (:arguments ("timer")) nil [2522 2708])
            ("timer-set-time" function
               (:documentation "Set the trigger time of TIMER to TIME.
TIME must be in the internal format returned by, e.g., `current-time'.
If optional third argument DELTA is a positive number, make the timer
fire repeatedly that many seconds apart."
                :arguments ("timer" "time" "delta"))
                nil [2710 3105])
            ("timer-set-idle-time" function
               (:documentation "Set the trigger idle time of TIMER to SECS.
SECS may be an integer, floating point number, or the internal
time format returned by, e.g., `current-idle-time'.
If optional third argument REPEAT is non-nil, make the timer
fire each time Emacs is idle for that many seconds."
                :arguments ("timer" "secs" "repeat"))
                nil [3107 3606])
            ("timer-next-integral-multiple-of-time" function
               (:documentation "Yield the next value after TIME that is an integral multiple of SECS.
More precisely, the next value, after TIME, that is an integral multiple
of SECS seconds since the epoch.  SECS may be a fraction."
                :arguments ("time" "secs"))
                nil [3608 4622])
            ("timer-relative-time" function
               (:documentation "Advance TIME by SECS seconds and optionally USECS microseconds
and PSECS picoseconds.  SECS may be either an integer or a
floating point number."
                :arguments ("time" "secs" "usecs" "psecs"))
                nil [4624 4977])
            ("timer--time-less-p" function
               (:documentation "Say whether time value T1 is less than time value T2."
                :arguments ("t1" "t2"))
                nil [4979 5121])
            ("timer-inc-time" function
               (:documentation "Increment the time set in TIMER by SECS seconds, USECS microseconds,
and PSECS picoseconds.  SECS may be a fraction.  If USECS or PSECS are
omitted, they are treated as zero."
                :arguments ("timer" "secs" "usecs" "psecs"))
                nil [5123 5455])
            ("timer-set-function" function
               (:documentation "Make TIMER call FUNCTION with optional ARGS when triggering."
                :arguments ("timer" "function" "args"))
                nil [5457 5687])
            ("timer--activate" function (:arguments ("timer" "triggered-p" "reuse-cell" "idle")) nil [5690 6689])
            ("timer-activate" function
               (:documentation "Insert TIMER into `timer-list'.
If TRIGGERED-P is t, make TIMER inactive (put it on the list, but
mark it as already triggered).  To remove it, use `cancel-timer'.

REUSE-CELL, if non-nil, is a cons cell to reuse when inserting
TIMER into `timer-list' (usually a cell removed from that list by
`cancel-timer-internal'; using this reduces consing for repeat
timers).  If nil, allocate a new cell."
                :arguments ("timer" "triggered-p" "reuse-cell"))
                nil [6691 7207])
            ("timer-activate-when-idle" function
               (:documentation "Insert TIMER into `timer-idle-list'.
This arranges to activate TIMER whenever Emacs is next idle.
If optional argument DONT-WAIT is non-nil, set TIMER to activate
immediately (see below), or at the right time, if Emacs is
already idle.

REUSE-CELL, if non-nil, is a cons cell to reuse when inserting
TIMER into `timer-idle-list' (usually a cell removed from that
list by `cancel-timer-internal'; using this reduces consing for
repeat timers).  If nil, allocate a new cell.

Using non-nil DONT-WAIT is not recommended when activating an
idle timer from an idle timer handler, if the timer being
activated has an idleness time that is smaller or equal to
the time of the current timer.  That's because the activated
timer will fire right away."
                :arguments ("timer" "dont-wait" "reuse-cell"))
                nil [7209 8086])
            ("defalias" code nil nil [8088 8129])
            ("cancel-timer" function
               (:documentation "Remove TIMER from the list of active timers."
                :arguments ("timer"))
                nil [8131 8335])
            ("cancel-timer-internal" function
               (:documentation "Remove TIMER from the list of active timers or idle timers.
Only to be used in this file.  It returns the cons cell
that was removed from the timer list."
                :arguments ("timer"))
                nil [8337 8759])
            ("cancel-function-timers" function
               (:documentation "Cancel all timers which would run FUNCTION.
This affects ordinary timers such as are scheduled by `run-at-time',
and idle timers such as are scheduled by `run-with-idle-timer'."
                :user-visible-flag t
                :arguments ("function"))
                nil [8761 9299])
            ("timer-event-last" variable (:documentation "Last timer that was run.") nil [9348 9406])
            ("timer-event-last-1" variable (:documentation "Next-to-last timer that was run.") nil [9407 9475])
            ("timer-event-last-2" variable (:documentation "Third-to-last timer that was run.") nil [9476 9545])
            ("timer-max-repeats" variable
               (:documentation "Maximum number of times to repeat a timer, if many repeats are delayed.
Timer invocations can be delayed because Emacs is suspended or busy,
or because the system's time changes.  If such an occurrence makes it
appear that many invocations are overdue, this variable controls
how many will really happen."
                :default-value 10)
                nil [9547 9924])
            ("timer-until" function
               (:documentation "Calculate number of seconds from when TIMER will run, until TIME.
TIMER is a timer, and stands for the time when its next repeat is scheduled.
TIME is a time-list."
                :arguments ("timer" "time"))
                nil [9926 10183])
            ("timer-event-handler" function
               (:documentation "Call the handler for the timer TIMER.
This function is called, by name, directly by the C code."
                :arguments ("timer"))
                nil [10185 13133])
            ("timeout-event-p" function
               (:documentation "Non-nil if EVENT is a timeout event."
                :arguments ("event"))
                nil [13196 13320])
            ("declare-function" code nil nil [13324 13375])
            ("run-at-time" function
               (:documentation "Perform an action at time TIME.
Repeat the action every REPEAT seconds, if REPEAT is non-nil.
REPEAT may be an integer or floating point number.
TIME should be one of:
- a string giving today's time like \"11:23pm\"
  (the acceptable formats are HHMM, H:MM, HH:MM, HHam, HHAM,
  HHpm, HHPM, HH:MMam, HH:MMAM, HH:MMpm, or HH:MMPM;
  a period `.' can be used instead of a colon `:' to separate
  the hour and minute parts);
- a string giving a relative time like \"90\" or \"2 hours 35 minutes\"
  (the acceptable forms are a number of seconds without units
  or some combination of values using units in `timer-duration-words');
- nil, meaning now;
- a number of seconds from now;
- a value from `encode-time';
- or t (with non-nil REPEAT) meaning the next integral
  multiple of REPEAT.

The action is to call FUNCTION with arguments ARGS.

This function returns a timer object which you can use in
`cancel-timer'."
                :user-visible-flag t
                :arguments ("time" "repeat" "function" "args"))
                nil [13377 15798])
            ("run-with-timer" function
               (:documentation "Perform an action after a delay of SECS seconds.
Repeat the action every REPEAT seconds, if REPEAT is non-nil.
SECS and REPEAT may be integers or floating point numbers.
The action is to call FUNCTION with arguments ARGS.

This function returns a timer object which you can use in `cancel-timer'."
                :user-visible-flag t
                :arguments ("secs" "repeat" "function" "args"))
                nil [15800 16286])
            ("add-timeout" function
               (:documentation "Add a timer to run SECS seconds from now, to call FUNCTION on OBJECT.
If REPEAT is non-nil, repeat the timer every REPEAT seconds.

This function returns a timer object which you can use in `cancel-timer'.
This function is for compatibility; see also `run-with-timer'."
                :arguments ("secs" "function" "object" "repeat"))
                nil [16288 16667])
            ("run-with-idle-timer" function
               (:documentation "Perform an action the next time Emacs is idle for SECS seconds.
The action is to call FUNCTION with arguments ARGS.
SECS may be an integer, a floating point number, or the internal
time format returned by, e.g., `current-idle-time'.
If Emacs is currently idle, and has been idle for N seconds (N < SECS),
then it will call FUNCTION in SECS - N seconds from now.  Using
SECS <= N is not recommended if this function is invoked from an idle
timer, because FUNCTION will then be called immediately.

If REPEAT is non-nil, do the action each time Emacs has been idle for
exactly SECS seconds (that is, only once for each time Emacs becomes idle).

This function returns a timer object which you can use in `cancel-timer'."
                :user-visible-flag t
                :arguments ("secs" "repeat" "function" "args"))
                nil [16669 17820])
            ("with-timeout-timers" variable (:documentation "List of all timers used by currently pending `with-timeout' calls.") nil [17823 17926])
            ("with-timeout" function
               (:documentation "Run BODY, but if it doesn't finish in SECONDS seconds, give up.
If we give up, we run the TIMEOUT-FORMS and return the value of the last one.
The timeout is checked whenever Emacs waits for some kind of external
event (such as keyboard input, input from subprocesses, or a certain time);
if the program loops without waiting in any way, the timeout will not
be detected.

(fn (SECONDS TIMEOUT-FORMS...) BODY)"
                :arguments ("list" "body"))
                nil [17928 19407])
            ("with-timeout-suspend" function (:documentation "Stop the clock for `with-timeout'.  Used by debuggers.
The idea is that the time you spend in the debugger should not
count against these timeouts.

The value is a list that the debugger can pass to `with-timeout-unsuspend'
when it exits, to make these timers start counting again.") nil [19409 19861])
            ("with-timeout-unsuspend" function
               (:documentation "Restart the clock for `with-timeout'.
The argument should be a value previously returned by `with-timeout-suspend'."
                :arguments ("timer-spec-list"))
                nil [19863 20195])
            ("y-or-n-p-with-timeout" function
               (:documentation "Like (y-or-n-p PROMPT), with a timeout.
If the user does not answer after SECONDS seconds, return DEFAULT-VALUE."
                :arguments ("prompt" "seconds" "default-value"))
                nil [20197 20437])
            ("timer-duration-words" variable
               (:documentation "Alist mapping temporal words to durations in seconds."
                :constant-flag t
                :default-value (list (cons "microsec" 1e-06) (cons "microsecond" 1e-06) (cons "millisec" 0.001) (cons "millisecond" 0.001) (cons "sec" 1) (cons "second" 1) (cons "min" 60) (cons "minute" 60) (cons "hour" (* 60 60)) (cons "day" (* 24 60 60)) (cons "week" (* 7 24 60 60)) (cons "fortnight" (* 14 24 60 60)) (cons "month" (* 30 24 60 60)) (cons "year" (* 365.25 24 60 60))))
                nil [20440 20956])
            ("timer-duration" function
               (:documentation "Return number of seconds specified by STRING, or nil if parsing fails."
                :arguments ("string"))
                nil [20958 21660])
            ("internal-timer-start-idle" function (:documentation "Mark all idle-time timers as once again candidates for running.") nil [21662 21889])
            ("timer" package nil nil [21892 21908]))          
      :file "timer.el.gz"
      :pointmax 21933
      :fsize 7119
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax '((close-paren 1091 . 1092) (symbol 1056 . 1073) (open-paren 1055 . 1056)))
    (semanticdb-table "semanticdb-table-189d9c0"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("trace" customgroup
               (:documentation "Tracing facility for Emacs Lisp functions."
                :user-visible-flag t)
                nil [4199 4300])
            ("trace-buffer" variable
               (:documentation "Trace output will by default go to that buffer."
                :default-value "*trace-output*")
                nil [4317 4426])
            ("trace-level" variable nil nil [4476 4498])
            ("trace-advice-name" variable (:default-value 'trace-function\ ) nil [4555 4599])
            ("trace-separator" variable (:default-value (format "%s
" (make-string 70 61))) nil [4665 4725])
            ("inhibit-trace" variable (:documentation "If non-nil, all tracing is temporarily inhibited.") nil [4727 4807])
            ("trace-values" function
               (:documentation "Helper function to get internal values.
You can call this function to add internal values in the trace buffer."
                :arguments ("values"))
                nil [4824 5156])
            ("trace-entry-message" function
               (:documentation "Generate a string that describes that FUNCTION has been entered.
LEVEL is the trace level, ARGS is the list of arguments passed to FUNCTION,
and CONTEXT is a string describing the dynamic context (e.g. values of
some global variables)."
                :arguments ("function" "level" "args" "context"))
                nil [5158 5817])
            ("trace-exit-message" function
               (:documentation "Generate a string that describes that FUNCTION has exited.
LEVEL is the trace level, VALUE value returned by FUNCTION,
and CONTEXT is a string describing the dynamic context (e.g. values of
some global variables)."
                :arguments ("function" "level" "value" "context"))
                nil [5819 6387])
            ("trace--timer" variable nil nil [6389 6414])
            ("trace--display-buffer" function (:arguments ("buf")) nil [6416 6742])
            ("trace-make-advice" function
               (:documentation "Build the piece of advice to be added to trace FUNCTION.
FUNCTION is the name of the traced function.
BUFFER is the buffer where the trace should be printed.
BACKGROUND if nil means to display BUFFER.
CONTEXT if non-nil should be a function that returns extra info that should
be printed along with the arguments in the trace."
                :arguments ("function" "buffer" "background" "context"))
                nil [6745 8381])
            ("trace-function-internal" function
               (:documentation "Add trace advice for FUNCTION."
                :arguments ("function" "buffer" "background" "context"))
                nil [8383 8688])
            ("trace-is-traced" function (:arguments ("function")) nil [8690 8771])
            ("trace--read-args" function
               (:documentation "Read a function name, prompting with string PROMPT.
If `current-prefix-arg' is non-nil, also read a buffer and a \"context\"
(Lisp expression).  Return (FUNCTION BUFFER FUNCTION-CONTEXT)."
                :arguments ("prompt"))
                nil [8773 10056])
            ("trace-function-foreground" function
               (:documentation "Trace calls to function FUNCTION.
With a prefix argument, also prompt for the trace buffer (default
`trace-buffer'), and a Lisp expression CONTEXT.

Tracing a function causes every call to that function to insert
into BUFFER Lisp-style trace messages that display the function's
arguments and return values.  It also evaluates CONTEXT, if that is
non-nil, and inserts its value too.  For example, you can use this
to track the current buffer, or position of point.

This function creates BUFFER if it does not exist.  This buffer will
popup whenever FUNCTION is called.  Do not use this function to trace
functions that switch buffers, or do any other display-oriented
stuff - use `trace-function-background' instead.

To stop tracing a function, use `untrace-function' or `untrace-all'."
                :user-visible-flag t
                :arguments ("function" "buffer" "context"))
                nil [10073 11044])
            ("trace-function-background" function
               (:documentation "Trace calls to function FUNCTION, quietly.
This is like `trace-function-foreground', but without popping up
the output buffer or changing the window configuration."
                :user-visible-flag t
                :arguments ("function" "buffer" "context"))
                nil [11061 11420])
            ("defalias" code nil nil [11437 11490])
            ("untrace-function" function
               (:documentation "Untraces FUNCTION and possibly activates all remaining advice.
Activation is performed with `ad-update', hence remaining advice will get
activated only if the advice of FUNCTION is currently active.  If FUNCTION
was not traced this is a noop."
                :user-visible-flag t
                :arguments ("function"))
                nil [11492 11955])
            ("untrace-all" function
               (:documentation "Untraces all currently traced functions."
                :user-visible-flag t)
                nil [11957 12072])
            ("trace" package nil nil [12074 12090]))          
      :file "trace.el.gz"
      :pointmax 12115
      :fsize 4279
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189d9e0"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("defvar-local" code nil nil [1683 2714])
            ("put" code nil nil [2715 2762])
            ("defvar-local" code nil nil [2764 2875])
            ("defvar-local" code nil nil [2877 3759])
            ("put" code nil nil [3760 3808])
            ("defvar-local" code nil nil [3810 4028])
            ("put" code nil nil [4029 4077])
            ("tabulated-list-revert-hook" variable (:documentation "Hook run before reverting a Tabulated List buffer.
This is commonly used to recompute `tabulated-list-entries'.") nil [4079 4234])
            ("defvar-local" code nil nil [4236 4538])
            ("tabulated-list--near-rows" variable nil nil [4540 4574])
            ("defvar-local" code nil nil [4576 4990])
            ("put" code nil nil [4991 5040])
            ("tabulated-list-get-id" function
               (:documentation "Return the entry ID of the Tabulated List entry at POS.
The value is an ID object from `tabulated-list-entries', or nil.
POS, if omitted or nil, defaults to point."
                :arguments ("pos"))
                nil [5042 5316])
            ("tabulated-list-get-entry" function
               (:documentation "Return the Tabulated List entry at POS.
The value is a vector of column descriptors, or nil if there is
no entry at POS.  POS, if omitted or nil, defaults to point."
                :arguments ("pos"))
                nil [5318 5599])
            ("tabulated-list-put-tag" function
               (:documentation "Put TAG in the padding area of the current line.
TAG should be a string, with length <= `tabulated-list-padding'.
If ADVANCE is non-nil, move forward by one line afterwards."
                :arguments ("tag" "advance"))
                nil [5601 6508])
            ("tabulated-list-mode-map" variable
               (:documentation "Local keymap for `tabulated-list-mode' buffers."
                :default-value (let ((map (copy-keymap special-mode-map))) (set-keymap-parent map button-buffer-map) (define-key map "n" 'next-line) (define-key map "p" 'previous-line) (define-key map "S" 'tabulated-list-sort) (define-key map [follow-link] 'mouse-face) (define-key map [mouse-2] 'mouse-select-window) map))
                nil [6510 6916])
            ("tabulated-list-sort-button-map" variable
               (:documentation "Local keymap for `tabulated-list-mode' sort buttons."
                :default-value (let ((map (make-sparse-keymap))) (define-key map [header-line mouse-1] 'tabulated-list-col-sort) (define-key map [header-line mouse-2] 'tabulated-list-col-sort) (define-key map [mouse-1] 'tabulated-list-col-sort) (define-key map [mouse-2] 'tabulated-list-col-sort) (define-key map "" 'tabulated-list-sort) (define-key map [follow-link] 'mouse-face) map))
                nil [6918 7403])
            ("tabulated-list-glyphless-char-display" variable
               (:documentation "The `glyphless-char-display' table in Tabulated List buffers."
                :default-value (let ((table (make-char-table 'glyphless-char-display nil))) (set-char-table-parent table glyphless-char-display) (aset table 9650 (cons nil "^")) (aset table 9660 (cons nil "v")) table))
                nil [7405 7792])
            ("tabulated-list--header-string" variable (:documentation "Holds the header if `tabulated-list-use-header-line' is nil.
Populated by `tabulated-list-init-header'.") nil [7794 7944])
            ("tabulated-list--header-overlay" variable nil nil [7945 7988])
            ("tabulated-list-line-number-width" function (:documentation "Return the width taken by display-line-numbers in the current buffer.") nil [7990 8518])
            ("tabulated-list-init-header" function (:documentation "Set up header line for the Tabulated List buffer.") nil [8520 10748])
            ("tabulated-list-print-fake-header" function (:documentation "Insert a fake Tabulated List \"header line\" at the start of the buffer.
Do nothing if `tabulated-list--header-string' is nil.") nil [10750 11368])
            ("tabulated-list-header-overlay-p" function
               (:documentation "Return non-nil if there is a fake header.
Optional arg POS is a buffer position where to look for a fake header;
defaults to `point-min'."
                :arguments ("pos"))
                nil [11370 11607])
            ("tabulated-list-revert" function
               (:documentation "The `revert-buffer-function' for `tabulated-list-mode'.
It runs `tabulated-list-revert-hook', then calls `tabulated-list-print'."
                :user-visible-flag t
                :arguments ("ignored"))
                nil [11609 11984])
            ("tabulated-list--column-number" function (:arguments ("name")) nil [11986 12283])
            ("tabulated-list--get-sorter" function (:documentation "Return a sorting predicate for the current tabulated-list.
Return nil if `tabulated-list-sort-key' specifies an unsortable
column.  Negate the predicate that would be returned if
`tabulated-list-sort-key' has a non-nil cdr.") nil [12285 13264])
            ("tabulated-list--col-local-max-widths" function
               (:documentation "Return maximum entry widths at column COL around current row.
Check the current row, the previous one and the next row."
                :arguments ("col"))
                nil [13266 13653])
            ("tabulated-list-print" function
               (:documentation "Populate the current Tabulated List mode buffer.
This sorts the `tabulated-list-entries' list if sorting is
specified by `tabulated-list-sort-key'.  It then erases the
buffer and inserts the entries with `tabulated-list-printer'.

Optional argument REMEMBER-POS, if non-nil, means to move point
to the entry with the same ID element as the current line and
recenter window line accordingly.

Non-nil UPDATE argument means to use an alternative printing
method which is faster if most entries haven't changed since the
last print.  The only difference in outcome is that tags will not
be removed from entries that haven't changed (see
`tabulated-list-put-tag').  Don't use this immediately after
changing `tabulated-list-sort-key'."
                :arguments ("remember-pos" "update"))
                nil [13655 17414])
            ("tabulated-list-print-entry" function
               (:documentation "Insert a Tabulated List entry at point.
This is the default `tabulated-list-printer' function.  ID is a
Lisp object identifying the entry to print, and COLS is a vector
of column descriptors."
                :arguments ("id" "cols"))
                nil [17416 18397])
            ("tabulated-list-print-col" function
               (:documentation "Insert a specified Tabulated List entry at point.
N is the column number, COL-DESC is a column descriptor (see
`tabulated-list-entries'), and X is the column number at point.
Return the column number after insertion."
                :arguments ("n" "col-desc" "x"))
                nil [18399 21174])
            ("tabulated-list-delete-entry" function (:documentation "Delete the Tabulated List entry at point.
Return a list (ID COLS), where ID is the ID of the deleted entry
and COLS is a vector of its column descriptors.  Move point to
the beginning of the deleted entry.  Return nil if there is no
entry at point.

This function only changes the buffer contents; it does not alter
`tabulated-list-entries'.") nil [21176 21817])
            ("tabulated-list-set-col" function
               (:documentation "Change the Tabulated List entry at point, setting COL to DESC.
COL is the column number to change, or the name of the column to change.
DESC is the new column descriptor, which is inserted via
`tabulated-list-print-col'.

If CHANGE-ENTRY-DATA is non-nil, modify the underlying entry data
by setting the appropriate slot of the vector originally used to
print this entry.  If `tabulated-list-entries' has a list value,
this is the vector stored within it."
                :arguments ("col" "desc" "change-entry-data"))
                nil [21819 23677])
            ("tabulated-list-col-sort" function
               (:documentation "Sort Tabulated List entries by the column of the mouse click E."
                :user-visible-flag t
                :arguments ("e"))
                nil [23679 24086])
            ("tabulated-list-sort" function
               (:documentation "Sort Tabulated List entries by the column at point.
With a numeric prefix argument N, sort the Nth column."
                :user-visible-flag t
                :arguments ("n"))
                nil [24088 24550])
            ("tabulated-list--sort-by-column-name" function (:arguments ("name")) nil [24552 24945])
            ("tabulated-list--current-lnum-width" variable nil nil [24947 24994])
            ("tabulated-list-watch-line-number-width" function (:arguments ("_window")) nil [24995 25320])
            ("tabulated-list-window-scroll-function" function (:arguments ("window" "_start")) nil [25322 25712])
            ("define-derived-mode" code nil nil [25740 28317])
            ("put" code nil nil [28319 28366])
            ("tabulated-list" package nil nil [28368 28393]))          
      :file "tabulated-list.el.gz"
      :pointmax 28427
      :fsize 8266
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189da00"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("cl-lib" include nil nil [3304 3321])
            ("edebug" include nil nil [3323 3340])
            ("testcover" package nil nil [3341 3361])
            ("testcover" customgroup
               (:documentation "Code-coverage tester."
                :user-visible-flag t)
                nil [3538 3644])
            ("testcover-constants" variable
               (:documentation "Variables whose values never change.  No brown splotch is shown for
these.  This list is quite incomplete!"
                :default-value '(nil t emacs-build-time emacs-version emacs-major-version emacs-minor-version))
                nil [3646 3921])
            ("testcover-1value-functions" variable
               (:documentation "Functions that always return the same value, according to `equal'.
No brown splotch is shown for these.  This list is quite
incomplete!  Notes: Nobody ever changes the current global map."
                :default-value '(backward-char barf-if-buffer-read-only beginning-of-line buffer-disable-undo buffer-enable-undo current-global-map deactivate-mark delete-backward-char delete-char delete-region ding forward-char function* insert insert-and-inherit kill-all-local-variables kill-line kill-paragraph kill-region kill-sexp minibuffer-complete-and-exit narrow-to-region next-line push-mark put-text-property run-hooks set-match-data signal substitute-key-definition suppress-keymap undo use-local-map while widen yank))
                nil [3923 4733])
            ("testcover-noreturn-functions" variable
               (:documentation "Subset of `testcover-1value-functions' -- these never return.  We mark
them as having returned nil just before calling them."
                :default-value '(error noreturn throw signal))
                nil [4735 4982])
            ("testcover-compose-functions" variable
               (:documentation "Functions that are 1-valued if all their args are either constants or
calls to one of the `testcover-1value-functions', so if that's true then no
brown splotch is shown for these.  This list is quite incomplete!  Most
side-effect-free functions should be here."
                :default-value '(+ - * / = append length list make-keymap make-sparse-keymap message propertize replace-regexp-in-string run-with-idle-timer set-buffer-modified-p))
                nil [4984 5492])
            ("testcover-progn-functions" variable
               (:documentation "Functions whose return value is the same as their last argument.  No
brown splotch is shown for these if the last argument is a constant or a
call to one of the `testcover-1value-functions'.  This list is probably
incomplete!"
                :default-value '(define-key fset function goto-char mapc overlay-put progn save-current-buffer save-excursion save-match-data save-restriction save-selected-window save-window-excursion set set-default set-marker-insertion-type setq setq-default with-current-buffer with-output-to-temp-buffer with-syntax-table with-temp-buffer with-temp-file with-temp-message with-timeout))
                nil [5494 6188])
            ("testcover-prog1-functions" variable
               (:documentation "Functions whose return value is the same as their first argument.  No
brown splotch is shown for these if the first argument is a constant or a
call to one of the `testcover-1value-functions'."
                :default-value '(prog1 unwind-protect))
                nil [6190 6495])
            ("testcover-potentially-1value-functions" variable
               (:documentation "Functions that are potentially 1-valued.  No brown splotch if actually
1-valued, no error if actually multi-valued."
                :default-value '(add-hook and beep or remove-hook unless when))
                nil [6497 6762])
            ("testcover-nohits" variable
               (:documentation "Face for forms that had no hits during coverage test"
                :default-value '((t (:background "DeepPink2")))
                :type "face")
                nil [6764 6902])
            ("testcover-1value" variable
               (:documentation "Face for forms that always produced the same value during coverage test"
                :default-value '((t (:background "Wheat2")))
                :type "face")
                nil [6904 7058])
            ("testcover-module-constants" variable (:documentation "Symbols declared with defconst in the last file processed by
`testcover-start'.") nil [7236 7359])
            ("testcover-module-1value-functions" variable (:documentation "Symbols declared with defun in the last file processed by
`testcover-start', whose functions should always return the same value.") nil [7361 7541])
            ("testcover-module-potentially-1value-functions" variable (:documentation "Symbols declared with defun in the last file processed by
`testcover-start', whose functions might always return the same value.") nil [7543 7734])
            ("testcover-vector" variable (:documentation "Locally bound to coverage vector for function in progress.") nil [7736 7828])
            ("testcover-start" function
               (:documentation "Use Edebug to instrument for coverage all macros and functions in FILENAME.
If BYTE-COMPILE is non-nil, byte compile each function after instrumenting."
                :user-visible-flag t
                :arguments ("filename" "byte-compile"))
                nil [8040 8881])
            ("testcover-this-defun" function
               (:documentation "Start coverage on function under point."
                :user-visible-flag t)
                nil [8898 9191])
            ("testcover-end" function
               (:documentation "Turn off instrumentation of all macros and functions in FILENAME."
                :user-visible-flag t
                :arguments ("filename"))
                nil [9193 9403])
            ("testcover-after-instrumentation" function
               (:documentation "Analyze FORM for code coverage."
                :arguments ("form"))
                nil [9590 9715])
            ("testcover-init-definition" function
               (:documentation "Mark SYM as under test coverage."
                :arguments ("sym"))
                nil [9717 9865])
            ("testcover-enter" function
               (:documentation "Begin execution of a function under coverage testing.
Bind `testcover-vector' to the code-coverage vector for FUNC and
return the result of evaluating BODY."
                :arguments ("func" "_args" "body"))
                nil [9867 10145])
            ("testcover-before" function
               (:documentation "Update code coverage before a form is evaluated.
BEFORE-INDEX is the form's index into the code-coverage vector."
                :arguments ("before-index"))
                nil [10147 10520])
            ("testcover-after" function
               (:documentation "Update code coverage with the result of a form's evaluation.
AFTER-INDEX is the form's index into the code-coverage
vector.  Return VALUE."
                :arguments ("_before-index" "after-index" "value"))
                nil [10522 11602])
            ("unless" code nil nil [11638 11788])
            ("testcover--copy-object" function
               (:documentation "Make a copy of OBJ.
If OBJ is a cons cell, copy both its car and its cdr.
Contrast to `copy-tree' which does the same but fails on circular
structures, and `copy-sequence', which copies only along the
cdrs.  Copy vectors as well as conses."
                :arguments ("obj"))
                nil [11790 12152])
            ("testcover--copy-object1" function
               (:documentation "Make a copy of OBJ, using a HASH-TABLE of objects already copied.
If OBJ is a cons cell, this recursively copies its car and
iteratively copies its cdr.  When VECP is non-nil, copy
vectors as well as conses."
                :arguments ("obj" "vecp" "hash-table"))
                nil [12154 13697])
            ("testcover-mark" function
               (:documentation "Marks one DEF (a function or macro symbol) to highlight its contained forms
that did not get completely tested during coverage tests.
  A marking with the face `testcover-nohits' (default = red) indicates that the
form was never evaluated.  A marking using the `testcover-1value' face
(default = tan) indicates that the form always evaluated to the same value.
  The forms throw, error, and signal are not marked.  They do not return and
would always get a red mark.  Some forms that always return the same
value (e.g., setq of a constant), always get a tan mark that can't be
eliminated by adding more test cases."
                :arguments ("def"))
                nil [13917 15515])
            ("testcover-mark-all" function
               (:documentation "Mark all forms in BUFFER that did not get completely tested during
coverage tests.  This function creates many overlays."
                :user-visible-flag t
                :arguments ("buffer"))
                nil [15517 15880])
            ("testcover-unmark-all" function
               (:documentation "Remove all overlays from FILENAME."
                :user-visible-flag t
                :arguments ("buffer"))
                nil [15882 16130])
            ("testcover-next-mark" function
               (:documentation "Moves point to next line in current buffer that has a splotch."
                :user-visible-flag t)
                nil [16165 16338])
            ("testcover-analyze-coverage" function
               (:documentation "Analyze FORM and initialize coverage vectors for definitions found within.
Return 1value, maybe or nil depending on if the form is determined
to return only a single value, potentially return only a single value,
or return multiple values."
                :arguments ("form"))
                nil [18051 20118])
            ("testcover-analyze-coverage-progn" function
               (:documentation "Analyze FORMS, which should be a list of forms, for code coverage.
Analyze all the forms in FORMS and return 1value, maybe or nil
depending on the analysis of the last one.  Find the coverage
vectors referenced by `edebug-enter' forms nested within FORMS and
update them with the results of the analysis."
                :arguments ("forms"))
                nil [20120 20602])
            ("testcover-analyze-coverage-edebug-after" function
               (:documentation "Analyze a _FORM wrapped by `edebug-after' for code coverage.
_FORM should be either:
    (edebug-after (edebug-before BEFORE-ID) AFTER-ID WRAPPED-FORM)
or:
    (edebug-after 0 AFTER-ID WRAPPED-FORM)

where BEFORE-FORM is bound to either (edebug-before BEFORE-ID) or
0.  WRAPPER may be 1value or noreturn, and if so it forces the
form to be treated accordingly."
                :arguments ("_form" "before-form" "before-id" "after-id" "wrapped-form" "wrapper"))
                nil [20604 22061])
            ("testcover-analyze-coverage-wrapped-form" function
               (:documentation "Analyze a FORM for code coverage which was wrapped by `edebug-after'.
FORM is treated as if it will be evaluated."
                :arguments ("form"))
                nil [22063 25032])
            ("testcover-analyze-coverage-wrapped-application" function
               (:documentation "Analyze the application of FUNC to ARGS for code coverage."
                :arguments ("func" "args"))
                nil [25034 26309])
            ("testcover-coverage-combine" function
               (:documentation "Combine RESULT with VAL and return the new result.
If either argument is nil, return nil, otherwise if either
argument is maybe, return maybe.  Return 1value only if both arguments
are 1value."
                :arguments ("result" "val"))
                nil [26311 26637])
            ("testcover-analyze-coverage-compose" function
               (:documentation "Analyze a list of FORMS for code coverage using FUNC.
The list is 1valued if all of its constituent elements are also 1valued."
                :arguments ("forms" "func"))
                nil [26639 27097])
            ("testcover-analyze-coverage-backquote" function
               (:documentation "Analyze BQ-LIST, the body of a backquoted list, for code coverage."
                :arguments ("bq-list"))
                nil [27099 27726])
            ("testcover-analyze-coverage-backquote-form" function
               (:documentation "Analyze a single FORM from a backquoted list for code coverage."
                :arguments ("form"))
                nil [27728 28098]))          
      :file "testcover.el.gz"
      :pointmax 28127
      :fsize 7940
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax '((close-paren 3321 . 3322) (symbol 3286 . 3303) (open-paren 3285 . 3286)))
    (semanticdb-table "semanticdb-table-189da20"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("tq-queue" function (:arguments ("tq")) nil [2131 2175])
            ("tq-process" function (:arguments ("tq")) nil [2176 2226])
            ("tq-buffer" function (:arguments ("tq")) nil [2227 2277])
            ("tq-queue-head-question" function (:arguments ("tq")) nil [2426 2487])
            ("tq-queue-head-regexp" function (:arguments ("tq")) nil [2573 2640])
            ("tq-queue-head-closure" function (:arguments ("tq")) nil [2693 2766])
            ("tq-queue-head-fn" function (:arguments ("tq")) nil [2846 2919])
            ("tq-queue-empty" function (:arguments ("tq")) nil [2957 3012])
            ("tq-create" function
               (:documentation "Create and return a transaction queue communicating with PROCESS.
PROCESS should be a subprocess capable of sending and receiving
streams of bytes.  It may be a local process, or it may be connected
to a tcp server on another machine."
                :arguments ("process"))
                nil [3053 3580])
            ("tq-queue-add" function (:arguments ("tq" "question" "re" "closure" "fn")) nil [3582 3733])
            ("tq-queue-pop" function (:arguments ("tq")) nil [3735 3947])
            ("tq-enqueue" function
               (:documentation "Add a transaction to transaction queue TQ.
This sends the string QUESTION to the process that TQ communicates with.

When the corresponding answer comes back, we call FN with two
arguments: CLOSURE, which may contain additional data that FN
needs, and the answer to the question.

REGEXP is a regular expression to match the entire answer;
that's how we tell where the answer ends.

If DELAY-QUESTION is non-nil, delay sending this question until
the process has finished replying to any previous questions.
This produces more reliable results with some processes."
                :arguments ("tq" "question" "regexp" "closure" "fn" "delay-question"))
                nil [3949 4796])
            ("tq-close" function
               (:documentation "Shut down transaction queue TQ, terminating the process."
                :arguments ("tq"))
                nil [4798 4946])
            ("tq-filter" function
               (:documentation "Append STRING to the TQ's buffer; then process the new data."
                :arguments ("tq" "string"))
                nil [4948 5211])
            ("tq-process-buffer" function
               (:documentation "Check TQ's buffer for the regexp at the head of the queue."
                :arguments ("tq"))
                nil [5213 6154])
            ("tq" package nil nil [6156 6169]))          
      :file "tq.el.gz"
      :pointmax 6191
      :fsize 2424
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189da40"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("eldoc" customgroup
               (:documentation "Show function arglist or variable docstring in echo area."
                :user-visible-flag t)
                nil [2006 2124])
            ("eldoc-idle-delay" variable
               (:documentation "Number of seconds of idle time to wait before printing.
If user input arrives before this interval of time has elapsed after the
last input, no documentation will be printed.

If this variable is set to 0, no idle time is required."
                :default-value 0.5)
                nil [2126 2427])
            ("eldoc-print-after-edit" variable (:documentation "If non-nil eldoc info is only shown when editing.
Changing the value requires toggling `eldoc-mode'.") nil [2429 2605])
            ("eldoc-minor-mode-string" variable
               (:documentation "String to display in mode line when ElDoc Mode is enabled; nil for none."
                :default-value (purecopy " ElDoc"))
                nil [2622 2819])
            ("eldoc-argument-case" variable
               (:documentation "Case to display argument names of functions, as a symbol.
This has two preferred values: `upcase' or `downcase'.
Actually, any name of a function which takes a string as an argument and
returns another string is acceptable.

Note that this variable has no effect, unless
`eldoc-documentation-function' handles it explicitly."
                :default-value nil)
                nil [2821 3300])
            ("make-obsolete-variable" code nil nil [3301 3357])
            ("eldoc-echo-area-use-multiline-p" variable
               (:documentation "Allow long ElDoc messages to resize echo area display.
If value is t, never attempt to truncate messages; complete symbol name
and function arglist or 1-line variable documentation will be displayed
even if echo area must be resized to fit.

If value is any non-nil value other than t, symbol name may be truncated
if it will enable the function arglist or documentation string to fit on a
single line without resizing window.  Otherwise, behavior is just like
former case.

If value is nil, messages are always truncated to fit in a single line of
display in the echo area.  Function or variable symbol name may be
truncated to make more of the arglist or documentation string visible.

Note that this variable has no effect, unless
`eldoc-documentation-function' handles it explicitly."
                :default-value 'truncate-sym-name-if-fit)
                nil [3359 4458])
            ("eldoc-highlight-function-argument" variable
               (:documentation "Face used for the argument at point in a function's argument list.
Note that this face has no effect unless the `eldoc-documentation-function'
handles it explicitly."
                :default-value '((t (:inherit bold)))
                :type "face")
                nil [4460 4714])
            ("eldoc-message-commands-table-size" variable
               (:documentation "Used by `eldoc-add-command' to initialize `eldoc-message-commands' obarray.
It should probably never be necessary to do so, but if you
choose to increase the number of buckets, you must do so before loading
this file since the obarray is initialized at load time.
Remember to keep it a prime number to improve hash performance."
                :default-value 31)
                nil [4749 5126])
            ("eldoc-message-commands" variable
               (:documentation "Commands after which it is appropriate to print in the echo area.
ElDoc does not try to print function arglists, etc., after just any command,
because some commands print their own messages in the echo area and these
functions would instantly overwrite them.  But `self-insert-command' as well
as most motion commands are good candidates.
This variable contains an obarray of symbols; do not manipulate it
directly.  Instead, use `eldoc-add-command' and `eldoc-remove-command'."
                :default-value (make-vector eldoc-message-commands-table-size 0))
                nil [5128 5774])
            ("eldoc-last-data" variable
               (:documentation "Bookkeeping; elements are as follows:
  0 - contains the last symbol read from the buffer.
  1 - contains the string last displayed in the echo area for variables,
      or argument string for functions.
  2 - `function' if function args, `variable' if variable documentation."
                :default-value (make-vector 3 nil))
                nil [5795 6201])
            ("make-obsolete-variable" code nil nil [6202 6273])
            ("eldoc-last-message" variable nil nil [6275 6306])
            ("eldoc-timer" variable (:documentation "ElDoc's timer object.") nil [6308 6356])
            ("eldoc-current-idle-delay" variable
               (:documentation "Idle time delay currently in use by timer.
This is used to determine if `eldoc-idle-delay' is changed by the user."
                :default-value eldoc-idle-delay)
                nil [6358 6527])
            ("eldoc-message-function" variable
               (:documentation "The function used by `eldoc-message' to display messages.
It should receive the same arguments as `message'."
                :default-value nil)
                nil [6529 6700])
            ("eldoc-edit-message-commands" function (:documentation "Return an obarray containing common editing commands.

When `eldoc-print-after-edit' is non-nil, ElDoc messages are only
printed after commands contained in this obarray.") nil [6702 7172])
            ("define-minor-mode" code nil nil [7191 8416])
            ("define-globalized-minor-mode" code nil nil [8433 8582])
            ("turn-on-eldoc-mode" function (:documentation "Turn on `eldoc-mode' if the buffer has ElDoc support enabled.
See `eldoc-documentation-function' for more detail.") nil [8599 8795])
            ("eldoc--supported-p" function (:documentation "Non-nil if an ElDoc function is set for this buffer.") nil [8797 8941])
            ("eldoc-schedule-timer" function (:documentation "Ensure `eldoc-timer' is running.

If the user has changed `eldoc-idle-delay', update the timer to
reflect the change.") nil [8945 9718])
            ("eldoc-mode-line-string" variable nil nil [9720 9755])
            ("put" code nil nil [9756 9809])
            ("eldoc-minibuffer-message" function
               (:documentation "Display messages in the mode-line when in the minibuffer.
Otherwise work like `message'."
                :arguments ("format-string" "args"))
                nil [9811 10808])
            ("eldoc-message" function
               (:documentation "Display STRING as an ElDoc message if it's non-nil.

Also store it in `eldoc-last-message' and return that value."
                :arguments ("string"))
                nil [10810 11468])
            ("eldoc--message-command-p" function
               (:documentation "Return non-nil if COMMAND is in `eldoc-message-commands'."
                :arguments ("command"))
                nil [11470 11666])
            ("eldoc-pre-command-refresh-echo-area" function (:documentation "Reprint `eldoc-last-message' in the echo area.") nil [12089 12619])
            ("eldoc-display-message-p" function (:documentation "Return non-nil when it is appropriate to display an ElDoc message.") nil [12680 13134])
            ("eldoc-display-message-no-interference-p" function (:documentation "Return nil if displaying a message would cause interference.") nil [13273 13454])
            ("eldoc-documentation-function" variable
               (:documentation "Function to call to return doc string.
The function of no args should return a one-line string for displaying
doc about a function etc. appropriate to the context around point.
It should return nil if there's no doc appropriate for the context.
Typically doc is returned if point is on a function-like name or in its
arg list.

The result is used as is, so the function must explicitly handle
the variables `eldoc-argument-case' and `eldoc-echo-area-use-multiline-p',
and the face `eldoc-highlight-function-argument', if they are to have any
effect.

Major modes should modify this variable using `add-function', for example:
  (add-function :before-until (local \\='eldoc-documentation-function)
                #\\='foo-mode-eldoc-function)
so that the global documentation function (i.e. the default value of the
variable) is taken into account if the major mode specific function does not
return any documentation."
                :default-value nil)
                nil [13473 14442])
            ("eldoc-print-current-symbol-info" function (:documentation "Print the text produced by `eldoc-documentation-function'.") nil [14444 14976])
            ("eldoc-docstring-format-sym-doc" function
               (:documentation "Combine PREFIX and DOC, and shorten the result to fit in the echo area.

When PREFIX is a symbol, propertize its symbol name with FACE
before combining it with DOC.  If FACE is not provided, just
apply the nil face.

See also: `eldoc-echo-area-use-multiline-p'."
                :arguments ("prefix" "doc" "face"))
                nil [15141 16516])
            ("eldoc-add-command" function
               (:documentation "Add each of CMDS to the obarray `eldoc-message-commands'."
                :arguments ("cmds"))
                nil [16851 17088])
            ("eldoc-add-command-completions" function
               (:documentation "Pass every prefix completion of NAMES to `eldoc-add-command'."
                :arguments ("names"))
                nil [17090 17304])
            ("eldoc-remove-command" function
               (:documentation "Remove each of CMDS from the obarray `eldoc-message-commands'."
                :arguments ("cmds"))
                nil [17306 17545])
            ("eldoc-remove-command-completions" function
               (:documentation "Pass every prefix completion of NAMES to `eldoc-remove-command'."
                :arguments ("names"))
                nil [17547 17786])
            ("eldoc-add-command-completions" code nil nil [17817 18300])
            ("eldoc" package nil nil [18302 18318]))          
      :file "eldoc.el.gz"
      :pointmax 18343
      :fsize 6280
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-189dd80"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("backtrace" include nil nil [1937 1957])
            ("macroexp" include nil nil [1958 1977])
            ("cl-lib" include nil nil [1978 1995])
            ("pcase" include nil nil [2015 2031])
            ("edebug" customgroup
               (:documentation "A source-level debugger for Emacs Lisp."
                :user-visible-flag t)
                nil [2047 2127])
            ("edebug-setup-hook" variable (:documentation "Functions to call before edebug is used.
Each time it is set to a new value, Edebug will call those functions
once and then reset `edebug-setup-hook' to nil.  You could use this
to load up Edebug specifications associated with a package you are
using, but only when you also use Edebug.") nil [2130 2485])
            ("edebug-all-defs" variable (:documentation "If non-nil, evaluating defining forms instruments for Edebug.
This applies to `eval-defun', `eval-region', `eval-buffer', and
`eval-current-buffer'.  `eval-region' is also called by
`eval-last-sexp', and `eval-print-last-sexp'.

You can use the command `edebug-all-defs' to toggle the value of this
variable.  You may wish to make it local to each buffer with
(make-local-variable \\='edebug-all-defs) in your
`emacs-lisp-mode-hook'.") nil [2707 3211])
            ("edebug-all-forms" variable (:documentation "Non-nil means evaluation of all forms will instrument for Edebug.
This doesn't apply to loading or evaluations in the minibuffer.
Use the command `edebug-all-forms' to toggle the value of this option.") nil [3433 3704])
            ("edebug-eval-macro-args" variable (:documentation "Non-nil means all macro call arguments may be evaluated.
If this variable is nil, the default, Edebug will *not* wrap
macro call arguments as if they will be evaluated.
For each macro, an `edebug-form-spec' overrides this option.
So to specify exceptions for macros that have some arguments evaluated
and some not, use `def-edebug-spec' to specify an `edebug-form-spec'.") nil [3706 4153])
            ("edebug-max-depth" variable
               (:documentation "Maximum recursion depth when instrumenting code.
This limit is intended to stop recursion if an Edebug specification
contains an infinite loop.  When Edebug is instrumenting code
containing very large quoted lists, it may reach this limit and give
the error message \"Too deep - perhaps infinite loop in spec?\".
Make this limit larger to countermand that, but you may also need to
increase `max-lisp-eval-depth' and `max-specpdl-size'."
                :default-value 150)
                nil [4155 4680])
            ("edebug-save-windows" variable
               (:documentation "If non-nil, Edebug saves and restores the window configuration.
That takes some time, so if your program does not care what happens to
the window configurations, it is better to set this variable to nil.

If the value is a list, only the listed windows are saved and
restored.

`edebug-toggle-save-windows' may be used to change this variable."
                :default-value t)
                nil [4682 5122])
            ("edebug-save-displayed-buffer-points" variable (:documentation "If non-nil, save and restore point in all displayed buffers.

Saving and restoring point in other buffers is necessary if you are
debugging code that changes the point of a buffer that is displayed
in a non-selected window.  If Edebug or the user then selects the
window, the buffer's point will be changed to the window's point.

Saving and restoring point in all buffers is expensive, since it
requires selecting each window twice, so enable this only if you
need it.") nil [5124 5683])
            ("edebug-initial-mode" variable
               (:documentation "Initial execution mode for Edebug, if non-nil.
If this variable is non-nil, it specifies the initial execution mode
for Edebug when it is first activated.  Possible values are step, next,
go, Go-nonstop, trace, Trace-fast, continue, and Continue-fast."
                :default-value 'step)
                nil [5685 6150])
            ("edebug-trace" variable (:documentation "Non-nil means display a trace of function entry and exit.
Tracing output is displayed in a buffer named `*edebug-trace*', one
function entry or exit per line, indented by the recursion level.

You can customize by replacing functions `edebug-print-trace-before'
and `edebug-print-trace-after'.") nil [6152 6512])
            ("edebug-test-coverage" variable (:documentation "If non-nil, Edebug tests coverage of all expressions debugged.
This is done by comparing the result of each expression with the
previous result.  Coverage is considered OK if two different
results are found.

Use `edebug-display-freq-count' to display the frequency count and
coverage information for a definition.") nil [6514 6903])
            ("edebug-continue-kbd-macro" variable (:documentation "If non-nil, continue defining or executing any keyboard macro.
Use this with caution since it is not debugged.") nil [6905 7095])
            ("edebug-print-length" variable
               (:documentation "If non-nil, default value of `print-length' for printing results in Edebug."
                :default-value 50)
                nil [7098 7246])
            ("edebug-print-level" variable
               (:documentation "If non-nil, default value of `print-level' for printing results in Edebug."
                :default-value 50)
                nil [7247 7393])
            ("edebug-print-circle" variable
               (:documentation "If non-nil, default value of `print-circle' for printing results in Edebug."
                :default-value t)
                nil [7394 7541])
            ("edebug-unwrap-results" variable (:documentation "Non-nil if Edebug should unwrap results of expressions.
That is, Edebug will try to remove its own instrumentation from the result.
This is useful when debugging macros where the results of expressions
are instrumented expressions.") nil [7543 7850])
            ("edebug-on-error" variable
               (:documentation "Value bound to `debug-on-error' while Edebug is active.

If `debug-on-error' is non-nil, that value is still used.

If the value is a list of signal names, Edebug will stop when any of
these errors are signaled from Lisp code whether or not the signal is
handled by a `condition-case'.  This option is useful for debugging
signals that *are* handled since they would otherwise be missed.
After execution is resumed, the error is signaled again."
                :default-value t)
                nil [7852 8483])
            ("edebug-on-quit" variable
               (:documentation "Value bound to `debug-on-quit' while Edebug is active."
                :default-value t)
                nil [8485 8606])
            ("edebug-global-break-condition" variable (:documentation "If non-nil, an expression to test for at every stop point.
If the result is non-nil, then break.  Errors are ignored.") nil [8608 8817])
            ("edebug-sit-for-seconds" variable
               (:documentation "Number of seconds to pause when execution mode is `trace' or `continue'."
                :default-value 1)
                nil [8819 8965])
            ("edebug-sit-on-break" variable
               (:documentation "Whether or not to pause for `edebug-sit-for-seconds' on reaching a break."
                :default-value t)
                nil [8967 9130])
            ("get-edebug-spec" function (:arguments ("symbol")) nil [9158 9544])
            ("edebug-basic-spec" function
               (:documentation "Return t if SPEC uses only extant spec symbols.
An extant spec symbol is a symbol that is not a function and has a
`edebug-form-spec' property."
                :arguments ("spec"))
                nil [9561 9983])
            ("edebug-lambda-list-keywordp" function
               (:documentation "Return t if OBJECT is a lambda list keyword.
A lambda list keyword is a symbol that starts with `&'."
                :arguments ("object"))
                nil [10000 10218])
            ("edebug-last-sexp" function nil nil [10221 10476])
            ("edebug-window-list" function (:documentation "Return a list of windows, in order of `next-window'.") nil [10478 10700])
            ("edebug-two-window-p" function (:documentation "Return t if there are two windows.") nil [10716 10876])
            ("edebug-sort-alist" function (:arguments ("alist" "function")) nil [10878 11127])
            ("edebug-save-restriction" function
               (:documentation "Evaluate BODY while saving the current buffers restriction.
BODY may change buffer outside of current restriction, unlike
save-restriction.  BODY may change the current buffer,
and the restriction will be restored to the original buffer,
and the current buffer remains current.
Return the result of the last expression in BODY."
                :arguments ("body"))
                nil [11143 11779])
            ("edebug-trace-buffer" variable
               (:documentation "Name of the buffer to put trace info in."
                :constant-flag t
                :default-value "*edebug-trace*")
                nil [11794 11886])
            ("edebug-pop-to-buffer" function (:arguments ("buffer" "window")) nil [11888 13209])
            ("edebug-get-displayed-buffer-points" function nil nil [13231 13516])
            ("edebug-set-buffer-points" function (:arguments ("buffer-points")) nil [13519 13829])
            ("edebug-current-windows" function (:arguments ("which-windows")) nil [13831 14347])
            ("edebug-set-windows" function (:arguments ("window-info")) nil [14349 15169])
            ("edebug--read" function
               (:documentation "Read one Lisp expression as text from STREAM, return as Lisp object.
If STREAM is nil, use the value of `standard-input' (which see).
STREAM or the value of `standard-input' may be:
 a buffer (read from point and advance it)
 a marker (read from where it points and advance it)
 a function (call it with no arguments for each character,
     call it with a char as argument to push a char back)
 a string (takes text from string, starting at the beginning)
 t (read text line using minibuffer and use it).

This version, from Edebug, maybe instruments the expression.  But the
STREAM must be the current buffer to do so.  Whether it instruments is
also dependent on the values of the option `edebug-all-defs' and
the option `edebug-all-forms'."
                :arguments ("orig" "stream"))
                nil [15331 16280])
            ("edebug-result" variable nil nil [16282 16304])
            ("edebug-eval-defun" function
               (:documentation "Evaluate the top-level form containing point, or after point.

If the current defun is actually a call to `defvar', then reset the
variable using its initial value expression even if the variable
already has some other value.  (Normally `defvar' does not change the
variable's value if it already has a value.)  Treat `defcustom'
similarly.  Reinitialize the face according to `defface' specification.

With a prefix argument, instrument the code for Edebug.

Setting option `edebug-all-defs' to a non-nil value reverses the meaning
of the prefix argument.  Code is then instrumented when this function is
invoked without a prefix argument.

If acting on a `defun' for FUNCTION, and the function was instrumented,
`Edebug: FUNCTION' is printed in the minibuffer.  If not instrumented,
just FUNCTION is printed.

If not acting on a `defun', the result of evaluation is displayed in
the minibuffer."
                :user-visible-flag t
                :arguments ("edebug-it"))
                nil [16463 18977])
            ("defalias" code nil nil [18995 19047])
            ("edebug-eval-top-level-form" function
               (:documentation "Evaluate the top level form point is in, stepping through with Edebug.
This is like `eval-defun' except that it steps the code for Edebug
before evaluating it.  It displays the value in the echo area
using `eval-expression' (which see).

If you do this on a function definition such as a defun or defmacro,
it defines the function and instruments its definition for Edebug,
so it will do Edebug stepping when called later.  It displays
`Edebug: FUNCTION' in the echo area to indicate that FUNCTION is now
instrumented for Edebug.

If the current defun is actually a call to `defvar' or `defcustom',
evaluating it this way resets the variable using its initial value
expression even if the variable already has some other value.
(Normally `defvar' and `defcustom' do not alter the value if there
already is one.)"
                :user-visible-flag t)
                nil [19064 20195])
            ("edebug-read-top-level-form" function nil nil [20198 20449])
            ("defalias" code nil nil [20488 20534])
            ("edebug-all-defs" function
               (:documentation "Toggle edebugging of all definitions."
                :user-visible-flag t)
                nil [20551 20766])
            ("edebug-all-forms" function
               (:documentation "Toggle edebugging of all forms."
                :user-visible-flag t)
                nil [20784 20991])
            ("edebug-install-read-eval-functions" function nil nil [20994 21171])
            ("edebug-uninstall-read-eval-functions" function nil nil [21173 21339])
            ("defvar-local" code nil nil [21479 21998])
            ("cl-defstruct" code nil nil [22000 22299])
            ("edebug-set-form-data-entry" function (:arguments ("entry" "name" "begin" "end")) nil [22301 22536])
            ("edebug-get-form-data-entry" function (:arguments ("pnt" "end-point")) nil [22538 23248])
            ("edebug-form-data-symbol" function (:documentation "Return the edebug data symbol of the form where point is in.
If point is not inside an edebuggable form, signal an error.") nil [23359 23633])
            ("edebug-make-top-form-data-entry" function (:arguments ("new-entry")) nil [23635 23835])
            ("edebug-clear-form-data-entry" function
               (:documentation "If non-nil, clear ENTRY out of the form data.
Maybe clear the markers and delete the symbol's edebug property?"
                :arguments ("entry"))
                nil [23837 24348])
            ("edebug-syntax-error" function (:arguments ("args")) nil [24372 24495])
            ("edebug-read-syntax-table" variable
               (:constant-flag t
                :default-value (let ((table (make-char-table 'syntax-table 'symbol)) (i 0)) (while (< i 33) (aset table i 'space) (setq i (1+ i))) (aset table 40 'lparen) (aset table 41 'rparen) (aset table 39 'quote) (aset table 96 'backquote) (aset table 44 'comma) (aset table 34 'string) (aset table 63 'char) (aset table 91 'lbracket) (aset table 93 'rbracket) (aset table 46 'dot) (aset table 35 'hash) table))
                nil [24498 25278])
            ("edebug-next-token-class" function nil nil [25280 25810])
            ("edebug-skip-whitespace" function nil nil [25813 26079])
            ("edebug-read-sexp" function nil nil [26134 27056])
            ("edebug-offsets" variable nil nil [27405 27432])
            ("edebug-offsets-stack" variable nil nil [27545 27578])
            ("edebug-current-offset" variable nil nil [27579 27613])
            ("edebug-read-objects" variable nil nil [27845 27877])
            ("edebug-read-dotted-list" variable nil nil [28046 28082])
            ("edebug-initialize-offsets" function nil nil [28084 28194])
            ("edebug-store-before-offset" function (:arguments ("point")) nil [28196 28773])
            ("edebug-store-after-offset" function (:arguments ("point")) nil [28775 29707])
            ("edebug-ignore-offset" function nil nil [29709 29849])
            ("edebug-storing-offsets" function (:arguments ("point" "body")) nil [29851 30069])
            ("edebug-read-alist" variable
               (:constant-flag t
                :default-value '((symbol . edebug-read-symbol) (lparen . edebug-read-list) (string . edebug-read-string) (quote . edebug-read-quote) (backquote . edebug-read-backquote) (comma . edebug-read-comma) (lbracket . edebug-read-vector) (hash . edebug-read-special)))
                nil [30169 30476])
            ("edebug-read-storing-offsets" function (:arguments ("stream")) nil [30478 30771])
            ("defalias" code nil nil [30773 30810])
            ("defalias" code nil nil [30811 30848])
            ("edebug-read-quote" function (:arguments ("stream")) nil [30850 31036])
            ("edebug-read-backquote" function (:arguments ("stream")) nil [31038 31222])
            ("edebug-read-comma" function (:arguments ("stream")) nil [31224 31793])
            ("edebug-read-special" function
               (:documentation "Read from STREAM a Lisp object beginning with #.
Turn #'thing into (function thing) and handle the read syntax for
circular objects.  Let `read' read everything else."
                :arguments ("stream"))
                nil [31795 33591])
            ("edebug-read-list" function (:arguments ("stream")) nil [33593 34275])
            ("edebug-read-vector" function (:arguments ("stream")) nil [34277 34566])
            ("edebug-dotted-spec" variable (:documentation "Set to t when matching after the dot in a dotted spec list.") nil [34637 34732])
            ("edebug-new-cursor" function (:arguments ("expressions" "offsets")) nil [34734 34944])
            ("edebug-set-cursor" function (:arguments ("cursor" "expressions" "offsets")) nil [34946 35152])
            ("edebug-copy-cursor" function (:arguments ("cursor")) nil [35154 35280])
            ("edebug-cursor-expressions" function (:arguments ("cursor")) nil [35282 35342])
            ("edebug-cursor-offsets" function (:arguments ("cursor")) nil [35343 35399])
            ("edebug-empty-cursor" function (:arguments ("cursor")) nil [35401 35529])
            ("edebug-top-element" function (:arguments ("cursor")) nil [35531 35657])
            ("edebug-top-element-required" function (:arguments ("cursor" "error")) nil [35659 36009])
            ("edebug-top-offset" function (:arguments ("cursor")) nil [36011 36135])
            ("edebug-move-cursor" function (:arguments ("cursor")) nil [36137 36613])
            ("edebug-before-offset" function (:arguments ("cursor")) nil [36616 36944])
            ("edebug-after-offset" function (:arguments ("cursor")) nil [36946 37150])
            ("edebug-top-window-data" variable nil nil [38345 38376])
            ("edebug-&optional" variable nil nil [38378 38403])
            ("edebug-&rest" variable nil nil [38404 38425])
            ("edebug-gate" variable nil nil [38426 38450])
            ("edebug-def-name" variable nil nil [38489 38517])
            ("edebug-old-def-name" variable nil nil [38565 38597])
            ("edebug-error-point" variable nil nil [38641 38672])
            ("edebug-best-error" variable nil nil [38673 38703])
            ("edebug-after-instrumentation-function" variable
               (:documentation "Function to run on code after instrumentation for debugging.
The function is called with one argument, a FORM which has just
been instrumented for Edebugging, and it should return either FORM
or a replacement form to use in its place."
                :default-value nil)
                nil [38804 39100])
            ("edebug-new-definition-function" variable
               (:documentation "Function to call after Edebug wraps a new definition.
After Edebug has initialized its own data, this function is
called with one argument, the symbol associated with the
definition, which may be the actual symbol defined or one
generated by Edebug."
                :default-value nil)
                nil [39102 39419])
            ("edebug-behavior-alist" variable
               (:documentation "Alist describing the runtime behavior of Edebug's instrumented code.
Each definition instrumented by Edebug will have a
`edebug-behavior' property which is a key to this alist.  When
the instrumented code is running, Edebug will look here for the
implementations of `edebug-enter', `edebug-before', and
`edebug-after'.  Edebug's instrumentation may be used for a new
purpose by adding an entry to this alist, and setting
`edebug-new-definition-function' to a function which sets
`edebug-behavior' for the definition."
                :default-value '((edebug edebug-default-enter edebug-slow-before edebug-slow-after)))
                nil [39421 40044])
            ("edebug-read-and-maybe-wrap-form" function nil nil [40046 41021])
            ("edebug-read-and-maybe-wrap-form1" function nil nil [41024 43906])
            ("edebug-def-args" variable nil nil [43908 43932])
            ("edebug-def-interactive" variable nil nil [43958 43989])
            ("edebug-inside-func" variable nil nil [44029 44056])
            ("edebug--cl-macrolet-defs" variable nil nil [44166 44199])
            ("edebug-interactive-p-name" function nil nil [44225 44434])
            ("edebug-wrap-def-body" function
               (:documentation "Wrap the FORMS of a definition body."
                :arguments ("forms"))
                nil [44437 44688])
            ("edebug-make-enter-wrapper" function (:arguments ("forms")) nil [44691 45419])
            ("edebug-form-begin-marker" variable nil nil [45422 45455])
            ("edebug-offset-index" variable nil nil [45495 45523])
            ("edebug-offset-list" variable nil nil [45559 45586])
            ("edebug-inc-offset" function (:arguments ("offset")) nil [45620 45943])
            ("edebug-make-before-and-after-form" function (:arguments ("before-index" "form" "after-index")) nil [45946 46315])
            ("edebug-make-after-form" function (:arguments ("form" "after-index")) nil [46317 46466])
            ("edebug-unwrap" function
               (:documentation "Return the unwrapped SEXP or return it as is if it is not wrapped.
The SEXP might be the result of wrapping a body, which is a list of
expressions; a `progn' form will be returned enclosing these forms.
Does not unwrap inside vectors, records, structures, or hash tables."
                :arguments ("sexp"))
                nil [46469 47215])
            ("edebug-unwrap*" function
               (:documentation "Return the SEXP recursively unwrapped."
                :arguments ("sexp"))
                nil [47217 47362])
            ("edebug--unwrap1" function
               (:documentation "Unwrap SEXP using HASH-TABLE of things already unwrapped.
HASH-TABLE contains the results of unwrapping cons cells within
SEXP, which are reused to avoid infinite loops when SEXP is or
contains a circular object."
                :arguments ("sexp" "hash-table"))
                nil [47364 48493])
            ("edebug-defining-form" function (:arguments ("cursor" "form-begin" "form-end" "speclist")) nil [48496 48952])
            ("edebug-make-form-wrapper" function (:arguments ("cursor" "form-begin" "form-end" "speclist")) nil [48954 52290])
            ("edebug-new-definition" function
               (:documentation "Set up DEF-NAME to use Edebug's instrumentation functions."
                :arguments ("def-name"))
                nil [52292 52471])
            ("edebug-clear-frequency-count" function (:arguments ("name")) nil [52474 52722])
            ("edebug-clear-coverage" function (:arguments ("name")) nil [52725 52959])
            ("edebug-form" function (:arguments ("cursor")) nil [52962 54464])
            ("edebug-forms" function (:arguments ("cursor")) nil [54467 54536])
            ("edebug-sexps" function (:arguments ("cursor")) nil [54537 54606])
            ("edebug-list-form-args" function (:arguments ("head" "cursor")) nil [54608 55610])
            ("edebug-list-form" function (:arguments ("cursor")) nil [55613 57183])
            ("edebug-matching-depth" variable nil nil [57209 57241])
            ("edebug-no-match" function (:arguments ("cursor" "args")) nil [57466 57970])
            ("edebug-match" function (:arguments ("cursor" "specs")) nil [57973 58293])
            ("edebug-match-one-spec" function (:arguments ("cursor" "spec")) nil [58296 58622])
            ("edebug-match-specs" function (:arguments ("cursor" "specs" "remainder-handler")) nil [58625 61134])
            ("dolist" code nil nil [61417 62442])
            ("edebug-match-symbol" function (:arguments ("cursor" "symbol")) nil [62444 63334])
            ("edebug-match-sexp" function (:arguments ("cursor")) nil [63337 63472])
            ("edebug-match-form" function (:arguments ("cursor")) nil [63474 63538])
            ("defalias" code nil nil [63540 63589])
            ("edebug-match-body" function (:arguments ("cursor")) nil [63695 63754])
            ("edebug-match-&optional" function (:arguments ("cursor" "specs")) nil [63756 63910])
            ("edebug-&optional-wrapper" function (:arguments ("cursor" "specs" "remainder-handler")) nil [63912 64440])
            ("edebug-&rest-wrapper" function (:arguments ("cursor" "specs" "remainder-handler")) nil [64443 64679])
            ("edebug-match-&rest" function (:arguments ("cursor" "specs")) nil [64681 64913])
            ("edebug-match-&or" function (:arguments ("cursor" "specs")) nil [64916 65790])
            ("edebug-match-&not" function (:arguments ("cursor" "specs")) nil [65793 66155])
            ("def-edebug-spec" code nil nil [66180 66220])
            ("edebug-match-&key" function (:arguments ("cursor" "specs")) nil [66222 66640])
            ("edebug-match-gate" function (:arguments ("_cursor")) nil [66643 66771])
            ("edebug-match-list" function (:arguments ("cursor" "specs")) nil [66774 68361])
            ("edebug-match-sublist" function (:arguments ("cursor" "specs")) nil [68364 68898])
            ("edebug-match-string" function (:arguments ("cursor" "spec")) nil [68901 69255])
            ("edebug-match-nil" function (:arguments ("cursor")) nil [69257 69443])
            ("edebug-match-function" function (:arguments ("_cursor")) nil [69446 69550])
            ("edebug-match-&define" function (:arguments ("cursor" "specs")) nil [69552 70079])
            ("edebug-match-lambda-expr" function (:arguments ("cursor")) nil [70081 71064])
            ("edebug-match-name" function (:arguments ("cursor")) nil [71067 71601])
            ("edebug-match-colon-name" function (:arguments ("_cursor" "spec")) nil [71603 71864])
            ("edebug-match-cl-generic-method-args" function (:arguments ("cursor")) nil [71866 72250])
            ("edebug--cl-macrolet-defs" variable (:documentation "List of symbols found within the bindings of enclosing `cl-macrolet' forms.") nil [72252 72369])
            ("edebug--current-cl-macrolet-defs" variable (:documentation "List of symbols found within the bindings of the current `cl-macrolet' form.") nil [72370 72496])
            ("edebug-match-cl-macrolet-expr" function
               (:documentation "Match a `cl-macrolet' form at CURSOR."
                :arguments ("cursor"))
                nil [72498 72885])
            ("edebug-match-cl-macrolet-name" function
               (:documentation "Match the name in a `cl-macrolet' binding at CURSOR.
Collect the names in `edebug--cl-macrolet-defs' where they
will be checked by `edebug-list-form-args' and treated as
macros without a spec."
                :arguments ("cursor"))
                nil [72887 73511])
            ("edebug-match-cl-macrolet-body" function
               (:documentation "Match the body of a `cl-macrolet' expression at CURSOR.
Put the definitions collected in `edebug--current-cl-macrolet-defs'
into `edebug--cl-macrolet-defs' which is checked in `edebug-list-form-args'."
                :arguments ("cursor"))
                nil [73513 73939])
            ("edebug-match-arg" function (:arguments ("cursor")) nil [73941 74361])
            ("edebug-match-def-form" function (:arguments ("cursor")) nil [74363 74745])
            ("edebug-match-def-body" function (:arguments ("cursor")) nil [74747 75239])
            ("edebug-spec-p" function
               (:documentation "Return non-nil if OBJECT is a symbol with an edebug-form-spec property."
                :arguments ("object"))
                nil [75378 75547])
            ("def-edebug-spec" code nil nil [75549 75720])
            ("def-edebug-spec" code nil nil [75722 75861])
            ("def-edebug-spec" code nil nil [75863 76233])
            ("def-edebug-spec" code nil nil [76349 76377])
            ("def-edebug-spec" code nil nil [76411 76444])
            ("def-edebug-spec" code nil nil [76445 76502])
            ("def-edebug-spec" code nil nil [76504 76670])
            ("def-edebug-spec" code nil nil [76671 76884])
            ("def-edebug-spec" code nil nil [76886 76923])
            ("def-edebug-spec" code nil nil [76959 77083])
            ("def-edebug-spec" code nil nil [77085 77195])
            ("def-edebug-spec" code nil nil [77197 77261])
            ("def-edebug-spec" code nil nil [77403 77615])
            ("def-edebug-spec" code nil nil [77710 77762])
            ("def-edebug-spec" code nil nil [77833 77896])
            ("def-edebug-spec" code nil nil [78205 78283])
            ("def-edebug-spec" code nil nil [78285 78311])
            ("def-edebug-spec" code nil nil [78313 78356])
            ("def-edebug-spec" code nil nil [78357 78392])
            ("def-edebug-spec" code nil nil [78394 78437])
            ("def-edebug-spec" code nil nil [78439 78537])
            ("def-edebug-spec" code nil nil [78540 78577])
            ("def-edebug-spec" code nil nil [78663 79375])
            ("defalias" code nil nil [79999 80024])
            ("def-edebug-spec" code nil nil [80062 80100])
            ("def-edebug-spec" code nil nil [80177 80232])
            ("def-edebug-spec" code nil nil [80233 80339])
            ("def-edebug-spec" code nil nil [80364 80404])
            ("def-edebug-spec" code nil nil [80405 80444])
            ("edebug-active" variable nil nil [80490 80516])
            ("edebug-stack" variable nil nil [80552 80577])
            ("edebug-stack-depth" variable (:default-value -1) nil [80665 80695])
            ("edebug-offset-indices" variable nil nil [80733 80767])
            ("edebug-entered" variable nil nil [80919 81071])
            ("edebug-debugger" variable
               (:constant-flag t
                :default-value 'edebug)
                nil [81101 81261])
            ("edebug-function" variable nil nil [81332 81356])
            ("edebug-data" variable nil nil [81402 81422])
            ("edebug-def-mark" variable nil nil [81458 81482])
            ("edebug-freq-count" variable nil nil [81513 81539])
            ("edebug-coverage" variable nil nil [81574 81598])
            ("edebug-buffer" variable nil nil [81655 81677])
            ("edebug-execution-mode" variable (:default-value 'step) nil [81714 81750])
            ("edebug-next-execution-mode" variable nil nil [81786 81825])
            ("edebug-outside-debug-on-error" variable nil nil [81863 81901])
            ("edebug-outside-debug-on-quit" variable nil nil [81940 81977])
            ("edebug-signal" function
               (:documentation "Signal an error.  Args are SIGNAL-NAME, and associated DATA.
A signal name is a symbol with an `error-conditions' property
that is a list of condition names.
A handler for any of those names will get to handle this signal.
The symbol `error' should always be one of them.

DATA should be a list.  Its elements are printed as part of the error message.
If the signal is handled, DATA is made available to the handler.
See `condition-case'.

This is the Edebug replacement for the standard `signal'.  It should
only be active while Edebug is.  It checks `debug-on-error' to see
whether it should call the debugger.  When execution is resumed, the
error is signaled again."
                :arguments ("signal-name" "signal-data"))
                nil [82038 83111])
            ("edebug-enter" function
               (:documentation "Enter Edebug for a function.
FUNC should be the symbol with the Edebug information, ARGS is
the list of arguments and BODY is the code.

Look up the `edebug-behavior' for FUNC in `edebug-behavior-alist'
and run its entry function, and set up `edebug-before' and
`edebug-after'."
                :arguments ("func" "args" "body"))
                nil [83134 83757])
            ("edebug-default-enter" function (:arguments ("function" "args" "body")) nil [83759 86281])
            ("edebug-var-status" function
               (:documentation "Return a cons cell describing the status of VAR's current binding.
The purpose of this function is so you can properly undo
subsequent changes to the same binding, by passing the status
cons cell to `edebug-restore-status'.  The status cons cell
has the form (LOCUS . VALUE), where LOCUS can be a buffer
(for a buffer-local binding), or nil (if the default binding is current)."
                :arguments ("var"))
                nil [86283 86755])
            ("edebug-restore-status" function
               (:documentation "Reset VAR based on STATUS.
STATUS should be a list returned by `edebug-var-status'."
                :arguments ("var" "status"))
                nil [86757 87162])
            ("edebug--enter-trace" function (:arguments ("function" "args" "body")) nil [87164 87492])
            ("def-edebug-spec" code nil nil [87494 87538])
            ("edebug-tracing" function
               (:documentation "Print MSG in *edebug-trace* before and after evaluating BODY.
The result of BODY is also printed."
                :arguments ("msg" "body"))
                nil [87540 87922])
            ("edebug-print-trace-before" function
               (:documentation "Function called to print trace info before expression evaluation.
MSG is printed after `::::{ '."
                :arguments ("msg"))
                nil [87924 88162])
            ("edebug-print-trace-after" function
               (:documentation "Function called to print trace info after expression evaluation.
MSG is printed after `::::} '."
                :arguments ("msg"))
                nil [88164 88400])
            ("edebug-slow-before" function (:arguments ("before-index")) nil [88404 88947])
            ("edebug-fast-before" function (:arguments ("_before-index")) nil [88949 89011])
            ("edebug-slow-after" function (:arguments ("_before-index" "after-index" "value")) nil [89013 89672])
            ("edebug-fast-after" function (:arguments ("_before-index" "_after-index" "value")) nil [89673 89779])
            ("edebug-run-slow" function (:documentation "Set up Edebug's normal behavior.") nil [89781 89965])
            ("edebug-run-fast" function (:documentation "Disable Edebug without de-instrumenting code.") nil [89993 90190])
            ("defalias" code nil nil [90192 90328])
            ("defalias" code nil nil [90329 90463])
            ("edebug--update-coverage" function (:arguments ("after-index" "value")) nil [90465 90825])
            ("edebug-breakpoints" variable nil nil [90871 90898])
            ("edebug-break-data" variable nil nil [90899 90925])
            ("edebug-break" variable nil nil [90961 90982])
            ("edebug-global-break" variable nil nil [91011 91039])
            ("edebug-break-condition" variable nil nil [91075 91106])
            ("edebug-break-result" variable nil nil [91149 91181])
            ("edebug-global-break-result" variable nil nil [91182 91221])
            ("edebug-debugger" function (:arguments ("offset-index" "arg-mode" "value")) nil [91224 92808])
            ("edebug-point" variable nil nil [93180 93201])
            ("edebug-outside-buffer" variable nil nil [93231 93261])
            ("edebug-outside-point" variable nil nil [93301 93330])
            ("edebug-outside-mark" variable nil nil [93361 93389])
            ("edebug-window-data" variable nil nil [93419 93446])
            ("edebug-outside-windows" variable nil nil [93495 93526])
            ("edebug-eval-buffer" variable nil nil [93558 93585])
            ("edebug-outside-d-c-i-n-s-w" variable nil nil [93613 93648])
            ("edebug-eval-list" variable nil nil [93699 93728])
            ("edebug-previous-result" variable nil nil [93766 93801])
            ("defalias" code nil nil [93877 93920])
            ("edebug--display" function (:arguments ("value" "offset-index" "arg-mode")) nil [93922 94199])
            ("edebug--display-1" function (:arguments ("value" "offset-index" "arg-mode")) nil [94201 104652])
            ("edebug-number-of-recursions" variable nil nil [104655 104693])
            ("edebug-recursion-depth" variable nil nil [104776 104809])
            ("edebug-outside-match-data" variable nil nil [104900 104934])
            ("edebug-backtrace-buffer" variable nil nil [104966 104998])
            ("edebug-inside-windows" variable nil nil [105034 105064])
            ("edebug-interactive-p" variable nil nil [105065 105094])
            ("edebug--recursive-edit" function (:arguments ("arg-mode")) nil [105096 108218])
            ("edebug-arrow-alist" variable
               (:documentation "Association list of arrows for each edebug mode."
                :constant-flag t
                :default-value '((Continue-fast . "=") (Trace-fast . "-") (continue . ">") (trace . "->") (step . "=>") (next . "=>") (go . "<>") (Go-nonstop . "..")))
                nil [108252 108505])
            ("edebug-overlay-arrow" function nil nil [108507 108937])
            ("edebug-toggle-save-all-windows" function
               (:documentation "Toggle the saving and restoring of all windows.
Also, each time you toggle it on, the inside and outside window
configurations become the same as the current configuration."
                :user-visible-flag t)
                nil [108940 109471])
            ("edebug-changing-windows" function (:arguments ("body")) nil [109473 109921])
            ("edebug-toggle-save-selected-window" function
               (:documentation "Toggle the saving and restoring of the selected window.
Also, each time you toggle it on, the inside and outside window
configurations become the same as the current configuration."
                :user-visible-flag t)
                nil [109923 110931])
            ("edebug-toggle-save-windows" function
               (:documentation "Toggle the saving and restoring of windows.
With prefix, toggle for just the selected window.
Otherwise, toggle for all windows."
                :user-visible-flag t
                :arguments ("arg"))
                nil [110933 111217])
            ("edebug-where" function
               (:documentation "Show the debug windows and where we stopped in the program."
                :user-visible-flag t)
                nil [111219 111644])
            ("edebug-view-outside" function
               (:documentation "Change to the outside window configuration.
Use `edebug-where' to return."
                :user-visible-flag t)
                nil [111646 112125])
            ("edebug-bounce-point" function
               (:documentation "Bounce the point in the outside current buffer.
If prefix argument ARG is supplied, sit for that many seconds
before returning.  The default is one second."
                :user-visible-flag t
                :arguments ("arg"))
                nil [112128 112901])
            ("edebug-display-buffer-list" variable (:documentation "List of buffers that edebug will display when it is active.") nil [113050 113153])
            ("edebug-display-buffer" function
               (:documentation "Toggle display of a buffer inside of edebug."
                :user-visible-flag t
                :arguments ("buffer"))
                nil [113156 113583])
            ("edebug-find-stop-point" function nil nil [113619 114773])
            ("edebug-next-breakpoint" function
               (:documentation "Move point to the next breakpoint, or first if none past point."
                :user-visible-flag t)
                nil [114776 115996])
            ("edebug-modify-breakpoint" function
               (:documentation "Modify the breakpoint for the form at point or after it.
Set it if FLAG is non-nil, clear it otherwise.  Then move to that point.
If CONDITION or TEMPORARY are non-nil, add those attributes to
the breakpoint."
                :arguments ("flag" "condition" "temporary"))
                nil [115999 117429])
            ("edebug-set-breakpoint" function
               (:documentation "Set the breakpoint of nearest sexp.
With prefix argument, make it a temporary breakpoint."
                :user-visible-flag t
                :arguments ("arg"))
                nil [117431 117619])
            ("edebug-unset-breakpoint" function
               (:documentation "Clear the breakpoint of nearest sexp."
                :user-visible-flag t)
                nil [117621 117746])
            ("edebug-set-global-break-condition" function
               (:documentation "Set `edebug-global-break-condition' to EXPRESSION."
                :user-visible-flag t
                :arguments ("expression"))
                nil [117749 118246])
            ("edebug-set-mode" function (:arguments ("mode" "shortmsg" "msg")) nil [118279 118689])
            ("defalias" code nil nil [118692 118746])
            ("edebug-step-mode" function
               (:documentation "Proceed to next stop point."
                :user-visible-flag t)
                nil [118748 118891])
            ("edebug-next-mode" function
               (:documentation "Proceed to next `after' stop point."
                :user-visible-flag t)
                nil [118893 119041])
            ("edebug-go-mode" function
               (:documentation "Go, evaluating until break.
With prefix ARG, set temporary break at current point and go."
                :user-visible-flag t
                :arguments ("arg"))
                nil [119043 119290])
            ("edebug-Go-nonstop-mode" function
               (:documentation "Go, evaluating without debugging.
You can use `edebug-stop', or any editing command, to stop."
                :user-visible-flag t)
                nil [119292 119526])
            ("edebug-trace-mode" function
               (:documentation "Begin trace mode.
Pauses for `edebug-sit-for-seconds' at each stop point."
                :user-visible-flag t)
                nil [119529 119723])
            ("edebug-Trace-fast-mode" function
               (:documentation "Trace with no wait at each step.
Updates the display at each stop point, but does not pause."
                :user-visible-flag t)
                nil [119725 119959])
            ("edebug-continue-mode" function
               (:documentation "Begin continue mode.
Pauses for `edebug-sit-for-seconds' at each break point."
                :user-visible-flag t)
                nil [119961 120175])
            ("edebug-Continue-fast-mode" function
               (:documentation "Trace with no wait at each step.
Updates the display at each break point, but does not pause."
                :user-visible-flag t)
                nil [120177 120428])
            ("edebug-goto-here" function
               (:documentation "Proceed to first stop-point at or after current position of point."
                :user-visible-flag t)
                nil [120561 120696])
            ("edebug-stop" function
               (:documentation "Stop execution and do not continue.
Useful for exiting from trace or continue loop."
                :user-visible-flag t)
                nil [120699 120844])
            ("edebug-forward" function
               (:documentation "Proceed to the exit of the next expression to be evaluated."
                :user-visible-flag t)
                nil [120848 121052])
            ("edebug-forward-sexp" function
               (:documentation "Proceed from the current point to the end of the ARGth sexp ahead.
If there are not ARG sexps ahead, then do `edebug-step-out'."
                :user-visible-flag t
                :arguments ("arg"))
                nil [121055 121445])
            ("edebug-step-out" function
               (:documentation "Proceed from the current point to the end of the containing sexp.
If there is no containing sexp that is not the top level defun,
go to the end of the last sexp, or if that is the same point, then step."
                :user-visible-flag t)
                nil [121447 122163])
            ("edebug-instrument-function" function
               (:documentation "Instrument the function or generic method FUNC.
Return the list of function symbols which were instrumented.
This may be simply (FUNC) for a normal function, or a list of
generated symbols for methods.  If a function or method to
instrument cannot be found, signal an error."
                :arguments ("func"))
                nil [122165 123772])
            ("edebug-instrument-callee" function
               (:documentation "Instrument the definition of the function or macro about to be called.
Do this when stopped before the form or it will be too late.
One side effect of using this command is that the next time the
function or macro is called, Edebug will be called there as well.
If the callee is a generic function, Edebug will instrument all
the methods, not just the one which is about to be called.  Return
the list of symbols which were instrumented."
                :user-visible-flag t)
                nil [123774 124573])
            ("edebug-step-in" function
               (:documentation "Step into the definition of the function, macro or method about to be called.
This first does `edebug-instrument-callee' to ensure that it is
instrumented.  Then it does `edebug-on-entry' and switches to `go' mode."
                :user-visible-flag t)
                nil [124576 125004])
            ("edebug-on-entry" function
               (:documentation "Cause Edebug to stop when FUNCTION is called.
With prefix argument, make this temporary so it is automatically
canceled the first time the function is entered."
                :user-visible-flag t
                :arguments ("function" "flag"))
                nil [125006 125364])
            ("cancel-edebug-on-entry" function (:arguments ("function")) nil [125366 125485])
            ("advice-add" code nil nil [125489 125549])
            ("edebug--debug-on-entry" function
               (:documentation "If the function is instrumented for Edebug, call `edebug-on-entry'."
                :arguments ("orig" "function"))
                nil [125617 125889])
            ("edebug-top-level-nonstop" function
               (:documentation "Set mode to Go-nonstop, and exit to top-level.
This is useful for exiting even if `unwind-protect' code may be executed."
                :user-visible-flag t)
                nil [125892 126125])
            ("edebug-initial-mode-alist" variable
               (:documentation "Association list between commands and the modes they set."
                :constant-flag t
                :default-value '((edebug-step-mode . step) (edebug-next-mode . next) (edebug-trace-mode . trace) (edebug-Trace-fast-mode . Trace-fast) (edebug-go-mode . go) (edebug-continue-mode . continue) (edebug-Continue-fast-mode . Continue-fast) (edebug-Go-nonstop-mode . Go-nonstop)))
                nil [126259 126646])
            ("edebug-mode-map" variable nil nil [126648 126672])
            ("edebug-set-initial-mode" function
               (:documentation "Set the initial execution mode of Edebug.
The mode is requested via the key that would be used to set the mode in
edebug-mode."
                :user-visible-flag t)
                nil [126706 127442])
            ("edebug-outside-excursion" function
               (:documentation "Evaluate an expression list in the outside context.
Return the result of the last expression."
                :arguments ("body"))
                nil [127475 129317])
            ("edebug-eval" function (:arguments ("expr")) nil [129319 129385])
            ("edebug-safe-eval" function (:arguments ("expr")) nil [129387 129688])
            ("edebug-report-error" function (:arguments ("value")) nil [129705 130205])
            ("print-readably" variable nil nil [130207 130230])
            ("edebug-safe-prin1-to-string" function (:arguments ("value")) nil [130365 130680])
            ("edebug-compute-previous-result" function (:arguments ("previous-value")) nil [130682 130979])
            ("edebug-previous-result" function
               (:documentation "Print the previous result."
                :user-visible-flag t)
                nil [130981 131101])
            ("defalias" code nil nil [131129 131184])
            ("defalias" code nil nil [131185 131227])
            ("defalias" code nil nil [131228 131264])
            ("edebug-eval-expression" function
               (:documentation "Evaluate an expression in the outside environment.
If interactive, prompt for the expression.
Print result in minibuffer."
                :user-visible-flag t
                :arguments ("expr"))
                nil [131266 131754])
            ("edebug-eval-last-sexp" function
               (:documentation "Evaluate sexp before point in the outside environment.
Print value in minibuffer."
                :user-visible-flag t)
                nil [131756 131936])
            ("edebug-eval-print-last-sexp" function
               (:documentation "Evaluate sexp before point in outside environment; insert value.
This prints the value into current buffer."
                :user-visible-flag t)
                nil [131938 132395])
            ("define-obsolete-variable-alias" code nil nil [132420 132531])
            ("edebug-inhibit-emacs-lisp-mode-bindings" variable (:documentation "If non-nil, inhibit Edebug bindings on the C-x C-a key.
By default, loading the `edebug' library causes these bindings to
be installed in `emacs-lisp-mode-map'.") nil [132533 132750])
            ("unless" code nil nil [132808 133237])
            ("edebug-mode-map" variable (:default-value (let ((map (copy-keymap emacs-lisp-mode-map))) (define-key map " " 'edebug-step-mode) (define-key map "n" 'edebug-next-mode) (define-key map "g" 'edebug-go-mode) (define-key map "G" 'edebug-Go-nonstop-mode) (define-key map "t" 'edebug-trace-mode) (define-key map "T" 'edebug-Trace-fast-mode) (define-key map "c" 'edebug-continue-mode) (define-key map "C" 'edebug-Continue-fast-mode) (define-key map "f" 'edebug-forward-sexp) (define-key map "h" 'edebug-goto-here) (define-key map "I" 'edebug-instrument-callee) (define-key map "i" 'edebug-step-in) (define-key map "o" 'edebug-step-out) (define-key map "q" 'top-level) (define-key map "Q" 'edebug-top-level-nonstop) (define-key map "a" 'abort-recursive-edit) (define-key map "S" 'edebug-stop) (define-key map "b" 'edebug-set-breakpoint) (define-key map "u" 'edebug-unset-breakpoint) (define-key map "B" 'edebug-next-breakpoint) (define-key map "x" 'edebug-set-conditional-breakpoint) (define-key map "X" 'edebug-set-global-break-condition) (define-key map "r" 'edebug-previous-result) (define-key map "e" 'edebug-eval-expression) (define-key map "" 'edebug-eval-last-sexp) (define-key map "E" 'edebug-visit-eval-list) (define-key map "w" 'edebug-where) (define-key map "v" 'edebug-view-outside) (define-key map "p" 'edebug-bounce-point) (define-key map "P" 'edebug-view-outside) (define-key map "W" 'edebug-toggle-save-windows) (define-key map "?" 'edebug-help) (define-key map "d" 'edebug-pop-to-backtrace) (define-key map "-" 'negative-argument) (define-key map "=" 'edebug-temp-display-freq-count) (define-key map "" 'edebug-step-mode) (define-key map "" 'edebug-next-mode) (define-key map "" 'edebug-go-mode) (define-key map " " 'edebug-set-breakpoint) (define-key map "" 'edebug-unset-breakpoint) (define-key map "" (lambda nil (interactive) (edebug-set-breakpoint t))) (define-key map "" 'edebug-where) map)) nil [133239 135612])
            ("global-edebug-prefix" variable
               (:documentation "Prefix key for global edebug commands, available from any buffer."
                :default-value "X")
                nil [135753 135859])
            ("global-edebug-map" variable
               (:documentation "Global map of edebug commands, available from any buffer."
                :default-value (let ((map (make-sparse-keymap))) (define-key map " " 'edebug-step-mode) (define-key map "g" 'edebug-go-mode) (define-key map "G" 'edebug-Go-nonstop-mode) (define-key map "t" 'edebug-trace-mode) (define-key map "T" 'edebug-Trace-fast-mode) (define-key map "c" 'edebug-continue-mode) (define-key map "C" 'edebug-Continue-fast-mode) (define-key map "b" 'edebug-set-breakpoint) (define-key map "u" 'edebug-unset-breakpoint) (define-key map "x" 'edebug-set-conditional-breakpoint) (define-key map "X" 'edebug-set-global-break-condition) (define-key map "w" 'edebug-where) (define-key map "W" 'edebug-toggle-save-windows) (define-key map "q" 'top-level) (define-key map "Q" 'edebug-top-level-nonstop) (define-key map "a" 'abort-recursive-edit) (define-key map "=" 'edebug-display-freq-count) map))
                nil [135861 136886])
            ("global-unset-key" code nil nil [136888 136927])
            ("global-set-key" code nil nil [136928 136983])
            ("edebug-help" function
               (:documentation "Describe `edebug-mode'."
                :user-visible-flag t)
                nil [136986 137087])
            ("edebug--mode-saved-vars" variable nil nil [137089 137125])
            ("define-minor-mode" code nil nil [137127 139059])
            ("edebug-kill-buffer" function (:documentation "Used on `kill-buffer-hook' when Edebug is operating in a buffer of Lisp code.") nil [139061 139209])
            ("edebug-eval-result-list" function (:documentation "Return a list of evaluations of `edebug-eval-list'.") nil [139312 139591])
            ("edebug-eval-display-list" function (:arguments ("eval-result-list")) nil [139593 140060])
            ("edebug-create-eval-buffer" function nil nil [140062 140264])
            ("edebug-eval-display" function
               (:documentation "Display expressions and evaluations in EVAL-RESULT-LIST.
It modifies the context by popping up the eval display."
                :arguments ("eval-result-list"))
                nil [140386 140655])
            ("edebug-eval-redisplay" function (:documentation "Redisplay eval list in outside environment.
May only be called from within `edebug--recursive-edit'.") nil [140657 140913])
            ("edebug-visit-eval-list" function
               (:documentation "Switch to the evaluation list buffer \"*edebug*\"."
                :user-visible-flag t)
                nil [140915 141089])
            ("edebug-update-eval-list" function
               (:documentation "Replace the evaluation list with the sexps now in the eval buffer."
                :user-visible-flag t)
                nil [141092 141785])
            ("edebug-delete-eval-item" function
               (:documentation "Delete the item under point and redisplay."
                :user-visible-flag t)
                nil [141788 142127])
            ("edebug-eval-mode-map" variable
               (:documentation "Keymap for Edebug Eval mode.  Superset of Lisp Interaction mode."
                :default-value (let ((map (make-sparse-keymap))) (set-keymap-parent map lisp-interaction-mode-map) (define-key map "" 'edebug-where) (define-key map "" 'edebug-delete-eval-item) (define-key map "" 'edebug-update-eval-list) (define-key map "" 'edebug-eval-last-sexp) (define-key map "
" 'edebug-eval-print-last-sexp) map))
                nil [142131 142600])
            ("put" code nil nil [142602 142646])
            ("define-derived-mode" code nil nil [142648 143165])
            ("edebug" function
               (:documentation "Replacement for `debug'.
If we are running an edebugged function, show where we last were.
Otherwise call `debug' normally."
                :arguments ("arg-mode" "args"))
                nil [143602 144598])
            ("defvar-local" code nil nil [144622 144796])
            ("defvar-local" code nil nil [144797 144981])
            ("cl-defstruct" code nil nil [145094 145235])
            ("edebug-pop-to-backtrace" function
               (:documentation "Display the current backtrace in a `backtrace-mode' window."
                :user-visible-flag t)
                nil [145237 146161])
            ("edebug--strip-instrumentation" function
               (:documentation "Return a new list of backtrace frames with instrumentation removed.
Remove frames for Edebug's functions and the lambdas in
`edebug-enter' wrappers.  Fill in the def-name, before-index
and after-index fields in both FRAMES and the returned list
of deinstrumented frames, for those frames where the source
code location is known."
                :arguments ("frames"))
                nil [146163 147973])
            ("edebug--symbol-not-prefixed-p" function
               (:documentation "Return non-nil if SYM is a symbol not prefixed by \"edebug-\"."
                :arguments ("sym"))
                nil [147975 148166])
            ("edebug--unwrap-frame" function
               (:documentation "Remove Edebug's instrumentation from FRAME.
Strip it from the function and any unevaluated arguments."
                :arguments ("frame"))
                nil [148168 148598])
            ("edebug--add-source-info" function
               (:documentation "Update FRAME with the additional info needed by an edebug--frame.
Save DEF-NAME, BEFORE-INDEX and AFTER-INDEX in FRAME."
                :arguments ("frame" "def-name" "before-index" "after-index"))
                nil [148600 149160])
            ("edebug--backtrace-goto-source" function nil nil [149162 149637])
            ("edebug-backtrace-show-instrumentation" function
               (:documentation "Show Edebug's instrumentation in an Edebug Backtrace buffer."
                :user-visible-flag t)
                nil [149639 149923])
            ("edebug-backtrace-hide-instrumentation" function
               (:documentation "Hide Edebug's instrumentation in an Edebug Backtrace buffer."
                :user-visible-flag t)
                nil [149925 150183])
            ("edebug-trace-display" function
               (:documentation "In buffer BUF-NAME, display FMT and ARGS at the end and make it visible.
The buffer is created if it does not exist.
You must include newlines in FMT to break lines, but one newline is appended."
                :arguments ("buf-name" "fmt" "args"))
                nil [150205 151288])
            ("edebug-trace" function
               (:documentation "Convenience call to `edebug-trace-display' using `edebug-trace-buffer'."
                :arguments ("fmt" "args"))
                nil [151291 151466])
            ("edebug-display-freq-count" function
               (:documentation "Display the frequency count data for each line of the current definition.
The frequency counts are inserted as comment lines after each line,
and you can undo all insertions with one `undo' command.

The counts are inserted starting under the `(' before an expression
or the `)' after an expression, or on the last char of a symbol.
The counts are only displayed when they differ from previous counts on
the same line.

If coverage is being tested, whenever all known results of an expression
are `eq', the char `=' will be appended after the count
for that expression.  Note that this is always the case for an
expression only evaluated once.

To clear the frequency count and coverage data for a definition,
reinstrument it."
                :user-visible-flag t)
                nil [151647 154040])
            ("edebug-temp-display-freq-count" function
               (:documentation "Temporarily display the frequency count data for the current definition.
It is removed when you hit any char."
                :user-visible-flag t)
                nil [154181 154661])
            ("edebug-toggle" function (:arguments ("variable")) nil [154676 154809])
            ("easymenu" include nil nil [154928 154947])
            ("edebug-mode-menus" variable
               (:documentation "Menus for Edebug."
                :constant-flag t
                :default-value '("Edebug" ["Stop" edebug-stop t] ["Step" edebug-step-mode t] ["Next" edebug-next-mode t] ["Trace" edebug-trace-mode t] ["Trace Fast" edebug-Trace-fast-mode t] ["Continue" edebug-continue-mode t] ["Continue Fast" edebug-Continue-fast-mode t] ["Go" edebug-go-mode t] ["Go Nonstop" edebug-Go-nonstop-mode t] "----" ["Help" edebug-help t] ["Abort" abort-recursive-edit t] ["Quit to Top Level" top-level t] ["Quit Nonstop" edebug-top-level-nonstop t] "----" ("Jumps" ["Forward Sexp" edebug-forward-sexp t] ["Step In" edebug-step-in t] ["Step Out" edebug-step-out t] ["Goto Here" edebug-goto-here t]) ("Breaks" ["Set Breakpoint" edebug-set-breakpoint t] ["Unset Breakpoint" edebug-unset-breakpoint t] ["Set Conditional Breakpoint" edebug-set-conditional-breakpoint t] ["Set Global Break Condition" edebug-set-global-break-condition t] ["Show Next Breakpoint" edebug-next-breakpoint t]) ("Views" ["Where am I?" edebug-where t] ["Bounce to Current Point" edebug-bounce-point t] ["View Outside Windows" edebug-view-outside t] ["Previous Result" edebug-previous-result t] ["Show Backtrace" edebug-pop-to-backtrace t] ["Display Freq Count" edebug-display-freq-count t]) ("Eval" ["Expression" edebug-eval-expression t] ["Last Sexp" edebug-eval-last-sexp t] ["Visit Eval List" edebug-visit-eval-list t]) ("Options" ["Edebug All Defs" edebug-all-defs :style toggle :selected edebug-all-defs] ["Edebug All Forms" edebug-all-forms :style toggle :selected edebug-all-forms] "----" ["Tracing" (edebug-toggle 'edebug-trace) :style toggle :selected edebug-trace] ["Test Coverage" (edebug-toggle 'edebug-test-coverage) :style toggle :selected edebug-test-coverage] ["Save Windows" edebug-toggle-save-windows :style toggle :selected edebug-save-windows] ["Save Point" (edebug-toggle 'edebug-save-displayed-buffer-points) :style toggle :selected edebug-save-displayed-buffer-points])))
                nil [154949 157137])
            ("defalias" code nil nil [157174 157221])
            ("edebug-mark" function nil nil [157223 157256])
            ("edebug-set-conditional-breakpoint" function
               (:documentation "Set a conditional breakpoint at nearest sexp.
The condition is evaluated in the outside context.
With prefix argument, make it a temporary breakpoint."
                :user-visible-flag t
                :arguments ("arg" "condition"))
                nil [157258 158351])
            ("easy-menu-define" code nil nil [158353 158432])
            ("edebug--require-cl-read" function nil nil [158543 158605])
            ("if" code nil nil [158607 158830])
            ("add-hook" code nil nil [159086 159176])
            ("edebug--called-interactively-skip" function (:arguments ("i" "frame1" "frame2")) nil [159177 159546])
            ("edebug-install-read-eval-functions" code nil nil [159700 159736])
            ("edebug-unload-function" function (:documentation "Unload the Edebug source level debugger.") nil [159738 160294])
            ("edebug" package nil nil [160296 160313]))          
      :file "edebug.el.gz"
      :pointmax 160338
      :fsize 42792
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax '((punctuation 125616 . 125617) (punctuation 125488 . 125489) (punctuation 120847 . 120848) (punctuation 113155 . 113156) (punctuation 113049 . 113050) (punctuation 11142 . 11143) (punctuation 10715 . 10716) (close-paren 2031 . 2032) (symbol 1997 . 2014) (open-paren 1996 . 1997)))
    (semanticdb-table "semanticdb-table-1e6e3d4"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("backquote" package nil nil [1392 1412])
            ("backquote-list*-function" function
               (:documentation "Like `list' but the last argument is the tail of the new list.

For example (backquote-list* \\='a \\='b \\='c) => (a b . c)"
                :arguments ("first" "list"))
                nil [1465 2060])
            ("backquote-list*-macro" function
               (:documentation "Like `list' but the last argument is the tail of the new list.

For example (backquote-list* \\='a \\='b \\='c) => (a b . c)"
                :arguments ("first" "list"))
                nil [2062 2724])
            ("defalias" code nil nil [2726 2794])
            ("backquote-backquote-symbol" variable
               (:documentation "Symbol used to represent a backquote or nested backquote."
                :constant-flag t
                :default-value '\`)
                nil [2925 3028])
            ("backquote-unquote-symbol" variable
               (:documentation "Symbol used to represent an unquote inside a backquote."
                :constant-flag t
                :default-value '\,)
                nil [3030 3129])
            ("backquote-splice-symbol" variable
               (:documentation "Symbol used to represent a splice inside a backquote."
                :constant-flag t
                :default-value '\,@)
                nil [3131 3228])
            ("backquote" function
               (:documentation "Argument STRUCTURE describes a template to build.

The whole structure acts as if it were quoted except for certain
places where expressions are evaluated and inserted or spliced in.

For example:

b              => (ba bb bc)		; assume b has this value
\\=`(a b c)       => (a b c)		; backquote acts like quote
\\=`(a ,b c)      => (a (ba bb bc) c)	; insert the value of b
\\=`(a ,@b c)     => (a ba bb bc c)	; splice in the value of b

Vectors work just like lists.  Nested backquotes are permitted."
                :arguments ("structure"))
                nil [3230 3806])
            ("defalias" code nil nil [3843 3886])
            ("backquote-delay-process" function
               (:documentation "Process a (un|back|splice)quote inside a backquote.
This simply recurses through the body."
                :arguments ("s" "level"))
                nil [4132 4459])
            ("backquote-process" function
               (:documentation "Process the body of a backquote.
S is the body.  Returns a cons cell whose cdr is piece of code which
is the macro-expansion of S, and whose car is a small integer whose value
can either indicate that the code is constant (0), or not (1), or returns
a list which should be spliced into its environment (2).
LEVEL is only used internally and indicates the nesting level:
0 (the default) is for the toplevel nested inside a single backquote."
                :arguments ("s" "level"))
                nil [4461 8238])
            ("backquote-listify" function (:arguments ("list" "old-tail")) nil [8422 9197])
            ("put" code nil nil [9276 9364])
            ("put" code nil nil [9365 9394])
            ("put" code nil nil [9396 9471])
            ("put" code nil nil [9472 9502]))          
      :file "backquote.el.gz"
      :pointmax 9531
      :fsize 3413
      :lastmodtime '(23443 29219 0 0)
      :unmatched-syntax nil))
  :file "!usr!local!share!emacs!27.0.50!lisp!emacs-lisp!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
