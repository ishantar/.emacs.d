;; Object semanticdb-project-database-file-145c688
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file-145c688"
  :tables
  (list
    (semanticdb-table "semanticdb-table-142c0a8"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("paredit-mode" variable nil nil [2342 2363])
            ("paredit-version" variable nil nil [2315 2339])
            ("paredit-space-for-delimiter-predicates" variable nil nil [2265 2312])
            ("font-lock-end" variable nil nil [2240 2262])
            ("font-lock-beg" variable nil nil [2215 2237])
            ("calculate-lisp-indent-last-sexp" variable nil nil [2172 2212])
            ("cl-lib" include nil nil [2366 2383])
            ("imenu" include nil nil [2384 2400])
            ("newcomment" include nil nil [2401 2422])
            ("align" include nil nil [2423 2439])
            ("subr-x" include nil nil [2440 2457])
            ("declare-function" code nil nil [2459 2530])
            ("clojure" customgroup
               (:documentation "Major mode for editing Clojure code."
                :user-visible-flag t)
                nil [2532 2784])
            ("clojure-mode-version" variable
               (:documentation "The current version of `clojure-mode'."
                :constant-flag t
                :default-value "5.8.2")
                nil [2786 2868])
            ("clojure-keyword-face" variable
               (:documentation "Face used to font-lock Clojure keywords (:something)."
                :default-value '((t (:inherit font-lock-constant-face)))
                :type "face")
                nil [2870 3047])
            ("clojure-character-face" variable
               (:documentation "Face used to font-lock Clojure character literals."
                :default-value '((t (:inherit font-lock-string-face)))
                :type "face")
                nil [3049 3223])
            ("clojure-indent-style" variable
               (:documentation "Indentation style to use for function forms and macro forms.
There are two cases of interest configured by this variable.

- Case (A) is when at least one function argument is on the same
  line as the function name.
- Case (B) is the opposite (no arguments are on the same line as
  the function name).  Note that the body of macros is not
  affected by this variable, it is always indented by
  `lisp-body-indent' (default 2) spaces.

Note that this variable configures the indentation of function
forms (and function-like macros), it does not affect macros that
already use special indentation rules.

The possible values for this variable are keywords indicating how
to indent function forms.

    `:always-align' - Follow the same rules as `lisp-mode'.  All
    args are vertically aligned with the first arg in case (A),
    and vertically aligned with the function name in case (B).
    For instance:
        (reduce merge
                some-coll)
        (reduce
         merge
         some-coll)

    `:always-indent' - All args are indented like a macro body.
        (reduce merge
          some-coll)
        (reduce
          merge
          some-coll)

    `:align-arguments' - Case (A) is indented like `lisp', and
    case (B) is indented like a macro body.
        (reduce merge
                some-coll)
        (reduce
          merge
          some-coll)"
                :default-value :always-align)
                nil [3225 4992])
            ("define-obsolete-variable-alias" code nil nil [4994 5094])
            ("clojure-use-backtracking-indent" variable
               (:documentation "When non-nil, enable context sensitive indentation."
                :default-value t)
                nil [5096 5232])
            ("clojure-max-backtracking" variable
               (:documentation "Maximum amount to backtrack up a list to check for context."
                :default-value 3)
                nil [5234 5371])
            ("clojure-docstring-fill-column" variable
               (:documentation "Value of `fill-column' to use when filling a docstring."
                :default-value fill-column)
                nil [5373 5521])
            ("clojure-docstring-fill-prefix-width" variable
               (:documentation "Width of `fill-prefix' when filling a docstring.
The default value conforms with the de facto convention for
Clojure docstrings, aligning the second line with the opening
double quotes on the third column."
                :default-value 2)
                nil [5523 5817])
            ("clojure-omit-space-between-tag-and-delimiters" variable
               (:documentation "Allowed opening delimiter characters after a reader literal tag.
For example, [ is allowed in :db/id[:db.part/user]."
                :default-value '(91 123 40))
                nil [5819 6254])
            ("clojure-build-tool-files" variable
               (:documentation "A list of files, which identify a Clojure project's root.
Out-of-the box `clojure-mode' understands lein, boot, gradle,
 shadow-cljs and tools.deps."
                :default-value '("project.clj" "build.boot" "build.gradle" "deps.edn" "shadow-cljs.edn"))
                nil [6256 6803])
            ("clojure-project-root-function" variable
               (:documentation "Function to locate clojure project root directory."
                :default-value nil)
                nil [6805 7003])
            ("clojure-refactor-map-prefix" variable
               (:documentation "Clojure refactor keymap prefix."
                :default-value (kbd "C-c C-r"))
                nil [7005 7157])
            ("clojure-refactor-map" variable
               (:documentation "Keymap for Clojure refactoring commands."
                :default-value (let ((map (make-sparse-keymap))) (define-key map (kbd "C-t") #'clojure-thread) (define-key map (kbd "t") #'clojure-thread) (define-key map (kbd "C-u") #'clojure-unwind) (define-key map (kbd "u") #'clojure-unwind) (define-key map (kbd "C-f") #'clojure-thread-first-all) (define-key map (kbd "f") #'clojure-thread-first-all) (define-key map (kbd "C-l") #'clojure-thread-last-all) (define-key map (kbd "l") #'clojure-thread-last-all) (define-key map (kbd "C-a") #'clojure-unwind-all) (define-key map (kbd "a") #'clojure-unwind-all) (define-key map (kbd "C-p") #'clojure-cycle-privacy) (define-key map (kbd "p") #'clojure-cycle-privacy) (define-key map (kbd "C-(") #'clojure-convert-collection-to-list) (define-key map (kbd "(") #'clojure-convert-collection-to-list) (define-key map (kbd "C-'") #'clojure-convert-collection-to-quoted-list) (define-key map (kbd "'") #'clojure-convert-collection-to-quoted-list) (define-key map (kbd "C-{") #'clojure-convert-collection-to-map) (define-key map (kbd "{") #'clojure-convert-collection-to-map) (define-key map (kbd "C-[") #'clojure-convert-collection-to-vector) (define-key map (kbd "[") #'clojure-convert-collection-to-vector) (define-key map (kbd "C-#") #'clojure-convert-collection-to-set) (define-key map (kbd "#") #'clojure-convert-collection-to-set) (define-key map (kbd "C-i") #'clojure-cycle-if) (define-key map (kbd "i") #'clojure-cycle-if) (define-key map (kbd "C-w") #'clojure-cycle-when) (define-key map (kbd "w") #'clojure-cycle-when) (define-key map (kbd "C-o") #'clojure-cycle-not) (define-key map (kbd "o") #'clojure-cycle-not) (define-key map (kbd "n i") #'clojure-insert-ns-form) (define-key map (kbd "n h") #'clojure-insert-ns-form-at-point) (define-key map (kbd "n u") #'clojure-update-ns) (define-key map (kbd "n s") #'clojure-sort-ns) (define-key map (kbd "s i") #'clojure-introduce-let) (define-key map (kbd "s m") #'clojure-move-to-let) (define-key map (kbd "s f") #'clojure-let-forward-slurp-sexp) (define-key map (kbd "s b") #'clojure-let-backward-slurp-sexp) map))
                nil [7159 9416])
            ("fset" code nil nil [9417 9466])
            ("clojure-mode-map" variable
               (:documentation "Keymap for Clojure mode."
                :default-value (let ((map (make-sparse-keymap))) (set-keymap-parent map prog-mode-map) (define-key map (kbd "C-:") #'clojure-toggle-keyword-string) (define-key map (kbd "C-c SPC") #'clojure-align) (define-key map clojure-refactor-map-prefix 'clojure-refactor-map) (easy-menu-define clojure-mode-menu map "Clojure Mode Menu" '("Clojure" ["Toggle between string & keyword" clojure-toggle-keyword-string] ["Align expression" clojure-align] ["Cycle privacy" clojure-cycle-privacy] ["Cycle if, if-not" clojure-cycle-if] ["Cycle when, when-not" clojure-cycle-when] ["Cycle not" clojure-cycle-not] ("ns forms" ["Insert ns form at the top" clojure-insert-ns-form] ["Insert ns form here" clojure-insert-ns-form-at-point] ["Update ns form" clojure-update-ns] ["Sort ns form" clojure-sort-ns]) ("Convert collection" ["Convert to list" clojure-convert-collection-to-list] ["Convert to quoted list" clojure-convert-collection-to-quoted-list] ["Convert to map" clojure-convert-collection-to-map] ["Convert to vector" clojure-convert-collection-to-vector] ["Convert to set" clojure-convert-collection-to-set]) ("Refactor -> and ->>" ["Thread once more" clojure-thread] ["Fully thread a form with ->" clojure-thread-first-all] ["Fully thread a form with ->>" clojure-thread-last-all] "--" ["Unwind once" clojure-unwind] ["Fully unwind a threading macro" clojure-unwind-all]) ("Let expression" ["Introduce let" clojure-introduce-let] ["Move to let" clojure-move-to-let] ["Forward slurp form into let" clojure-let-forward-slurp-sexp] ["Backward slurp form into let" clojure-let-backward-slurp-sexp]) ("Documentation" ["View a Clojure guide" clojure-view-guide] ["View a Clojure reference section" clojure-view-reference-section] ["View the Clojure cheatsheet" clojure-view-cheatsheet] ["View the Clojure Grimoire" clojure-view-grimoire] ["View the Clojure style guide" clojure-view-style-guide]) "--" ["Report a clojure-mode bug" clojure-mode-report-bug] ["Clojure-mode version" clojure-mode-display-version])) map))
                nil [9468 11865])
            ("clojure-mode-syntax-table" variable
               (:documentation "Syntax table for Clojure mode.
Inherits from `emacs-lisp-mode-syntax-table'."
                :default-value (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table))) (modify-syntax-entry 123 "(}" table) (modify-syntax-entry 125 "){" table) (modify-syntax-entry 91 "(]" table) (modify-syntax-entry 93 ")[" table) (modify-syntax-entry 63 "_ p" table) (modify-syntax-entry 35 "_ p" table) (modify-syntax-entry 126 "'" table) (modify-syntax-entry 94 "'" table) (modify-syntax-entry 64 "'" table) table))
                nil [11867 12492])
            ("clojure--prettify-symbols-alist" variable
               (:constant-flag t
                :default-value '(("fn" . 955)))
                nil [12494 12554])
            ("defvar-local" code nil nil [12556 12854])
            ("clojure-mode-display-version" function
               (:documentation "Display the current `clojure-mode-version' in the minibuffer."
                :user-visible-flag t)
                nil [12856 13038])
            ("clojure-mode-report-bug-url" variable
               (:documentation "The URL to report a `clojure-mode' issue."
                :constant-flag t
                :default-value "https://github.com/clojure-emacs/clojure-mode/issues/new")
                nil [13040 13183])
            ("clojure-mode-report-bug" function
               (:documentation "Report a bug in your default browser."
                :user-visible-flag t)
                nil [13185 13320])
            ("clojure-guides-base-url" variable
               (:documentation "The base URL for official Clojure guides."
                :constant-flag t
                :default-value "https://clojure.org/guides/")
                nil [13322 13432])
            ("clojure-guides" variable
               (:documentation "A list of all official Clojure guides."
                :constant-flag t
                :default-value '(("Getting Started" . "getting_started") ("FAQ" . "faq") ("spec" . "spec") ("Destructuring" . "destructuring") ("Threading Macros" . "threading_macros") ("Comparators" . "comparators") ("Reader Conditionals" . "reader_conditionals")))
                nil [13434 13899])
            ("clojure-view-guide" function
               (:documentation "Open a Clojure guide in your default browser.

The command will prompt you to select one of the available guides."
                :user-visible-flag t)
                nil [13901 14291])
            ("clojure-reference-base-url" variable
               (:documentation "The base URL for the official Clojure reference."
                :constant-flag t
                :default-value "https://clojure.org/reference/")
                nil [14293 14416])
            ("clojure-reference-sections" variable
               (:constant-flag t
                :default-value '(("The Reader" . "reader") ("The REPL and main" . "repl_and_main") ("Evaluation" . "evaluation") ("Special Forms" . "special_forms") ("Macros" . "macros") ("Other Functions" . "other_functions") ("Data Structures" . "data_structures") ("Datatypes" . "datatypes") ("Sequences" . "sequences") ("Transients" . "transients") ("Transducers" . "transducers") ("Multimethods and Hierarchies" . "multimethods") ("Protocols" . "protocols") ("Metadata" . "metadata") ("Namespaces" . "namespaces") ("Libs" . "libs") ("Vars and Environments" . "vars") ("Refs and Transactions" . "refs") ("Agents" . "agents") ("Atoms" . "atoms") ("Reducers" . "reducers") ("Java Interop" . "java_interop") ("Compilation and Class Generation" . "compilation") ("Other Libraries" . "other_libraries") ("Differences with Lisps" . "lisps")))
                nil [14418 16200])
            ("clojure-view-reference-section" function
               (:documentation "Open a Clojure reference section in your default browser.

The command will prompt you to select one of the available sections."
                :user-visible-flag t)
                nil [16202 16667])
            ("clojure-cheatsheet-url" variable
               (:documentation "The URL of the official Clojure cheatsheet."
                :constant-flag t
                :default-value "http://clojure.org/api/cheatsheet")
                nil [16669 16786])
            ("clojure-view-cheatsheet" function
               (:documentation "Open the Clojure cheatsheet in your default browser."
                :user-visible-flag t)
                nil [16788 16933])
            ("clojure-grimoire-url" variable
               (:documentation "The URL of the Grimoire community documentation site."
                :constant-flag t
                :default-value "https://www.conj.io/")
                nil [16935 17047])
            ("clojure-view-grimoire" function
               (:documentation "Open the Clojure Grimoire in your default browser."
                :user-visible-flag t)
                nil [17049 17188])
            ("clojure-style-guide-url" variable
               (:documentation "The URL of the Clojure style guide."
                :constant-flag t
                :default-value "https://github.com/bbatsov/clojure-style-guide")
                nil [17190 17313])
            ("clojure-view-style-guide" function
               (:documentation "Open the Clojure style guide in your default browser."
                :user-visible-flag t)
                nil [17315 17463])
            ("clojure-space-for-delimiter-p" function
               (:documentation "Prevent paredit from inserting useless spaces.
See `paredit-space-for-delimiter-predicates' for the meaning of
ENDP and DELIM."
                :arguments ("endp" "delim"))
                nil [17465 18208])
            ("clojure--collection-tag-regexp" variable
               (:documentation "Collection reader macro tag regexp.
It is intended to check for allowed strings that can come before a
collection literal (e.g. '[]' or '{}'), as reader macro tags.
This includes #fully.qualified/my-ns[:kw val] and #::my-ns{:kw
val} as of Clojure 1.9."
                :constant-flag t
                :default-value "#\\(::[a-zA-Z0-9._-]*\\|:?\\([a-zA-Z0-9._-]+/\\)?[a-zA-Z0-9._-]+\\)")
                nil [18210 18579])
            ("clojure-no-space-after-tag" function
               (:documentation "Prevent inserting a space after a reader-literal tag.

When a reader-literal tag is followed be an opening delimiter
listed in `clojure-omit-space-between-tag-and-delimiters', this
function returns t.

This allows you to write things like #db/id[:db.part/user]
and #::my-ns{:some \"map\"} without inserting a space between
the tag and the opening bracket.

See `paredit-space-for-delimiter-predicates' for the meaning of
ENDP and DELIMITER."
                :arguments ("endp" "delimiter"))
                nil [18581 19465])
            ("declare-function" code nil nil [19467 19518])
            ("declare-function" code nil nil [19519 19571])
            ("declare-function" code nil nil [19572 19627])
            ("clojure--replace-let-bindings-and-indent" function
               (:documentation "Advise ORIG-FUN to replace let bindings.

Sexps are replace by their bound name if a let form was
convoluted.

ORIG-FUN should be `paredit-convolute-sexp'.

ARGS are passed to ORIG-FUN, as with all advice."
                :arguments ("orig-fun" "args"))
                nil [19629 20050])
            ("clojure-paredit-setup" function
               (:documentation "Make \"paredit-mode\" play nice with `clojure-mode'.

If an optional KEYMAP is passed the changes are applied to it,
instead of to `clojure-mode-map'.
Also advice `paredit-convolute-sexp' when used on a let form as drop in
replacement for `cljr-expand-let`."
                :arguments ("keymap"))
                nil [20052 20850])
            ("clojure-mode-variables" function (:documentation "Set up initial buffer-local variables for Clojure mode.") nil [20852 22450])
            ("clojure-in-docstring-p" function (:documentation "Check whether point is in a docstring.") nil [22452 22745])
            ("define-derived-mode" code nil nil [22762 23329])
            ("clojure-verify-major-mode" variable
               (:documentation "If non-nil, warn when activating the wrong `major-mode'."
                :default-value t)
                nil [23331 23510])
            ("clojure--check-wrong-major-mode" function (:documentation "Check if the current `major-mode' matches the file extension.

If it doesn't, issue a warning if `clojure-verify-major-mode' is
non-nil.") nil [23512 24779])
            ("add-hook" code nil nil [24781 24844])
            ("clojure-docstring-fill-prefix" function (:documentation "The prefix string used by `clojure-fill-paragraph'.
It is simply `clojure-docstring-fill-prefix-width' number of spaces.") nil [24846 25069])
            ("clojure-adaptive-fill-function" function (:documentation "Clojure adaptive fill function.
This only takes care of filling docstring correctly.") nil [25071 25271])
            ("clojure-fill-paragraph" function
               (:documentation "Like `fill-paragraph', but can handle Clojure docstrings.
If JUSTIFY is non-nil, justify as well as fill the paragraph."
                :arguments ("justify"))
                nil [25273 26607])
            ("clojure-auto-fill-function" function (:documentation "Clojure auto-fill function.") nil [26609 27039])
            ("clojure--comment-macro-regexp" variable
               (:documentation "Regexp matching the start of a comment sexp.
The beginning of match-group 1 should be before the sexp to be
marked as a comment.  The end of sexp is found with
`clojure-forward-logical-sexp'."
                :default-value (rx "#_" (* " ") (group-n 1 (not (any " ")))))
                nil [27191 27473])
            ("clojure--reader-and-comment-regexp" variable
               (:documentation "Regexp matching both `#_' macro and a comment sexp."
                :default-value "#_ *\\(?1:[^ ]\\)\\|\\(?1:(comment\\_>\\)")
                nil [27475 27621])
            ("clojure-comment-regexp" variable
               (:documentation "Comment mode.

The possible values for this variable are keywords indicating
what is considered a comment (affecting font locking).

    - Reader macro `#_' only - the default
    - Reader macro `#_' and `(comment)'"
                :default-value clojure--comment-macro-regexp)
                nil [27623 28139])
            ("clojure--search-comment-macro-internal" function
               (:documentation "Search for a comment forward stopping at LIMIT."
                :arguments ("limit"))
                nil [28141 28744])
            ("clojure--search-comment-macro" function
               (:documentation "Find comment macros and set the match data.
Search from point up to LIMIT.  The region that should be
considered a comment is between `(match-beginning 1)'
and `(match-end 1)'."
                :arguments ("limit"))
                nil [28746 29246])
            ("clojure-match-next-def" function (:documentation "Scans the buffer backwards for the next \"top-level\" definition.
Called by `imenu--generic-function'.") nil [29275 30503])
            ("clojure--sym-regexp" variable
               (:documentation "A regexp matching a Clojure symbol or namespace alias.
Matches the rule `clojure--sym-forbidden-1st-chars' followed by
any number of matches of `clojure--sym-forbidden-rest-chars'."
                :constant-flag t
                :default-value (concat "[^" clojure--sym-forbidden-1st-chars "][^" clojure--sym-forbidden-rest-chars "]*"))
                nil [31046 31359])
            ("clojure--sym-forbidden-1st-chars" variable
               (:documentation "A list of chars that a Clojure symbol cannot start with.
See the for-loop: URL `http://git.io/vRGTj' lines: URL
`http://git.io/vRGIh', URL `http://git.io/vRGLE' and value
definition of 'macros': URL `http://git.io/vRGLD'."
                :constant-flag t
                :default-value (concat clojure--sym-forbidden-rest-chars "0-9:"))
                nil [30722 31043])
            ("clojure--sym-forbidden-rest-chars" variable
               (:documentation "A list of chars that a Clojure symbol cannot contain.
See definition of 'macros': URL `http://git.io/vRGLD'."
                :constant-flag t
                :default-value "][\";'@\\^`~(){}\\, 	
")
                nil [30525 30719])
            ("clojure-font-lock-keywords" variable
               (:documentation "Default expressions to highlight in Clojure mode."
                :constant-flag t
                :default-value (eval-when-compile `((,(concat "(\\(?:clojure.core/\\)?\\(" (regexp-opt '("def" "defonce")) "\\)\\>" "[ 
	]*" "\\(?:#?^\\(?:{[^}]*}\\|\\sw+\\)[ 
	]*\\)*" "\\(\\sw+\\)?") (1 font-lock-keyword-face) (2 font-lock-variable-name-face nil t)) (,(concat "(\\(?:clojure.core/\\)?\\(" (regexp-opt '("defstruct" "deftype" "defprotocol" "defrecord")) "\\)\\>" "[ 
	]*" "\\(?:#?^\\(?:{[^}]*}\\|\\sw+\\)[ 
	]*\\)*" "\\(\\sw+\\)?") (1 font-lock-keyword-face) (2 font-lock-type-face nil t)) (,(concat "(\\(?:" clojure--sym-regexp "/\\)?" "\\(def[^ 
	]*\\)" "\\>" "[ 
	]*" "\\(?:#?^\\(?:{[^}]*}\\|\\sw+\\)[ 
	]*\\)*" "\\(\\sw+\\)?") (1 font-lock-keyword-face) (2 font-lock-function-name-face nil t)) (,(concat "(\\(?:clojure.core/\\)?\\(fn\\)[ 	]+" "\\(?:#?^\\sw+[ 	]*\\)?" "\\(\\sw+\\)?") (1 font-lock-keyword-face) (2 font-lock-function-name-face nil t)) ("\\<%[&1-9]?" (0 font-lock-variable-name-face)) (,(concat "(" (regexp-opt '("def" "do" "if" "let" "let*" "var" "fn" "fn*" "loop" "loop*" "recur" "throw" "try" "catch" "finally" "set!" "new" "." "monitor-enter" "monitor-exit" "quote") t) "\\>") 1 font-lock-keyword-face) (,(concat "(\\(?:clojure.core/\\)?" (regexp-opt '("letfn" "case" "cond" "cond->" "cond->>" "condp" "for" "when" "when-not" "when-let" "when-first" "when-some" "if-let" "if-not" "if-some" ".." "->" "->>" "as->" "doto" "and" "or" "dosync" "doseq" "dotimes" "dorun" "doall" "ns" "in-ns" "with-open" "with-local-vars" "binding" "with-redefs" "with-redefs-fn" "declare") t) "\\>") 1 font-lock-keyword-face) (,(rx symbol-start (or "let" "when" "while") "-" (1+ (or (syntax word) (syntax symbol))) symbol-end) 0 font-lock-keyword-face) (,(concat "\\<" (regexp-opt '("*1" "*2" "*3" "*agent*" "*allow-unresolved-vars*" "*assert*" "*clojure-version*" "*command-line-args*" "*compile-files*" "*compile-path*" "*data-readers*" "*default-data-reader-fn*" "*e" "*err*" "*file*" "*flush-on-newline*" "*in*" "*macro-meta*" "*math-context*" "*ns*" "*out*" "*print-dup*" "*print-length*" "*print-level*" "*print-meta*" "*print-readably*" "*read-eval*" "*source-path*" "*unchecked-math*" "*use-context-classloader*" "*warn-on-reflection*") t) "\\>") 0 font-lock-builtin-face) ("\\(?:\\<\\|/\\)@?\\(\\*[a-z-]*\\*\\)\\>" 1 font-lock-variable-name-face) (,(concat "\\<" (regexp-opt '("true" "false" "nil") t) "\\>") 0 font-lock-constant-face) ("\\\\\\([[:punct:]]\\|[a-z0-9]+\\>\\)" 0 'clojure-character-face) (,(concat "(\\<ns\\>[ 
	]*" "\\(?:\\^?{[^}]+}[ 
	]*\\)*" "\\(" clojure--sym-regexp "\\)") (1 font-lock-type-face)) (,(concat "\\(:\\{1,2\\}\\)\\(" clojure--sym-regexp "?\\)\\(/\\)\\(" clojure--sym-regexp "\\)") (1 'clojure-keyword-face) (2 font-lock-type-face) (3 'default) (4 'clojure-keyword-face)) (,(concat "\\(:\\{1,2\\}\\)\\(" clojure--sym-regexp "\\)") (1 'clojure-keyword-face) (2 'clojure-keyword-face)) (,(concat "\\(#^\\)\\(" clojure--sym-regexp "?\\)\\(/\\)\\(" clojure--sym-regexp "\\)") (1 'default) (2 font-lock-type-face) (3 'default) (4 'default)) (,(concat "\\(#^\\)\\(" clojure--sym-regexp "\\)") (1 'default) (2 font-lock-type-face)) (,(concat "\\(" clojure--sym-regexp "?\\)\\(/\\)\\(" clojure--sym-regexp "\\)") (1 font-lock-type-face) (2 nil) (3 nil)) (,(concat "\\(" clojure--sym-regexp "\\)") (1 nil)) (clojure--search-comment-macro 1 font-lock-comment-face t) (,(rx "`" (group-n 1 (optional "#'") (+ (or (syntax symbol) (syntax word)))) "`") (1 'font-lock-constant-face prepend)) (clojure-font-lock-escaped-chars 0 'bold prepend) (clojure-font-lock-regexp-groups (1 'font-lock-regexp-grouping-construct prepend)))))
                nil [31362 38094])
            ("clojure-font-lock-syntactic-face-function" function
               (:documentation "Find and highlight text with a Clojure-friendly syntax table.

This function is passed to `font-lock-syntactic-face-function',
which is called with a single parameter, STATE (which is, in
turn, returned by `parse-partial-sexp' at the beginning of the
highlighted region)."
                :arguments ("state"))
                nil [38096 40289])
            ("clojure-font-lock-setup" function (:documentation "Configures font-lock for editing Clojure code.") nil [40291 40840])
            ("clojure-font-lock-def-at-point" function
               (:documentation "Range between the top-most def* and the fourth element after POINT.
Note that this means that there is no guarantee of proper font
locking in def* forms that are not at top level."
                :arguments ("point"))
                nil [40842 41434])
            ("clojure-font-lock-extend-region-def" function (:documentation "Set region boundaries to include the first four elements of def* forms.") nil [41436 42200])
            ("clojure--font-locked-as-string-p" function
               (:documentation "Non-nil if the char before point is font-locked as a string.
If REGEXP is non-nil, also check whether current string is
preceeded by a #."
                :arguments ("regexp"))
                nil [42202 42702])
            ("clojure-font-lock-escaped-chars" function
               (:documentation "Highlight scaped chars in strings.
BOUND denotes a buffer position to limit the search."
                :arguments ("bound"))
                nil [42704 43014])
            ("clojure-font-lock-regexp-groups" function
               (:documentation "Highlight grouping constructs in regular expression.

BOUND denotes the maximum number of characters (relative to the
point) to check."
                :arguments ("bound"))
                nil [43016 44813])
            ("put" code nil nil [44838 44873])
            ("put" code nil nil [44874 44910])
            ("put" code nil nil [44911 44948])
            ("put" code nil nil [44949 44987])
            ("put" code nil nil [44988 45029])
            ("put" code nil nil [45030 45071])
            ("put" code nil nil [45072 45114])
            ("put" code nil nil [45115 45159])
            ("put" code nil nil [45160 45200])
            ("clojure-align-forms-automatically" variable (:documentation "If non-nil, vertically align some forms automatically.
Automatically means it is done as part of indenting code.  This
applies to binding forms (`clojure-align-binding-forms'), to cond
forms (`clojure-align-cond-forms') and to map literals.  For
instance, selecting a map a hitting \\<clojure-mode-map>`\\[indent-for-tab-command]'
will align the values like this:
    {:some-key 10
     :key2     20}") nil [45275 45808])
            ("clojure-align-reader-conditionals" variable (:documentation "Whether to align reader conditionals, as if they were maps.") nil [45810 46003])
            ("clojure-align-binding-forms" variable
               (:documentation "List of strings matching forms that have binding forms."
                :default-value '("let" "when-let" "when-some" "if-let" "if-some" "binding" "loop" "doseq" "for" "with-open" "with-local-vars" "with-redefs"))
                nil [46005 46320])
            ("clojure-align-cond-forms" variable
               (:documentation "List of strings identifying cond-like forms."
                :default-value '("condp" "cond" "cond->" "cond->>" "case" "are"))
                nil [46322 46541])
            ("clojure--beginning-of-reader-conditional-regexp" variable
               (:documentation "Regexp denoting the beginning of a reader conditional."
                :default-value "#\\?@(\\|#\\?(")
                nil [46543 46677])
            ("clojure--position-for-alignment" function (:documentation "Non-nil if the sexp around point should be automatically aligned.
This function expects to be called immediately after an
open-brace or after the function symbol in a function call.

First check if the sexp around point is a map literal, or is a
call to one of the vars listed in `clojure-align-cond-forms'.  If
it isn't, return nil.  If it is, return non-nil and place point
immediately before the forms that should be aligned.

For instance, in a map literal point is left immediately before
the first key; while, in a let-binding, point is left inside the
binding vector and immediately before the first binding
construct.") nil [46679 48755])
            ("clojure--find-sexp-to-align" function
               (:documentation "Non-nil if there's a sexp ahead to be aligned before END.
Place point as in `clojure--position-for-alignment'."
                :arguments ("end"))
                nil [48757 49780])
            ("clojure--search-whitespace-after-next-sexp" function
               (:documentation "Move point after all whitespace after the next sexp.

Set the match data group 1 to be this region of whitespace and
return point.

BOUND is bounds the whitespace search."
                :arguments ("bound" "_noerror"))
                nil [49782 50531])
            ("clojure-align" function
               (:documentation "Vertically align the contents of the sexp around point.
If region is active, align it.  Otherwise, align everything in the
current \"top-level\" sexp.
When called from lisp code align everything between BEG and END."
                :user-visible-flag t
                :arguments ("beg" "end"))
                nil [50533 52136])
            ("clojure-indent-region" function
               (:documentation "Like `indent-region', but also maybe align forms.
Forms between BEG and END are aligned according to
`clojure-align-forms-automatically'."
                :arguments ("beg" "end"))
                nil [52154 52548])
            ("clojure-indent-line" function (:documentation "Indent current line as Clojure code.") nil [52550 52968])
            ("clojure-get-indent-function" variable (:documentation "Function to get the indent spec of a symbol.
This function should take one argument, the name of the symbol as
a string.  This name will be exactly as it appears in the buffer,
so it might start with a namespace alias.

This function is analogous to the `clojure-indent-function'
symbol property, and its return value should match one of the
allowed values of this property.  See `clojure-indent-function'
for more information.") nil [52970 53442])
            ("clojure--get-indent-method" function
               (:documentation "Return the indent spec for the symbol named FUNCTION-NAME.
FUNCTION-NAME is a string.  If it contains a `/', also try only
the part after the `/'.

Look for a spec using `clojure-get-indent-function', then try the
`clojure-indent-function' and `clojure-backtracking-indent'
symbol properties."
                :arguments ("function-name"))
                nil [53444 54514])
            ("clojure--current-backtracking-depth" variable nil nil [54516 54562])
            ("clojure--find-indent-spec-backtracking" function (:documentation "Return the indent sexp that applies to the sexp at point.
Implementation function for `clojure--find-indent-spec'.") nil [54564 56392])
            ("clojure--find-indent-spec" function (:documentation "Return the indent spec that applies to current sexp.
If `clojure-use-backtracking-indent' is non-nil, also do
backtracking up to a higher-level sexp in order to find the
spec.") nil [56394 56813])
            ("clojure--normal-indent" function
               (:documentation "Return the normal indentation column for a sexp.
Point should be after the open paren of the _enclosing_ sexp, and
LAST-SEXP is the start of the previous sexp (immediately before
the sexp being indented).  INDENT-MODE is any of the values
accepted by `clojure-indent-style'."
                :arguments ("last-sexp" "indent-mode"))
                nil [56815 58914])
            ("clojure--not-function-form-p" function (:documentation "Non-nil if form at point doesn't represent a function call.") nil [58916 59390])
            ("clojure-indent-function" function
               (:documentation "When indenting a line within a function call, indent properly.

INDENT-POINT is the position where the user typed TAB, or equivalent.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.

If the current line is in a call to a Clojure function with a
non-nil property `clojure-indent-function', that specifies how to do
the indentation.

The property value can be

- `defun', meaning indent `defun'-style;
- an integer N, meaning indent the first N arguments specially
  like ordinary function arguments and then indent any further
  arguments like a body;
- a function to call just as this function was called.
  If that function returns nil, that means it doesn't specify
  the indentation.
- a list, which is used by `clojure-backtracking-indent'.

This function also returns nil meaning don't specify the indentation."
                :arguments ("indent-point" "state"))
                nil [59596 63010])
            ("put-clojure-indent" function
               (:documentation "Instruct `clojure-indent-function' to indent the body of SYM by INDENT."
                :arguments ("sym" "indent"))
                nil [63036 63195])
            ("define-clojure-indent" function
               (:documentation "Call `put-clojure-indent' on a series, KVS."
                :arguments ("kvs"))
                nil [63197 63426])
            ("add-custom-clojure-indents" function
               (:documentation "Allow `clojure-defun-indents' to indent user-specified macros.

Requires the macro's NAME and a VALUE."
                :arguments ("name" "value"))
                nil [63428 63698])
            ("clojure-defun-indents" variable (:documentation "List of additional symbols with defun-style indentation in Clojure.

You can use this to let Emacs indent your own macros the same way
that it indents built-in macros like with-open.  This variable
only works when set via the customize interface (`setq' won't
work).  To set it from Lisp code, use
     (put-clojure-indent \\='some-symbol :defn).") nil [63700 64148])
            ("define-clojure-indent" code nil nil [64150 65315])
            ("clojure-string-start" function
               (:documentation "Return the position of the \" that begins the string at point.
If REGEX is non-nil, return the position of the # that begins the
regex at point.  If point is not inside a string or regex, return
nil."
                :arguments ("regex"))
                nil [65458 66259])
            ("clojure-char-at-point" function (:documentation "Return the char at point or nil if at buffer end.") nil [66261 66444])
            ("clojure-char-before-point" function (:documentation "Return the char before point or nil if at buffer beginning.") nil [66446 66643])
            ("clojure-toggle-keyword-string" function
               (:documentation "Convert the string or keyword at point to keyword or string."
                :user-visible-flag t)
                nil [66645 67464])
            ("clojure-delete-and-extract-sexp" function (:documentation "Delete the surrounding sexp and return it.") nil [67466 67703])
            ("clojure-cache-project-dir" variable
               (:documentation "Whether to cache the results of `clojure-project-dir'."
                :default-value t)
                nil [67708 67887])
            ("defvar-local" code nil nil [67889 67995])
            ("clojure-project-dir" function
               (:documentation "Return the absolute path to the project's root directory.

Call is delegated down to `clojure-project-root-function' with
optional DIR-NAME as argument.

When `clojure-cache-project-dir' is t the results of the command
are cached in a buffer local variable (`clojure-cached-project-dir')."
                :arguments ("dir-name"))
                nil [67997 68673])
            ("clojure-current-project" function
               (:documentation "Return the current project as a cons cell usable by project.el.

Call is delegated down to `clojure-clojure-dir' with
optional DIR-NAME as argument."
                :arguments ("dir-name"))
                nil [68675 69002])
            ("clojure-project-root-path" function
               (:documentation "Return the absolute path to the project's root directory.

Use `default-directory' if DIR-NAME is nil.
Return nil if not inside a project."
                :arguments ("dir-name"))
                nil [69004 69549])
            ("clojure-project-relative-path" function
               (:documentation "Denormalize PATH by making it relative to the project root."
                :arguments ("path"))
                nil [69551 69709])
            ("clojure-expected-ns" function
               (:documentation "Return the namespace matching PATH.

PATH is expected to be an absolute file path.

If PATH is nil, use the path to the file backing the current buffer."
                :arguments ("path"))
                nil [69733 70457])
            ("clojure-insert-ns-form-at-point" function
               (:documentation "Insert a namespace form at point."
                :user-visible-flag t)
                nil [70459 70624])
            ("clojure-insert-ns-form" function
               (:documentation "Insert a namespace form at the beginning of the buffer."
                :user-visible-flag t)
                nil [70626 70807])
            ("clojure-update-ns" function
               (:documentation "Update the namespace of the current buffer.
Useful if a file has been renamed."
                :user-visible-flag t)
                nil [70809 71322])
            ("clojure--sort-following-sexps" function (:documentation "Sort sexps between point and end of current sexp.
Comments at the start of a line are considered part of the
following sexp.  Comments at the end of a line (after some other
content) are considered part of the preceding sexp.") nil [71324 72940])
            ("clojure-sort-ns" function
               (:documentation "Internally sort each sexp inside the ns form."
                :user-visible-flag t)
                nil [72942 73842])
            ("clojure-namespace-name-regex" variable
               (:constant-flag t
                :default-value (rx line-start "(" (zero-or-one (group (regexp "clojure.core/"))) (zero-or-one (submatch "in-")) "ns" (zero-or-one "+") (one-or-more (any whitespace "
")) (zero-or-more (or (submatch (zero-or-one "#") "^{" (zero-or-more (not (any "}"))) "}") (zero-or-more "^:" (one-or-more (not (any whitespace))))) (one-or-more (any whitespace "
"))) (zero-or-one (any ":'")) (group (one-or-more (not (any "()\"" whitespace))) symbol-end)))
                nil [73844 74581])
            ("clojure-cache-ns" variable (:documentation "Whether to cache the results of `clojure-find-ns'.

Note that this won't work well in buffers with multiple namespace
declarations (which rarely occur in practice) and you'll
have to invalidate this manually after changing the ns for
a buffer.  If you update the ns using `clojure-update-ns'
the cached value will be updated automatically.") nil [74583 75040])
            ("defvar-local" code nil nil [75042 75140])
            ("clojure-find-ns" function (:documentation "Return the namespace of the current Clojure buffer.
Return the namespace closest to point and above it.  If there are
no namespaces above point, return the first one in the buffer.

The results will be cached if `clojure-cache-ns' is set to t.") nil [75142 76151])
            ("clojure-show-cache" function
               (:documentation "Display cached values if present.
Useful for debugging."
                :user-visible-flag t)
                nil [76153 76358])
            ("clojure-clear-cache" function
               (:documentation "Clear all buffer-local cached values.

Normally you'd need to do this very infrequently - e.g.
after renaming the root folder of project or after
renaming a namespace."
                :user-visible-flag t)
                nil [76360 76702])
            ("clojure-def-type-and-name-regex" variable
               (:constant-flag t
                :default-value (concat "(\\(?:\\(?:\\sw\\|\\s_\\)+/\\)?" "\\(def\\(?:\\sw\\|\\s_\\)*\\)\\>" "[ 
	]*" "\\(?:#?^\\(?:{[^}]*}\\|\\(?:\\sw\\|\\s_\\)+\\)[ 
	]*\\)*" "\\(\\(?:\\sw\\|\\s_\\)+\\)"))
                nil [76704 77088])
            ("clojure-find-def" function (:documentation "Find the var declaration macro and symbol name of the current form.
Returns a list pair, e.g. (\"defn\" \"abc\") or (\"deftest\" \"some-test\").") nil [77090 77530])
            ("clojure--looking-at-non-logical-sexp" function (:documentation "Return non-nil if text after point is \"non-logical\" sexp.
\"Non-logical\" sexp are ^metadata and #reader.macros.") nil [77555 77818])
            ("clojure-forward-logical-sexp" function
               (:documentation "Move forward N logical sexps.
This will skip over sexps that don't represent objects, so that ^hints and
#reader.macros are considered part of the following sexp."
                :user-visible-flag t
                :arguments ("n"))
                nil [77820 78393])
            ("clojure-backward-logical-sexp" function
               (:documentation "Move backward N logical sexps.
This will skip over sexps that don't represent objects, so that ^hints and
#reader.macros are considered part of the following sexp."
                :user-visible-flag t
                :arguments ("n"))
                nil [78395 79128])
            ("clojure-top-level-form-p" function
               (:documentation "Return truthy if the first form matches FIRST-FORM."
                :arguments ("first-form"))
                nil [79130 79529])
            ("clojure-sexp-starts-until-position" function
               (:documentation "Return the starting points for forms before POSITION.
Positions are in descending order to aide in finding the first starting
position before the current position."
                :arguments ("position"))
                nil [79531 80088])
            ("clojure-toplevel-inside-comment-form" variable (:documentation "Eval top level forms inside comment forms instead of the comment form itself.
Experimental.  Function `cider-defun-at-point' is used extensively so if we
change this heuristic it needs to be bullet-proof and desired.  While
testing, give an easy way to turn this new behavior off.") nil [80090 80508])
            ("clojure-find-first" function
               (:documentation "Find first element of COLL for which PRED return truthy."
                :arguments ("pred" "coll"))
                nil [80510 80834])
            ("clojure-beginning-of-defun-function" function
               (:documentation "Go to top level form.
Set as `beginning-of-defun-function' so that these generic
operators can be used.  Given a positive N it will do it that
many times."
                :arguments ("n"))
                nil [80836 82125])
            ("clojure-thread-all-but-last" variable (:documentation "Non-nil means do not thread the last expression.
This means that `clojure-thread-first-all' and
`clojure-thread-last-all' not thread the deepest sexp inside the
current sexp.") nil [82272 82575])
            ("clojure--point-after" function
               (:documentation "Return POINT after performing ACTIONS.

An action is either the symbol of a function or a two element
list of (fn args) to pass to `apply''"
                :arguments ("actions"))
                nil [82577 82993])
            ("clojure--maybe-unjoin-line" function (:documentation "Undo a `join-line' done by a threading command.") nil [82995 83249])
            ("clojure--unwind-last" function (:documentation "Unwind a thread last macro once.

Point must be between the opening paren and the ->> symbol.") nil [83251 84210])
            ("clojure--ensure-parens-around-function-names" function (:documentation "Insert parens around function names if necessary.") nil [84212 84440])
            ("clojure--unwind-first" function (:documentation "Unwind a thread first macro once.

Point must be between the opening paren and the -> symbol.") nil [84442 84921])
            ("clojure--pop-out-of-threading" function (:documentation "Raise a sexp up a level to unwind a threading form.") nil [84923 85096])
            ("clojure--nothing-more-to-unwind" function (:documentation "Return non-nil if a threaded form cannot be unwound further.") nil [85098 85483])
            ("clojure--fix-sexp-whitespace" function
               (:documentation "Fix whitespace after unwinding a threading form.

Optional argument MOVE-OUT, if non-nil, means moves up a list
before fixing whitespace."
                :arguments ("move-out"))
                nil [85485 85903])
            ("clojure-unwind" function
               (:documentation "Unwind thread at point or above point by one level.
Return nil if there are no more levels to unwind."
                :user-visible-flag t)
                nil [85920 86753])
            ("clojure-unwind-all" function
               (:documentation "Fully unwind thread at point or above point."
                :user-visible-flag t)
                nil [86770 86891])
            ("clojure--remove-superfluous-parens" function (:documentation "Remove extra parens from a form.") nil [86893 87026])
            ("clojure--thread-first" function (:documentation "Thread a nested sexp using ->.") nil [87028 87570])
            ("clojure--thread-last" function (:documentation "Thread a nested sexp using ->>.") nil [87572 88185])
            ("clojure--threadable-p" function (:documentation "Return non-nil if a form can be threaded.") nil [88187 88338])
            ("clojure-thread" function
               (:documentation "Thread by one more level an existing threading macro."
                :user-visible-flag t)
                nil [88355 88828])
            ("clojure--thread-all" function
               (:documentation "Fully thread the form at point.

FIRST-OR-LAST-THREAD is \"->\" or \"->>\".

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'."
                :arguments ("first-or-last-thread" "but-last"))
                nil [88830 89277])
            ("clojure-thread-first-all" function
               (:documentation "Fully thread the form at point using ->.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'."
                :user-visible-flag t
                :arguments ("but-last"))
                nil [89294 89553])
            ("clojure-thread-last-all" function
               (:documentation "Fully thread the form at point using ->>.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'."
                :user-visible-flag t
                :arguments ("but-last"))
                nil [89570 89830])
            ("clojure-use-metadata-for-privacy" variable (:documentation "If nil, `clojure-cycle-privacy' will use (defn- f []).
If t, it will use (defn ^:private f []).") nil [89851 90080])
            ("clojure-cycle-privacy" function
               (:documentation "Make public the current private def, or vice-versa.
See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-privacy"
                :user-visible-flag t)
                nil [90097 90660])
            ("clojure--convert-collection" function
               (:documentation "Convert the collection at (point) by unwrapping it an wrapping it between COLL-OPEN and COLL-CLOSE."
                :arguments ("coll-open" "coll-close"))
                nil [90662 91289])
            ("clojure-convert-collection-to-list" function
               (:documentation "Convert collection at (point) to list."
                :user-visible-flag t)
                nil [91306 91450])
            ("clojure-convert-collection-to-quoted-list" function
               (:documentation "Convert collection at (point) to quoted list."
                :user-visible-flag t)
                nil [91467 91626])
            ("clojure-convert-collection-to-map" function
               (:documentation "Convert collection at (point) to map."
                :user-visible-flag t)
                nil [91643 91785])
            ("clojure-convert-collection-to-vector" function
               (:documentation "Convert collection at (point) to vector."
                :user-visible-flag t)
                nil [91802 91950])
            ("clojure-convert-collection-to-set" function
               (:documentation "Convert collection at (point) to set."
                :user-visible-flag t)
                nil [91967 92110])
            ("clojure--in-string-p" function (:documentation "Check whether the point is currently in a string.") nil [92112 92221])
            ("clojure--goto-if" function (:documentation "Find the first surrounding if or if-not expression.") nil [92223 92605])
            ("clojure-cycle-if" function
               (:documentation "Change a surrounding if to if-not, or vice-versa.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-if"
                :user-visible-flag t)
                nil [92622 93090])
            ("clojure--goto-when" function (:documentation "Find the first surrounding when or when-not expression.") nil [93150 93546])
            ("clojure-cycle-when" function
               (:documentation "Change a surrounding when to when-not, or vice-versa."
                :user-visible-flag t)
                nil [93563 93872])
            ("clojure-cycle-not" function
               (:documentation "Add or remove a not form around the current form."
                :user-visible-flag t)
                nil [93874 94316])
            ("clojure--let-regexp" variable
               (:documentation "Regexp matching let like expressions, i.e. \"let\", \"when-let\", \"if-let\".

The first match-group is the let expression.

The second match-group is the whitespace or the opening square
bracket if no whitespace between the let expression and the
bracket."
                :default-value "(\\(when-let\\|if-let\\|let\\)\\(\\s-*\\|\\[\\)")
                nil [94341 94683])
            ("clojure--goto-let" function (:documentation "Go to the beginning of the nearest let form.") nil [94685 95023])
            ("clojure--inside-let-binding-p" function (:documentation "Return non-nil if point is inside a let binding.") nil [95025 95363])
            ("clojure--beginning-of-current-let-binding" function (:documentation "Move before the bound name of the current binding.
Assume that point is in the binding form of a let.") nil [95365 95706])
            ("clojure--previous-line" function (:documentation "Keep the column position while go the previous line.") nil [95708 95878])
            ("clojure--prepare-to-insert-new-let-binding" function (:documentation "Move to right place in the let form to insert a new binding and indent.") nil [95880 96446])
            ("clojure--sexp-regexp" function
               (:documentation "Return a regexp for matching SEXP."
                :arguments ("sexp"))
                nil [96448 96703])
            ("clojure--replace-sexp-with-binding" function
               (:documentation "Replace a binding with its bound name in the let form.

BOUND-NAME is the name (left-hand side) of a binding.

INIT-EXPR is the value (right-hand side) of a binding."
                :arguments ("bound-name" "init-expr"))
                nil [96705 97172])
            ("clojure--replace-sexps-with-bindings" function
               (:documentation "Replace bindings with their respective bound names in the let form.

BINDINGS is the list of bound names and init expressions."
                :arguments ("bindings"))
                nil [97174 97573])
            ("clojure--replace-sexps-with-bindings-and-indent" function (:documentation "Replace sexps with bindings.") nil [97575 97869])
            ("clojure--read-let-bindings" function (:documentation "Read the bound-name and init expression pairs in the binding form.
Return a list: odd elements are bound names, even elements init expressions.") nil [97871 98573])
            ("clojure--introduce-let-internal" function
               (:documentation "Create a let form, binding the form at point with NAME.

Optional numeric argument N, if non-nil, introduces the let N
lists up."
                :arguments ("name" "n"))
                nil [98575 99423])
            ("clojure--move-to-let-internal" function
               (:documentation "Bind the form at point to NAME in the nearest let."
                :arguments ("name"))
                nil [99425 99910])
            ("clojure--let-backward-slurp-sexp-internal" function (:documentation "Slurp the s-expression before the let form into the let form.") nil [99912 100294])
            ("clojure-let-backward-slurp-sexp" function
               (:documentation "Slurp the s-expression before the let form into the let form.
With a numberic prefix argument slurp the previous N s-expression into the let form."
                :user-visible-flag t
                :arguments ("n"))
                nil [100311 100642])
            ("clojure--let-forward-slurp-sexp-internal" function (:documentation "Slurp the next s-expression after the let form into the let form.") nil [100644 100985])
            ("clojure-let-forward-slurp-sexp" function
               (:documentation "Slurp the next s-expression after the let form into the let form.
With a numeric prefix argument slurp the next N s-expressions into the let form."
                :user-visible-flag t
                :arguments ("n"))
                nil [101002 101331])
            ("clojure-introduce-let" function
               (:documentation "Create a let form, binding the form at point.
With a numeric prefix argument the let is introduced N lists up."
                :user-visible-flag t
                :arguments ("n"))
                nil [101348 101612])
            ("clojure-move-to-let" function
               (:documentation "Move the form at point to a binding in the nearest let."
                :user-visible-flag t)
                nil [101629 101817])
            ("clojurescript-font-lock-keywords" variable
               (:documentation "Additional font-locking for `clojurescript-mode'."
                :constant-flag t
                :default-value (eval-when-compile `((,(concat "(\\(?:.*/\\)?" (regexp-opt '("js-obj" "js-delete" "clj->js" "js->clj")) "\\>") 0 font-lock-builtin-face))))
                nil [101839 102154])
            ("define-derived-mode" code nil nil [102171 102379])
            ("define-derived-mode" code nil nil [102396 102520])
            ("progn" code nil nil [102537 102911])
            ("clojure-mode" package nil nil [102913 102936]))          
      :file "clojure-mode.el"
      :pointmax 103014
      :fsize 103016
      :lastmodtime '(23451 10644 127436 383000)
      :unmatched-syntax '((close-paren 31359 . 31360) (symbol 30506 . 30522) (open-paren 30505 . 30506) (close-paren 2363 . 2364) (symbol 2152 . 2169) (open-paren 2151 . 2152))))
  :file "!home!lk!.emacs.d!elpa!clojure-mode-20180827.1827!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
