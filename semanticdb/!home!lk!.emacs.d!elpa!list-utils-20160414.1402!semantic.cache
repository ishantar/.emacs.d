;; Object semanticdb-project-database-file-17a3680
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file-17a3680"
  :tables
  (list
    (semanticdb-table "semanticdb-table-17a3660"
      :major-mode emacs-lisp-mode
      :tags nil
      :file "list-utils-autoloads.el"
      :pointmax 359
      :fsize 16178
      :lastmodtime '(23398 9722 494589 39000)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-1806d78"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("cl" include nil nil [5599 5612])
            ("declare-function" code nil nil [5632 5691])
            ("declare-function" code nil nil [5692 5761])
            ("list-utils" customgroup
               (:documentation "List-manipulation utility functions."
                :user-visible-flag t)
                nil [5778 6126])
            ("unless" code nil nil [6157 7260])
            ("list-utils-htt-=" function
               (:documentation "A comparison function in which `=' floats and integers are identical.

Non-numeric arguments are permitted and will be compared by `equal'.

A hash-table-test is defined with the same name."
                :arguments ("x" "y"))
                nil [7284 7598])
            ("define-hash-table-test" code nil nil [7600 7913])
            ("list-utils-htt-case-fold-equal" function
               (:documentation "A string comparison function which ignores case.

Non-string arguments are permitted, and will be compared after
stringification by `format'.

A hash-table-test is defined with the same name."
                :arguments ("x" "y"))
                nil [7915 8313])
            ("define-hash-table-test" code nil nil [8315 8538])
            ("list-utils-htt-ignore-whitespace-equal" function
               (:documentation "A string comparison function which ignores whitespace.

Non-string arguments are permitted, and will be compared after
stringification by `format'.

A hash-table-test is defined with the same name."
                :arguments ("x" "y"))
                nil [8540 8963])
            ("define-hash-table-test" code nil nil [8965 9237])
            ("progn" code nil nil [9312 9365])
            ("tconc-list" function
               (:documentation "Efficiently append LIST to TC.

TC is a data structure created by `make-tconc'."
                :arguments ("tc" "list"))
                nil [9382 9749])
            ("tconc" function
               (:documentation "Efficiently append ARGS to TC.

TC is a data structure created by `make-tconc'

Without ARGS, return the list held by TC."
                :arguments ("tc" "args"))
                nil [9766 9944])
            ("list-utils-cons-cell-p" function
               (:documentation "Return non-nil if CELL holds a cons cell rather than a proper list.

A proper list is defined as a series of cons cells in which the
cdr slot of each cons holds a pointer to the next element of the
list, and the cdr slot in the final cons holds nil.

A plain cons cell, for the purpose of this function, is a single
cons in which the cdr holds data rather than a pointer to the
next cons cell, eg

    '(1 . 2)

In addition, a list which is not nil-terminated is not a proper
list and will be recognized by this function as a cons cell.
Such a list is printed using dot notation for the last two
elements, eg

    '(1 2 3 4 . 5)

Such improper lists are produced by `list*'."
                :arguments ("cell"))
                nil [9972 10849])
            ("list-utils-make-proper-copy" function
               (:documentation "Copy a cons cell or improper LIST into a proper list.

If optional TREE is non-nil, traverse LIST, making proper
copies of any improper lists contained within.

Optional RECUR-INTERNAL is for internal use only.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'."
                :arguments ("list" "tree" "recur-internal"))
                nil [10866 11747])
            ("list-utils-make-proper-inplace" function
               (:documentation "Make a cons cell or improper LIST into a proper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making any
improper lists contained within into proper lists.

Optional RECUR-INTERNAL is for internal use only.

Modifies LIST and returns the modified value."
                :arguments ("list" "tree" "recur-internal"))
                nil [11764 12581])
            ("define-obsolete-function-alias" code nil nil [12582 12670])
            ("list-utils-make-improper-copy" function
               (:documentation "Copy a proper LIST into an improper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making proper
copies of any improper lists contained within.

Optional RECUR-INTERNAL is for internal use only."
                :arguments ("list" "tree" "recur-internal"))
                nil [12687 13668])
            ("list-utils-make-improper-inplace" function
               (:documentation "Make proper LIST into an improper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making any
proper lists contained within into improper lists.

Optional RECUR-INTERNAL is for internal use only.

Modifies LIST and returns the modified value."
                :arguments ("list" "tree" "recur-internal"))
                nil [13685 14620])
            ("define-obsolete-function-alias" code nil nil [14621 14713])
            ("list-utils-linear-subseq" function
               (:documentation "Return the linear elements from a partially cyclic LIST.

If there is no cycle in LIST, return LIST.  If all elements of
LIST are included in a cycle, return nil.

As an optimization, CYCLE-LENGTH may be specified if the length
of the cyclic portion is already known.  Otherwise it will be
calculated from LIST."
                :arguments ("list" "cycle-length"))
                nil [14730 15571])
            ("list-utils-cyclic-subseq" function
               (:documentation "Return any cyclic elements from LIST as a circular list.

The first element of the cyclic structure is not guaranteed to be
first element of the return value unless FROM-START is non-nil.

To linearize the return value, use `list-utils-make-linear-inplace'.

If there is no cycle in LIST, return nil."
                :arguments ("list" "from-start"))
                nil [15588 16330])
            ("list-utils-cyclic-length" function
               (:documentation "Return the number of cyclic elements in LIST.

If some portion of LIST is linear, only the cyclic
elements will be counted.

If LIST is completely linear, return 0."
                :arguments ("list"))
                nil [16347 17011])
            ("list-utils-cyclic-p" function
               (:documentation "Return non-nil if LIST contains any cyclic structures.

If optional PERFECT is set, only return non-nil if LIST is a
perfect non-branching cycle in which the last element points
to the first."
                :arguments ("list" "perfect"))
                nil [17028 17455])
            ("list-utils-linear-p" function
               (:documentation "Return non-nil if LIST is linear (no cyclic structure)."
                :arguments ("list"))
                nil [17472 17606])
            ("defalias" code nil nil [17623 17680])
            ("list-utils-safe-length" function
               (:documentation "Return the number of elements in LIST.

LIST may be linear or cyclic.

If LIST is not really a list, returns 0.

If LIST is an improper list, return the number of proper list
elements, like `safe-length'."
                :arguments ("list"))
                nil [17697 18139])
            ("list-utils-flat-length" function
               (:documentation "Count simple elements from the beginning of LIST.

Stop counting when a cons is reached.  nil is not a cons,
and is considered to be a \"simple\" element.

If the car of LIST is a cons, return 0."
                :arguments ("list"))
                nil [18156 18595])
            ("list-utils-make-linear-copy" function
               (:documentation "Return a linearized copy of LIST, which may be cyclic.

If optional TREE is non-nil, traverse LIST, substituting
linearized copies of any cyclic lists contained within."
                :arguments ("list" "tree"))
                nil [18612 19092])
            ("list-utils-make-linear-inplace" function
               (:documentation "Linearize LIST, which may be cyclic.

Modifies LIST and returns the modified value.

If optional TREE is non-nil, traverse LIST, linearizing any
cyclic lists contained within."
                :arguments ("list" "tree"))
                nil [19109 19624])
            ("list-utils-safe-equal" function
               (:documentation "Compare LIST-1 and LIST-2, which may be cyclic lists.

LIST-1 and LIST-2 may also contain cyclic lists, which are
each traversed and compared.  This function will not infloop
when cyclic lists are encountered.

Non-nil is returned only if the leaves of LIST-1 and LIST-2 are
`equal' and the structure is identical.

Optional TEST specifies a test, defaulting to `equal'.

If LIST-1 and LIST-2 are not actually lists, they are still
compared according to TEST."
                :arguments ("list-1" "list-2" "test"))
                nil [19641 21757])
            ("list-utils-depth" function
               (:documentation "Find the depth of LIST, which may contain other lists.

If LIST is not a list or is an empty list, returns a depth
of 0.

If LIST is a cons cell or a list which does not contain other
lists, returns a depth of 1."
                :arguments ("list"))
                nil [21774 22396])
            ("list-utils-flatten" function
               (:documentation "Return a flattened copy of LIST, which may contain other lists.

This function flattens cons cells as lists, and
flattens circular list structures."
                :arguments ("list"))
                nil [22413 23100])
            ("list-utils-insert-before" function
               (:documentation "Look in LIST for ELEMENT and insert NEW-ELEMENT before it.

Optional TEST sets the test used for a matching element, and
defaults to `equal'.

LIST is modified and the new value is returned."
                :arguments ("list" "element" "new-element" "test"))
                nil [23117 23772])
            ("list-utils-insert-after" function
               (:documentation "Look in LIST for ELEMENT and insert NEW-ELEMENT after it.

Optional TEST sets the test used for a matching element, and
defaults to `equal'.

LIST is modified and the new value is returned."
                :arguments ("list" "element" "new-element" "test"))
                nil [23789 24448])
            ("list-utils-insert-before-pos" function
               (:documentation "Look in LIST for position POS, and insert NEW-ELEMENT before.

POS is zero-indexed.

LIST is modified and the new value is returned."
                :arguments ("list" "pos" "new-element"))
                nil [24465 25042])
            ("list-utils-insert-after-pos" function
               (:documentation "Look in LIST for position POS, and insert NEW-ELEMENT after.

LIST is modified and the new value is returned."
                :arguments ("list" "pos" "new-element"))
                nil [25059 25618])
            ("list-utils-and" function
               (:documentation "Return the elements of LIST1 which are present in LIST2.

This is similar to `cl-intersection' (or `intersection') from
the cl library, except that `list-utils-and' preserves order,
does not uniquify the results, and exhibits more predictable
performance for large lists.

Order will follow LIST1.  Duplicates may be present in the result
as in LIST1.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed.  When FLIP is set, LIST2 will be the guide for the
order of the result, and will determine whether duplicates may
be returned.  Since this function preserves duplicates, setting
FLIP can change the number of elements in the result.

Performance: `list-utils-and' and friends use a general-purpose
hashing approach.  `intersection' and friends use pure iteration.
Iteration can be much faster in a few special cases, especially
when the number of elements is small.  In other scenarios,
iteration can be much slower.  Hashing has no worst-case
performance scenario, although it uses much more memory.  For
heavy-duty list operations, performance may be improved by
`let'ing `gc-cons-threshold' to a high value around sections that
make frequent use of this function."
                :arguments ("list1" "list2" "test" "hint" "flip"))
                nil [25635 27864])
            ("list-utils-not" function
               (:documentation "Return the elements of LIST1 which are not present in LIST2.

This is similar to `cl-set-difference' (or `set-difference') from
the cl library, except that `list-utils-not' preserves order and
exhibits more predictable performance for large lists.  Order will
follow LIST1.  Duplicates may be present as in LIST1.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed, returning elements of LIST2 which are not present in
LIST1.  When FLIP is set, LIST2 will be the guide for the order
of the result, and will determine whether duplicates may be
returned.

Performance: see notes under `list-utils-and'."
                :arguments ("list1" "list2" "test" "hint" "flip"))
                nil [27881 30032])
            ("list-utils-xor" function
               (:documentation "Return elements which are only present in either LIST1 or LIST2.

This is similar to `cl-set-exclusive-or' (or `set-exclusive-or')
from the cl library, except that `list-utils-xor' preserves order,
and exhibits more predictable performance for large lists.  Order
will follow LIST1, then LIST2.  Duplicates may be present as in
LIST1 or LIST2.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed, causing order and duplicates to follow LIST2, then
LIST1.

Performance: see notes under `list-utils-and'."
                :arguments ("list1" "list2" "test" "hint" "flip"))
                nil [30049 31158])
            ("list-utils-uniq" function
               (:documentation "Return a uniquified copy of LIST, preserving order.

This is similar to `cl-remove-duplicates' (or `remove-duplicates')
from the cl library, except that `list-utils-uniq' preserves order,
and exhibits more predictable performance for large lists.  Order
will follow LIST.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'."
                :arguments ("list" "test" "hint"))
                nil [31175 32282])
            ("list-utils-dupes" function
               (:documentation "Return only duplicated elements from LIST, preserving order.

Duplicated elements may still exist in the result: this function
removes singlets.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'."
                :arguments ("list" "test" "hint"))
                nil [32299 33298])
            ("list-utils-singlets" function
               (:documentation "Return only singlet elements from LIST, preserving order.

Duplicated elements may not exist in the result.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'."
                :arguments ("list" "test" "hint"))
                nil [33315 34280])
            ("list-utils-partition-dupes" function
               (:documentation "Partition LIST into duplicates and singlets, preserving order.

The return value is an alist with two keys: 'dupes and 'singlets.
The two values of the alist are lists which, if combined, comprise
a complete copy of the elements of LIST.

Duplicated elements may still exist in the 'dupes partition.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'."
                :arguments ("list" "test" "hint"))
                nil [34297 35766])
            ("list-utils-alist-or-flat-length" function
               (:documentation "Count simple or cons-cell elements from the beginning of LIST.

Stop counting when a proper list of non-zero length is reached.

If the car of LIST is a list, return 0."
                :arguments ("list"))
                nil [35795 36280])
            ("list-utils-alist-flatten" function
               (:documentation "Flatten LIST, which may contain other lists.  Do not flatten cons cells.

It is not guaranteed that the result contains *only* cons cells.
The result could contain other data types present in LIST.

This function simply avoids flattening single conses or improper
lists where the last two elements would be expressed as a dotted
pair."
                :arguments ("list"))
                nil [36297 37309])
            ("list-utils-plist-reverse" function
               (:documentation "Return reversed copy of property-list PLIST, maintaining pair associations."
                :arguments ("plist"))
                nil [37338 37597])
            ("list-utils-plist-del" function
               (:documentation "Delete from PLIST the property PROP and its associated value.

When PROP is not present in PLIST, there is no effect.

The new plist is returned; use `(setq x (list-utils-plist-del x prop))'
to be sure to use the new value.

This functionality overlaps with the undocumented `cl-do-remf'."
                :arguments ("plist" "prop"))
                nil [37614 38104])
            ("list-utils" package nil nil [38106 38127]))          
      :file "list-utils.el"
      :pointmax 38511
      :fsize 38510
      :lastmodtime '(23398 9722 334587 396000)
      :unmatched-syntax nil))
  :file "!home!lk!.emacs.d!elpa!list-utils-20160414.1402!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
