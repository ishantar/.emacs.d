;; Object semanticdb-project-database-file-191da5c
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file-191da5c"
  :tables
  (list
    (semanticdb-table "semanticdb-table-117b890"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("seq" include nil nil [1592 1606])
            ("unless" code nil nil [1607 1662])
            ("clj-refactor-compat" include nil nil [1664 1694])
            ("yasnippet" include nil nil [1695 1715])
            ("paredit" include nil nil [1716 1734])
            ("multiple-cursors-core" include nil nil [1735 1767])
            ("clojure-mode" include nil nil [1768 1791])
            ("cider" include nil nil [1792 1808])
            ("edn" include nil nil [1809 1823])
            ("sgml-mode" include nil nil [1824 1844])
            ("inflections" include nil nil [1845 1867])
            ("hydra" include nil nil [1868 1884])
            ("subword" include nil nil [1885 1903])
            ("cljr-add-ns-to-blank-clj-files" variable
               (:documentation "If t, automatically add a ns form to new .clj files."
                :default-value t)
                nil [1905 2038])
            ("cljr-auto-sort-ns" variable
               (:documentation "If t, sort ns form after any command that changes it."
                :default-value t)
                nil [2040 2161])
            ("cljr-magic-requires" variable
               (:documentation "Whether to automatically require common namespaces when they are used.
These are the namespaces listed in `cljr-magic-require-namespaces'.

If this variable is `:prompt', typing the short form followed by
`\\[cljr-slash]' will ask if you want to add the corresponding require
statement to the ns form.
Any other non-nil value means to add the form without asking."
                :default-value t)
                nil [2163 2708])
            ("cljr-magic-require-namespaces" variable
               (:documentation "Alist of aliases and namespaces used by `cljr-slash'."
                :default-value '(("io" . "clojure.java.io") ("set" . "clojure.set") ("str" . "clojure.string") ("walk" . "clojure.walk") ("zip" . "clojure.zip")))
                nil [2710 3085])
            ("cljr-project-clean-prompt" variable
               (:documentation "If t, `cljr-project-clean' asks before doing anything.
If nil, the project clean functions are run without warning."
                :default-value t)
                nil [3087 3278])
            ("cljr-project-clean-functions" variable
               (:documentation "List of functions called by `cljr-project-clean'.
These are called on all .clj files in the project."
                :default-value (list #'cljr-clean-ns))
                nil [3280 3492])
            ("cljr-project-clean-exceptions" variable
               (:documentation "A list of files that `cljr-project-clean' should avoid."
                :default-value '("dev/user.clj" "project.clj" "boot.clj"))
                nil [3494 3678])
            ("cljr-hotload-dependencies" variable (:documentation "If t, newly added dependencies are also hotloaded into the repl.
This only applies to dependencies added by `cljr-add-project-dependency'.") nil [3680 3896])
            ("cljr-favor-private-functions" variable
               (:documentation "If t, refactorings insert private function declarations."
                :default-value t)
                nil [3898 4033])
            ("cljr-favor-prefix-notation" variable (:documentation "If t, `cljr-clean-ns' favors prefix notation in the ns form.") nil [4035 4174])
            ("cljr-use-multiple-cursors" variable
               (:documentation "If t, some refactorings use the `multiple-cursors' package.
This improves interactivity of the commands. If nil, those
refactorings will use regular prompts instead."
                :default-value t)
                nil [4176 4417])
            ("cljr-auto-clean-ns" variable
               (:documentation "If t, call `cljr-clean-ns' after commands that change the ns."
                :default-value t)
                nil [4419 4549])
            ("cljr-populate-artifact-cache-on-startup" variable
               (:documentation "If t, the middleware will eagerly populate the artifact cache.
This makes `cljr-add-project-dependency' as snappy as can be."
                :default-value t)
                nil [4551 4765])
            ("cljr-warn-on-eval" variable
               (:documentation "If t, warn the user before running any op that requires ASTs to be built
   that the project will be evaled. If this is not preferred the op will
   be aborted. Also effectively overrides `cljr-eagerly-build-asts-on-startup'
   so if this is on the AST cache is not warmed at startup or after certain
   operations."
                :default-value t)
                nil [4767 5150])
            ("cljr-eagerly-build-asts-on-startup" variable
               (:documentation "If t, the middleware will eagerly populate the ast cache.
This makes `cljr-find-usages' and `cljr-rename-symbol' as snappy
as can be."
                :default-value t)
                nil [5152 5370])
            ("cljr-suppress-middleware-warnings" variable (:documentation "If t, no middleware warnings are printed to the repl.") nil [5372 5511])
            ("cljr-suppress-no-project-warning" variable (:documentation "If t, no warning is printed when starting a REPL outside a project.
By default, a warning is printed in this case since clj-refactor
will not work as expected in such REPLs.") nil [5513 5771])
            ("cljr-find-usages-ignore-analyzer-errors" variable (:documentation "DEPRECATED: use `cljr-ignore-analyzer-errors' instead.
  If t, `cljr-find-usages' ignores namespaces that cannot be analyzed.
If any namespaces presents an analyzer error, it is skipped and
the command carries on looking for the given symbol in those
namespaces which can be analyzed.

If nil, `cljr-find-usages' won't run if there is a broken
namespace in the project.") nil [5773 6234])
            ("cljr-ignore-analyzer-errors" variable (:documentation "If t, `cljr-find-usages' `cljr-inline-symbol' `cljr-rename-symbol'
ignores namespaces that cannot be analyzed.
If any namespaces presents an analyzer error, it is skipped and
the command carries on looking for the given symbol in those
namespaces which can be analyzed.

If nil, `cljr-find-usages'  `cljr-inline-symbol' `cljr-rename-symbol'
won't run if there is a broken namespace in the project.") nil [6236 6713])
            ("cljr-auto-eval-ns-form" variable
               (:documentation "When true refactorings which change the ns form also trigger
  its re-evaluation."
                :default-value t)
                nil [6715 6869])
            ("cljr-midje-test-declaration" variable
               (:documentation "The require form to use when midje is in use."
                :default-value "[midje.sweet :as midje]")
                nil [6871 7017])
            ("cljr-expectations-test-declaration" variable
               (:documentation "The require form to use when expectations is in use."
                :default-value "[expectations :as e]")
                nil [7019 7176])
            ("cljr-cljc-clojure-test-declaration" variable
               (:documentation "The require form to use when clojure.test and cljs.test is in use in a cljc file."
                :default-value "#?(:clj [clojure.test :as t]
:cljs [cljs.test :as t :include-macros true])")
                nil [7178 7418])
            ("cljr-cljs-clojure-test-declaration" variable
               (:documentation "The require form to use when cljs.test is in use in a cljs file."
                :default-value "[cljs.test :as t :include-macros true]")
                nil [7420 7607])
            ("cljr-clojure-test-declaration" variable
               (:documentation "The require form to use when clojure.test is in use in a clj file."
                :default-value "[clojure.test :as t]")
                nil [7609 7775])
            ("cljr-clojure-test-namespace-under-test-alias" variable
               (:documentation "The package alias to use for the namespace under test."
                :default-value "sut")
                nil [7777 7930])
            ("cljr-inject-dependencies-at-jack-in" variable
               (:documentation "When nil, do not inject repl dependencies (most likely nREPL middlewares) at `cider-jack-in' time."
                :default-value t)
                nil [7932 8116])
            ("cljr-assume-language-context" variable (:documentation "If set to 'clj' or 'cljs', clj-refactor will use that value in situations
  where the language context is ambiguous. If set to nil, a popup will be
  created in each ambiguous case asking user to choose language context.") nil [8118 8418])
            ("cljr-libspec-whitelist" variable
               (:documentation "List of regexes to match against libspec names which shouldn't be pruned.

This is useful when `clean-ns' should leave a libspec alone even
if it appears to be unused."
                :default-value '("^cljsns" "^slingshot.test" "^monger.joda-time" "^monger.json"))
                nil [8420 8734])
            ("cljr-minimum-clojure-version" variable
               (:documentation "The oldest clojure version our middleware can tolerate."
                :default-value "1.7.0")
                nil [8736 8841])
            ("clj-refactor-map" variable (:default-value (make-sparse-keymap)) nil [8843 8892])
            ("cljr--add-require-snippet" variable
               (:documentation "The snippet used in in `cljr-add-require-to-ns'"
                :default-value "${1:[${2:${3:} :as ${4:${3:$(cljr--ns-name yas-text)}}}]}")
                nil [8894 9042])
            ("cljr--ns-name" function
               (:documentation "Return the last name in a full NS."
                :arguments ("ns"))
                nil [9044 9152])
            ("cljr--add-use-snippet" variable
               (:documentation "The snippet used in in `cljr-add-use-to-ns'."
                :default-value "[$1 :refer ${2:[$3]}]")
                nil [9154 9257])
            ("*cljr--noninteractive*" variable (:documentation "t, when our interactive functions are called programmatically.") nil [9259 9361])
            ("cljr--file-column-pattern" variable
               (:documentation "A regexp pattern that groups output into filename, line number and column number."
                :default-value "^\\(.+?\\):\\([1-9][0-9]*\\):\\([0-9][0-9]*\\): ")
                nil [9363 9536])
            ("cljr--debug-mode" variable nil nil [9538 9567])
            ("cljr--occurrences" variable nil nil [9569 9599])
            ("cljr--signature-changes" variable nil nil [9600 9636])
            ("cljr--change-signature-buffer" variable (:default-value "*cljr-change-signature*") nil [9637 9701])
            ("cljr--manual-intervention-buffer" variable (:default-value "*cljr-manual-intervention*") nil [9702 9772])
            ("cljr--find-symbol-buffer" variable (:default-value "*cljr-find-usages*") nil [9773 9827])
            ("cljr--post-command-messages" variable (:documentation "Message(s) to display after the current command is done.") nil [9828 9927])
            ("cljr-before-warming-ast-cache-hook" variable (:documentation "Runs before each time the AST is loaded.") nil [9929 10053])
            ("cljr-after-warming-ast-cache-hook" variable (:documentation "Runs after each time the AST is loaded.") nil [10055 10177])
            ("cljr-middleware-ignored-paths" variable (:documentation "List of (Java style) regexes to paths that should be ignored
  by the middleware.") nil [10179 10350])
            ("defvar-local" code nil nil [10424 10500])
            ("defvar-local" code nil nil [10502 10588])
            ("defvar-local" code nil nil [10590 10683])
            ("cljr--update-file" function
               (:documentation "If there is an open buffer for FILENAME, then change that.
Otherwise open the file and do the changes non-interactively."
                :arguments ("filename" "body"))
                nil [10685 11318])
            ("define-key" code nil nil [11320 11393])
            ("define-key" code nil nil [11394 11503])
            ("define-key" code nil nil [11504 11611])
            ("define-key" code nil nil [11612 11663])
            ("cljr--use-multiple-cursors-p" function nil nil [11665 11780])
            ("cljr--vector-at-point-p" function nil nil [11782 11840])
            ("cljr--fix-special-modifier-combinations" function (:arguments ("key")) nil [11842 11975])
            ("cljr--key-pairs-with-modifier" function (:arguments ("modifier" "keys")) nil [11977 12217])
            ("cljr--key-pairs-with-prefix" function (:arguments ("prefix" "keys")) nil [12219 12312])
            ("cljr--all-helpers" variable (:default-value '(("ai" cljr-add-import-to-ns "Add import to ns" 105 ("ns")) ("am" cljr-add-missing-libspec "Add missing libspec" 109 ("ns")) ("ap" cljr-add-project-dependency "Add project dependency" 112 ("ns" "project")) ("ar" cljr-add-require-to-ns "Add require to ns" 114 ("ns")) ("as" cljr-add-stubs "Add stubs for the interface/protocol at point" 115 ("toplevel-form")) ("au" cljr-add-use-to-ns "Add use to ns" 85 ("ns")) ("ci" clojure-cycle-if "Cycle if" 73 ("code")) ("cn" cljr-clean-ns "Clean ns" 99 ("ns")) ("cp" clojure-cycle-privacy "Cycle privacy" 80 ("toplevel-form")) ("cs" cljr-change-function-signature "Change function signature" 67 ("toplevel-form" "project")) ("ct" cljr-cycle-thread "Cycle thread" 116 ("code")) ("dk" cljr-destructure-keys "Destructure keys" 100 ("code")) ("ec" cljr-extract-constant "Extract constant" 99 ("toplevel-form")) ("ed" cljr-extract-def "Extract form as def" 68 ("toplevel-form")) ("ef" cljr-extract-function "Extract function" 101 ("toplevel-form")) ("el" cljr-expand-let "Expand let" 101 ("code")) ("fe" cljr-create-fn-from-example "Create function from example" 102 ("toplevel-form")) ("fu" cljr-find-usages "Find usages" 117 ("project" "code")) ("hd" cljr-hotload-dependency "Hotload dependency" 104 ("project")) ("il" cljr-introduce-let "Introduce let" 108 ("code")) ("is" cljr-inline-symbol "Inline symbol" 105 ("project" "toplevel-form" "code")) ("mf" cljr-move-form "Move form" 109 ("toplevel-form" "project")) ("ml" cljr-move-to-let "Move to let" 109 ("code")) ("pc" cljr-project-clean "Project clean" 99 ("project")) ("pf" cljr-promote-function "Promote function" 112 ("code" "toplevel-form")) ("rf" cljr-rename-file-or-dir "Rename file-or-dir" 114 ("project" "toplevel-form")) ("rl" cljr-remove-let "Remove let" 114 ("code")) ("rm" cljr-require-macro "Add to or extend the require-macros form" 77 ("ns")) ("rs" cljr-rename-symbol "Rename symbol" 115 ("project" "code")) ("sc" cljr-show-changelog "Show the project's changelog" 99 ("cljr")) ("sp" cljr-sort-project-dependencies "Sort project dependencies" 83 ("project")) ("sr" cljr-stop-referring "Stop referring" 116 ("ns")) ("tf" clojure-thread-first-all "Thread first all" 102 ("code")) ("th" clojure-thread "Thread" 84 ("code")) ("tl" clojure-thread-last-all "Thread last all" 76 ("code")) ("ua" clojure-unwind-all "Unwind all" 85 ("code")) ("up" cljr-update-project-dependencies "Update project dependencies" 85 ("project")) ("uw" clojure-unwind "Unwind" 119 ("code")) ("ad" cljr-add-declaration "Add declaration" 100 ("toplevel-form")) ("?" cljr-describe-refactoring "Describe refactoring" 100 ("cljr")) ("hh" hydra-cljr-help-menu/body "Parent menu for hydra menus" 104 ("hydra")) ("hn" hydra-cljr-ns-menu/body "Hydra menu for ns refactorings" 110 ("hydra")) ("hc" hydra-cljr-code-menu/body "Hydra menu for code refactorings" 99 ("hydra")) ("hp" hydra-cljr-project-menu/body "Hydra menu for project refactorings" 112 ("hydra")) ("ht" hydra-cljr-toplevel-form-menu/body "Hydra menu for top level refactorings " 116 ("hydra")) ("hs" hydra-cljr-cljr-menu/body "Hydra menu for self features" 115 ("hydra")))) nil [12314 15780])
            ("defhydra" code nil nil [15783 16591])
            ("defhydra" code nil nil [16593 17899])
            ("defhydra" code nil nil [17901 18918])
            ("defhydra" code nil nil [18920 20049])
            ("defhydra" code nil nil [20051 20445])
            ("defhydra" code nil nil [20447 21039])
            ("cljr--add-keybindings" function
               (:documentation "Build the keymap from the list of keys/functions in `cljr--all-helpers'."
                :arguments ("key-fn"))
                nil [21041 21317])
            ("cljr-add-keybindings-with-prefix" function
               (:documentation "Bind keys in `cljr--all-helpers' under a PREFIX key."
                :arguments ("prefix"))
                nil [21334 21520])
            ("cljr-add-keybindings-with-modifier" function
               (:documentation "Bind keys in `cljr--all-helpers' under a MODIFIER key."
                :arguments ("modifier"))
                nil [21537 21733])
            ("cljr--extract-sexp" function nil nil [21770 21865])
            ("cljr--delete-sexp" function nil nil [21867 21958])
            ("cljr--extract-sexp-as-list" function
               (:documentation "Returns list of strings representing the elements of the SEXP at point.

If optional `with-whitespace' is T sexp elements are not trimmed."
                :arguments ("with-whitespace"))
                nil [21960 22654])
            ("cljr--extract-region" function (:arguments ("beg" "end")) nil [22656 22779])
            ("cljr--comment-line-p" function nil nil [22781 22889])
            ("cljr--search-forward-within-sexp" function
               (:documentation "Searches forward for S in the current sexp.

if SAVE-EXCURSION is T POINT does not move."
                :arguments ("s" "save-excursion"))
                nil [22891 23232])
            ("cljr--goto-toplevel" function nil nil [23234 23361])
            ("cljr--top-level-p" function (:documentation "T unless we're in an s-expression or string.") nil [23363 23471])
            ("cljr--depth-at-point" function (:documentation "Returns the depth in s-expressions, or strings, at point.") nil [23473 23682])
            ("cljr--cleanup-whitespace" function
               (:documentation "Removes blank lines preceding `stuff' as well as trailing whitespace."
                :arguments ("stuff"))
                nil [23684 24113])
            ("cljr--delete-line" function (:documentation "Deletes the current line without introducing whitespace
errors.") nil [24115 24307])
            ("cljr--looking-at-dependency-p" function nil nil [24309 24610])
            ("cljr--just-one-blank-line" function (:documentation "Ensure there's only one blank line at POINT.") nil [24612 24754])
            ("cljr--point-after" function
               (:documentation "Returns POINT after performing ACTIONS.

An action is either the symbol of a function or a two element
list of (fn args) to pass to `apply''"
                :arguments ("actions"))
                nil [24756 25170])
            ("cljr--whitespacep" function
               (:documentation "True if S contains only whitespace."
                :arguments ("s"))
                nil [25172 25290])
            ("cljr--make-room-for-toplevel-form" function nil nil [25292 25644])
            ("cljr--new-toplevel-form" function
               (:documentation "Insert a new toplevel FORM before the form containing POINT."
                :arguments ("form"))
                nil [25646 25803])
            ("cljr--goto-toplevel-forward" function (:documentation "Move forward and up until we reach toplevel.") nil [25805 25938])
            ("cljr--indent-defun" function (:documentation "Indent the toplevel form containing point") nil [25940 26140])
            ("cljr--point-at-text-matching" function
               (:documentation "Return the point after searching in DIRECTION for TEXT.

DIRECTION is either :forward or :backward.

the optional arguments are passed on the to search function.  See
e.g. `re-search-forward'"
                :arguments ("regexp" "direction" "bound" "noerror" "count"))
                nil [26142 26862])
            ("cljr--inside-prefixed-libspec-vector-p" function (:documentation "If we're inside a prefixed libspec vector then point is
assumed to be just inside the []

Note that this function also moves point from the suffix to the prefix.") nil [26864 27223])
            ("cljr--resolve-alias" function
               (:documentation "Look up ALIAS in the ns form.

if alias is util and the ns-from contains

(:require [refactor-nrepl [util s-expresions]])
refactor-nrepl.util will be returned."
                :arguments ("alias"))
                nil [27225 28042])
            ("cljr--point-for-anon-function" function (:documentation "Returns the location of point if the point is currently placed
at the opening parentheses of an anonymous function.") nil [28044 28360])
            ("cljr--goto-fn-definition" function nil nil [28362 29091])
            ("cljr--evenp" function (:arguments ("n")) nil [29093 29165])
            ("cljr--create-msg" function
               (:documentation "Create a msg for the middleware for OP and optionally include
  the kv pairs KVS.

All config settings are included in the created msg."
                :arguments ("op" "kvs"))
                nil [29167 29720])
            ("cljr--post-command-message" function
               (:documentation "Display msg in a post command hook, to ensure it doesn't drown
  in emacs' general chatter."
                :arguments ("format-string" "args"))
                nil [29722 29960])
            ("cljr--post-command-hook" function nil nil [29962 30087])
            ("cljr-show-changelog" function
               (:documentation "Show the changelog for `clj-refactor'.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-show-changelog"
                :user-visible-flag t)
                nil [30089 30423])
            ("cljr--goto-reify" function nil nil [30475 30746])
            ("cljr-reify-to-defrecord" function
               (:documentation "Replace a call to reify with a call to a new constructor.
A new record is created to define this constructor."
                :user-visible-flag t)
                nil [30748 31628])
            ("cljr--locate-project-file" function (:arguments ("file")) nil [31658 31789])
            ("cljr--project-dir" function nil nil [31791 31970])
            ("cljr--inside-project-p" function (:documentation "Return non-nil if `default-directory' is inside a Clojure project.") nil [31972 32121])
            ("cljr--project-file" function nil nil [32123 32629])
            ("cljr--project-files" function nil nil [32631 33023])
            ("cljr--project-with-deps-p" function (:arguments ("project-file")) nil [33025 33116])
            ("cljr--buffers-visiting-dir" function (:arguments ("dir")) nil [33118 33331])
            ("cljr--revisit-buffers" function
               (:documentation "After moving a directory revisit all files visited by BUFFERS
  by looking them up in NEW-DIR.

ACTIVE is the buffer the user was looking at when the command was
issued, and should be left focused."
                :arguments ("buffers" "new-dir" "active"))
                nil [33333 34170])
            ("cljr-rename-file-or-dir" function
               (:documentation "Rename a file or directory of files.
Buffers visiting any affected file are killed and the
corresponding files are revisited.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-rename-file-or-dir"
                :user-visible-flag t
                :arguments ("old-path" "new-path"))
                nil [34187 36299])
            ("cljr-rename-file" function (:arguments ("new-path")) nil [36316 36645])
            ("cljr--op-supported-p" function
               (:documentation "Is the OP we require provided by the current middleware stack?"
                :arguments ("op"))
                nil [36647 36781])
            ("cljr--assert-middleware" function nil nil [36783 37109])
            ("cljr--ensure-op-supported" function
               (:documentation "Check for support of middleware op OP.

Signal an error if it is not supported, otherwise return OP."
                :arguments ("op"))
                nil [37111 37530])
            ("cljr--assert-leiningen-project" function nil nil [37532 37724])
            ("cljr--goto-ns" function (:documentation "Go to the first namespace defining form in the buffer.") nil [37763 38007])
            ("cljr--goto-closest-ns" function (:documentation "Go to the closest namespace defining form.
Go to the namespace form closest to point and above it.  If there is
no namespace form above point, return the first one in the buffer.") nil [38009 38552])
            ("cljr--goto-cljs-branch" function (:documentation "Move POINT to the cljs branch of the reader conditional following point.") nil [38554 38917])
            ("cljr--insert-in-ns" function
               (:documentation "Insert another clause into the TYPE clause of the ns statement.

TYPE is :require, :use etc

If CLJS? is T we insert in the cljs part of the ns declaration."
                :arguments ("type" "cljs?"))
                nil [38919 39644])
            ("cljr--project-depends-on-p" function (:arguments ("package")) nil [39646 39825])
            ("cljr--find-source-ns-of-test-ns" function (:arguments ("test-ns" "test-file")) nil [39827 40734])
            ("cljr--cljs-file-p" function
               (:documentation "Is BUF, or the current buffer, visiting a cljs file?"
                :arguments ("buf"))
                nil [40736 40941])
            ("cljr--cljc-file-p" function
               (:documentation "Is BUF, or the current buffer, visiting a cljc file?"
                :arguments ("buf"))
                nil [40943 41148])
            ("cljr--clj-file-p" function
               (:documentation "Is BUF, or the current buffer, visiting a clj file?"
                :arguments ("buf"))
                nil [41150 41397])
            ("cljr--add-test-declarations" function nil nil [41399 42275])
            ("cljr--in-tests-p" function (:documentation "Check whether the current file is a test file.

Two checks are made - whether the namespace of the file has the
word test in it and whether the file lives under the test/ directory.") nil [42277 42591])
            ("cljr--clojure-ish-filename-p" function (:arguments ("file-name")) nil [42593 42809])
            ("cljr--clojure-filename-p" function (:arguments ("file-name")) nil [42811 42997])
            ("cljr--add-ns-if-blank-clj-file" function nil nil [42999 43342])
            ("add-hook" code nil nil [43344 43402])
            ("cljr--dash-in-file-name-p" function (:arguments ("file-name")) nil [43404 43515])
            ("cljr--maybe-replace-dash-in-file-name" function (:arguments ("file-name")) nil [43517 43855])
            ("cljr--ensure-no-dashes-in-filename" function nil nil [43857 44312])
            ("add-hook" code nil nil [44314 44376])
            ("cljr--get-ns-statements" function (:arguments ("statement-type")) nil [44378 44681])
            ("cljr--get-ns-statements-as-list" function (:arguments ("statement-type")) nil [44683 44889])
            ("cljr--extract-sexp-content" function (:arguments ("sexp")) nil [44891 44982])
            ("cljr--maybe-clean-ns" function nil nil [44984 45177])
            ("cljr--tmp-marker" variable (:default-value (make-marker)) nil [45179 45218])
            ("cljr--pop-tmp-marker-after-yasnippet-1" function (:arguments ("_")) nil [45220 45450])
            ("cljr--pop-tmp-marker-after-yasnippet" function nil nil [45452 45604])
            ("cljr--maybe-eval-ns-form-and-remove-hook" function nil nil [45606 45795])
            ("cljr--maybe-sort-ns" function nil nil [45797 45964])
            ("cljr--sort-and-remove-hook" function (:arguments ("_")) nil [45966 46129])
            ("cljr--add-yas-ns-updated-hook" function nil nil [46131 46359])
            ("cljr-add-require-to-ns" function
               (:documentation "Add a require statement to the ns form in current buffer.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-require-to-ns"
                :user-visible-flag t
                :arguments ("cljs?"))
                nil [46376 46842])
            ("cljr-add-use-to-ns" function
               (:documentation "Add a use statement to the buffer's ns form.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-use-to-ns"
                :user-visible-flag t
                :arguments ("cljs?"))
                nil [46859 47300])
            ("cljr-add-import-to-ns" function
               (:documentation "Add an import statement to the buffer's ns form.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-import-to-ns"
                :user-visible-flag t
                :arguments ("cljs?"))
                nil [47317 47760])
            ("cljr--extract-refer-all-namespaces" function (:documentation "Returns a list of all the namespaces that are required with :refer :all") nil [47762 49101])
            ("cljr-require-macro" function
               (:documentation "Add a require statement for a macro to the ns form in current buffer.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-require-macro"
                :user-visible-flag t)
                nil [49118 49521])
            ("cljr-stop-referring" function
               (:documentation "Stop referring to vars in the namespace at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-stop-referring"
                :user-visible-flag t)
                nil [49538 51622])
            ("cljr--add-ns-prefix" function
               (:documentation "Adds an NS prefix to every symbol in SYMBOLS."
                :arguments ("ns" "symbols"))
                nil [51624 51957])
            ("cljr--insert-with-proper-whitespace" function (:arguments ("forms")) nil [51959 52230])
            ("cljr--slice-at" function
               (:documentation "Slice S up at every index matching PATTERN"
                :arguments ("pattern" "s"))
                nil [52232 52443])
            ("cljr-move-form" function
               (:documentation "Move the form containing POINT to a new namespace.

If REGION is active, move all forms contained by region.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-move-form"
                :user-visible-flag t)
                nil [52460 54948])
            ("cljr--remove-references-of-target-ns" function (:arguments ("forms" "ns" "alias")) nil [54950 55144])
            ("cljr--update-ns-after-moving-fns" function
               (:documentation "Updates the current ns declaration after moving defn forms out of the
  current file and to NS.  Optionally referring the names in REFER-NAMES."
                :arguments ("ns" "refer-names"))
                nil [55146 56151])
            ("cljr--append-refer-clause" function
               (:documentation "Appends :refer [REFER-NAMES] to the :require clause for NS."
                :arguments ("ns" "refer-names"))
                nil [56153 56473])
            ("cljr--append-names-to-refer" function
               (:documentation "Append NAMES to the :refer vector for NS"
                :arguments ("ns" "names"))
                nil [56475 56795])
            ("cljr--new-require-clause" function
               (:documentation "Creates a new :require clause for NS.

Optionally adds :refer [REFER-NAMES] clause."
                :arguments ("ns" "refer-names"))
                nil [56797 57068])
            ("cljr--with-string-content" function (:arguments ("s" "body")) nil [57070 57307])
            ("cljr--name-of-defns" function
               (:documentation "Returns a list of the function names in STRING-WITH-DEFNS,
optionally including those that are declared private."
                :arguments ("string-with-defns" "include-private"))
                nil [57309 57970])
            ("cljr--current-namespace" function nil nil [57972 58231])
            ("cljr--goto-declare" function nil nil [58275 58507])
            ("cljr--name-of-current-def" function nil nil [58509 58861])
            ("cljr--already-declared-p" function (:arguments ("def")) nil [58863 59022])
            ("cljr--add-declaration" function (:arguments ("def")) nil [59024 59294])
            ("cljr-add-declaration" function
               (:documentation "Add a declare for the current def near the top of the buffer.

With a prefix add a declaration for the symbol under the cursor instead.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-declaration"
                :user-visible-flag t
                :arguments ("for-thing-at-point-p"))
                nil [59311 59804])
            ("cljr--existing-group-of-defs-p" function (:documentation "Is there a group of defs at the beginning of the namespace?") nil [59851 60090])
            ("cljr--prepare-to-append-to-existing-group-of-defs" function (:documentation "Place point at the end of the final def form in the group of
defs appearing at the start of the ns.

Point is assumed to be just after the ns form.") nil [60092 60509])
            ("cljr--prepare-to-insert-new-def" function (:documentation "Skip past all previously defined vars at the beginning of the ns.") nil [60511 60777])
            ("cljr--extract-def-at-point" function (:arguments ("const?")) nil [60779 61400])
            ("cljr-extract-constant" function
               (:documentation "Extract form at (or above) point as a constant.
Create a def for it at the top level, and replace its current
occurrence with the defined name.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-constant"
                :user-visible-flag t)
                nil [61417 61733])
            ("cljr-extract-def" function
               (:documentation "Extract form at (or above) point as a def.
Create a def for it at the top level, and replace its current
occurrence with the defined name.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-def"
                :user-visible-flag t)
                nil [61750 62044])
            ("cljr--goto-thread" function nil nil [62046 62192])
            ("cljr--reindent-thread" function nil nil [62194 62351])
            ("cljr-cycle-thread" function
               (:documentation "Cycle a threading macro between -> and ->>.
Also applies to other versions of the macros, like cond->.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-thread"
                :user-visible-flag t)
                nil [62368 62962])
            ("cljr-introduce-let" function
               (:documentation "Create a let form, binding the form at point.
The resulting let form can then be expanded with `\\[cljr-expand-let]'.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-introduce-let"
                :user-visible-flag t
                :arguments ("n"))
                nil [63013 63582])
            ("add-to-list" code nil nil [63584 63647])
            ("cljr--get-let-bindings" function (:documentation "Returns a list of lists. The inner lists contain two elements first is
   the binding, second is the init-expr") nil [63649 63846])
            ("cljr--replace-sexp-with-binding" function (:arguments ("binding")) nil [63848 64195])
            ("cljr--one-shot-keybinding" function (:arguments ("key" "command")) nil [64197 64355])
            ("cljr--paredit-convolute-no-advice" function nil nil [64357 64737])
            ("cljr-expand-let" function
               (:documentation "Expand the let form above point by one level.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-expand-let"
                :user-visible-flag t)
                nil [64754 65222])
            ("cljr--replace-sexp-with-binding-in-let" function nil nil [65224 65454])
            ("cljr-move-to-let" function
               (:documentation "Move the form at point to a binding in the nearest let.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-move-to-let"
                :user-visible-flag t)
                nil [65471 66214])
            ("cljr--eliminate-let" function (:documentation "Remove a the nearest let form.

This function only does the actual removal.") nil [66216 66436])
            ("cljr-remove-let" function
               (:documentation "Inlines all variables in the let form and removes it.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-remove-let"
                :user-visible-flag t)
                nil [66438 66916])
            ("add-to-list" code nil nil [66918 66979])
            ("cljr-destructure-keys" function
               (:documentation "Change a symbol binding at point to a destructuring bind.
Keys to use in the destructuring are inferred from the code, and
their usage is replaced with the new local variables.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-destructure-keys"
                :user-visible-flag t)
                nil [67026 68597])
            ("cljr--goto-if" function nil nil [68629 68781])
            ("cljr-raise-sexp" function
               (:documentation "Like paredit-raise-sexp, but removes # in front of function literals and sets."
                :user-visible-flag t
                :arguments ("argument"))
                nil [68798 69029])
            ("cljr-splice-sexp-killing-backward" function
               (:documentation "Like paredit-splice-sexp-killing-backward, but removes # in
front of function literals and sets."
                :user-visible-flag t
                :arguments ("argument"))
                nil [69046 69331])
            ("cljr-splice-sexp-killing-forward" function
               (:documentation "Like paredit-splice-sexp-killing-backward, but removes # in
front of function literals and sets."
                :user-visible-flag t
                :arguments ("argument"))
                nil [69348 69680])
            ("cljr--magic-requires-re" function nil nil [69716 69810])
            ("cljr--goto-reader-conditional" function (:documentation "Move point just before #?.

Return the value of point if we moved.") nil [69812 70231])
            ("cljr--point-in-reader-conditional-p" function (:documentation "Return t if point is inside a reader conditional.") nil [70233 70388])
            ("cljr--point-in-reader-conditional-branch-p" function
               (:documentation "Is point in a reader conditional branch for FEATURE?

FEATURE is either :clj or :cljs."
                :arguments ("feature"))
                nil [70390 71143])
            ("cljr--clj-context-p" function (:documentation "Is point in a clj context?") nil [71145 71678])
            ("cljr--aget" function (:arguments ("map" "key")) nil [71680 71732])
            ("cljr--call-middleware-for-namespace-aliases" function nil nil [71734 71942])
            ("cljr--get-aliases-from-middleware" function nil nil [71944 72149])
            ("cljr--js-alias-p" function (:arguments ("alias")) nil [72151 72244])
            ("cljr--magic-requires-lookup-alias" function (:documentation "Return (alias (ns.candidate1 ns.candidate1)) if we recognize
the alias in the project.") nil [72246 73230])
            ("cljr--in-keyword-sans-alias-p" function (:documentation "Checks if thing at point is keyword without an alias.") nil [73232 73466])
            ("cljr--in-map-destructuring?" function (:documentation "True when `point' is inside a destructuring form.") nil [73468 73687])
            ("cljr--in-ns-above-point-p" function nil nil [73689 73805])
            ("cljr-slash" function
               (:documentation "Inserts / as normal, but also checks for common namespace shorthands to require.
If `cljr-magic-require-namespaces' is non-nil, typing one of the
short aliases listed in `cljr-magic-requires' followed by this
command will add the corresponding require statement to the ns
form."
                :user-visible-flag t)
                nil [73822 75368])
            ("cljr--in-namespace-declaration-p" function (:arguments ("s")) nil [75370 75494])
            ("cljr--excluded-from-project-clean-p" function (:arguments ("filename")) nil [75530 75752])
            ("cljr-project-clean" function
               (:documentation "Run `cljr-project-clean-functions' on every clojure file, then
sorts the project's dependency vectors.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-project-clean"
                :user-visible-flag t)
                nil [75769 76673])
            ("cljr--extract-dependency-name" function nil nil [76675 77055])
            ("cljr--empty-buffer-p" function (:arguments ("buffer")) nil [77057 77279])
            ("cljr--extract-next-dependency-name" function nil nil [77281 77517])
            ("cljr--get-sorted-dependency-names" function
               (:documentation "Strips metadata and comments"
                :arguments ("deps"))
                nil [77519 77920])
            ("cljr--prepare-sort-buffer" function (:arguments ("sorted-names" "vectors-and-meta" "dividing-line")) nil [77922 78170])
            ("cljr--sort-dependency-vectors-with-meta-and-comments" function (:arguments ("dividing-line")) nil [78172 79590])
            ("cljr--sort-dependency-vectors" function (:arguments ("sorted-names" "vectors-and-meta")) nil [79592 79989])
            ("cljr-sort-project-dependencies" function
               (:documentation "Sorts all dependency vectors in project.clj

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-sort-project-dependencies"
                :user-visible-flag t)
                nil [80006 81169])
            ("cljr--call-middleware-sync" function
               (:documentation "Call the middleware with REQUEST.

If it's present KEY indicates the key to extract from the response."
                :arguments ("request" "key"))
                nil [81171 81571])
            ("cljr--call-middleware-async" function (:arguments ("request" "callback")) nil [81573 81683])
            ("cljr--get-artifacts-from-middleware" function (:arguments ("force")) nil [81685 82056])
            ("cljr--update-artifact-cache" function nil nil [82058 82398])
            ("cljr--dictionary-lessp" function
               (:documentation "return t if STR1 is < STR2 when doing a dictionary compare
(splitting the string at numbers and doing numeric compare with them).
It is optimized for version comparisons, in that empty strings are sorted
before non-empty. This lets 1.7.0 be sorted above 1.7.0-RC1."
                :arguments ("str1" "str2"))
                nil [82400 82890])
            ("cljr--dict-lessp" function
               (:documentation "compare the two lists of strings & numbers"
                :arguments ("slist1" "slist2"))
                nil [82892 83666])
            ("cljr--dict-split" function
               (:documentation "split a string into a list of number and non-number components"
                :arguments ("str"))
                nil [83668 84354])
            ("cljr--get-versions-from-middleware" function (:arguments ("artifact")) nil [84356 84695])
            ("cljr--prompt-user-for" function
               (:documentation "Prompt the user with PROMPT.

If CHOICES is provided provide a completed read among the
possible choices. If the choice is trivial, return it."
                :arguments ("prompt" "choices"))
                nil [84697 85083])
            ("cljr--insert-into-leiningen-dependencies" function (:arguments ("artifact" "version")) nil [85085 85303])
            ("cljr--insert-into-clj-dependencies" function (:arguments ("artifact" "version")) nil [85305 85508])
            ("cljr--add-project-dependency" function (:arguments ("artifact" "version")) nil [85510 86141])
            ("cljr-add-project-dependency" function
               (:documentation "Add a dependency to the project.clj file.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-project-dependency"
                :user-visible-flag t
                :arguments ("force"))
                nil [86158 86742])
            ("cljr-update-project-dependency" function
               (:documentation "Update the version of the dependency at point."
                :user-visible-flag t
                :arguments ("version"))
                nil [86759 87789])
            ("cljr-update-project-dependencies" function
               (:documentation "Update all project dependencies.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-update-project-dependencies"
                :user-visible-flag t)
                nil [87806 88344])
            ("cljr--update-dependencies" function (:arguments ("keyword" "dependency-closing-brace" "forward-count")) nil [88346 88851])
            ("cljr--skip-past-whitespace-and-comments" function nil nil [88853 89034])
            ("cljr--extract-anon-fn-name" function (:arguments ("sexp-str")) nil [89036 89185])
            ("cljr--highlight" function (:arguments ("start" "end")) nil [89187 89372])
            ("cljr--highlight-sexp" function nil nil [89374 89470])
            ("cljr--string-present-p" function (:arguments ("s")) nil [89472 89547])
            ("cljr--promote-fn" function nil nil [89549 91447])
            ("cljr--append-fn-parameter" function (:arguments ("param")) nil [91449 91666])
            ("cljr--promote-function-literal" function nil nil [91668 92609])
            ("cljr-promote-function" function
               (:documentation "Promote a function literal to an fn, or an fn to a defn.
With prefix PROMOTE-TO-DEFN, promote to a defn even if it is a
function literal.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-promote-function"
                :user-visible-flag t
                :arguments ("promote-to-defn"))
                nil [92626 93515])
            ("add-to-list" code nil nil [93517 93583])
            ("cljr--insert-in-find-symbol-buffer" function (:arguments ("occurrence")) nil [93585 93756])
            ("cljr--end-of-buffer-p" function (:documentation "True if point is at end of buffer") nil [93758 93877])
            ("cljr--find-symbol-sync" function (:arguments ("symbol" "ns")) nil [93879 94872])
            ("cljr--find-symbol" function (:arguments ("symbol" "ns" "callback")) nil [94874 95908])
            ("cljr--first-line" function (:arguments ("s")) nil [95910 96010])
            ("cljr--project-relative-path" function
               (:documentation "Denormalize PATH to make to make it relative to the project
root."
                :arguments ("path"))
                nil [96012 96174])
            ("cljr--get-valid-filename" function
               (:documentation "Get :file value from the hash table and convert path if necessary."
                :arguments ("hash"))
                nil [96176 96354])
            ("cljr--format-symbol-occurrence" function (:arguments ("occurrence")) nil [96356 96712])
            ("cljr--format-and-insert-symbol-occurrence" function (:arguments ("occurrence-resp")) nil [96714 97798])
            ("cljr--finalise-find-symbol-buffer" function (:arguments ("total")) nil [97800 98130])
            ("cljr--setup-find-symbol-buffer" function (:arguments ("symbol-name")) nil [98132 98869])
            ("cljr--asts-y-or-n-p" function nil nil [98871 99172])
            ("cljr-find-usages" function
               (:documentation "Find all usages of the symbol at point in the project.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-find-usages"
                :user-visible-flag t)
                nil [99189 99902])
            ("cljr--rename-occurrence" function (:arguments ("file" "line-beg" "col-beg" "line-end" "col-end" "name" "new-name")) nil [99904 100947])
            ("cljr--rename-occurrences" function (:arguments ("occurrences" "new-name")) nil [100949 101574])
            ("cljr-rename-symbol" function
               (:documentation "Rename the symbol at point and all of its occurrences.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-rename-symbol"
                :user-visible-flag t
                :arguments ("new-name"))
                nil [101591 102676])
            ("cljr--replace-refer-all-with-alias" function (:arguments ("ns" "publics-occurrences" "alias")) nil [102678 103108])
            ("cljr--replace-refer-all" function
               (:documentation "Replaces :refer :all style require with alias :as style require.

Also adds the alias prefix to all occurrences of public symbols in the namespace.
"
                :arguments ("ns" "alias"))
                nil [103110 103900])
            ("cljr--maybe-nses-in-bad-state" function (:arguments ("response")) nil [103902 104653])
            ("cljr--warm-ast-cache" function nil nil [104655 105034])
            ("cljr--replace-ns" function (:arguments ("new-ns")) nil [105036 105198])
            ("cljr--clean-ns" function
               (:documentation "If PATH is passed use that instead of the path to the current buffer

If NO-PRUNE is passed, the default is overridden and unused stuff isn't removed."
                :arguments ("path" "no-prune?"))
                nil [105200 106193])
            ("cljr-clean-ns" function
               (:documentation "Clean the ns form for the current buffer.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-clean-ns"
                :user-visible-flag t)
                nil [106210 106453])
            ("cljr--narrow-candidates" function (:arguments ("candidates" "symbol")) nil [106455 106868])
            ("cljr--insert-libspec-verbosely" function (:arguments ("libspec")) nil [106870 107030])
            ("cljr--insert-missing-import" function (:arguments ("missing")) nil [107032 107176])
            ("cljr--qualified-symbol-p" function (:arguments ("symbol")) nil [107178 107319])
            ("cljr--symbol-prefix" function
               (:documentation "java.util.Date => java.util
str/split => str
split => ''"
                :arguments ("symbol"))
                nil [107321 107623])
            ("cljr--insert-missing-require" function
               (:documentation "Require MISSING-SYMBOL.

Inspect SYMBOL, the thing at point, to find out whether we have
to create an alias or refer."
                :arguments ("symbol" "missing-symbol" "type"))
                nil [107625 108639])
            ("cljr--add-missing-libspec" function (:arguments ("symbol" "candidates")) nil [108641 109569])
            ("cljr--symbol-suffix" function
               (:documentation "java.util.Date => Date
Date => Date
clojure.string/split => split
str/split => split"
                :arguments ("symbol"))
                nil [109571 110003])
            ("cljr--normalize-symbol-name" function
               (:documentation "Removes reader macros and quoting

Date. -> Date
@sym => sym
#'sym => sym
'sym => sym
~sym => sym
~@sym => sym"
                :arguments ("name"))
                nil [110005 110847])
            ("cljr--call-middleware-to-resolve-missing" function (:arguments ("symbol")) nil [110849 111404])
            ("cljr--get-error-value" function
               (:documentation "Gets the error value from the middleware response.

We can't simply call `nrepl-dict-get' because the error value
itself might be `nil'."
                :arguments ("response"))
                nil [111406 112286])
            ("cljr--format-escape" function
               (:documentation "Make the message consumable by format."
                :arguments ("msg"))
                nil [112288 112406])
            ("cljr--maybe-rethrow-error" function (:arguments ("response")) nil [112408 112555])
            ("cljr--maybe-eval-ns-form" function nil nil [112557 112675])
            ("cljr-add-missing-libspec" function
               (:documentation "Requires or imports the symbol at point.

If the symbol at point is of the form str/join then the ns
containing join will be aliased to str.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-missing-libspec"
                :user-visible-flag t)
                nil [112692 113390])
            ("cljr--dependency-at-point" function (:documentation "Returns project dependency at point.

Recognizes both leiningen- and deps.edn-style dependencies, but the latter is always
transformed back to leiningen dependency vector which is what nrepl backend
expects for hot-loading.") nil [113392 114100])
            ("cljr-hotload-dependency" function
               (:documentation "Download a dependency (if needed) and hotload it into the current repl session.

Defaults to the dependency vector at point, but prompts if none is found.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-hotload-dependency"
                :user-visible-flag t)
                nil [114117 114493])
            ("cljr--defn-str" function (:arguments ("public")) nil [114495 114761])
            ("cljr--call-middleware-to-find-used-locals" function (:arguments ("file" "line" "column")) nil [114763 115005])
            ("cljr--goto-enclosing-sexp" function nil nil [115007 115216])
            ("cljr-extract-function" function
               (:documentation "Extract the form at (or above) point as a top-level defn.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-function"
                :user-visible-flag t)
                nil [115233 116799])
            ("add-to-list" code nil nil [116801 116867])
            ("cljr--at-end-of-symbol-at-point" function nil nil [116869 116982])
            ("cljr--insert-function-stubs" function (:arguments ("functions")) nil [116984 117395])
            ("cljr-add-stubs" function
               (:documentation "Adds implementation stubs for the interface or protocol at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-stubs"
                :user-visible-flag t)
                nil [117412 118368])
            ("cljr--delete-definition" function
               (:documentation "Delete a definition as part of inlining a symbol."
                :arguments ("definition"))
                nil [118370 119365])
            ("cljr--sort-occurrences" function
               (:documentation "Sort the OCCURRENCES so the last ones in the file comes first."
                :arguments ("occurrences"))
                nil [119367 120065])
            ("cljr--inline-fn-at-call-site" function
               (:documentation "Point is at a call site, where the sexp call-site has just
  been extracted."
                :arguments ("def" "call-site"))
                nil [120067 120890])
            ("cljr--inline-symbol" function (:arguments ("definition" "occurrences")) nil [120892 122015])
            ("cljr--var-info" function
               (:documentation "Like `cider-var-info' but also handles locally bound vars.

If SYMBOL is passed we assume it's a global var and look it up.

If SYMBOL is nil the symbol at point is used and we consider
locals in that context.

If the symbol is bound locally nil will be returned.

ALL has the same meaning as for `cider-var-info'"
                :arguments ("symbol" "all"))
                nil [122017 122796])
            ("cljr-inline-symbol" function
               (:documentation "Inline the symbol at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-inline-symbol"
                :user-visible-flag t)
                nil [122813 124784])
            ("cljr--version" function
               (:documentation "Get the version of `clj-refactor' from the package header.

if REMOVE-PACKAGE_VERSION is t get rid of the (package: 20150828.1048) suffix."
                :arguments ("remove-package-version"))
                nil [124786 125250])
            ("cljr--middleware-version" function nil nil [125252 125357])
            ("cljr--check-middleware-version" function (:documentation "Check whether clj-refactor and nrepl-refactor versions are the same") nil [125359 126336])
            ("cljr-version" function
               (:documentation "Returns the version of the middleware as well as this package."
                :user-visible-flag t)
                nil [126353 126626])
            ("cljr-toggle-debug-mode" function nil nil [126643 126828])
            ("cljr--check-clojure-version" function nil nil [126830 127435])
            ("cljr--init-middleware" function nil nil [127437 127944])
            ("cljr--list-fold-function-names" variable (:default-value '("map" "mapv" "pmap" "keep" "mapcat" "filter" "remove" "take-while" "drop-while" "group-by" "partition-by" "some" "every?" "not-every?" "not-any?")) nil [127946 128140])
            ("cljr--list-fold-function-names-with-index" variable (:default-value '("map-indexed" "keep-indexed")) nil [128142 128226])
            ("cljr--ns-path" function
               (:documentation "Find the file path to the ns named NS-NAME."
                :arguments ("ns-name"))
                nil [128228 128413])
            ("cljr-create-fn-from-example" function
               (:documentation "Create a top-level defn for the symbol at point.
The context in which symbol is being used should be that of a
function, and the arglist of the defn is guessed from this
context.

For instance, if the symbol is the first argument of a `map'
call, the defn is created with one argument. If it is the first
argument of a `reduce', the defn will take two arguments.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-create-fn-from-example"
                :user-visible-flag t)
                nil [128430 131459])
            ("cljr--create-fn-from-list-fold" function (:arguments ("args" "path")) nil [131461 131845])
            ("cljr--create-fn-from-list-fold-with-index" function (:arguments ("args" "path")) nil [131847 132314])
            ("cljr--create-fn-from-update" function (:arguments ("args" "path")) nil [132316 132651])
            ("cljr--create-fn-from-update-in" function (:arguments ("path")) nil [132653 133123])
            ("cljr--create-fn-from-sort" function (:arguments ("args" "path")) nil [133125 133660])
            ("cljr--create-fn-from-sort-by" function (:arguments ("args" "path")) nil [133662 134612])
            ("cljr--create-fn-from-reduce" function (:arguments ("args" "path")) nil [134614 134945])
            ("cljr--unwind-and-extract-this-as-list" function (:arguments ("name")) nil [134947 135287])
            ("cljr--unwind-s" function (:arguments ("s")) nil [135289 135470])
            ("cljr--keywordp" function (:arguments ("s")) nil [135472 135602])
            ("cljr--symbolp" function
               (:documentation "True when S is a symbol."
                :arguments ("s"))
                nil [135604 135759])
            ("cljr--keyword-lookup-p" function (:arguments ("s")) nil [135761 135849])
            ("cljr--first-fn-call-s" function (:arguments ("s")) nil [135851 136000])
            ("cljr--first-arg-s" function (:arguments ("s")) nil [136002 136183])
            ("cljr--last-arg-s" function (:arguments ("s")) nil [136185 136343])
            ("cljr--fns-that-get-item-out-of-coll" variable (:default-value (list "first" "second" "last" "fnext" "nth" "rand-nth")) nil [136345 136447])
            ("cljr--strip-keyword-ns" function (:arguments ("s")) nil [136449 136580])
            ("cljr--dashed-words" function
               (:documentation "Take the string S and replace all the word separators with '-'
and make the whole string lower-cased."
                :arguments ("s"))
                nil [136582 136922])
            ("cljr--guess-param-name" function (:arguments ("form")) nil [136924 138108])
            ("cljr--semantic-noops--first-position" variable (:default-value (list "assoc" "assoc-in" "update" "update-in" "dissoc" "conj" "concat" "cycle" "rest" "nthrest" "nthnext" "next" "nnext" "butlast" "reverse" "vec" "set" "distinct")) nil [138110 138338])
            ("cljr--semantic-noops--last-position" variable (:default-value (list "filter" "filterv" "remove" "take-nth" "cons" "drop" "drop-while" "take-last" "take" "take-while" "drop-last" "sort" "sort-by")) nil [138340 138528])
            ("cljr--strip-off-semantic-noops" function
               (:documentation "The idea here is that each of these functions, when called on
   something, doesn't truly change what that something is - so we
   can ignore them when trying to figure out a name for a parameter."
                :arguments ("form"))
                nil [138530 139575])
            ("cljr--find-param-name-from-get-in" function (:arguments ("form")) nil [139577 139978])
            ("cljr--find-param-name-from-get" function (:arguments ("form")) nil [139980 140309])
            ("cljr--insert-example-fn" function
               (:documentation "Create a new function from NAME and ARGS.

If PATH is non-nil append the new function to the end of the file
at PATH."
                :arguments ("name" "args" "path"))
                nil [140311 141085])
            ("cljr--extract-wiki-description" function (:arguments ("description-buffer")) nil [141087 141369])
            ("cljr-describe-refactoring" function
               (:documentation "Show the wiki page, in emacs, for one of the available refactorings.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-describe-refactoring"
                :user-visible-flag t
                :arguments ("cljr-fn"))
                nil [141386 142297])
            ("cljr--get-function-params" function
               (:documentation "Retrieve the parameters for FN."
                :arguments ("fn"))
                nil [142299 142866])
            ("cljr--change-signature-mode-map" variable (:default-value (let ((keymap (make-sparse-keymap))) (define-key keymap (kbd "M-n") #'cljr--move-param-down) (define-key keymap (kbd "M-p") #'cljr--move-param-up) (define-key keymap (kbd "C-c C-k") #'cljr--abort-signature-edit) (define-key keymap (kbd "q") #'cljr--abort-signature-edit) (define-key keymap (kbd "e") #'cljr--edit-parameter-name) (define-key keymap (kbd "C-c C-c") #'cljr--commit-signature-edit) (define-key keymap (kbd "RET") #'cljr--commit-signature-edit) keymap)) nil [142868 143407])
            ("cljr--abort-signature-edit" function nil nil [143409 143508])
            ("cljr--move-line-up" function (:documentation "Move the current line up.") nil [143510 143673])
            ("cljr--move-line-down" function
               (:documentation "Move the current line down."
                :user-visible-flag t)
                nil [143675 143899])
            ("cljr--signature-change-at-index" function (:arguments ("signature-changes" "i")) nil [143901 144057])
            ("cljr--dec-parameter-index" function nil nil [144059 144561])
            ("cljr--inc-parameter-index" function nil nil [144563 145065])
            ("cljr--move-param-down" function nil nil [145067 145472])
            ("cljr--move-param-up" function nil nil [145474 145852])
            ("cljr--edit-parameter-name" function nil nil [145854 146461])
            ("cljr--defnp" function (:arguments ("match")) nil [146463 146738])
            ("cljr--update-parameter-name" function (:arguments ("new-name")) nil [146740 146879])
            ("cljr--forward-parameter" function (:documentation "Move point forward across one parameter.

This includes skipping past any type information added by
prismatic/schema and moving paste any whitespace") nil [146881 147229])
            ("cljr--update-signature-names" function
               (:documentation "Point is assumed to be at the the first character in the
  lambda list.

Updates the names of the function parameters."
                :arguments ("signature-changes"))
                nil [147231 147643])
            ("cljr--delete-and-extract-region" function (:arguments ("beg" "end")) nil [147645 147779])
            ("cljr--delete-and-extract-function-parameter" function nil nil [147781 148459])
            ("cljr--maybe-wrap-form" function (:documentation "Insert newlines in or prior to the current form to prevent long lines.

Point is assumed to be at the end of the form.") nil [148461 149265])
            ("cljr--update-signature-order" function
               (:documentation "Point is assumed to be at the first character in the lambda list.

Updates the ordering of the function parameters."
                :arguments ("signature-changes"))
                nil [149267 150480])
            ("cljr--goto-lambda-list" function (:documentation "Move into the lambda list of the function definition beginning
at point.

E.g. move point from here:  |(defn foo [bar baz] ...)
to here:  (defn foo [|bar baz] ...)") nil [150482 150882])
            ("cljr--update-function-signature" function
               (:documentation "Point is assumed to be just prior to the function definition
  we're about to update."
                :arguments ("signature-changes"))
                nil [150884 151213])
            ("cljr--call-site-p" function
               (:documentation "Is point at a call-site for FN?"
                :arguments ("fn"))
                nil [151215 151450])
            ("cljr--no-changes-to-parameter-order-p" function (:arguments ("signature-changes")) nil [151452 151629])
            ("cljr--update-call-site" function
               (:documentation "Point is assumed to be at the name of the function being
called."
                :arguments ("signature-changes"))
                nil [151631 152353])
            ("cljr--append-to-manual-intervention-buffer" function (:documentation "Append the current line to the buffer of stuff requiring
manual intervention.") nil [152355 152846])
            ("cljr--update-apply-call-site" function
               (:documentation "Update a call-site where apply is used to call the function
  whose signature we're currently editing.

point is assumed to be at the function name"
                :arguments ("signature-changes"))
                nil [152848 154157])
            ("cljr--update-partial-call-site" function
               (:documentation "Update a call-site with partial application of the function
  whose signature we're currently editing.

This only handles the case where we have (partial my-fn a b c)
and only parameters a b or c are affected.

point is assumed to be at the function name"
                :arguments ("signature-changes"))
                nil [154159 155664])
            ("cljr--apply-call-site-p" function (:documentation "Is the function invocation at this place being done using
  apply?

Point is assumed to be at the function being called.") nil [155666 155950])
            ("cljr--partial-call-site-p" function (:documentation "Is the function invocation at this place being done using
  partial.

Point is assumed to be at the function being called.") nil [155952 156242])
            ("cljr--ignorable-occurrence-p" function nil nil [156244 156358])
            ("cljr--change-function-signature" function (:arguments ("occurrences" "signature-changes")) nil [156360 158029])
            ("cljr--commit-signature-edit" function nil nil [158031 158209])
            ("define-derived-mode" code nil nil [158211 158350])
            ("cljr--setup-change-signature-buffer" function (:arguments ("control-buffer" "params")) nil [158352 159515])
            ("cljr-change-function-signature" function
               (:documentation "Change the function signature of the function at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-change-function-signature"
                :user-visible-flag t)
                nil [159532 160346])
            ("cljr--inject-middleware-p" function
               (:documentation "Return non-nil if nREPL middleware should be injected."
                :arguments ("_"))
                nil [160363 160492])
            ("cljr--inject-jack-in-dependencies" function (:documentation "Inject the REPL dependencies of clj-refactor at `cider-jack-in'.
If injecting the dependencies is not preferred set `cljr-inject-dependencies-at-jack-in' to nil.") nil [160509 161229])
            ("eval-after-load" code nil nil [161246 161309])
            ("add-hook" code nil nil [161311 161367])
            ("define-obsolete-variable-alias" code nil nil [161414 161518])
            ("define-obsolete-variable-alias" code nil nil [161519 161633])
            ("define-obsolete-function-alias" code nil nil [161635 161713])
            ("define-obsolete-function-alias" code nil nil [161714 161812])
            ("define-obsolete-function-alias" code nil nil [161813 161909])
            ("define-obsolete-function-alias" code nil nil [161910 161988])
            ("define-obsolete-function-alias" code nil nil [161989 162075])
            ("define-obsolete-function-alias" code nil nil [162076 162168])
            ("define-obsolete-function-alias" code nil nil [162169 162251])
            ("make-obsolete" code nil nil [162252 162392])
            ("define-minor-mode" code nil nil [162442 162753])
            ("clj-refactor" package nil nil [162755 162778]))          
      :file "clj-refactor.el"
      :pointmax 162809
      :fsize 162810
      :lastmodtime '(23432 34335 372837 376000)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table-167cf68"
      :file "clj-refactor-compat.el"
      :fsize 5395
      :lastmodtime '(23432 34335 416170 768000)))
  :file "!home!lk!.emacs.d!elpa!clj-refactor-20180826.2149!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
