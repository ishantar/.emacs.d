;;; Quickstart file to activate all packages at startup  -*- lexical-binding:t -*-
;; ¡¡ This file is autogenerated by `package-quickstart-refresh', DO NOT EDIT !!

(let ((load-file-name "/home/lk/.emacs.d/elpa/dash-20180910.1856/dash-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/dash-20180910.1856/dash-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dash" '("!cdr" "!cons" "--" "->" "-a" "-butlast" "-c" "-d" "-e" "-f" "-gr" "-i" "-keep" "-l" "-m" "-non" "-only-some" "-p" "-r" "-s" "-t" "-u" "-value-to-list" "-when-let" "-zip" "dash-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/s-20180406.808/s-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/s-20180406.808/s-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "s" '("s-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/deferred-20170901.1330/deferred-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/deferred-20170901.1330/deferred-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "deferred" '("deferred:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/request-20170201.147/request-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/request-20170201.147/request-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "request" '("request-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/request-deferred-20160419.2305/request-deferred-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/request-deferred-20160419.2305/request-deferred-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "request-deferred" '("request-deferred")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/epl-20180205.2049/epl-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/epl-20180205.2049/epl-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "epl" '("epl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pkg-info-20150517.1143/pkg-info-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pkg-info-20150517.1143/pkg-info-autoloads.el") (car load-path))))



(autoload 'pkg-info-library-original-version "pkg-info" "\
Get the original version in the header of LIBRARY.

The original version is stored in the X-Original-Version header.
This header is added by the MELPA package archive to preserve
upstream version numbers.

LIBRARY is either a symbol denoting a named feature, or a library
name as string.

If SHOW is non-nil, show the version in the minibuffer.

Return the version from the header of LIBRARY as list.  Signal an
error if the LIBRARY was not found or had no X-Original-Version
header.

See Info node `(elisp)Library Headers' for more information
about library headers.

\(fn LIBRARY &optional SHOW)" t nil)

(autoload 'pkg-info-library-version "pkg-info" "\
Get the version in the header of LIBRARY.

LIBRARY is either a symbol denoting a named feature, or a library
name as string.

If SHOW is non-nil, show the version in the minibuffer.

Return the version from the header of LIBRARY as list.  Signal an
error if the LIBRARY was not found or had no proper header.

See Info node `(elisp)Library Headers' for more information
about library headers.

\(fn LIBRARY &optional SHOW)" t nil)

(autoload 'pkg-info-defining-library-original-version "pkg-info" "\
Get the original version of the library defining FUNCTION.

The original version is stored in the X-Original-Version header.
This header is added by the MELPA package archive to preserve
upstream version numbers.

If SHOW is non-nil, show the version in mini-buffer.

This function is mainly intended to find the version of a major
or minor mode, i.e.

   (pkg-info-defining-library-version 'flycheck-mode)

Return the version of the library defining FUNCTION.  Signal an
error if FUNCTION is not a valid function, if its defining
library was not found, or if the library had no proper version
header.

\(fn FUNCTION &optional SHOW)" t nil)

(autoload 'pkg-info-defining-library-version "pkg-info" "\
Get the version of the library defining FUNCTION.

If SHOW is non-nil, show the version in mini-buffer.

This function is mainly intended to find the version of a major
or minor mode, i.e.

   (pkg-info-defining-library-version 'flycheck-mode)

Return the version of the library defining FUNCTION.  Signal an
error if FUNCTION is not a valid function, if its defining
library was not found, or if the library had no proper version
header.

\(fn FUNCTION &optional SHOW)" t nil)

(autoload 'pkg-info-package-version "pkg-info" "\
Get the version of an installed PACKAGE.

If SHOW is non-nil, show the version in the minibuffer.

Return the version as list, or nil if PACKAGE is not installed.

\(fn PACKAGE &optional SHOW)" t nil)

(autoload 'pkg-info-version-info "pkg-info" "\
Obtain complete version info for LIBRARY and PACKAGE.

LIBRARY is a symbol denoting a named feature, or a library name
as string.  PACKAGE is a symbol denoting an ELPA package.  If
omitted or nil, default to LIBRARY.

If SHOW is non-nil, show the version in the minibuffer.

When called interactively, prompt for LIBRARY.  When called
interactively with prefix argument, prompt for PACKAGE as well.

Return a string with complete version information for LIBRARY.
This version information contains the version from the headers of
LIBRARY, and the version of the installed PACKAGE, the LIBRARY is
part of.  If PACKAGE is not installed, or if the PACKAGE version
is the same as the LIBRARY version, do not include a package
version.

\(fn LIBRARY &optional PACKAGE SHOW)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pkg-info" '("pkg-info-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ycmd-20180724.1256/ycmd-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ycmd-20180724.1256/ycmd-autoloads.el") (car load-path))))



(autoload 'ycmd-mode "ycmd" "\
Minor mode for interaction with the ycmd completion server.

When called interactively, toggle `ycmd-mode'.  With prefix ARG,
enable `ycmd-mode' if ARG is positive, otherwise disable it.

When called from Lisp, enable `ycmd-mode' if ARG is omitted,
nil or positive.  If ARG is `toggle', toggle `ycmd-mode'.
Otherwise behave as if called interactively.

\\{ycmd-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'ycmd-setup "ycmd" "\
Setup `ycmd-mode'.

Hook `ycmd-mode' into modes in `ycmd-file-type-map'.

\(fn)" t nil)

(defvar global-ycmd-mode nil "\
Non-nil if Global Ycmd mode is enabled.
See the `global-ycmd-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-ycmd-mode'.")

(custom-autoload 'global-ycmd-mode "ycmd" nil)

(autoload 'global-ycmd-mode "ycmd" "\
Toggle Ycmd mode in all buffers.
With prefix ARG, enable Global Ycmd mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Ycmd mode is enabled in all buffers where
`ycmd--maybe-enable-mode' would do it.
See `ycmd-mode' for more information on Ycmd mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ycmd" '("ycmd-")))



(autoload 'ycmd-eldoc-setup "ycmd-eldoc" "\
Setup eldoc for `ycmd-mode'.

\(fn)" t nil)

(autoload 'ycmd-eldoc-mode "ycmd-eldoc" "\
Toggle ycmd eldoc mode.

If called interactively, enable Ycmd-Eldoc mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ycmd-eldoc" '("ycmd-eldoc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ycmd-next-error" '("ycmd-next-error-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ycm-20150822.1836/ycm-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ycm-20150822.1836/ycm-autoloads.el") (car load-path))))



(autoload 'ycm-query-completions "ycm" "\
Queries YCMD for completions, then calls callback with the results.

\(fn CALLBACK)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ycm" '("ycm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/yasnippet-20181007.2230/yasnippet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/yasnippet-20181007.2230/yasnippet-autoloads.el") (car load-path))))



(autoload 'yas-minor-mode "yasnippet" "\
Toggle YASnippet mode.

If called interactively, enable Yas minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When YASnippet mode is enabled, `yas-expand', normally bound to
the TAB key, expands snippets of code depending on the major
mode.

With no argument, this command toggles the mode.
positive prefix argument turns on the mode.
Negative prefix argument turns off the mode.

Key bindings:
\\{yas-minor-mode-map}

\(fn &optional ARG)" t nil)

(defvar yas-global-mode nil "\
Non-nil if Yas-Global mode is enabled.
See the `yas-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `yas-global-mode'.")

(custom-autoload 'yas-global-mode "yasnippet" nil)

(autoload 'yas-global-mode "yasnippet" "\
Toggle Yas minor mode in all buffers.
With prefix ARG, enable Yas-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Yas minor mode is enabled in all buffers where
`yas-minor-mode-on' would do it.
See `yas-minor-mode' for more information on Yas minor mode.

\(fn &optional ARG)" t nil)
(autoload 'snippet-mode "yasnippet" "A mode for editing yasnippets" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yasnippet" '("help-snippet-def" "snippet-mode-map" "yas")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/yasnippet-snippets-20180922.1928/yasnippet-snippets-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/yasnippet-snippets-20180922.1928/yasnippet-snippets-autoloads.el") (car load-path))))



(autoload 'yasnippet-snippets-initialize "yasnippet-snippets" "\


\(fn)" nil nil)

(eval-after-load 'yasnippet '(yasnippet-snippets-initialize))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yasnippet-snippets" '("yasnippet-snippets-dir")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/yasnippet-classic-snippets-1.0.2/yasnippet-classic-snippets-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/yasnippet-classic-snippets-1.0.2/yasnippet-classic-snippets-autoloads.el") (car load-path))))


 (eval-after-load 'yasnippet '(require 'yasnippet-classic-snippets))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yasnippet-classic-snippets" '("yasnippet-classic-snippets-dir")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/yafolding-20170305.317/yafolding-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/yafolding-20170305.317/yafolding-autoloads.el") (car load-path))))



(defvar yafolding-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "<C-S-return>") #'yafolding-hide-parent-element) (define-key map (kbd "<C-M-return>") #'yafolding-toggle-all) (define-key map (kbd "<C-return>") #'yafolding-toggle-element) map))

(autoload 'yafolding-mode "yafolding" "\
Toggle yafolding mode.

If called interactively, enable Yafolding mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yafolding" '("yafolding-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xtest-20141214.1706/xtest-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xtest-20141214.1706/xtest-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xtest" '("xt-" "xtd-" "xtest-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-title-20091203.1023/xterm-title-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-title-20091203.1023/xterm-title-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-title" '("xterm-title-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-keybinder-20160523.56/xterm-keybinder-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-keybinder-20160523.56/xterm-keybinder-autoloads.el") (car load-path))))



(autoload 'xterm-keybinder-setup "xterm-keybinder" "\
Enable Emacs keybinds even in the xterm terminal Emacs.

\(fn)" t nil)

(autoload 'urxvt-keybinder-insert "xterm-keybinder" "\
Insert urxvt setting.

\(fn)" t nil)

(autoload 'urxvt-change-font-size "xterm-keybinder" "\
Change font size in URxvt.

OFFSET is a variable to increase/decrease the font size from
current font size.

Optional variable FONT is the font name and as the default value,
this functions uses the value that you will set in
‘urxvt-keybinder-setup’.

If you set optional ABSOLUTE-SIZE variable, this function priors
the size than OFFSET and sets the ABSOLUTE-SIZE.

\(fn OFFSET &optional FONT ABSOLUTE-SIZE)" nil nil)

(autoload 'urxvt-keybinder-setup "xterm-keybinder" "\
Setup function for URxvt.
You can also set FONT name and the SIZE.

If you set BOTH FONT and SIZE, you can use ‘text-scale-increase’
and ‘text-scale-decrease’ functions to adjust font size inside
URxvt frame.

\(fn &optional FONT SIZE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-keybinder" '("urxvt-font-" "xterm-keybinder-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-frobs-20161207.1609/xterm-frobs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-frobs-20161207.1609/xterm-frobs-autoloads.el") (car load-path))))



(autoload 'xterm-iconify "xterm-frobs" "\
Minimize (iconify) xterm window.

\(fn)" t nil)

(autoload 'xterm-deiconify "xterm-frobs" "\
Restore (deiconify) xterm window.

\(fn)" t nil)

(autoload 'xterm-set-font "xterm-frobs" "\
Set the font of the xterm window to FONT.
When called interactively, prompt for the name of the font to use.

This function is used to change the font of the xterm window in which a
tty-mode emacs is running.  It should also work if emacs is running under
`screen' in an xterm window.

Use \\[set-default-font] if this emacs is using the window system directly.

\(fn FONT-NAME)" t nil)

(autoload 'xterm-set-icon-title "xterm-frobs" "\
Set the title in the icon for this xterm window to TITLE.
This does not change the title of the corresponding window.

\(fn TITLE)" t nil)

(autoload 'xterm-set-window-title "xterm-frobs" "\
Set the title for xterm window to TITLE.
This does not change the title in the corresponding icon.

\(fn TITLE)" t nil)

(autoload 'xterm-set-all-titles "xterm-frobs" "\
Set the title for xterm window and corresponding icon to TITLE.

\(fn TITLE)" t nil)

(autoload 'xterm-set-background-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-foreground-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-cursor-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-mouse-foreground-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-mouse-background-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-highlight-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-reverse-video "xterm-frobs" "\
Set xterm to reverse video mode.
For monochrome xterms, this is white foreground on black background.
For xterms which support color, this has the effect of swapping the
foreground and background colors, whatever they may be.

The effect of this command and \\[xterm-normal-video] may be exchanged
if the XTerm*reverseVideo resource property is set to True.

\(fn)" t nil)

(autoload 'xterm-normal-video "xterm-frobs" "\
Set xterm to normal (i.e. non-reverse) video mode.
For monochrome xterms, this is black foreground on white background.
For xterms which support color, this has the effect of restoring the
original foreground and background colors, whatever they may be.

The effect of this command and \\[xterm-reverse-video] may be exchanged
if the XTerm*reverseVideo resource property is set to True.

\(fn)" t nil)

(autoload 'xterm-sync-emacs-colors "xterm-frobs" "\
Query xterm for color palette and define color list for Emacs.

\(fn)" t nil)

(autoload 'xterm-print-formatted-color-alist "xterm-frobs" "\
Create a pretty-printed table of the current xterm color map.
This table is inserted into a new buffer which can be saved to a file and
reloaded later.

\(fn &optional COLOR-ALIST)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-frobs" '("xterm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-color-20180202.2318/xterm-color-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-color-20180202.2318/xterm-color-autoloads.el") (car load-path))))



(autoload 'xterm-color-filter "xterm-color" "\
Translate ANSI color sequences in STRING into text properties.
Returns new STRING with text properties applied.

This function will check if `xterm-color-preserve-properties' is
set to T and only call `xterm-color-filter-real' on substrings
that do not have text properties applied (passing through the rest
unmodified).  Preserving properties in this fashion is really a hack
and not very robust as there may be situations where text properties
are applied on ANSI data, which will mess up the state machine.
It works fine with and is really meant for eshell though.

This can be inserted into `comint-preoutput-filter-functions'.

\(fn STRING)" nil nil)

(autoload 'xterm-color-colorize-buffer "xterm-color" "\
Apply `xterm-color-filter' to current buffer, and replace its contents.

\(fn)" t nil)

(autoload 'xterm-color-test "xterm-color" "\
Create and display a new buffer that contains ANSI control sequences.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-color" '("+xterm-color--" "xterm-color-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xcscope-20180426.712/xcscope-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xcscope-20180426.712/xcscope-autoloads.el") (car load-path))))



(autoload 'cscope-minor-mode "xcscope" "\
This cscope minor mode maps cscope keybindings to make cscope
functions more accessible.

If called interactively, enable Cscope minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Key bindings:
\\{cscope-minor-mode-keymap}

\(fn &optional ARG)" t nil)

(autoload 'cscope-setup "xcscope" "\
Automatically turns on cscope-minor-mode when editing C and
C++ sources

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xcscope" '("cscope-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/x86-lookup-20180528.1635/x86-lookup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/x86-lookup-20180528.1635/x86-lookup-autoloads.el") (car load-path))))



(autoload 'x86-lookup "x86-lookup" "\
Jump to the PDF documentation for MNEMONIC.
Defaults to the mnemonic under point.

\(fn MNEMONIC)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "x86-lookup" '("x86-lookup-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/x509-mode-20180921.803/x509-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/x509-mode-20180921.803/x509-mode-autoloads.el") (car load-path))))



(autoload 'x509-mode "x509-mode" "\
Major mode for displaying openssl x509 output.

\\{x509-mode-map}

\(fn)" t nil)

(autoload 'x509-viewcert "x509-mode" "\
Parse current buffer as a certificate file.
Display result in another buffer.

With \\[universal-argument] prefix, you can edit the command arguements.

\(fn &optional ARGS)" t nil)

(autoload 'x509-viewcrl "x509-mode" "\
Parse current buffer as a CRL file. Display result in another buffer.

With \\[universal-argument] prefix, you can edit the command arguements.

\(fn &optional ARGS)" t nil)

(autoload 'x509-viewdh "x509-mode" "\
Parse current buffer as a DH-parameter file.
Display result in another buffer.

With \\[universal-argument] prefix, you can edit the command arguements.

\(fn &optional ARGS)" t nil)

(autoload 'x509-viewkey "x509-mode" "\
Display x509 private key using the OpenSSL pkey command.

With \\[universal-argument] prefix, you can edit the command arguements.
For example to enter pass-phrase, add -passin pass:PASSPHRASE.

\(fn &optional ARGS)" t nil)

(autoload 'x509-asn1-mode "x509-mode" "\
Major mode for displaying openssl asn1parse output.

\\{x509-mode-map}

\(fn)" t nil)

(autoload 'x509-viewasn1 "x509-mode" "\
Parse current buffer as ASN.1. Display result in another buffer.

With \\[universal-argument] prefix, you can edit the command arguements.

\(fn &optional ARGS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "x509-mode" '("x509-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/with-simulated-input-20170821.617/with-simulated-input-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/with-simulated-input-20170821.617/with-simulated-input-autoloads.el") (car load-path))))



(autoload 'with-simulated-input "with-simulated-input" "\
Eval BODY forms with KEYS as simulated input.

This macro is intended for automated testing of normally
interactive functions by simulating input. If BODY tries to read
user input (e.g. via `completing-read'), it will read input
events from KEYS instead, as if the user had manually typed those
keys after initiating evaluation of BODY.

KEYS should be a string representing a sequence of key presses,
in the format understood by `kbd'. In the most common case of
typing in some text and pressing RET, KEYS would be something
like `\"hello RET\"'. Note that spaced must be indicated
explicitly using `SPC', e.g. `\"hello SPC world RET\"'.

KEYS can also be a list. In this case, each element should either
be a key sequence as described above or an arbitrary lisp form
that will be evaluated at that point in the input sequence. For
example, `\"hello RET\"' could also be written as:

    `((insert \"hello\") \"RET\")'

If BODY tries to read more input events than KEYS provides, an
error is signalled. This is to ensure that BODY will never block
waiting for input, since this macro is intended for
non-interactive use. If BODY does not consume all the input
events in KEYS, the remaining input events in KEYS are discarded,
and any remaining lisp forms in KEYS are never evaluated.

Any errors generated by any means during the evaluation of BODY
are propagated normally.

The return value is the last form in BODY, as if it was wrapped
in `progn'.

\(fn KEYS &rest BODY)" nil t)

(function-put 'with-simulated-input 'lisp-indent-function '1)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "with-simulated-input" '("current-idle-time@simulate-idle-time" "wsi-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/async-20180527.1730/async-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/async-20180527.1730/async-autoloads.el") (car load-path))))



(autoload 'async-start-process "async" "\
Start the executable PROGRAM asynchronously.  See `async-start'.
PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the
process object when done.  If FINISH-FUNC is nil, the future
object will return the process object when the program is
finished.  Set DEFAULT-DIRECTORY to change PROGRAM's current
working directory.

\(fn NAME PROGRAM FINISH-FUNC &rest PROGRAM-ARGS)" nil nil)

(autoload 'async-start "async" "\
Execute START-FUNC (often a lambda) in a subordinate Emacs process.
When done, the return value is passed to FINISH-FUNC.  Example:

    (async-start
       ;; What to do in the child process
       (lambda ()
         (message \"This is a test\")
         (sleep-for 3)
         222)

       ;; What to do when it finishes
       (lambda (result)
         (message \"Async process done, result should be 222: %s\"
                  result)))

If FINISH-FUNC is nil or missing, a future is returned that can
be inspected using `async-get', blocking until the value is
ready.  Example:

    (let ((proc (async-start
                   ;; What to do in the child process
                   (lambda ()
                     (message \"This is a test\")
                     (sleep-for 3)
                     222))))

        (message \"I'm going to do some work here\") ;; ....

        (message \"Waiting on async process, result should be 222: %s\"
                 (async-get proc)))

If you don't want to use a callback, and you don't care about any
return value from the child process, pass the `ignore' symbol as
the second argument (if you don't, and never call `async-get', it
will leave *emacs* process buffers hanging around):

    (async-start
     (lambda ()
       (delete-file \"a remote file on a slow link\" nil))
     'ignore)

Note: Even when FINISH-FUNC is present, a future is still
returned except that it yields no value (since the value is
passed to FINISH-FUNC).  Call `async-get' on such a future always
returns nil.  It can still be useful, however, as an argument to
`async-ready' or `async-wait'.

\(fn START-FUNC &optional FINISH-FUNC)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "async" '("async-")))



(autoload 'async-byte-recompile-directory "async-bytecomp" "\
Compile all *.el files in DIRECTORY asynchronously.
All *.elc files are systematically deleted before proceeding.

\(fn DIRECTORY &optional QUIET)" nil nil)

(defvar async-bytecomp-package-mode nil "\
Non-nil if Async-Bytecomp-Package mode is enabled.
See the `async-bytecomp-package-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `async-bytecomp-package-mode'.")

(custom-autoload 'async-bytecomp-package-mode "async-bytecomp" nil)

(autoload 'async-bytecomp-package-mode "async-bytecomp" "\
Byte compile asynchronously packages installed with package.el.
Async compilation of packages can be controlled by
`async-bytecomp-allowed-packages'.

If called interactively, enable Async-Bytecomp-Package mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'async-byte-compile-file "async-bytecomp" "\
Byte compile Lisp code FILE asynchronously.

Same as `byte-compile-file' but asynchronous.

\(fn FILE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "async-bytecomp" '("async-byte")))



(defvar dired-async-mode nil "\
Non-nil if Dired-Async mode is enabled.
See the `dired-async-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `dired-async-mode'.")

(custom-autoload 'dired-async-mode "dired-async" nil)

(autoload 'dired-async-mode "dired-async" "\
Do dired actions asynchronously.

If called interactively, enable Dired-Async mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-copy "dired-async" "\
Run ‘dired-do-copy’ asynchronously.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-symlink "dired-async" "\
Run ‘dired-do-symlink’ asynchronously.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-hardlink "dired-async" "\
Run ‘dired-do-hardlink’ asynchronously.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-rename "dired-async" "\
Run ‘dired-do-rename’ asynchronously.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dired-async" '("dired-async-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smtpmail-async" '("async-smtpmail-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/with-editor-20181008.2142/with-editor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/with-editor-20181008.2142/with-editor-autoloads.el") (car load-path))))



(autoload 'with-editor-export-editor "with-editor" "\
Teach subsequent commands to use current Emacs instance as editor.

Set and export the environment variable ENVVAR, by default
\"EDITOR\".  The value is automatically generated to teach
commands to use the current Emacs instance as \"the editor\".

This works in `shell-mode', `term-mode' and `eshell-mode'.

\(fn &optional (ENVVAR \"EDITOR\"))" t nil)

(autoload 'with-editor-export-git-editor "with-editor" "\
Like `with-editor-export-editor' but always set `$GIT_EDITOR'.

\(fn)" t nil)

(autoload 'with-editor-export-hg-editor "with-editor" "\
Like `with-editor-export-editor' but always set `$HG_EDITOR'.

\(fn)" t nil)

(defvar shell-command-with-editor-mode nil "\
Non-nil if Shell-Command-With-Editor mode is enabled.
See the `shell-command-with-editor-mode' command
for a description of this minor mode.")

(custom-autoload 'shell-command-with-editor-mode "with-editor" nil)

(autoload 'shell-command-with-editor-mode "with-editor" "\
Teach `shell-command' to use current Emacs instance as editor.

If called interactively, enable Shell-Command-With-Editor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Teach `shell-command', and all commands that ultimately call that
command, to use the current Emacs instance as editor by executing
\"EDITOR=CLIENT COMMAND&\" instead of just \"COMMAND&\".

CLIENT is automatically generated; EDITOR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming no other variable overrides the effect of \"$EDITOR\".
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Alternatively you can use the `with-editor-async-shell-command',
which also allows the use of another variable instead of
\"EDITOR\".

\(fn &optional ARG)" t nil)

(autoload 'with-editor-async-shell-command "with-editor" "\
Like `async-shell-command' but with `$EDITOR' set.

Execute string \"ENVVAR=CLIENT COMMAND\" in an inferior shell;
display output, if any.  With a prefix argument prompt for an
environment variable, otherwise the default \"EDITOR\" variable
is used.  With a negative prefix argument additionally insert
the COMMAND's output at point.

CLIENT is automatically generated; ENVVAR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming it respects ENVVAR as an \"EDITOR\"-like variable.
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Also see `async-shell-command' and `shell-command'.

\(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil)

(autoload 'with-editor-shell-command "with-editor" "\
Like `shell-command' or `with-editor-async-shell-command'.
If COMMAND ends with \"&\" behave like the latter,
else like the former.

\(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "with-editor" '("server-" "shell-command--shell-command-with-editor-mode" "start-file-process--with-editor-process-filter" "with-editor")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/imenu-list-20180601.1402/imenu-list-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/imenu-list-20180601.1402/imenu-list-autoloads.el") (car load-path))))



(autoload 'imenu-list-noselect "imenu-list" "\
Update and show the imenu-list buffer, but don't select it.
If the imenu-list buffer doesn't exist, create it.

\(fn)" t nil)

(autoload 'imenu-list "imenu-list" "\
Update and show the imenu-list buffer.
If the imenu-list buffer doesn't exist, create it.

\(fn)" t nil)

(defvar imenu-list-minor-mode nil "\
Non-nil if Imenu-List minor mode is enabled.
See the `imenu-list-minor-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `imenu-list-minor-mode'.")

(custom-autoload 'imenu-list-minor-mode "imenu-list" nil)

(autoload 'imenu-list-minor-mode "imenu-list" "\
Toggle Imenu-List minor mode on or off.

If called interactively, enable Imenu-List minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{imenu-list-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'imenu-list-smart-toggle "imenu-list" "\
Enable or disable `imenu-list-minor-mode' according to buffer's visibility.
If the imenu-list buffer is displayed in any window, disable
`imenu-list-minor-mode', otherwise enable it.
Note that all the windows in every frame searched, even invisible ones, not
only those in the selected frame.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "imenu-list" '("imenu-list-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/window-purpose-20180926.1047/window-purpose-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/window-purpose-20180926.1047/window-purpose-autoloads.el") (car load-path))))



(defvar purpose-mode nil "\
Non-nil if Purpose mode is enabled.
See the `purpose-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `purpose-mode'.")

(custom-autoload 'purpose-mode "window-purpose" nil)

(autoload 'purpose-mode "window-purpose" "\
Toggle Purpose mode on or off.

If called interactively, enable Purpose mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{purpose-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose" '("find-file-" "purpose-" "switch-buffer-")))



(eieio-defclass-autoload 'purpose-conf 'nil "window-purpose-configuration" nil)

(autoload 'purpose-set-extension-configuration "window-purpose-configuration" "\
Set an extension's entry in `purpose-extended-configuration'.
EXT-KEYWORD should be a keyword used to identify the extension.
CONFIG is a `purpose-conf' object containing the extension's purpose
configuration.
Example:
 (purpose-set-extension-configuration
     :python
     (purpose-conf \"py\"
                   :mode-purposes
                   '((python-mode . python)
                     (inferior-python-mode . interpreter))))

This function calls `purpose-compile-extended-configuration' when its
done.

\(fn EXT-KEYWORD CONFIG)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-configuration" '("define-purpose-list-checker" "purpose-")))



(autoload 'purpose-toggle-window-buffer-dedicated "window-purpose-core" "\
Toggle window WINDOW's dedication to its current buffer on or off.
WINDOW defaults to the selected window.

\(fn &optional WINDOW)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-core" '("default-" "purpose-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-fixes" '("purpose-")))



(autoload 'purpose-save-window-layout-file "window-purpose-layout" "\
Save window layout of current frame to file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-load-window-layout-file "window-purpose-layout" "\
Load window layout from file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-save-window-layout "window-purpose-layout" "\
Save a window layout.
NAME is the name to give the window layout.
DIRECTORY is the directory in which to save the layout.

\(fn NAME DIRECTORY)" t nil)

(autoload 'purpose-load-window-layout "window-purpose-layout" "\
Load a window layout.
NAME is the name of a window layout.  If NAME is not given, prompt the
user for a name.
LAYOUT-DIRS is a list of directories to search for the layout file, and
defaults to `purpose-layout-dirs'.  If `purpose-use-built-in-layouts',
then `purpose--built-in-layouts-dir' is also searched.  See
`purpose-find-window-layout' for more details.

To load a window layout from a specific file, use
`purpose-load-window-layout-file'.

\(fn &optional NAME LAYOUT-DIRS)" t nil)

(autoload 'purpose-save-frame-layout-file "window-purpose-layout" "\
Save frame layout of Emacs to file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-load-frame-layout-file "window-purpose-layout" "\
Load frame layout from file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-save-frame-layout "window-purpose-layout" "\
Save a frame layout.
NAME is the name to give the frame layout.
DIRECTORY is the directory in which to save the layout.

\(fn NAME DIRECTORY)" t nil)

(autoload 'purpose-load-frame-layout "window-purpose-layout" "\
Load a frame layout.
NAME is the name of a frame layout.  If NAME is not given, prompt the
user for a name.
LAYOUT-DIRS is a list of directories to search for the layout file, and
defaults to `purpose-layout-dirs'.  If `purpose-use-built-in-layouts',
then `purpose--built-in-layouts-dir' is also searched.  See
`purpose-find-frame-layout' for more details.

To load a frame layout from a specific file, use
`purpose-load-frame-layout-file'.

\(fn &optional NAME LAYOUT-DIRS)" t nil)

(autoload 'purpose-delete-non-dedicated-windows "window-purpose-layout" "\
Delete all windows that aren't dedicated to their purpose or buffer.

\(fn)" t nil)

(autoload 'purpose-set-window-purpose "window-purpose-layout" "\
Set window's purpose to PURPOSE, and dedicate it.
With prefix argument (DONT-DEDICATE is non-nil), don't dedicate the
window.  If DONT-DEDICATE is non-nil, and the current window is
dedicated, un-dedicate the window.
Changing the window's purpose is done by displaying a buffer of
the right purpose in it, or creating a dummy buffer.

\(fn PURPOSE &optional DONT-DEDICATE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-layout" '("purpose-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-prefix-overload" '("define-purpose-prefix-overload" "purpose--")))



(autoload 'purpose-switch-buffer "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in the selected window.
If FORCE-SAME-WINDOW is non-nil, don't select a different window if the
currently selected window is not available.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD FORCE-SAME-WINDOW)" t nil)

(autoload 'purpose-switch-buffer-other-window "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME in another window.
Never selects the currently selected window.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-switch-buffer-other-frame "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in another frame.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-pop-buffer "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in another window.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-pop-buffer-same-window "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in the selected window.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-switch-buffer-with-purpose "window-purpose-switch" "\
Prompt the user and switch to a buffer with purpose PURPOSE.
If called interactively, or with PURPOSE nil, PURPOSE defaults to the
current buffer's purpose.

\(fn &optional PURPOSE)" t nil)

(autoload 'purpose-switch-buffer-with-some-purpose "window-purpose-switch" "\
Like `purpose-switch-buffer-with-purpose', but first choose a PURPOSE.

\(fn PURPOSE)" t nil)

(autoload 'purpose-switch-buffer-with-purpose-other-window "window-purpose-switch" "\
Prompt the user and switch to a buffer with purpose PURPOSE.
The buffer is display in another window.
If called interactively, or with PURPOSE nil, PURPOSE defaults to the
current buffer's purpose.

\(fn &optional PURPOSE)" t nil)

(autoload 'purpose-switch-buffer-with-purpose-other-frame "window-purpose-switch" "\
Prompt the user and switch to a buffer with purpose PURPOSE.
The buffer is display in another frame.
If called interactively, or with PURPOSE nil, PURPOSE defaults to the
current buffer's purpose.

\(fn &optional PURPOSE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-switch" '("purpose-" "without-purpose")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-utils" '("purpose-")))



(autoload 'purpose-x-code1-setup "window-purpose-x" "\
Setup purpose-x-code1.
This setup includes 4 windows:
1. dedicated 'edit window
2. dedicated 'dired window.  This window shows the current buffer's
directory in a special window, using `dired' and
`dired-hide-details-mode' (if available).
3. dedicated 'buffers window.  This window shows the currently open
files, using `ibuffer'.
4. dedicated 'ilist window.  This window shows the current buffer's
imenu.

\(fn)" t nil)

(autoload 'purpose-x-magit-single-on "window-purpose-x" "\
Turn on magit-single purpose configuration.

\(fn)" t nil)

(autoload 'purpose-x-magit-multi-on "window-purpose-x" "\
Turn on magit-multi purpose configuration.

\(fn)" t nil)

(autoload 'purpose-x-golden-ratio-setup "window-purpose-x" "\
Make `golden-ratio-mode' aware of `purpose-mode'.

\(fn)" t nil)

(autoload 'purpose-x-popwin-setup "window-purpose-x" "\
Activate `popwin' emulation.
This extension treats certain buffers as \"popup\" buffers and displays
them in a special popup window.
The window is closed automatically when selecting another buffer (via
`switch-to-buffer' and the like), or by pressing \\[keyboard-quit].
You can control which buffers are treated as popup buffers by changing
the variables `purpose-x-popwin-major-modes',
`purpose-x-popwin-buffer-names' and
`purpose-x-popwin-buffer-name-regexps'.
Look at `purpose-x-popwin-*' variables and functions to learn more.

\(fn)" t nil)

(autoload 'purpose-x-persp-setup "window-purpose-x" "\
Activate purpose-x-persp extension.
This extension automatically activates a purpose configuration for the
current perspective.  The configuration changes automatically when
switching perspectives or when toggling `persp-mode'.
The variable `purpose-x-persp-confs' matches between perspectives and
purpose configurations.

\(fn)" t nil)

(autoload 'purpose-x-persp-switch-buffer "window-purpose-x" "\
Switch to BUFFER, limited by purpose and perspective.
BUFFER is chosen from buffers with the same purpose as the current
buffer that are also part of the current perspective.
NORECORD and FORCE-SAME-WINDOW have the same meaning as in
`switch-to-buffer'.

\(fn BUFFER &optional NORECORD FORCE-SAME-WINDOW)" t nil)

(autoload 'purpose-x-persp-switch-buffer-other-window "window-purpose-x" "\
Switch to BUFFER in other window, limited by purpose and perspective.
NORECORD has the same meaning as in `switch-to-buffer-other-window'.
The relation between `purpose-x-persp-switch-buffer-other-window' and
`switch-to-buffer-other-window' is the same as the relation between
`purpose-x-persp-switch-buffer' and `switch-to-buffer'.

\(fn BUFFER &optional NORECORD)" t nil)

(autoload 'purpose-x-persp-switch-buffer-other-frame "window-purpose-x" "\
Switch to BUFFER in other frame, limited by purpose and perspective.
NORECORD has the same meaning as in `switch-to-buffer-other-frame'.
The relation between `purpose-x-persp-switch-buffer-other-frame' and
`switch-to-buffer-other-frame' is the same as the relation between
`purpose-x-persp-switch-buffer' and `switch-to-buffer'.

\(fn BUFFER &optional NORECORD)" t nil)

(autoload 'purpose-x-kill-setup "window-purpose-x" "\
Activate purpose-x-kill extension.
This extension makes `kill-buffer' aware of the purpose-dedicated window
parameter, when killing a visible buffer.  If a buffer that is being
killed is displayed in a window,and that window is purpose-dedicated,
then try to replace the buffer with another buffer with the same purpose.
If that isn't possible, treat the window as if it was buffer-dedicated.

This is implemented by overriding `replace-buffer-in-windows' with
`purpose-x-replace-buffer-in-windows-1'.  See
`purpose-x-replace-buffer-in-windows-1' for more details.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-x" '("purpose-x-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/window-layout-20170215.33/window-layout-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/window-layout-20170215.33/window-layout-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-layout" '("wlf:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/web-server-20140906.6/web-server-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/web-server-20140906.6/web-server-autoloads.el") (car load-path))))



(autoload 'ws-start "web-server" "\
Start a server using HANDLERS and return the server object.

HANDLERS may be a single function (which is then called on every
request) or a list of conses of the form (MATCHER . FUNCTION),
where the FUNCTION associated with the first successful MATCHER
is called.  Handler functions are called with two arguments, the
process and the request object.

A MATCHER may be either a function (in which case it is called on
the request object) or a cons cell of the form (KEYWORD . STRING)
in which case STRING is matched against the value of the header
specified by KEYWORD.

Any supplied NETWORK-ARGS are assumed to be keyword arguments for
`make-network-process' to which they are passed directly.

For example, the following starts a simple hello-world server on
port 8080.

  (ws-start
   (lambda (request)
     (with-slots (process headers) request
       (process-send-string process
        \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nhello world\")))
   8080)

Equivalently, the following starts an identical server using a
function MATCH and the `ws-response-header' convenience
function.

  (ws-start
   '(((lambda (_) t) .
      (lambda (proc request)
        (ws-response-header proc 200 '(\"Content-type\" . \"text/plain\"))
        (process-send-string proc \"hello world\")
        t)))
   8080)

\(fn HANDLERS PORT &optional LOG-BUFFER &rest NETWORK-ARGS)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-server" '("ws-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-server-status-codes" '("ws-status-codes")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/web-20141231.2001/web-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/web-20141231.2001/web-autoloads.el") (car load-path))))



(autoload 'web-http-call "web" "\
Make an HTTP method to the URL or the HOST, PORT, PATH and send DATA.

If URL is specified then it takes precedence over SECURE, HOST,
PORT and PATH.  URL may be HTTP or HTTPS.

Important note: any query in URL is currently IGNORED!

SECURE is `nil' by default but if `t' then SSL is used.

PORT is 80 by default.  Even if SECURE it `t'.  If you manually
specify SECURE you should manually specify PORT to be 443.  Using
URL negates the need for that, an SSL URL will work correctly.

The URL connected to (whether specified by URL or by the HOST and
PORT) is recorded on the resulting connection as the process
property `:web-url'.

EXTRA-HEADERS is an alist or a hash-table of extra headers to
send to the server.

The full set of headers sent to the server is recorded on the
connection with the process property `:web-headers'.

DATA is of MIME-TYPE.  We try to interpret DATA and MIME-TYPE
usefully:

If MIME-TYPE is `application/form-www-url-encoded' then
`web-to-query-string' is used to to format the DATA into a POST
body.

If MIME-TYPE is `multipart/form-data' then `web-to-multipart' is
called to get a POST body.

Any data sent to the server is recorded on the connection with
the process property `:web-sent'.

When the request comes back the CALLBACK is called.  CALLBACK is
always passed 3 arguments: the HTTP connection which is a process
object, the HTTP header which is a `hash-table' and `data', which
is normally a string.  `data' depends somewhat on the context.
See below.

MODE defines what it means for the request to cause the CALLBACK
to be fired.  When MODE is `stream' then the CALLBACK is called
for every chunk of data received after the header has arrived.
This allows streaming data to somewhere else; hence `stream'
mode.  In this mode CALLBACK's `data' argument is a single chunk
of the stream or `:done' when the stream ends.

The default MODE is `batch' which collects all the data from the
response before calling CALLBACK with all the data as a string.

\(fn METHOD CALLBACK &key URL (HOST \"localhost\") (PORT 80) SECURE (PATH \"/\") EXTRA-HEADERS DATA (MIME-TYPE web/request-mimetype) (MODE \\='batch) LOGGING)" nil nil)

(autoload 'web-http-get "web" "\
Make a GET calling CALLBACK with the result.

For information on URL or PATH, HOST, PORT and also EXTRA-HEADERS
and MODE see `web-http-call'.

The callback probably won't work unless you set `lexical-binding'
to `t'.

\(fn CALLBACK &key URL (HOST \"localhost\") (PORT 80) (PATH \"/\") EXTRA-HEADERS (MODE \\='batch) (LOGGING t))" nil nil)

(autoload 'web-http-post "web" "\
Make a POST and call CALLBACK with the result.

For information on URL or PATH, HOST, PORT and also MODE see
`web-http-call'.

The callback probably won't work unless you set `lexical-binding'
to `t'.

\(fn CALLBACK &key URL (HOST \"localhost\") (PORT 80) (PATH \"/\") EXTRA-HEADERS DATA (MIME-TYPE web/request-mimetype) (MODE \\='batch) (LOGGING t))" nil nil)

(autoload 'web-json-post "web" "\
POST DATA to URL expecting a JSON response sent to CALLBACK.

See `web-json-expected-mimetypes-list' for the list of Mime Types
we accept JSON for.  This may be let bound.  If the expectation
is not met then EXPECTATION-FAILURE-CALLBACK is called being
passed the CALLBACK parameters.  By default
EXPECTATION-FAILURE-CALLBACK is
`web-json-default-expectation-failure'.

The CALLBACK is called as:

  CALLBACK RESPONSE-DATA HTTPCON RESPONSE-HEADER

so the function may be defined like this:

  (lambda (data &rest stuff) ...)

HEADERS may be specified, these are treated as extra-headers to
be sent with the request.

The DATA is sent as `application/x-www-form-urlencoded' by
default, MIME-TYPE can change that.

JSON-ARRAY-TYPE, JSON-OBJECT-TYPE and JSON-KEY-TYPE, if present,
are used to let bind the `json-read' variables of the same name
affecting the resulting lisp structure.

\(fn CALLBACK &key URL DATA HEADERS (MIME-TYPE web/request-mimetype) (LOGGING t) (JSON-ARRAY-TYPE json-array-type) (JSON-OBJECT-TYPE json-object-type) (JSON-KEY-TYPE json-key-type) (EXPECTATION-FAILURE-CALLBACK \\='web-json-default-expectation-failure))" nil nil)

(autoload 'web-get "web" "\
Get the specified URL into the BUFFER.

\(fn URL &optional BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web" '("web")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/a-20180907.953/a-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/a-20180907.953/a-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "a" '("a-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/parseclj-20180602.2006/parseclj-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/parseclj-20180602.2006/parseclj-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj" '("parseclj-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj-ast" '("parseclj-ast-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj-lex" '("parseclj-lex-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj-parser" '("parseclj-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/treepy-20180724.656/treepy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/treepy-20180724.656/treepy-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "treepy" '("treepy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/walkclj-20180718.900/walkclj-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/walkclj-20180718.900/walkclj-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "walkclj" '("walkclj-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/vkill-20091203.1022/vkill-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/vkill-20091203.1022/vkill-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vkill" '("process-list-" "vkill" "list-unix-processes")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/visual-regexp-20170301.116/visual-regexp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/visual-regexp-20170301.116/visual-regexp-autoloads.el") (car load-path))))



(autoload 'vr/mc-mark "visual-regexp" "\
Convert regexp selection to multiple cursors.

\(fn REGEXP START END)" nil nil)

(autoload 'vr/replace "visual-regexp" "\
Regexp-replace with live visual feedback.

\(fn REGEXP REPLACE START END)" t nil)

(autoload 'vr/query-replace "visual-regexp" "\
Use vr/query-replace like you would use query-replace-regexp.

\(fn REGEXP REPLACE START END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "visual-regexp" '("vr--" "vr/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/visual-regexp-steroids-20170222.253/visual-regexp-steroids-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/visual-regexp-steroids-20170222.253/visual-regexp-steroids-autoloads.el") (car load-path))))



(autoload 'vr/select-replace "visual-regexp-steroids" "\


\(fn)" t nil)

(autoload 'vr/select-query-replace "visual-regexp-steroids" "\


\(fn)" t nil)

(autoload 'vr/select-mc-mark "visual-regexp-steroids" "\


\(fn)" t nil)

(autoload 'vr/isearch-forward "visual-regexp-steroids" "\
Like isearch-forward, but using Python (or custom) regular expressions.

\(fn)" t nil)

(autoload 'vr/isearch-backward "visual-regexp-steroids" "\
Like isearch-backward, but using Python (or custom) regular expressions.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "visual-regexp-steroids" '("vr--" "vr/")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/unkillable-scratch-20160505.203/unkillable-scratch-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/unkillable-scratch-20160505.203/unkillable-scratch-autoloads.el") (car load-path))))



(defvar unkillable-scratch nil "\
Non-nil if Unkillable-Scratch mode is enabled.
See the `unkillable-scratch' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `unkillable-scratch'.")

(custom-autoload 'unkillable-scratch "unkillable-scratch" nil)

(autoload 'unkillable-scratch "unkillable-scratch" "\
A minor mode to disallow the *scratch* buffer from being killed.

If called interactively, enable Unkillable-Scratch mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "unkillable-scratch" '("unkillable-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/undohist-20150315.1242/undohist-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/undohist-20150315.1242/undohist-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "undohist" '("make-undohist-file-name" "undohist-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/undo-tree-0.6.5/undo-tree-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/undo-tree-0.6.5/undo-tree-autoloads.el") (car load-path))))



(autoload 'undo-tree-mode "undo-tree" "\
Toggle undo-tree mode.
With no argument, this command toggles the mode.
A positive prefix argument turns the mode on.
A negative prefix argument turns it off.

If called interactively, enable Undo-Tree mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Undo-tree-mode replaces Emacs' standard undo feature with a more
powerful yet easier to use version, that treats the undo history
as what it is: a tree.

The following keys are available in `undo-tree-mode':

  \\{undo-tree-map}

Within the undo-tree visualizer, the following keys are available:

  \\{undo-tree-visualizer-mode-map}

\(fn &optional ARG)" t nil)

(defvar global-undo-tree-mode nil "\
Non-nil if Global Undo-Tree mode is enabled.
See the `global-undo-tree-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-undo-tree-mode'.")

(custom-autoload 'global-undo-tree-mode "undo-tree" nil)

(autoload 'global-undo-tree-mode "undo-tree" "\
Toggle Undo-Tree mode in all buffers.
With prefix ARG, enable Global Undo-Tree mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Undo-Tree mode is enabled in all buffers where
`turn-on-undo-tree-mode' would do it.
See `undo-tree-mode' for more information on Undo-Tree mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "undo-tree" '("*undo-tree-id-counter*" "buffer-undo-tree" "turn-on-undo-tree-mode" "undo-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shut-up-20180628.1830/shut-up-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shut-up-20180628.1830/shut-up-autoloads.el") (car load-path))))



(autoload 'shut-up "shut-up" "\
Evaluate BODY with silenced output.

While BODY is evaluated, all output is redirected to a buffer,
unless `shut-up-ignore' is non-nil.  This affects:

- `message'
- All functions using `standard-output' (e.g. `print', `princ', etc.)

Inside BODY, the buffer is bound to the lexical variable
`shut-up-sink'.  Additionally provide a lexical function
`shut-up-current-output', which returns the current contents of
`shut-up-sink' when called with no arguments.

Changes to the variable `shut-up-ignore' inside BODY does not
have any affect.

\(fn &rest BODY)" nil t)

(function-put 'shut-up 'lisp-indent-function '0)

(autoload 'shut-up-silence-emacs "shut-up" "\
Silence Emacs.

Change Emacs settings to reduce the output.

WARNING: This function has GLOBAL SIDE-EFFECTS.  You should only
call this function in `noninteractive' sessions.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shut-up" '("inhibit-message" "shut-up-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/undercover-20180403.1452/undercover-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/undercover-20180403.1452/undercover-autoloads.el") (car load-path))))



(autoload 'undercover "undercover" "\
Enable test coverage for files matched by CONFIGURATION.
Example of CONFIGURATION: (\"*.el\" \"subdir/*.el\" (:exclude \"exclude-*.el\")).

If running under Travic CI automatically generate report
on `kill-emacs' and send it to coveralls.io.

\(fn &rest CONFIGURATION)" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "undercover" '("undercover-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-mode-20181005.452/clojure-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-mode-20181005.452/clojure-mode-autoloads.el") (car load-path))))



(autoload 'clojure-mode "clojure-mode" "\
Major mode for editing Clojure code.

\\{clojure-mode-map}

\(fn)" t nil)

(autoload 'clojure-unwind "clojure-mode" "\
Unwind thread at point or above point by one level.
Return nil if there are no more levels to unwind.

\(fn)" t nil)

(autoload 'clojure-unwind-all "clojure-mode" "\
Fully unwind thread at point or above point.

\(fn)" t nil)

(autoload 'clojure-thread "clojure-mode" "\
Thread by one more level an existing threading macro.

\(fn)" t nil)

(autoload 'clojure-thread-first-all "clojure-mode" "\
Fully thread the form at point using ->.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'.

\(fn BUT-LAST)" t nil)

(autoload 'clojure-thread-last-all "clojure-mode" "\
Fully thread the form at point using ->>.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'.

\(fn BUT-LAST)" t nil)

(autoload 'clojure-cycle-privacy "clojure-mode" "\
Make public the current private def, or vice-versa.
See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-privacy

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-list "clojure-mode" "\
Convert collection at (point) to list.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-quoted-list "clojure-mode" "\
Convert collection at (point) to quoted list.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-map "clojure-mode" "\
Convert collection at (point) to map.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-vector "clojure-mode" "\
Convert collection at (point) to vector.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-set "clojure-mode" "\
Convert collection at (point) to set.

\(fn)" t nil)

(autoload 'clojure-cycle-if "clojure-mode" "\
Change a surrounding if to if-not, or vice-versa.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-if

\(fn)" t nil)

(autoload 'clojure-cycle-when "clojure-mode" "\
Change a surrounding when to when-not, or vice-versa.

\(fn)" t nil)

(autoload 'clojure-let-backward-slurp-sexp "clojure-mode" "\
Slurp the s-expression before the let form into the let form.
With a numberic prefix argument slurp the previous N s-expression
into the let form.

\(fn &optional N)" t nil)

(autoload 'clojure-let-forward-slurp-sexp "clojure-mode" "\
Slurp the next s-expression after the let form into the let form.
With a numeric prefix argument slurp the next N s-expressions into the let form.

\(fn &optional N)" t nil)

(autoload 'clojure-introduce-let "clojure-mode" "\
Create a let form, binding the form at point.
With a numeric prefix argument the let is introduced N lists up.

\(fn &optional N)" t nil)

(autoload 'clojure-move-to-let "clojure-mode" "\
Move the form at point to a binding in the nearest let.

\(fn)" t nil)

(autoload 'clojurescript-mode "clojure-mode" "\
Major mode for editing ClojureScript code.

\\{clojurescript-mode-map}

\(fn)" t nil)

(autoload 'clojurec-mode "clojure-mode" "\
Major mode for editing ClojureC code.

\\{clojurec-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(clj\\|dtm\\|edn\\)\\'" . clojure-mode))

(add-to-list 'auto-mode-alist '("\\.cljc\\'" . clojurec-mode))

(add-to-list 'auto-mode-alist '("\\.cljs\\'" . clojurescript-mode))

(add-to-list 'auto-mode-alist '("\\(?:build\\|profile\\)\\.boot\\'" . clojure-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-mode" '("add-custom-clojure-indents" "clojure" "define-clojure-indent" "put-clojure-indent")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/queue-0.2/queue-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/queue-0.2/queue-autoloads.el") (car load-path))))



(defalias 'make-queue 'queue-create "\
Create an empty queue data structure.")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "queue" '("queue")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/spinner-1.7.3/spinner-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/spinner-1.7.3/spinner-autoloads.el") (car load-path))))



(autoload 'spinner-create "spinner" "\
Create a spinner of the given TYPE.
The possible TYPEs are described in `spinner--type-to-frames'.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

If BUFFER-LOCAL is non-nil, the spinner will be automatically
deactivated if the buffer is killed.  If BUFFER-LOCAL is a
buffer, use that instead of current buffer.

When started, in order to function properly, the spinner runs a
timer which periodically calls `force-mode-line-update' in the
curent buffer.  If BUFFER-LOCAL was set at creation time, then
`force-mode-line-update' is called in that buffer instead.  When
the spinner is stopped, the timer is deactivated.

DELAY, if given, is the number of seconds to wait after starting
the spinner before actually displaying it. It is safe to cancel
the spinner before this time, in which case it won't display at
all.

\(fn &optional TYPE BUFFER-LOCAL FPS DELAY)" nil nil)

(autoload 'spinner-start "spinner" "\
Start a mode-line spinner of given TYPE-OR-OBJECT.
If TYPE-OR-OBJECT is an object created with `make-spinner',
simply activate it.  This method is designed for minor modes, so
they can use the spinner as part of their lighter by doing:
    \\='(:eval (spinner-print THE-SPINNER))
To stop this spinner, call `spinner-stop' on it.

If TYPE-OR-OBJECT is anything else, a buffer-local spinner is
created with this type, and it is displayed in the
`mode-line-process' of the buffer it was created it.  Both
TYPE-OR-OBJECT and FPS are passed to `make-spinner' (which see).
To stop this spinner, call `spinner-stop' in the same buffer.

Either way, the return value is a function which can be called
anywhere to stop this spinner.  You can also call `spinner-stop'
in the same buffer where the spinner was created.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

DELAY, if given, is the number of seconds to wait until actually
displaying the spinner. It is safe to cancel the spinner before
this time, in which case it won't display at all.

\(fn &optional TYPE-OR-OBJECT FPS DELAY)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "spinner" '("spinner")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sesman-20180921.2220/sesman-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sesman-20180921.2220/sesman-autoloads.el") (car load-path))))



(autoload 'sesman-start "sesman" "\
Start a Sesman session.

\(fn)" t nil)

(autoload 'sesman-restart "sesman" "\
Restart sesman session.
When WHICH is nil, restart the current session; when a single universal
argument or 'linked, restart all linked sessions; when a double universal
argument, t or 'all, restart all sessions. For programmatic use, WHICH can also
be a session or a name of the session, in which case that session is restarted.

\(fn &optional WHICH)" t nil)

(autoload 'sesman-quit "sesman" "\
Terminate a Sesman session.
When WHICH is nil, kill only the current session; when a single universal
argument or 'linked, kill all linked sessions; when a double universal argument,
t or 'all, kill all sessions. For programmatic use, WHICH can also be a session
or a name of the session, in which case that session is killed.

\(fn &optional WHICH)" t nil)

(autoload 'sesman-info "sesman" "\
Display linked sessions info.
When ALL is non-nil, show info for all sessions.

\(fn &optional ALL)" t nil)

(autoload 'sesman-link-with-buffer "sesman" "\
Ask for SESSION and link with BUFFER.
BUFFER defaults to current buffer. On universal argument, or if BUFFER is 'ask,
ask for buffer.

\(fn &optional BUFFER SESSION)" t nil)

(autoload 'sesman-link-with-directory "sesman" "\
Ask for SESSION and link with DIR.
DIR defaults to `default-directory'. On universal argument, or if DIR is 'ask,
ask for directory.

\(fn &optional DIR SESSION)" t nil)

(autoload 'sesman-link-with-project "sesman" "\
Ask for SESSION and link with PROJECT.
PROJECT defaults to current project. On universal argument, or if PROJECT is
'ask, ask for the project. SESSION defaults to the current session.

\(fn &optional PROJECT SESSION)" t nil)

(autoload 'sesman-link-with-least-specific "sesman" "\
Ask for SESSION and link with the least specific context available.
Normally the least specific context is the project. If not in a project, link
with the `default-directory'. If `default-directory' is nil, link with current
buffer.

\(fn &optional SESSION)" t nil)

(autoload 'sesman-unlink "sesman" "\
Break any of the previously created links.

\(fn)" t nil)
 (autoload 'sesman-map "sesman" "Session management prefix keymap." t 'keymap)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sesman" '("sesman-")))



(autoload 'sesman-browser "sesman-browser" "\
Display an interactive session browser.
See `sesman-browser-mode' for more details.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sesman-browser" '("sesman-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-20181008.1547/cider-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-20181008.1547/cider-autoloads.el") (car load-path))))



(autoload 'cider-version "cider" "\
Display CIDER's version.

\(fn)" t nil)
 (autoload 'cider-start-map "cider" "CIDER jack-in and connect keymap." t 'keymap)

(autoload 'cider-jack-in-clj "cider" "\
Start an nREPL server for the current project and connect to it.
PARAMS is a plist optionally containing :project-dir and :jack-in-cmd.
With the prefix argument, prompt for all these parameters.

\(fn PARAMS)" t nil)

(autoload 'cider-jack-in-cljs "cider" "\
Start an nREPL server for the current project and connect to it.
PARAMS is a plist optionally containing :project-dir, :jack-in-cmd and
:cljs-repl-type (e.g. Node, Figwheel, etc).  With the prefix argument,
prompt for all these parameters.

\(fn PARAMS)" t nil)

(autoload 'cider-jack-in-clj&cljs "cider" "\
Start an nREPL server and connect with clj and cljs REPLs.
PARAMS is a plist optionally containing :project-dir, :jack-in-cmd and
:cljs-repl-type (e.g. Node, Figwheel, etc).  With the prefix argument,
prompt for all these parameters.  When SOFT-CLJS-START is non-nil, start
cljs REPL only when the ClojureScript dependencies are met.

\(fn &optional PARAMS SOFT-CLJS-START)" t nil)

(autoload 'cider-connect-sibling-clj "cider" "\
Create a Clojure REPL with the same server as OTHER-REPL.
PARAMS is for consistency with other connection commands and is currently
ignored.  OTHER-REPL defaults to `cider-current-repl' and in programs can
also be a server buffer, in which case a new session with a REPL for that
server is created.

\(fn PARAMS &optional OTHER-REPL)" t nil)

(autoload 'cider-connect-sibling-cljs "cider" "\
Create a ClojureScript REPL with the same server as OTHER-REPL.
PARAMS is a plist optionally containing :cljs-repl-type (e.g. Node,
Figwheel, etc).  All other parameters are inferred from the OTHER-REPL.
OTHER-REPL defaults to `cider-current-repl' but in programs can also be a
server buffer, in which case a new session for that server is created.

\(fn PARAMS &optional OTHER-REPL)" t nil)

(autoload 'cider-connect-clj "cider" "\
Initialize a CLJ connection to an nREPL server.
PARAMS is a plist optionally containing :host, :port and :project-dir.  On
prefix argument, prompt for all the parameters.

\(fn &optional PARAMS)" t nil)

(autoload 'cider-connect-cljs "cider" "\
Initialize a CLJS connection to an nREPL server.
PARAMS is a plist optionally containing :host, :port, :project-dir and
:cljs-repl-type (e.g. Node, Figwheel, etc).  On prefix, prompt for all the
parameters regardless of their supplied or default values.

\(fn &optional PARAMS)" t nil)

(autoload 'cider-connect-clj&cljs "cider" "\
Initialize a CLJ and CLJS connection to an nREPL server..
PARAMS is a plist optionally containing :host, :port, :project-dir and
:cljs-repl-type (e.g. Node, Figwheel, etc).  When SOFT-CLJS-START is
non-nil, don't start if ClojureScript requirements are not met.

\(fn PARAMS &optional SOFT-CLJS-START)" t nil)

(autoload 'cider "cider" "\
Start a connection of any type interactively.

\(fn)" t nil)

(defalias 'cider-jack-in #'cider-jack-in-clj)

(defalias 'cider-jack-in-clojure #'cider-jack-in-clj)

(defalias 'cider-jack-in-clojurescript #'cider-jack-in-cljs)

(defalias 'cider-connect #'cider-connect-clj)

(defalias 'cider-connect-clojure #'cider-connect-clj)

(defalias 'cider-connect-clojurescript #'cider-connect-cljs)

(defalias 'cider-connect-sibling-clojure #'cider-connect-sibling-clj)

(defalias 'cider-connect-sibling-clojurescript #'cider-connect-sibling-cljs)

(with-eval-after-load 'clojure-mode (define-key clojure-mode-map (kbd "C-c M-x") #'cider) (define-key clojure-mode-map (kbd "C-c M-j") #'cider-jack-in-clj) (define-key clojure-mode-map (kbd "C-c M-J") #'cider-jack-in-cljs) (define-key clojure-mode-map (kbd "C-c M-c") #'cider-connect-clj) (define-key clojure-mode-map (kbd "C-c M-C") #'cider-connect-cljs) (define-key clojure-mode-map (kbd "C-c C-x") 'cider-start-map) (define-key clojure-mode-map (kbd "C-c C-s") 'sesman-map) (require 'sesman) (sesman-install-menu clojure-mode-map) (add-hook 'clojure-mode-hook (lambda nil (setq-local sesman-system 'CIDER))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider" '("cider-")))



(autoload 'cider-apropos "cider-apropos" "\
Show all symbols whose names match QUERY, a regular expression.
QUERY can also be a list of space-separated words (e.g. take while) which
will be converted to a regular expression (like take.+while) automatically
behind the scenes.  The search may be limited to the namespace NS, and may
optionally search doc strings (based on DOCS-P), include private vars
\(based on PRIVATES-P), and be case-sensitive (based on CASE-SENSITIVE-P).

\(fn QUERY &optional NS DOCS-P PRIVATES-P CASE-SENSITIVE-P)" t nil)

(autoload 'cider-apropos-documentation "cider-apropos" "\
Shortcut for (cider-apropos <query> nil t).

\(fn)" t nil)

(autoload 'cider-apropos-select "cider-apropos" "\
Similar to `cider-apropos', but presents the results in a completing read.
Show all symbols whose names match QUERY, a regular expression.
QUERY can also be a list of space-separated words (e.g. take while) which
will be converted to a regular expression (like take.+while) automatically
behind the scenes.  The search may be limited to the namespace NS, and may
optionally search doc strings (based on DOCS-P), include private vars
\(based on PRIVATES-P), and be case-sensitive (based on CASE-SENSITIVE-P).

\(fn QUERY &optional NS DOCS-P PRIVATES-P CASE-SENSITIVE-P)" t nil)

(autoload 'cider-apropos-documentation-select "cider-apropos" "\
Shortcut for (cider-apropos-select <query> nil t).

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-apropos" '("apropos-special-form" "cider-")))



(autoload 'cider-browse-ns "cider-browse-ns" "\
List all NAMESPACE's vars in BUFFER.

\(fn NAMESPACE)" t nil)

(autoload 'cider-browse-ns-all "cider-browse-ns" "\
List all loaded namespaces in BUFFER.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-browse-ns" '("cider-browse-ns-")))



(autoload 'cider-browse-spec "cider-browse-spec" "\
Browse SPEC definition.

\(fn SPEC)" t nil)

(autoload 'cider-browse-spec-all "cider-browse-spec" "\
Open list of specs in a popup buffer.

With a prefix argument ARG, prompts for a regexp to filter specs.
No filter applied if the regexp is the empty string.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-browse-spec" '("cider-")))



(autoload 'cider-cheatsheet "cider-cheatsheet" "\
Navigate `cider-cheatsheet-hierarchy' with `completing-read'.

When you make it to a Clojure var its doc buffer gets displayed.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-cheatsheet" '("cider-cheatsheet-")))



(autoload 'cider-classpath "cider-classpath" "\
List all classpath entries.

\(fn)" t nil)

(autoload 'cider-open-classpath-entry "cider-classpath" "\
Open a classpath entry.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-classpath" '("cider-classpath-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-client" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-common" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-completion" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-connection" '("cider-")))



(autoload 'cider-debug-defun-at-point "cider-debug" "\
Instrument the \"top-level\" expression at point.
If it is a defn, dispatch the instrumented definition.  Otherwise,
immediately evaluate the instrumented expression.

While debugged code is being evaluated, the user is taken through the
source code and displayed the value of various expressions.  At each step,
a number of keys will be prompted to the user.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-debug" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-doc" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-eldoc" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-eval" '("cider-")))



(autoload 'cider-find-var "cider-find" "\
Find definition for VAR at LINE.
Prompt according to prefix ARG and `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix of `-` or a double prefix argument causes
the results to be displayed in a different window.  The default value is
thing at point.

\(fn &optional ARG VAR LINE)" t nil)

(autoload 'cider-find-dwim-at-mouse "cider-find" "\
Find and display variable or resource at mouse EVENT.

\(fn EVENT)" t nil)

(autoload 'cider-find-dwim "cider-find" "\
Find and display the SYMBOL-FILE at point.
SYMBOL-FILE could be a var or a resource.  If thing at point is empty then
show dired on project.  If var is not found, try to jump to resource of the
same name.  When called interactively, a prompt is given according to the
variable `cider-prompt-for-symbol'.  A single or double prefix argument
inverts the meaning.  A prefix of `-' or a double prefix argument causes
the results to be displayed in a different window.  A default value of thing
at point is given when prompted.

\(fn SYMBOL-FILE)" t nil)

(autoload 'cider-find-resource "cider-find" "\
Find the resource at PATH.
Prompt for input as indicated by the variable `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix argument of `-` or a double prefix
argument causes the results to be displayed in other window.  The default
value is thing at point.

\(fn PATH)" t nil)

(autoload 'cider-find-ns "cider-find" "\
Find the file containing NS.
A prefix ARG of `-` or a double prefix argument causes
the results to be displayed in a different window.

\(fn &optional ARG NS)" t nil)

(autoload 'cider-find-keyword "cider-find" "\
Find the namespace of the keyword at point and its first occurrence there.

For instance - if the keyword at point is \":cider.demo/keyword\", this command
would find the namespace \"cider.demo\" and afterwards find the first mention
of \"::keyword\" there.

Prompt according to prefix ARG and `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix of `-` or a double prefix argument causes
the results to be displayed in a different window.  The default value is
thing at point.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-find" '("cider-")))



(autoload 'cider-format-region "cider-format" "\
Format the Clojure code in the current region.
START and END represent the region's boundaries.

\(fn START END)" t nil)

(autoload 'cider-format-defun "cider-format" "\
Format the code in the current defun.

\(fn)" t nil)

(autoload 'cider-format-buffer "cider-format" "\
Format the Clojure code in the current buffer.

\(fn)" t nil)

(autoload 'cider-format-edn-buffer "cider-format" "\
Format the EDN data in the current buffer.

\(fn)" t nil)

(autoload 'cider-format-edn-region "cider-format" "\
Format the EDN data in the current region.
START and END represent the region's boundaries.

\(fn START END)" t nil)

(autoload 'cider-format-edn-last-sexp "cider-format" "\
Format the EDN data of the last sexp.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-format" '("cider--format-")))



(autoload 'cider-grimoire-web "cider-grimoire" "\
Open grimoire documentation in the default web browser.

Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn &optional ARG)" t nil)

(autoload 'cider-grimoire "cider-grimoire" "\
Open grimoire documentation in a popup buffer.

Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-grimoire" '("cider-")))



(autoload 'cider-inspect-last-sexp "cider-inspector" "\
Inspect the result of the the expression preceding point.

\(fn)" t nil)

(autoload 'cider-inspect-defun-at-point "cider-inspector" "\
Inspect the result of the \"top-level\" expression at point.

\(fn)" t nil)

(autoload 'cider-inspect-last-result "cider-inspector" "\
Inspect the most recent eval result.

\(fn)" t nil)

(autoload 'cider-inspect "cider-inspector" "\
Inspect the result of the preceding sexp.

With a prefix argument ARG it inspects the result of the \"top-level\" form.
With a second prefix argument it prompts for an expression to eval and inspect.

\(fn &optional ARG)" t nil)

(autoload 'cider-inspect-expr "cider-inspector" "\
Evaluate EXPR in NS and inspect its value.
Interactively, EXPR is read from the minibuffer, and NS the
current buffer's namespace.

\(fn EXPR NS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-inspector" '("cider-")))



(autoload 'cider-macroexpand-1 "cider-macroexpansion" "\
Invoke \\=`macroexpand-1\\=` on the expression preceding point.
If invoked with a PREFIX argument, use \\=`macroexpand\\=` instead of
\\=`macroexpand-1\\=`.

\(fn &optional PREFIX)" t nil)

(autoload 'cider-macroexpand-all "cider-macroexpansion" "\
Invoke \\=`macroexpand-all\\=` on the expression preceding point.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-macroexpansion" '("cider-")))



(defvar cider-mode-line '(:eval (format " cider[%s]" (cider--modeline-info))) "\
Mode line lighter for cider mode.

The value of this variable is a mode line template as in
`mode-line-format'.  See Info Node `(elisp)Mode Line Format' for details
about mode line templates.

Customize this variable to change how cider mode displays its status in the
mode line.  The default value displays the current connection.  Set this
variable to nil to disable the mode line entirely.")

(custom-autoload 'cider-mode-line "cider-mode" t)

(with-eval-after-load 'clojure-mode (easy-menu-define cider-clojure-mode-menu-open clojure-mode-map "Menu for Clojure mode.\n  This is displayed in `clojure-mode' buffers, if `cider-mode' is not active." `("CIDER" :visible (not cider-mode) ["Start a Clojure REPL" cider-jack-in-clj :help "Starts an nREPL server and connects a Clojure REPL to it."] ["Connect to a Clojure REPL" cider-connect-clj :help "Connects to a REPL that's already running."] ["Start a ClojureScript REPL" cider-jack-in-cljs :help "Starts an nREPL server and connects a ClojureScript REPL to it."] ["Connect to a ClojureScript REPL" cider-connect-cljs :help "Connects to a ClojureScript REPL that's already running."] ["Start a Clojure REPL, and a ClojureScript REPL" cider-jack-in-clj&cljs :help "Starts an nREPL server, connects a Clojure REPL to it, and then a ClojureScript REPL."] "--" ["View manual online" cider-view-manual])))

(autoload 'cider-mode "cider-mode" "\
Minor mode for REPL interaction from a Clojure buffer.

If called interactively, enable Cider mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{cider-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-mode" '("cider-")))



(autoload 'cider-ns-reload "cider-ns" "\
Send a (require 'ns :reload) to the REPL.

With an argument PROMPT, it prompts for a namespace name.  This is the
Clojure out of the box reloading experience and does not rely on
org.clojure/tools.namespace.  See Commentary of this file for a longer list
of differences.  From the Clojure doc: \":reload forces loading of all the
identified libs even if they are already loaded\".

\(fn &optional PROMPT)" t nil)

(autoload 'cider-ns-reload-all "cider-ns" "\
Send a (require 'ns :reload-all) to the REPL.

With an argument PROMPT, it prompts for a namespace name.  This is the
Clojure out of the box reloading experience and does not rely on
org.clojure/tools.namespace.  See Commentary of this file for a longer list
of differences.  From the Clojure doc: \":reload-all implies :reload and
also forces loading of all libs that the identified libs directly or
indirectly load via require\".

\(fn &optional PROMPT)" t nil)

(autoload 'cider-ns-refresh "cider-ns" "\
Reload modified and unloaded namespaces on the classpath.

With a single prefix argument, or if MODE is `refresh-all', reload all
namespaces on the classpath unconditionally.

With a double prefix argument, or if MODE is `clear', clear the state of
the namespace tracker before reloading.  This is useful for recovering from
some classes of error (for example, those caused by circular dependencies)
that a normal reload would not otherwise recover from.  The trade-off of
clearing is that stale code from any deleted files may not be completely
unloaded.

With a negative prefix argument, or if MODE is `inhibit-fns', prevent any
refresh functions (defined in `cider-ns-refresh-before-fn' and
`cider-ns-refresh-after-fn') from being invoked.

\(fn &optional MODE)" t nil)

(define-obsolete-function-alias 'cider-refresh 'cider-ns-refresh "0.18")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-ns" '("cider-ns-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-overlays" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-popup" '("cider-")))



(autoload 'cider-profile-samples "cider-profile" "\
Displays current max-sample-count.
If optional QUERY is specified, set max-sample-count and display new value.

\(fn &optional QUERY)" t nil)

(autoload 'cider-profile-var-profiled-p "cider-profile" "\
Displays the profiling status of var under point.
Prompts for var if none under point or QUERY is present.

\(fn QUERY)" t nil)

(autoload 'cider-profile-ns-toggle "cider-profile" "\
Toggle profiling for the ns associated with optional QUERY.

If optional argument QUERY is non-nil, prompt for ns.  Otherwise use
current ns.

\(fn &optional QUERY)" t nil)

(autoload 'cider-profile-toggle "cider-profile" "\
Toggle profiling for the given QUERY.
Defaults to the symbol at point.
With prefix arg or no symbol at point, prompts for a var.

\(fn QUERY)" t nil)

(autoload 'cider-profile-summary "cider-profile" "\
Display a summary of currently collected profile data.

\(fn)" t nil)

(autoload 'cider-profile-var-summary "cider-profile" "\
Display profile data for var under point QUERY.
Defaults to the symbol at point.  With prefix arg or no symbol at point,
prompts for a var.

\(fn QUERY)" t nil)

(autoload 'cider-profile-clear "cider-profile" "\
Clear any collected profile data.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-profile" '("cider-profile-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-repl" '("cider-")))



(autoload 'cider-repl-history "cider-repl-history" "\
Display items in the CIDER command history in another buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-repl-history" '("cider-repl-history-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-resolve" '("cider-resolve-")))



(autoload 'cider-scratch "cider-scratch" "\
Go to the scratch buffer named `cider-scratch-buffer-name'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-scratch" '("cider-")))



(autoload 'cider-selector "cider-selector" "\
Select a new buffer by type, indicated by a single character.
The user is prompted for a single character indicating the method by
which to choose a new buffer.  The `?' character describes then
available methods.  OTHER-WINDOW provides an optional target.
See `def-cider-selector-method' for defining new methods.

\(fn &optional OTHER-WINDOW)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-selector" '("??" "?c" "?d" "?e" "?m" "?p" "?q" "?r" "?s" "?x" "cider-selector-" "def-cider-selector-method")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-stacktrace" '("cider-")))



(defvar cider-auto-test-mode nil "\
Non-nil if Cider-Auto-Test mode is enabled.
See the `cider-auto-test-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `cider-auto-test-mode'.")

(custom-autoload 'cider-auto-test-mode "cider-test" nil)

(autoload 'cider-auto-test-mode "cider-test" "\
Toggle automatic testing of Clojure files.

If called interactively, enable Cider-Auto-Test mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When enabled this reruns tests every time a Clojure file is loaded.
Only runs tests corresponding to the loaded file's namespace and does
nothing if no tests are defined or if the file failed to load.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-test" '("cider-")))



(autoload 'cider-toggle-trace-var "cider-tracing" "\
Toggle var tracing.
Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn ARG)" t nil)

(autoload 'cider-toggle-trace-ns "cider-tracing" "\
Toggle ns tracing.
Defaults to the current ns.  With prefix arg QUERY, prompts for a ns.

\(fn QUERY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-tracing" '("cider-")))



(autoload 'cider-view-manual "cider-util" "\
View the manual in your default browser.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-util" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-client" '("cider-enlighten-mode" "nrepl-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-dict" '("nrepl-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/typed-clojure-mode-20151003.1822/typed-clojure-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/typed-clojure-mode-20151003.1822/typed-clojure-mode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "typed-clojure-error-mode" '("typed-clojure-error-mode")))



(autoload 'typed-clojure-mode "typed-clojure-mode" "\
The official minor mode for editing Typed Clojure. Provides
namespace typechecking, error navigation, display of type data,
and annotation snippets.

If called interactively, enable Typed-Clojure mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{typed-clojure-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "typed-clojure-mode" '("typed-clojure-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tNFA-0.1.1/tNFA-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tNFA-0.1.1/tNFA-autoloads.el") (car load-path))))



(autoload 'tNFA-from-regexp "tNFA" "\
Create a tagged NFA that recognizes the regular expression REGEXP.
The return value is the initial state of the tagged NFA.

REGEXP can be any sequence type (vector, list, or string); it
need not be an actual string. Special characters in REGEXP are
still just that: elements of the sequence that are characters
which have a special meaning in regexps.

The :test keyword argument specifies how to test whether two
individual elements of STRING are identical. The default is `eq'.

Only a subset of the full Emacs regular expression syntax is
supported. There is no support for regexp constructs that are
only meaningful for strings (character ranges and character
classes inside character alternatives, and syntax-related
backslash constructs). Back-references and non-greedy postfix
operators are not supported, so `?' after a postfix operator
loses its special meaning. Also, matches are always anchored, so
`$' and `^' lose their special meanings (use `.*' at the
beginning and end of the regexp to get an unanchored match).

\(fn REGEXP &key (test \\='eq))" nil nil)

(autoload 'tNFA-regexp-match "tNFA" "\
Return non-nil if STRING matches REGEXP, nil otherwise.
Sets the match data if there was a match; see `match-beginning',
`match-end' and `match-string'.

REGEXP and STRING can be any sequence type (vector, list, or
string); they need not be actual strings. Special characters in
REGEXP are still just that: elements of the sequence that are
characters which have a special meaning in regexps.

The :test keyword argument specifies how to test whether two
individual elements of STRING are identical. The default is `eq'.

Only a subset of the full Emacs regular expression syntax is
supported. There is no support for regexp constructs that are
only meaningful for strings (character ranges and character
classes inside character alternatives, and syntax-related
backslash constructs). Back-references and non-greedy postfix
operators are not supported, so `?' after a postfix operator
loses its special meaning. Also, matches are always anchored, so
`$' and `^' lose their special meanings (use `.*' at the
beginning and end of the regexp to get an unanchored match).

\(fn REGEXP STRING &key (test \\='eq))" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tNFA" '("tNFA-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/heap-0.5/heap-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/heap-0.5/heap-autoloads.el") (car load-path))))



(autoload 'make-heap "heap" "\
Create an empty heap with comparison function COMPARE-FUNCTION.

COMPARE-FUNCTION takes two arguments, A and B, and returns
non-nil or nil. To implement a max-heap, it should return non-nil
if A is greater than B. To implemenet a min-heap, it should
return non-nil if A is less than B.

Optional argument INITIAL-SIZE sets the initial size of the heap,
defaulting to 10. Optional argument RESIZE-FACTOR sets the factor
by which the heap's size is increased if it runs out of space,
defaulting to 2.

\(fn COMPARE-FUNCTION &optional INITIAL-SIZE RESIZE-FACTOR)" nil nil)

(defalias 'heap-create 'make-heap)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "heap" '("heap-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/trie-0.4/trie-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/trie-0.4/trie-autoloads.el") (car load-path))))



(defalias 'make-trie 'trie--create "\
Return a new trie that uses comparison function COMPARISON-FUNCTION.

A trie stores sequences (strings, vectors or lists) along with
associated data. COMPARISON-FUNCTEION should accept two
arguments, each being an element of such a sequence, and return t
if the first is strictly smaller than the second.

The optional argument TYPE specifies the type of trie to
create. However, the only one that is currently implemented is
the default, so this argument is useless for now.

\(See also `make-trie-custom'.)")

(defalias 'trie-create 'make-trie)

(defalias 'make-trie-custom 'trie--create-custom "\
Return a new trie that uses comparison function COMPARISON-FUNCTION.

A trie stores sequences (strings, vectors or lists) along with
associated data. COMPARISON-FUNCTION should accept two arguments,
each being an element of such a sequence, and return t if the
first is strictly smaller than the second.

The remaining keyword arguments: :CREATEFUN, :INSERTFUN, :DELETEFUN,
:LOOKUPFUN, :MAPFUN, :EMPTYFUN, :STACK-CREATEFUN, :STACK-POPFUN,
:STACK-EMPTYFUN, :TRANSFORM-FOR-PRINT and :TRANSFORM-FROM-READ
determine the type of trie that is created.

CREATEFUN is called as follows:

  (CREATEFUN COMPARISON-FUNCTION SEQ)

and should return a data structure (\"ARRAY\") that can be used
as an associative array, where two elements A and B are equal if
the following is non-nil:

  (and (COMPARISON-FUNCTION b a)
       (COMPARISON-FUNCTION b a))

The SEQ argument is a vector containing the sequence that will
correspond to the newly created array in the trie. For most types
of trie, this value is ignored. It is passed to CREATEFUN only in
order to allow the creation of \"hybrid\" trie structures, in
which different types of associative array are used in different
parts of the trie. For example, the type of associative array
could be chosen based on the depth in the trie, given by (length
SEQ). (Note that all the other functions described below must be
able to correctly handle *any* of the types of associate array
that might be created by CREATEFUN.)

INSERTFUN, DELETEFUN, LOOKUPFUN, MAPFUN and EMPTYFUN should
insert, delete, lookup, map over, and check-if-there-exist-any
elements in an associative array. They are called as follows:

  (INSERTFUN array element &optional updatefun)
  (DELETEFUN array element &optional predicate nilflag)
  (LOOKUPFUN array element &optional nilflag)
  (MAPFUN function array &optional reverse)
  (EMPTYFUN array)

INSERTFUN should insert ELEMENT into ARRAY and return the new
element, which will be ELEMENT itself unless UPDATEFUN is
specified. In that case, if and only if an element matching
ELEMENT already exists in the associative array, INSERTFUN should
instead pass ELEMENT and the matching element as arguments to
UPDATEFUN, replace the matching element with the return value,
and return that return value.

DELETEFUN should delete the element in the associative array that
matches ELEMENT, and return the deleted element. However, if
PREDICATE is specified and a matching element exists in ARRAY,
DELETEFUN should first pass the matching element as an argument
to PREDICATE before deleting, and should only delete the element
if PREDICATE returns non-nil. DELETEFUN should return NILFLAG if
no element was deleted (either becuase no matching element was
found, or because TESTFUN returned nil).

LOOKUPFUN should return the element from the associative array
that matches ELEMENT, or NILFLAG if no matching element exists.

MAPFUN should map FUNCTION over all elements in the order defined by
COMPARISON-FUNCTION, or in reverse order if REVERSE is non-nil.


STACK-CREATEFUN, STACK-POPFUN and STACK-EMPTYFUN should allow the
associative array to be used as a stack. STACK-CREATEFUN is
called as follows:

  (STACK-CREATEFUN array)

and should return a data structure (\"STACK\") that behaves like
a sorted stack of all elements in the associative array. I.e.
successive calls to

  (STACK-POPFUN stack)

should return elements from the associative array in the order
defined by COMPARISON-FUNCTION, and

  (STACK-EMPTYFUN stack)

should return non-nil if the stack is empty, nil otherwise.

The stack functions are optional, in that all trie operations
other than the stack-related ones will work correctly. However,
any code that makes use of trie-stacks will complain if supplied
with this type of trie.


The :TRANSFORM-FOR-PRINT and :TRANSFORM-FROM-READ arguments are
optional. If supplied, they can be used to transform the trie
into a format suitable for passing to Elisp's `print'
functions (typically used to persistently store the trie by
writing it to file), and transform from that format back to the
original usable form.


Warning: to avoid nasty dynamic scoping bugs, the supplied
functions must *never* bind any variables with names commencing
\"--\".")

(defalias 'trie-create-custom 'make-trie-custom)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "trie" '("Lewenstein-" "edit-distance" "trie-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tree-mode-20151104.1331/tree-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tree-mode-20151104.1331/tree-mode-autoloads.el") (car load-path))))



(autoload 'tree-minor-mode "tree-mode" "\
More keybindings for tree-widget.

If called interactively, enable Tree minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{tree-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tree-mode" '("tree-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/thingopt-20160520.2318/thingopt-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/thingopt-20160520.2318/thingopt-autoloads.el") (car load-path))))



(autoload 'kill-thing "thingopt" "\


\(fn THING)" t nil)

(autoload 'copy-thing "thingopt" "\


\(fn THING)" t nil)

(autoload 'mark-thing "thingopt" "\


\(fn THING)" t nil)

(autoload 'upward-mark-thing "thingopt" "\
Marks the first type of thing in `upward-mark-thing-list' at
point.  When called successively, it marks successive types of
things in `upward-mark-thing-list'.  It is recommended to put
smaller things (e.g. word, symbol) before larger
things (e.g. list, paragraph) in `upward-mark-thing-list'.  When
this is called enough times to get to the end of the list, it
wraps back to the first type of thing.

\(fn)" t nil)

(autoload 'upward-isearch-thing "thingopt" "\
Much like `upward-mark-thing', but adds THING to the isearch string.
This should be invoked while isearch is active.  Clobbers the current isearch string.

\(fn)" t nil)

(autoload 'kill-region-dwim "thingopt" "\


\(fn)" t nil)

(autoload 'kill-ring-save-dwim "thingopt" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "thingopt" '("backward-" "bounds-of-up-list-at-point" "define-thing-commands" "forward-" "kill-" "list-thing" "read-thing" "reset-upward-bounds-of-thing" "string-face-p" "thing" "upward-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/test-simple-20170527.1532/test-simple-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/test-simple-20170527.1532/test-simple-autoloads.el") (car load-path))))



(autoload 'test-simple-start "test-simple" "\


\(fn &optional TEST-START-MSG)" nil t)

(autoload 'test-simple-clear "test-simple" "\
Initialize and reset everything to run tests.
You should run this before running any assertions.  Running more than once
clears out information from the previous run.

\(fn &optional TEST-INFO TEST-START-MSG)" t nil)

(autoload 'test-simple-run "test-simple" "\
Register command line to run tests non-interactively and bind key to run test.
After calling this function, you can run test by key specified by `test-simple-runner-key'.

It is preferable to write at the first line of test files as a comment, e.g,
;;;; (test-simple-run \"emacs -batch -L %s -l %s\" (file-name-directory (locate-library \"test-simple.elc\")) buffer-file-name)

Calling this function interactively, COMMAND-LINE-FORMATS is set above.

\(fn &rest COMMAND-LINE-FORMATS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "test-simple" '("assert-" "end-tests" "note" "test-simple-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/fringe-helper-20140620.2109/fringe-helper-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/fringe-helper-20140620.2109/fringe-helper-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fringe-helper" '("fringe-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/test-case-mode-20130525.1434/test-case-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/test-case-mode-20130525.1434/test-case-mode-autoloads.el") (car load-path))))



(autoload 'test-case-mode "test-case-mode" "\
A minor mode for test buffers.
Tests can be started with the commands `test-case-run' or
`test-case-run-all'.  If you want to run tests automatically after a
compilation, use `test-case-compilation-finish-run-all'.

If called interactively, enable Test-Case mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When a run has finished, the results appear in a buffer named \"*Test
Result*\".  Clicking on the files will take you to the failure location,
as will `next-error' and `previous-error'.

Failures are also highlighted in the buffer.  Hovering the mouse above
them, or enabling `test-case-echo-failure-mode' shows the associated
failure message.

The testing states are indicated visually.  The buffer name is colored
according to the result and a dot in the mode-line represents the global
state.  This behavior is customizable through `test-case-color-buffer-id'
and `test-case-mode-line-info-position'.

\(fn &optional ARG)" t nil)

(autoload 'enable-test-case-mode-if-test "test-case-mode" "\
Turns on ``test-case-mode'' if this buffer is a recognized test.

\(fn)" nil nil)
(add-hook 'find-file-hook 'enable-test-case-mode-if-test)

(autoload 'test-case-find-all-tests "test-case-mode" "\
Find all test cases in DIRECTORY.

\(fn DIRECTORY)" t nil)

(autoload 'test-case-compilation-finish-run-all "test-case-mode" "\
Post-compilation hook for running all tests after successful compilation.
Install this the following way:

\(add-hook 'compilation-finish-functions
          'test-case-compilation-finish-run-all)

\(fn BUFFER RESULT)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "test-case-mode" '("disable-test-case-mode" "tast-case-menu-format-buffer" "test-case-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/test-c-20180423.1720/test-c-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/test-c-20180423.1720/test-c-autoloads.el") (car load-path))))



(autoload 'test-c "test-c" "\
Compile and run a new test-c buffer (or reuse existing one).

\(fn NEW-BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "test-c" '("test-c-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term-run-20151228.905/term-run-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term-run-20151228.905/term-run-autoloads.el") (car load-path))))



(autoload 'term-run "term-run" "\
Run PROGRAM in BUFFER-OR-NAME with ARGS in terminal buffer.

If BUFFER-OR-NAME is given, use this buffer.  In this case, old process in the
buffer will be destroyed.  Otherwise, new buffer will be generated automatically
from PROGRAM.

This function returns the buffer where the process starts running.

\(fn PROGRAM &optional BUFFER-OR-NAME &rest ARGS)" nil nil)

(autoload 'term-run-shell-command "term-run" "\
Run COMMAND in terminal buffer.

If NEW-BUFFER-P is given or called with prefix argument, generate new terminal
buffer for running COMMAND.  Otherwise, use the same buffer.  In this case, old
process in the buffer will be destroyed.

This function returns the buffer where the process starts running.

\(fn COMMAND &optional NEW-BUFFER-P)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term-run" '("term-run-shell-command-history")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term-manager-20171020.841/term-manager-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term-manager-20171020.841/term-manager-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term-manager" '("term-manager")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term-manager-indexed-mapping" '("term-manager-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term+-20170509.17/term+-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term+-20170509.17/term+-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+edit" '("term+edit")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+file-transfer" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+input" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+logging" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+shell-history" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+vars" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-256color" '("term-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tab-group-20140306.1450/tab-group-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tab-group-20140306.1450/tab-group-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tab-group" '("tab-group:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term+mux-20140211.749/term+mux-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term+mux-20140211.749/term+mux-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+mux" '("term+mux-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tco-20160811.12/tco-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tco-20160811.12/tco-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tco" '("defun-tco" "tco-add-trampoline")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tablist-20170220.335/tablist-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tablist-20170220.335/tablist-autoloads.el") (car load-path))))



(autoload 'tablist-minor-mode "tablist" "\
Toggle Tablist minor mode on or off.

If called interactively, enable Tablist minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{tablist-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'tablist-mode "tablist" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tablist" '("tablist-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tablist-filter" '("tablist-filter-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tab-jump-out-20151006.130/tab-jump-out-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tab-jump-out-20151006.130/tab-jump-out-autoloads.el") (car load-path))))



(autoload 'tab-jump-out "tab-jump-out" "\
Use tab to jump out.

\(fn ARG)" t nil)

(autoload 'tab-jump-out-mode "tab-jump-out" "\
A minor mode that allows you to jump out with tab.

If called interactively, enable Tab-Jump-Out mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tab-jump-out" '("tab-jump-out-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/syntactic-close-20180924.947/syntactic-close-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/syntactic-close-20180924.947/syntactic-close-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "syntactic-close" '("haskell-interactive-mode-prompt-start" "syntactic-close")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/symbol-overlay-20181008.2016/symbol-overlay-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/symbol-overlay-20181008.2016/symbol-overlay-autoloads.el") (car load-path))))



(autoload 'symbol-overlay-mode "symbol-overlay" "\
Minor mode for auto-highlighting symbol at point.

If called interactively, enable Symbol-Overlay mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'symbol-overlay-put "symbol-overlay" "\
Toggle all overlays of symbol at point.

\(fn)" t nil)

(autoload 'symbol-overlay-count "symbol-overlay" "\
Show count of symbol at point.

\(fn)" t nil)

(autoload 'symbol-overlay-remove-all "symbol-overlay" "\
Remove all highlighted symbols in the buffer.

\(fn)" t nil)

(autoload 'symbol-overlay-save-symbol "symbol-overlay" "\
Copy symbol at point.

\(fn)" t nil)

(autoload 'symbol-overlay-toggle-in-scope "symbol-overlay" "\
Toggle overlays to be showed in buffer or only in scope.

\(fn)" t nil)

(autoload 'symbol-overlay-echo-mark "symbol-overlay" "\
Jump back to the mark.

\(fn)" t nil)

(autoload 'symbol-overlay-jump-next "symbol-overlay" "\
Jump to the next location of symbol at point.

\(fn)" t nil)

(autoload 'symbol-overlay-jump-prev "symbol-overlay" "\
Jump to the previous location of symbol at point.

\(fn)" t nil)

(autoload 'symbol-overlay-jump-to-definition "symbol-overlay" "\
Jump to the definition of symbol at point.
The definition syntax should be defined in a function stored in
`symbol-overlay-definition-function' that returns the definition's regexp
with the input symbol.

\(fn)" t nil)

(autoload 'symbol-overlay-switch-forward "symbol-overlay" "\
Switch forward to another symbol.

\(fn)" t nil)

(autoload 'symbol-overlay-switch-backward "symbol-overlay" "\
Switch backward to another symbol.

\(fn)" t nil)

(autoload 'symbol-overlay-isearch-literally "symbol-overlay" "\
Isearch symbol at point literally, without `regexp-quote' the symbol.

\(fn)" t nil)

(autoload 'symbol-overlay-query-replace "symbol-overlay" "\
Query replace symbol at point.

\(fn)" t nil)

(autoload 'symbol-overlay-rename "symbol-overlay" "\
Rename symbol at point on all its occurrences.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "symbol-overlay" '("symbol-overlay-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ivy-20180926.1249/ivy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ivy-20180926.1249/ivy-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "colir" '("colir-")))



(autoload 'ivy-resume "ivy" "\
Resume the last completion session.

\(fn)" t nil)

(autoload 'ivy-read "ivy" "\
Read a string in the minibuffer, with completion.

PROMPT is a format string, normally ending in a colon and a
space; %d anywhere in the string is replaced by the current
number of matching candidates.  For the literal % character,
escape it with %%. See also `ivy-count-format'.

COLLECTION is either a list of strings, a function, an alist, or
a hash table.

PREDICATE is applied to filter out the COLLECTION immediately.
This argument is for `completing-read' compat.

When REQUIRE-MATCH is non-nil, only members of COLLECTION can be
selected, i.e. custom text.

If INITIAL-INPUT is not nil, then insert that input in the
minibuffer initially.

HISTORY is a name of a variable to hold the completion session
history.

KEYMAP is composed with `ivy-minibuffer-map'.

If PRESELECT is not nil, then select the corresponding candidate
out of the ones that match the INITIAL-INPUT.

DEF is for compatibility with `completing-read'.

UPDATE-FN is called each time the current candidate(s) is changed.

When SORT is t, use `ivy-sort-functions-alist' for sorting.

ACTION is a lambda function to call after selecting a result.  It
takes a single string argument.

UNWIND is a lambda function to call before exiting.

RE-BUILDER is a lambda function to call to transform text into a
regex pattern.

MATCHER is to override matching.

DYNAMIC-COLLECTION is a boolean to specify if the list of
candidates is updated after each input by calling COLLECTION.

CALLER is a symbol to uniquely identify the caller to `ivy-read'.
It is used, along with COLLECTION, to determine which
customizations apply to the current completion session.

\(fn PROMPT COLLECTION &key PREDICATE REQUIRE-MATCH INITIAL-INPUT HISTORY PRESELECT DEF KEYMAP UPDATE-FN SORT ACTION UNWIND RE-BUILDER MATCHER DYNAMIC-COLLECTION CALLER)" nil nil)

(autoload 'ivy-completing-read "ivy" "\
Read a string in the minibuffer, with completion.

This interface conforms to `completing-read' and can be used for
`completing-read-function'.

PROMPT is a string that normally ends in a colon and a space.
COLLECTION is either a list of strings, an alist, an obarray, or a hash table.
PREDICATE limits completion to a subset of COLLECTION.
REQUIRE-MATCH is a boolean value.  See `completing-read'.
INITIAL-INPUT is a string inserted into the minibuffer initially.
HISTORY is a list of previously selected inputs.
DEF is the default value.
INHERIT-INPUT-METHOD is currently ignored.

\(fn PROMPT COLLECTION &optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HISTORY DEF INHERIT-INPUT-METHOD)" nil nil)

(defvar ivy-mode nil "\
Non-nil if Ivy mode is enabled.
See the `ivy-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ivy-mode'.")

(custom-autoload 'ivy-mode "ivy" nil)

(autoload 'ivy-mode "ivy" "\
Toggle Ivy mode on or off.
Turn Ivy mode on if ARG is positive, off otherwise.
Turning on Ivy mode sets `completing-read-function' to
`ivy-completing-read'.

Global bindings:
\\{ivy-mode-map}

Minibuffer bindings:
\\{ivy-minibuffer-map}

\(fn &optional ARG)" t nil)

(autoload 'ivy-switch-buffer "ivy" "\
Switch to another buffer.

\(fn)" t nil)

(autoload 'ivy-switch-view "ivy" "\
Switch to one of the window views stored by `ivy-push-view'.

\(fn)" t nil)

(autoload 'ivy-switch-buffer-other-window "ivy" "\
Switch to another buffer in another window.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy" '("ivy-" "with-ivy-window")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy-overlay" '("ivy-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/swiper-20181008.1731/swiper-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/swiper-20181008.1731/swiper-autoloads.el") (car load-path))))



(autoload 'swiper-avy "swiper" "\
Jump to one of the current swiper candidates.

\(fn)" t nil)

(autoload 'swiper "swiper" "\
`isearch' with an overview.
When non-nil, INITIAL-INPUT is the initial search pattern.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'swiper-all "swiper" "\
Run `swiper' for all open buffers.

\(fn &optional INITIAL-INPUT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "swiper" '("swiper-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sudo-ext-20170126.1214/sudo-ext-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sudo-ext-20170126.1214/sudo-ext-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sudo-ext" '("sudo")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sudo-edit-20180731.1908/sudo-edit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sudo-edit-20180731.1908/sudo-edit-autoloads.el") (car load-path))))



(autoload 'sudo-edit-set-header "sudo-edit" "\
*Display a warning in header line of the current buffer.
This function is suitable to add to `find-file-hook' and `dired-file-hook'.

\(fn)" nil nil)

(defvar sudo-edit-indicator-mode nil "\
Non-nil if Sudo-Edit-Indicator mode is enabled.
See the `sudo-edit-indicator-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `sudo-edit-indicator-mode'.")

(custom-autoload 'sudo-edit-indicator-mode "sudo-edit" nil)

(autoload 'sudo-edit-indicator-mode "sudo-edit" "\
Indicates editing as root by displaying a message in the header line.

If called interactively, enable Sudo-Edit-Indicator mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'sudo-edit "sudo-edit" "\
Edit currently visited file as another user, by default `sudo-edit-user'.

With a prefix ARG prompt for a file to visit.  Will also prompt
for a file to visit if current buffer is not visiting a file.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sudo-edit" '("sudo-edit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/string-edit-20160411.656/string-edit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/string-edit-20160411.656/string-edit-autoloads.el") (car load-path))))



(autoload 'string-edit-at-point "string-edit" "\
Pop up a buffer to edit the string at point.
This saves you from needing to manually escape characters.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "string-edit" '("se/" "string-edit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/strie-20160211.2222/strie-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/strie-20160211.2222/strie-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "strie" '("strie-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/stream-2.2.4/stream-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/stream-2.2.4/stream-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "stream" '("stream")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "stream-x" '("stream-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/strace-mode-20171116.2039/strace-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/strace-mode-20171116.2039/strace-mode-autoloads.el") (car load-path))))



(autoload 'strace-mode "strace-mode" "\
Major mode for strace output.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.strace\\'" . strace-mode))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-tunnels-20180703.2027/ssh-tunnels-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-tunnels-20180703.2027/ssh-tunnels-autoloads.el") (car load-path))))



(autoload 'ssh-tunnels "ssh-tunnels" "\
View and manipulate SSH tunnels.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh-tunnels" '("ssh-tunnels-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-config-mode-20180922.951/ssh-config-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-config-mode-20180922.951/ssh-config-mode-autoloads.el") (car load-path))))



(autoload 'ssh-config-mode "ssh-config-mode" "\
Major mode for fontifiying ssh config files.

\\{ssh-config-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("/\\.ssh/config\\'" . ssh-config-mode))

(add-to-list 'auto-mode-alist '("/sshd?_config\\'" . ssh-config-mode))

(add-to-list 'auto-mode-alist '("/known_hosts\\'" . ssh-known-hosts-mode))

(add-to-list 'auto-mode-alist '("/authorized_keys\\'" . ssh-authorized-keys-mode))

(autoload 'ssh-known-hosts-mode "ssh-config-mode" "\
Major mode for fontifiying ssh known_hosts files.
\\{ssh-known-hosts-mode}

\(fn)" t nil)
 (autoload 'ssh-authorized-keys-mode "ssh-config-mode" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh-config-mode" '("ssh-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-agency-20180508.26/ssh-agency-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-agency-20180508.26/ssh-agency-autoloads.el") (car load-path))))



(autoload 'ssh-agency-ensure "ssh-agency" "\
Start ssh-agent and add keys, as needed.

Intended to be added to `magit-credential-hook'.

\(fn)" nil nil)

(add-hook 'magit-credential-hook 'ssh-agency-ensure)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh-agency" '("ssh-agency-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-20120904.2042/ssh-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-20120904.2042/ssh-autoloads.el") (car load-path))))


 (add-hook 'same-window-regexps "^\\*ssh-.*\\*\\(\\|<[0-9]+>\\)")

(autoload 'ssh "ssh" "\
Open a network login connection via `ssh' with args INPUT-ARGS.
INPUT-ARGS should start with a host name; it may also contain
other arguments for `ssh'.

Input is sent line-at-a-time to the remote connection.

Communication with the remote host is recorded in a buffer `*ssh-HOST*'
\(or `*ssh-USER@HOST*' if the remote username differs).
If a prefix argument is given and the buffer `*ssh-HOST*' already exists,
a new buffer with a different connection will be made.

When called from a program, if the optional second argument BUFFER is
a string or buffer, it specifies the buffer to use.

The variable `ssh-program' contains the name of the actual program to
run.  It can be a relative or absolute path.

The variable `ssh-explicit-args' is a list of arguments to give to
the ssh when starting.  They are prepended to any arguments given in
INPUT-ARGS.

If the default value of `ssh-directory-tracking-mode' is t, then the
default directory in that buffer is set to a remote (FTP) file name to
access your home directory on the remote machine.  Occasionally this causes
an error, if you cannot access the home directory on that machine.  This
error is harmless as long as you don't try to use that default directory.

If `ssh-directory-tracking-mode' is neither t nor nil, then the default
directory is initially set up to your (local) home directory.
This is useful if the remote machine and your local machine
share the same files via NFS.  This is the default.

If you wish to change directory tracking styles during a session, use the
function `ssh-directory-tracking-mode' rather than simply setting the
variable.

The variable `ssh-x-display-follow-current-frame' can be used to specify
how ssh X display tunelling interacts with frames on remote displays.

\(fn INPUT-ARGS &optional BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh" '("ssh-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/srefactor-20180703.1810/srefactor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/srefactor-20180703.1810/srefactor-autoloads.el") (car load-path))))



(autoload 'srefactor-refactor-at-point "srefactor" "\
Offer contextual menu with actions based on current tag in scope.

Each menu item added returns a token for what type of refactoring
to perform.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "srefactor" '("srefactor-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "srefactor-lisp" '("comment-" "cur-buf" "first-token" "format-type" "ignore-num" "lexemes" "next-token" "orig-format-type" "recursive-p" "second-token" "srefactor-" "tok")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "srefactor-ui" '("srefactor-ui-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sotlisp-20180706.1749/sotlisp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sotlisp-20180706.1749/sotlisp-autoloads.el") (car load-path))))



(defvar speed-of-thought-mode nil "\
Non-nil if Speed-Of-Thought mode is enabled.
See the `speed-of-thought-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `speed-of-thought-mode'.")

(custom-autoload 'speed-of-thought-mode "sotlisp" nil)

(autoload 'speed-of-thought-mode "sotlisp" "\
Toggle Speed-Of-Thought mode on or off.

If called interactively, enable Speed-Of-Thought mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{speed-of-thought-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'speed-of-thought-hook-in "sotlisp" "\
Add functions ON and OFF to `speed-of-thought-mode' hooks.
If `speed-of-thought-mode' is already on, call ON.

\(fn ON OFF)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sotlisp" '("sotlisp-" "speed-of-thought-turn-o")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sotclojure-20170922.8/sotclojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sotclojure-20170922.8/sotclojure-autoloads.el") (car load-path))))



(autoload 'sotclojure-mode "sotclojure" "\
Toggle SoTclojure mode on or off.

If called interactively, enable SoTclojure mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{sotclojure-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sotclojure" '("sotclojure-")))



(autoload 'sotclojure-turn-on-everywhere "sotclojure-on" "\
Call-once function to turn on sotclojure everywhere.
Calls `sotclojure-mode' on all `clojure-mode' buffers, and sets
up a hook and abbrevs.

\(fn)" nil nil)

(eval-after-load 'sotlisp '(speed-of-thought-hook-in #'sotclojure-turn-on-everywhere #'sotclojure-turn-off-everywhere))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sotclojure-on" '("sotclojure-turn-off-everywhere")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/snippet-20130210.2315/snippet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/snippet-20130210.2315/snippet-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "snippet" '("snippet")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smartscan-20170211.2033/smartscan-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smartscan-20170211.2033/smartscan-autoloads.el") (car load-path))))



(autoload 'smartscan-symbol-go-forward "smartscan" "\
Jumps forward to the next symbol at point

\(fn)" t nil)

(autoload 'smartscan-symbol-go-backward "smartscan" "\
Jumps backward to the previous symbol at point

\(fn)" t nil)

(autoload 'smartscan-symbol-replace "smartscan" "\
Replaces the symbol at point with another string in the entire buffer.

With C-u the scope is limited to the current defun, as defined by
`narrow-to-defun'.

This function uses `search-forward' and `replace-match' to do the
actual work.

\(fn ARG)" t nil)

(autoload 'smartscan-mode "smartscan" "\
Jumps between other symbols found at point.

If called interactively, enable Smartscan mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When Smart Scan mode is enabled, you can jump between the all the
symbols in your current buffer that point is on.

You can customize Smart Scan by editing
`smartscan-use-extended-syntax' and `smartscan-symbol-selector'.

Key bindings:
\\{smartscan-map}

\(fn &optional ARG)" t nil)

(defvar global-smartscan-mode nil "\
Non-nil if Global Smartscan mode is enabled.
See the `global-smartscan-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-smartscan-mode'.")

(custom-autoload 'global-smartscan-mode "smartscan" nil)

(autoload 'global-smartscan-mode "smartscan" "\
Toggle Smartscan mode in all buffers.
With prefix ARG, enable Global Smartscan mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Smartscan mode is enabled in all buffers where
`smartscan-mode-turn-on' would do it.
See `smartscan-mode' for more information on Smartscan mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartscan" '("smartscan-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smartparens-20181007.1501/smartparens-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smartparens-20181007.1501/smartparens-autoloads.el") (car load-path))))



(autoload 'sp-cheat-sheet "smartparens" "\
Generate a cheat sheet of all the smartparens interactive functions.

Without a prefix argument, print only the short documentation and examples.

With non-nil prefix argument ARG, show the full documentation for each function.

You can follow the links to the function or variable help page.
To get back to the full list, use \\[help-go-back].

You can use `beginning-of-defun' and `end-of-defun' to jump to
the previous/next entry.

Examples are fontified using the `font-lock-string-face' for
better orientation.

\(fn &optional ARG)" t nil)

(defvar smartparens-mode-map (make-sparse-keymap) "\
Keymap used for `smartparens-mode'.")

(autoload 'sp-use-paredit-bindings "smartparens" "\
Initiate `smartparens-mode-map' with `sp-paredit-bindings'.

\(fn)" t nil)

(autoload 'sp-use-smartparens-bindings "smartparens" "\
Initiate `smartparens-mode-map' with `sp-smartparens-bindings'.

\(fn)" t nil)

(autoload 'smartparens-mode "smartparens" "\
Toggle smartparens mode.

If called interactively, enable Smartparens mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

You can enable pre-set bindings by customizing
`sp-base-key-bindings' variable.  The current content of
`smartparens-mode-map' is:

 \\{smartparens-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'smartparens-strict-mode "smartparens" "\
Toggle the strict smartparens mode.

If called interactively, enable Smartparens-Strict mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When strict mode is active, `delete-char', `kill-word' and their
backward variants will skip over the pair delimiters in order to
keep the structure always valid (the same way as `paredit-mode'
does).  This is accomplished by remapping them to
`sp-delete-char' and `sp-kill-word'.  There is also function
`sp-kill-symbol' that deletes symbols instead of words, otherwise
working exactly the same (it is not bound to any key by default).

When strict mode is active, this is indicated with \"/s\"
after the smartparens indicator in the mode list.

\(fn &optional ARG)" t nil)

(defvar smartparens-global-strict-mode nil "\
Non-nil if Smartparens-Global-Strict mode is enabled.
See the `smartparens-global-strict-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `smartparens-global-strict-mode'.")

(custom-autoload 'smartparens-global-strict-mode "smartparens" nil)

(autoload 'smartparens-global-strict-mode "smartparens" "\
Toggle Smartparens-Strict mode in all buffers.
With prefix ARG, enable Smartparens-Global-Strict mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Smartparens-Strict mode is enabled in all buffers where
`turn-on-smartparens-strict-mode' would do it.
See `smartparens-strict-mode' for more information on Smartparens-Strict mode.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-smartparens-strict-mode "smartparens" "\
Turn on `smartparens-strict-mode'.

\(fn)" t nil)

(autoload 'turn-off-smartparens-strict-mode "smartparens" "\
Turn off `smartparens-strict-mode'.

\(fn)" t nil)

(defvar smartparens-global-mode nil "\
Non-nil if Smartparens-Global mode is enabled.
See the `smartparens-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `smartparens-global-mode'.")

(custom-autoload 'smartparens-global-mode "smartparens" nil)

(autoload 'smartparens-global-mode "smartparens" "\
Toggle Smartparens mode in all buffers.
With prefix ARG, enable Smartparens-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Smartparens mode is enabled in all buffers where
`turn-on-smartparens-mode' would do it.
See `smartparens-mode' for more information on Smartparens mode.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-smartparens-mode "smartparens" "\
Turn on `smartparens-mode'.

This function is used to turn on `smartparens-global-mode'.

By default `smartparens-global-mode' ignores buffers with
`mode-class' set to special, but only if they are also not comint
buffers.

Additionally, buffers on `sp-ignore-modes-list' are ignored.

You can still turn on smartparens in these mode manually (or
in mode's startup-hook etc.) by calling `smartparens-mode'.

\(fn)" t nil)

(autoload 'turn-off-smartparens-mode "smartparens" "\
Turn off `smartparens-mode'.

\(fn)" t nil)

(autoload 'show-smartparens-mode "smartparens" "\
Toggle visualization of matching pairs.  When enabled, any
matching pair is highlighted after `sp-show-pair-delay' seconds
of Emacs idle time if the point is immediately in front or after
a pair.  This mode works similarly to `show-paren-mode', but
support custom pairs.

If called interactively, enable Show-Smartparens mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar show-smartparens-global-mode nil "\
Non-nil if Show-Smartparens-Global mode is enabled.
See the `show-smartparens-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `show-smartparens-global-mode'.")

(custom-autoload 'show-smartparens-global-mode "smartparens" nil)

(autoload 'show-smartparens-global-mode "smartparens" "\
Toggle Show-Smartparens mode in all buffers.
With prefix ARG, enable Show-Smartparens-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Show-Smartparens mode is enabled in all buffers where
`turn-on-show-smartparens-mode' would do it.
See `show-smartparens-mode' for more information on Show-Smartparens mode.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-show-smartparens-mode "smartparens" "\
Turn on `show-smartparens-mode'.

\(fn)" t nil)

(autoload 'turn-off-show-smartparens-mode "smartparens" "\
Turn off `show-smartparens-mode'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens" '("smartparens-" "sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-clojure" '("sp-clojure-prefix")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-config" '("sp-lisp-invalid-hyperlink-p")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-crystal" '("sp-crystal-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-elixir" '("sp-elixir-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-ess" '("sp-ess-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-haskell" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-html" '("sp-html-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-latex" '("sp-latex-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-lua" '("sp-lua-post-keyword-insert")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-markdown" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-org" '("sp--org-skip-asterisk")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-python" '("sp-python-fix-tripple-quotes")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-ruby" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-rust" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-scala" '("sp-scala-wrap-with-indented-newlines")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-text" '("sp-text-mode-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/f-20180106.922/f-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/f-20180106.922/f-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "f" '("f-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/popup-20160709.1429/popup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/popup-20160709.1429/popup-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "popup" '("popup-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/dumb-jump-20180930.550/dumb-jump-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/dumb-jump-20180930.550/dumb-jump-autoloads.el") (car load-path))))



(defvar dumb-jump-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "C-M-g") 'dumb-jump-go) (define-key map (kbd "C-M-p") 'dumb-jump-back) (define-key map (kbd "C-M-q") 'dumb-jump-quick-look) map))

(autoload 'dumb-jump-back "dumb-jump" "\
Jump back to where the last jump was done.

\(fn)" t nil)

(autoload 'dumb-jump-quick-look "dumb-jump" "\
Run dumb-jump-go in quick look mode.  That is, show a tooltip of where it would jump instead.

\(fn)" t nil)

(autoload 'dumb-jump-go-other-window "dumb-jump" "\
Like 'dumb-jump-go' but use 'find-file-other-window' instead of 'find-file'.

\(fn)" t nil)

(autoload 'dumb-jump-go-current-window "dumb-jump" "\
Like dumb-jump-go but always use 'find-file'.

\(fn)" t nil)

(autoload 'dumb-jump-go-prefer-external "dumb-jump" "\
Like dumb-jump-go but prefer external matches from the current file.

\(fn)" t nil)

(autoload 'dumb-jump-go-prompt "dumb-jump" "\
Like dumb-jump-go but prompts for function instead of using under point

\(fn)" t nil)

(autoload 'dumb-jump-go-prefer-external-other-window "dumb-jump" "\
Like dumb-jump-go-prefer-external but use 'find-file-other-window' instead of 'find-file'.

\(fn)" t nil)

(autoload 'dumb-jump-go "dumb-jump" "\
Go to the function/variable declaration for thing at point.
When USE-TOOLTIP is t a tooltip jump preview will show instead.
When PREFER-EXTERNAL is t it will sort external matches before
current file.

\(fn &optional USE-TOOLTIP PREFER-EXTERNAL PROMPT)" t nil)

(defvar dumb-jump-mode nil "\
Non-nil if Dumb-Jump mode is enabled.
See the `dumb-jump-mode' command
for a description of this minor mode.")

(custom-autoload 'dumb-jump-mode "dumb-jump" nil)

(autoload 'dumb-jump-mode "dumb-jump" "\
Minor mode for jumping to variable and function definitions

If called interactively, enable Dumb-Jump mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dumb-jump" '("dumb-jump-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-jump-20180822.139/smart-jump-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-jump-20180822.139/smart-jump-autoloads.el") (car load-path))))



(autoload 'smart-jump-setup-default-registers "smart-jump" "\
Register a default set of modes for `smart-jump'.

\(fn)" t nil)

(autoload 'smart-jump-diag "smart-jump" "\
Pop a buffer with information about `smart-jump'.

\(fn)" t nil)

(autoload 'smart-jump-peek "smart-jump" "\
Peek at definition.

\(fn)" t nil)

(autoload 'smart-jump-go "smart-jump" "\
Go to the function/variable declartion for thing at point.

SMART-LIST will be set (or nil) if this is a continuation of a previous jump.

CONTINUE will be non nil if this is a continuation of a previous jump.

\(fn &optional SMART-LIST CONTINUE)" t nil)

(autoload 'smart-jump-back "smart-jump" "\
Jump back to where the last jump was done.

\(fn)" t nil)

(autoload 'smart-jump-references "smart-jump" "\
Find references with fallback.
Optional argument SMART-LIST This will be non-nil of continuation of previous
call to `smart-jump-references'.

CONTINUE will be set if this is a continuation of a previous call to
`smart-jump-references'.

\(fn &optional SMART-LIST CONTINUE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump" '("smart-jump-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-cc-mode" '("smart-jump-cc-mode-register")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-clojure-mode" '("smart-jump-clojure-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-csharp-mode" '("smart-jump-csharp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-eglot" '("smart-jump-eglot-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-elisp-mode" '("smart-jump-elisp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-elixir-mode" '("smart-jump-elixir-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-elm-mode" '("smart-jump-elm-mode-register")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-erlang-mode" '("smart-jump-erlang-mode-register")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-go-mode" '("smart-jump-go-mode-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-haskell-mode" '("smart-jump-haskell-mode-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-js2-mode" '("smart-jump-js2-mode-register")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-lisp-mode" '("smart-jump-lisp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-lispy" '("smart-jump-lispy-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-lsp-mode" '("smart-jump-lsp-mode-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-lua-mode" '("smart-jump-lua-mode-register")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-python" '("smart-jump-python-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-ruby-mode" '("smart-jump-ruby-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-rust-mode" '("smart-jump-rust-mode-r")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-scala-mode" '("smart-jump-scala-mode-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-scheme" '("smart-jump-scheme-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-swift-mode" '("smart-jump-swift-mode-register")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-typescript-mode" '("smart-jump-typescript-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-jump-web-mode" '("smart-jump-web-mode-register")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/expand-region-20180817.1134/expand-region-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/expand-region-20180817.1134/expand-region-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cc-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cperl-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "css-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "enh-ruby-mode-expansions" '("er/add-enh-ruby-mode-expansions")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "er-basic-expansions" '("er--" "er/mark-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-mode-expansions" '("er/add-erlang-mode-expansions")))



(autoload 'er/expand-region "expand-region" "\
Increase selected region by semantic units.

With prefix argument expands the region that many times.
If prefix argument is negative calls `er/contract-region'.
If prefix argument is 0 it resets point and mark to their state
before calling `er/expand-region' for the first time.

\(fn ARG)" t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "expand-region-core" '("er--" "er/")))



(let ((loads (get 'expand-region 'custom-loads))) (if (member '"expand-region-custom" loads) nil (put 'expand-region 'custom-loads (cons '"expand-region-custom" loads))))

(defvar expand-region-preferred-python-mode 'python "\
The name of your preferred python mode")

(custom-autoload 'expand-region-preferred-python-mode "expand-region-custom" t)

(defvar expand-region-guess-python-mode t "\
If expand-region should attempt to guess your preferred python mode")

(custom-autoload 'expand-region-guess-python-mode "expand-region-custom" t)

(defvar expand-region-autocopy-register "" "\
If set to a string of a single character (try \"e\"), then the
contents of the most recent expand or contract command will
always be copied to the register named after that character.")

(custom-autoload 'expand-region-autocopy-register "expand-region-custom" t)

(defvar expand-region-skip-whitespace t "\
If expand-region should skip past whitespace on initial expansion")

(custom-autoload 'expand-region-skip-whitespace "expand-region-custom" t)

(defvar expand-region-fast-keys-enabled t "\
If expand-region should bind fast keys after initial expand/contract")

(custom-autoload 'expand-region-fast-keys-enabled "expand-region-custom" t)

(defvar expand-region-contract-fast-key "-" "\
Key to use after an initial expand/contract to contract once more.")

(custom-autoload 'expand-region-contract-fast-key "expand-region-custom" t)

(defvar expand-region-reset-fast-key "0" "\
Key to use after an initial expand/contract to undo.")

(custom-autoload 'expand-region-reset-fast-key "expand-region-custom" t)

(defvar expand-region-exclude-text-mode-expansions '(html-mode nxml-mode) "\
List of modes which derive from `text-mode' for which text mode expansions are not appropriate.")

(custom-autoload 'expand-region-exclude-text-mode-expansions "expand-region-custom" t)

(defvar expand-region-smart-cursor nil "\
Defines whether the cursor should be placed intelligently after expansion.

If set to t, and the cursor is already at the beginning of the new region,
keep it there; otherwise, put it at the end of the region.

If set to nil, always place the cursor at the beginning of the region.")

(custom-autoload 'expand-region-smart-cursor "expand-region-custom" t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "expand-region-custom" '("expand-region-guess-python-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "feature-mode-expansions" '("er--block-between-keywords" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "html-mode-expansions" '("er--" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "js-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "js2-mode-expansions" '("er/add-js2-mode-expansions" "js2-mark-parent-statement")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "jsp-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "latex-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nxml-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "octave-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-el-expansions" '("er--python-string-delimiter" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-el-fgallina-expansions" '("er--python-" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-mode-expansions" '("er--" "er/" "py-goto-beyond-clause")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ruby-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sml-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "subword-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "text-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "the-org-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-mode-expansions" '("er/add-web-mode-expansions")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-forward-20140430.713/smart-forward-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-forward-20140430.713/smart-forward-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-forward" '("smart-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-cursor-color-20141124.1719/smart-cursor-color-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-cursor-color-20141124.1719/smart-cursor-color-autoloads.el") (car load-path))))



(defvar smart-cursor-color-mode nil "\
Non-nil if Smart-Cursor-Color mode is enabled.
See the `smart-cursor-color-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `smart-cursor-color-mode'.")

(custom-autoload 'smart-cursor-color-mode "smart-cursor-color" nil)

(autoload 'smart-cursor-color-mode "smart-cursor-color" "\
Dynamically changed cursor color at point's color.

If called interactively, enable Smart-Cursor-Color mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-smart-cursor-color "smart-cursor-color" "\
Unconditionally turn on `smart-cursor-color-mode'.

\(fn)" t nil)

(autoload 'turn-off-smart-cursor-color "smart-cursor-color" "\
Unconditionally turn off `smart-cursor-color-mode'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-cursor-color" '("scc--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-compile-20180316.330/smart-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-compile-20180316.330/smart-compile-autoloads.el") (car load-path))))



(autoload 'smart-compile "smart-compile" "\
An interface to `compile'.
It calls `compile' or other compile function,
which is defined in `smart-compile-alist'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-compile" '("smart-compile-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-comment-20160322.1839/smart-comment-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-comment-20160322.1839/smart-comment-autoloads.el") (car load-path))))



(autoload 'smart-comment-cleanup "smart-comment" "\
Remove lines marked for deletion.

\(fn)" t nil)

(autoload 'smart-comment-mark-line "smart-comment" "\
Mark a line for deletion. ARG is ignored.

\(fn ARG)" t nil)

(autoload 'smart-comment-mark-region "smart-comment" "\
Mark a region from BEG to END for deletion. ARG is ignored.

\(fn BEG END ARG)" t nil)

(autoload 'smart-comment-region "smart-comment" "\
Comment or uncomment a region from BEG to END. ARG is ignored.

\(fn BEG END ARG)" t nil)

(autoload 'smart-comment-line "smart-comment" "\
Comment or uncomment a line. ARG is ignored.

\(fn ARG)" t nil)

(autoload 'smart-comment "smart-comment" "\
Smart commenting based on the location of point on line.
A single ARG is passed along to the function being invoked. Two
universal arguments invoke `smart-comment-cleanup' which deletes
all lines marked for deletion.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-comment" '("smart-comment-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/macrostep-20161120.2106/macrostep-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/macrostep-20161120.2106/macrostep-autoloads.el") (car load-path))))



(autoload 'macrostep-mode "macrostep" "\
Minor mode for inline expansion of macros in Emacs Lisp source buffers.

If called interactively, enable Macrostep mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\<macrostep-keymap>Progressively expand macro forms with \\[macrostep-expand], collapse them with \\[macrostep-collapse],
and move back and forth with \\[macrostep-next-macro] and \\[macrostep-prev-macro].
Use \\[macrostep-collapse-all] or collapse all visible expansions to
quit and return to normal editing.

\\{macrostep-keymap}

\(fn &optional ARG)" t nil)

(autoload 'macrostep-expand "macrostep" "\
Expand the macro form following point by one step.

Enters `macrostep-mode' if it is not already active, making the
buffer temporarily read-only. If macrostep-mode is active and the
form following point is not a macro form, search forward in the
buffer and expand the next macro form found, if any.

With a prefix argument, the expansion is displayed in a separate
buffer instead of inline in the current buffer.  Setting
`macrostep-expand-in-separate-buffer' to non-nil swaps these two
behaviors.

\(fn &optional TOGGLE-SEPARATE-BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macrostep" '("macrostep-")))



(autoload 'macrostep-c-mode-hook "macrostep-c" "\


\(fn)" nil nil)

(add-hook 'c-mode-hook #'macrostep-c-mode-hook)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macrostep-c" '("macrostep-c-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/slime-20180923.1848/slime-autoloads.el"))






(autoload 'slime "slime"
  "Start a Lisp subprocess and connect to its Swank server." t)

(autoload 'slime-mode "slime"
  "SLIME: The Superior Lisp Interaction (Minor) Mode for Emacs." t)

(autoload 'slime-connect "slime"
  "Connect to a running Swank server." t)

(autoload 'slime-selector "slime"
  "Select a new by type, indicated by a single character." t)

(autoload 'hyperspec-lookup "lib/hyperspec" nil t)

(autoload 'slime-lisp-mode-hook "slime")

(autoload 'slime-scheme-mode-hook "slime")

(defvar slime-contribs nil
  "A list of contrib packages to load with SLIME.")

(autoload 'slime-setup "slime"
  "Setup some SLIME contribs.")

(define-obsolete-variable-alias 'slime-setup-contribs
  'slime-contribs "2.3.2")

(add-hook 'lisp-mode-hook 'slime-lisp-mode-hook)

(provide 'slime-autoloads)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "slime" '("??" "?c" "?d" "?e" "?i" "?l" "?n" "?p" "?q" "?t" "?v" "def-slime-selector-method" "define-sl" "inferior-lisp-program" "make-slime-" "sldb-" "slime")))





(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "slime-tests" '("arglist" "async-eval-debugging" "break" "comp" "def-slime-test" "dis" "end-of-file" "find-definition" "flow-control" "indentation" "inspector" "inter" "locally-bound-debugger-hook" "loop-interrupt-" "macroexpand" "narrowing" "read" "report-condition-with-circular-list" "sbcl-world-lock" "sexp-at-point.1" "symbol-at-point." "traditional-recipe" "unwind-to-previous-sldb-level" "utf-8-source")))

)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-20180913.2311/company-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-20180913.2311/company-autoloads.el") (car load-path))))



(autoload 'company-mode "company" "\
\"complete anything\"; is an in-buffer completion framework.
Completion starts automatically, depending on the values
`company-idle-delay' and `company-minimum-prefix-length'.

If called interactively, enable Company mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Completion can be controlled with the commands:
`company-complete-common', `company-complete-selection', `company-complete',
`company-select-next', `company-select-previous'.  If these commands are
called before `company-idle-delay', completion will also start.

Completions can be searched with `company-search-candidates' or
`company-filter-candidates'.  These can be used while completion is
inactive, as well.

The completion data is retrieved using `company-backends' and displayed
using `company-frontends'.  If you want to start a specific backend, call
it interactively or use `company-begin-backend'.

By default, the completions list is sorted alphabetically, unless the
backend chooses otherwise, or `company-transformers' changes it later.

regular keymap (`company-mode-map'):

\\{company-mode-map}
keymap during active completions (`company-active-map'):

\\{company-active-map}

\(fn &optional ARG)" t nil)

(defvar global-company-mode nil "\
Non-nil if Global Company mode is enabled.
See the `global-company-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-company-mode'.")

(custom-autoload 'global-company-mode "company" nil)

(autoload 'global-company-mode "company" "\
Toggle Company mode in all buffers.
With prefix ARG, enable Global Company mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Company mode is enabled in all buffers where
`company-mode-on' would do it.
See `company-mode' for more information on Company mode.

\(fn &optional ARG)" t nil)

(autoload 'company-manual-begin "company" "\


\(fn)" t nil)

(autoload 'company-complete "company" "\
Insert the common part of all candidates or the current selection.
The first time this is called, the common part is inserted, the second
time, or when the selection has been changed, the selected candidate is
inserted.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company" '("company-")))



(autoload 'company-abbrev "company-abbrev" "\
`company-mode' completion backend for abbrev.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-abbrev" '("company-abbrev-insert")))



(autoload 'company-bbdb "company-bbdb" "\
`company-mode' completion backend for BBDB.

\(fn COMMAND &optional ARG &rest IGNORE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-bbdb" '("company-bbdb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-capf" '("company-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-clang" '("company-clang")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-cmake" '("company-cmake")))



(autoload 'company-css "company-css" "\
`company-mode' completion backend for `css-mode'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-css" '("company-css-")))



(autoload 'company-dabbrev "company-dabbrev" "\
dabbrev-like `company-mode' completion backend.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-dabbrev" '("company-dabbrev-")))



(autoload 'company-dabbrev-code "company-dabbrev-code" "\
dabbrev-like `company-mode' backend for code.
The backend looks for all symbols in the current buffer that aren't in
comments or strings.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-dabbrev-code" '("company-dabbrev-code-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-eclim" '("company-eclim")))



(autoload 'company-elisp "company-elisp" "\
`company-mode' completion backend for Emacs Lisp.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-elisp" '("company-elisp-")))



(autoload 'company-etags "company-etags" "\
`company-mode' completion backend for etags.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-etags" '("company-etags-")))



(autoload 'company-files "company-files" "\
`company-mode' completion backend existing file names.
Completions works for proper absolute and relative files paths.
File paths with spaces are only supported inside strings.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-files" '("company-file")))



(autoload 'company-gtags "company-gtags" "\
`company-mode' completion backend for GNU Global.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-gtags" '("company-gtags-")))



(autoload 'company-ispell "company-ispell" "\
`company-mode' completion backend using Ispell.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-ispell" '("company-ispell-")))



(autoload 'company-keywords "company-keywords" "\
`company-mode' backend for programming language keywords.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-keywords" '("company-keywords-")))



(autoload 'company-nxml "company-nxml" "\
`company-mode' completion backend for `nxml-mode'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-nxml" '("company-nxml-")))



(autoload 'company-oddmuse "company-oddmuse" "\
`company-mode' completion backend for `oddmuse-mode'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-oddmuse" '("company-oddmuse-")))



(autoload 'company-semantic "company-semantic" "\
`company-mode' completion backend using CEDET Semantic.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-semantic" '("company-semantic-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-template" '("company-template-")))



(autoload 'company-tempo "company-tempo" "\
`company-mode' completion backend for tempo.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-tempo" '("company-tempo-")))



(autoload 'company-tng-frontend "company-tng" "\
When the user changes the selection at least once, this
frontend will display the candidate in the buffer as if it's
already there and any key outside of `company-active-map' will
confirm the selection and finish the completion.

\(fn COMMAND)" nil nil)

(autoload 'company-tng-configure-default "company-tng" "\
Applies the default configuration to enable company-tng.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-tng" '("company-tng--")))



(autoload 'company-xcode "company-xcode" "\
`company-mode' completion backend for Xcode projects.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-xcode" '("company-xcode-")))



(autoload 'company-yasnippet "company-yasnippet" "\
`company-mode' backend for `yasnippet'.

This backend should be used with care, because as long as there are
snippets defined for the current major mode, this backend will always
shadow backends that come after it.  Recommended usages:

* In a buffer-local value of `company-backends', grouped with a backend or
  several that provide actual text completions.

  (add-hook 'js-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   '((company-dabbrev-code company-yasnippet)))))

* After keyword `:with', grouped with other backends.

  (push '(company-semantic :with company-yasnippet) company-backends)

* Not in `company-backends', just bound to a key.

  (global-set-key (kbd \"C-c y\") 'company-yasnippet)

\(fn COMMAND &optional ARG &rest IGNORE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-yasnippet" '("company-yasnippet--")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/slime-company-20180119.1843/slime-company-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/slime-company-20180119.1843/slime-company-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "slime-company" '("company-slime" "slime-company")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/simple-httpd-20180528.1603/simple-httpd-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/simple-httpd-20180528.1603/simple-httpd-autoloads.el") (car load-path))))



(autoload 'httpd-start "simple-httpd" "\
Start the web server process. If the server is already
running, this will restart the server. There is only one server
instance per Emacs instance.

\(fn)" t nil)

(autoload 'httpd-stop "simple-httpd" "\
Stop the web server if it is currently running, otherwise do nothing.

\(fn)" t nil)

(autoload 'httpd-running-p "simple-httpd" "\
Return non-nil if the simple-httpd server is running.

\(fn)" nil nil)

(autoload 'httpd-serve-directory "simple-httpd" "\
Start the web server with given `directory' as `httpd-root'.

\(fn DIRECTORY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "simple-httpd" '("defservlet" "httpd" "with-httpd-buffer")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/signal-20160816.1438/signal-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/signal-20160816.1438/signal-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "signal" '("defsignal" "undefsignal")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shell-toggle-20150226.1411/shell-toggle-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shell-toggle-20150226.1411/shell-toggle-autoloads.el") (car load-path))))



(autoload 'shell-toggle-cd "shell-toggle" "\
Call `shell-toggle' with a prefix argument.
See command `shell-toggle'.

\(fn)" t nil)

(autoload 'shell-toggle "shell-toggle" "\
Toggle between the shell buffer and whatever buffer you are editing.
With a prefix argument MAKE-CD also insert a \"cd DIR\" command
into the shell, where DIR is the directory of the current buffer.

Call twice in a row to get a full screen window for the shell buffer.

When called in the shell buffer returns you to the buffer you were editing
before calling this the first time.

Options: `shell-toggle-goto-eob'

\(fn MAKE-CD)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shell-toggle" '("shell-toggle-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shell-switcher-20161029.552/shell-switcher-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shell-switcher-20161029.552/shell-switcher-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rswitcher" '("rswitcher-")))



(defvar shell-switcher-new-shell-function 'shell-switcher-make-eshell "\
This variable references a function used to create new shells.
The function must take 0 arguments and return a newly created
shell buffer.
`shell-switcher-make-shell',`shell-switcher-make-eshell' and
`shell-switcher-make-ansi-term' are possible functions.")

(custom-autoload 'shell-switcher-new-shell-function "shell-switcher" t)

(defvar shell-switcher-ask-before-creating-new nil "\
If non-nil ask the user before creating a new shell buffer.
A new shell buffer is automatically created if there are no
buffers to switch to and this variable is set to nil.")

(custom-autoload 'shell-switcher-ask-before-creating-new "shell-switcher" t)

(defvar shell-switcher-ansi-term-shell "" "\
If non-empty use this shell with `ansi-term'.
Otherwise the shell will be chosen based on the environment with
a fallback to /bin/sh")

(custom-autoload 'shell-switcher-ansi-term-shell "shell-switcher" t)

(defvar shell-switcher-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "C-'") 'shell-switcher-switch-buffer) (define-key map (kbd "C-x 4 '") 'shell-switcher-switch-buffer-other-window) (define-key map (kbd "C-M-'") 'shell-switcher-new-shell) map) "\
Keymap to use in shell-switcher mode.")

(defvar shell-switcher-mode nil "\
Non-nil if Shell-Switcher mode is enabled.
See the `shell-switcher-mode' command
for a description of this minor mode.")

(custom-autoload 'shell-switcher-mode "shell-switcher" nil)

(autoload 'shell-switcher-mode "shell-switcher" "\
Toggle shell-switcher mode.
Interactively with no argument, this command toggles the mode. A
positive prefix argument enables the mode, any other prefix
argument disables it. From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

If called interactively, enable Shell-Switcher mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When shell-switcher mode is enabled, switching and creating shell
buffers is just a matter of calling
\\[shell-switcher-switch-buffer]. Then, you can type the last key
of this key binding again to continue switching. Additionally,
see commands \\[shell-switcher-switch-buffer-other-window] and
\\[shell-switcher-new-shell].

\(fn &optional ARG)" t nil)

(autoload 'shell-switcher-switch-buffer "shell-switcher" "\
Switch to the most recently accessed buffer.
Switch to the most recently accessed shell buffer that is not the
current one.  Pressing the last key of the key sequence that call
this command will result in switching to the next shell buffer :
for example, if `C-'' is bound to this command, repeatedly
pressing `'' (quote) will let the user visit all shell
buffers (this is actually done by `sswitcher--switch-partially'.

If there is no shell buffer or if the only shell buffer is the
current buffer, propose the creation of a new shell buffer.

\(fn)" t nil)

(autoload 'shell-switcher-switch-buffer-other-window "shell-switcher" "\
Switch to the most recently accessed buffer in another window.
Same as `shell-switcher-switch-buffer' but change another
window.

\(fn)" t nil)

(autoload 'shell-switcher-new-shell "shell-switcher" "\
Unconditionally create and display a new shell buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shell-switcher" '("shell-switcher-" "sswitcher--")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shell-command-20090830.1040/shell-command-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shell-command-20090830.1040/shell-command-autoloads.el") (car load-path))))



(autoload 'shell-command-completion-mode "shell-command" "\
Enable or disable tab-completion for some commands.
The commands are `shell-command', `shell-command-on-region', `grep',
`grep-find' and `compile'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shell-command" '("compile-prompt" "grep-" "shell-command")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sexp-move-20150915.1730/sexp-move-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sexp-move-20150915.1730/sexp-move-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sexp-move" '("*sexp-move-read-table*" "sexp-move-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sequences-20170818.1252/sequences-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sequences-20170818.1252/sequences-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sequences" '("sequences-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sed-mode-1.0/sed-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sed-mode-1.0/sed-mode-autoloads.el") (car load-path))))


 (add-to-list 'auto-mode-alist '("\\.sed\\'" . sed-mode))
 (add-to-list 'interpreter-mode-alist '("sed" . sed-mode))

(autoload 'sed-mode "sed-mode" "\
Sed editing mode.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sed-mode" '("sed-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/scheme-here-20141028.718/scheme-here-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/scheme-here-20141028.718/scheme-here-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "scheme-here" '("run-scheme-here" "scheme-here-" "switch-to-scheme-here")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/scheme-complete-20170824.1413/scheme-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/scheme-complete-20170824.1413/scheme-complete-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "scheme-complete" '("*scheme-" "in-mod-p" "scheme-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sayid-20180901.903/sayid-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sayid-20180901.903/sayid-autoloads.el") (car load-path))))



(autoload 'sayid--inject-jack-in-dependencies "sayid" "\
Inject the REPL dependencies of sayid at `cider-jack-in'.
If injecting the dependencies is not preferred set `sayid-inject-dependencies-at-jack-in' to nil.

\(fn)" nil nil)

(eval-after-load 'cider '(sayid--inject-jack-in-dependencies))

(autoload 'sayid-version "sayid" "\
Show which version of Sayid and the sayid Emacs package are in use.

\(fn)" t nil)

(autoload 'sayid-get-trace-ns-dir "sayid" "\
Return current trace ns dir, or prompt for it if not set.

\(fn)" t nil)

(autoload 'sayid-set-trace-ns-dir "sayid" "\
Prompt for trace ns dir and store value.

\(fn)" t nil)

(autoload 'sayid-query-form-at-point "sayid" "\
Query sayid for calls made to function defined at point.

\(fn)" t nil)

(autoload 'sayid-get-meta-at-point "sayid" "\
Query sayid for meta data of form at point.

\(fn)" t nil)

(autoload 'sayid-trace-fn-enable "sayid" "\
Enable tracing for symbol at point.  Symbol should point to a fn var.

\(fn)" t nil)

(autoload 'sayid-trace-fn-disable "sayid" "\
Disable tracing for symbol at point.  Symbol should point to a fn var.

\(fn)" t nil)

(autoload 'sayid-outer-trace-fn "sayid" "\
Add outer tracing for symbol at point.  Symbol should point to a fn var.

\(fn)" t nil)

(autoload 'sayid-inner-trace-fn "sayid" "\
Add inner tracing for symbol at point.  Symbol should point to a fn var.

\(fn)" t nil)

(autoload 'sayid-remove-trace-fn "sayid" "\
Remove tracing for symbol at point.  Symbol should point to a fn var.

\(fn)" t nil)

(autoload 'sayid-load-enable-clear "sayid" "\
Workflow helper function.
Disable traces, load buffer, enable traces, clear log.

\(fn)" t nil)

(autoload 'sayid-get-workspace "sayid" "\
View sayid workspace.

\(fn)" t nil)

(autoload 'sayid-show-traced "sayid" "\
Show what sayid has traced.  Optionally specify namespace NS.

\(fn &optional NS)" t nil)

(autoload 'sayid-show-traced-ns "sayid" "\
Show what sayid has traced in current namespace.

\(fn)" t nil)

(autoload 'sayid-traced-buf-enter "sayid" "\
Perform 'enter' on trace buffer.  Either navigate to ns view or function source.

\(fn)" t nil)

(autoload 'sayid-trace-all-ns-in-dir "sayid" "\
Trace all namespaces in specified dir.

\(fn)" t nil)

(autoload 'sayid-trace-ns-in-file "sayid" "\
Trace namespace defined in current buffer.

\(fn)" t nil)

(autoload 'sayid-trace-ns-by-pattern "sayid" "\
Trace all namespaces that match specified pattern.

\(fn)" t nil)

(autoload 'sayid-trace-enable-all "sayid" "\
Enable all traces.

\(fn)" t nil)

(autoload 'sayid-trace-disable-all "sayid" "\
Disable all traces.

\(fn)" t nil)

(autoload 'sayid-traced-buf-inner-trace-fn "sayid" "\
Apply inner trace from trace buffer.

\(fn)" t nil)

(autoload 'sayid-traced-buf-outer-trace-fn "sayid" "\
Apply outer trace from trace buffer.

\(fn)" t nil)

(autoload 'sayid-traced-buf-enable "sayid" "\
Enable trace from trace buffer.

\(fn)" t nil)

(autoload 'sayid-traced-buf-disable "sayid" "\
Disable trace from trace buffer.

\(fn)" t nil)

(autoload 'sayid-traced-buf-remove-trace "sayid" "\
Remove trace from trace buffer.

\(fn)" t nil)

(autoload 'sayid-kill-all-traces "sayid" "\
Kill all traces.

\(fn)" t nil)

(autoload 'sayid-clear-log "sayid" "\
Clear workspace log.

\(fn)" t nil)

(autoload 'sayid-reset-workspace "sayid" "\
Reset all traces and log in workspace.

\(fn)" t nil)

(autoload 'sayid-buffer-nav-from-point "sayid" "\
Navigate from sayid buffer to function source.

\(fn)" t nil)

(autoload 'sayid-buffer-nav-to-prev "sayid" "\
Move point to previous function in sayid buffer.

\(fn)" t nil)

(autoload 'sayid-buffer-nav-to-next "sayid" "\
Move point to next function in sayid buffer.

\(fn)" t nil)

(autoload 'sayid-query-id-w-mod "sayid" "\
Query workspace for id, with optional modifier.

\(fn)" t nil)

(autoload 'sayid-query-id "sayid" "\
Query workspace for id.

\(fn)" t nil)

(autoload 'sayid-query-fn-w-mod "sayid" "\
Query workspace for function, with optional modifier.

\(fn)" t nil)

(autoload 'sayid-query-fn "sayid" "\
Query workspace for function.

\(fn)" t nil)

(autoload 'sayid-buf-def-at-point "sayid" "\
Def value at point to a var.

\(fn)" t nil)

(autoload 'sayid-buf-inspect-at-point "sayid" "\
Def value at point and pass to 'cider-inspect'.

\(fn)" t nil)

(autoload 'sayid-buf-pprint-at-point "sayid" "\
Open pretty-print buffer for value at point in sayid buffer.

\(fn)" t nil)

(autoload 'sayid-set-view "sayid" "\
Set view.

\(fn)" t nil)

(autoload 'sayid-toggle-view "sayid" "\
Toggle whether view is active.

\(fn)" t nil)

(autoload 'sayid-gen-instance-expr "sayid" "\
Try to generate an expression that will reproduce traced call.
Place expression in kill ring.

\(fn)" t nil)

(autoload 'sayid-buf-back "sayid" "\
Move to previous sayid buffer state.

\(fn)" t nil)

(autoload 'sayid-buf-forward "sayid" "\
Move to next sayid buffer state.

\(fn)" t nil)

(autoload 'sayid-mode "sayid" "\
A major mode for displaying Sayid output

\(fn)" t nil)

(autoload 'sayid-traced-mode "sayid" "\
A major mode for displaying Sayid trace output.

\(fn)" t nil)

(autoload 'sayid-pprint-mode "sayid" "\
A major mode for displaying Sayid pretty print output.

\(fn)" t nil)

(autoload 'sayid-setup-package "sayid" "\
Setup the sayid package.  Optionally takes CLJ-MODE-PREFIX,
which is used as the prefix for clojure-mode keybindings.
Default prefix is 'C-c s'.

\(fn &optional CLJ-MODE-PREFIX)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sayid" '("sayid-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/projectile-20181009.851/projectile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/projectile-20181009.851/projectile-autoloads.el") (car load-path))))



(autoload 'projectile-version "projectile" "\
Get the Projectile version as string.

If called interactively or if SHOW-VERSION is non-nil, show the
version in the echo area and the messages buffer.

The returned string includes both, the version from package.el
and the library version, if both a present and different.

If the version number could not be determined, signal an error,
if called interactively, or if SHOW-VERSION is non-nil, otherwise
just return nil.

\(fn &optional SHOW-VERSION)" t nil)

(autoload 'projectile-invalidate-cache "projectile" "\
Remove the current project's files from `projectile-projects-cache'.

With a prefix argument PROMPT prompts for the name of the project whose cache
to invalidate.

\(fn PROMPT)" t nil)

(autoload 'projectile-purge-file-from-cache "projectile" "\
Purge FILE from the cache of the current project.

\(fn FILE)" t nil)

(autoload 'projectile-purge-dir-from-cache "projectile" "\
Purge DIR from the cache of the current project.

\(fn DIR)" t nil)

(autoload 'projectile-cache-current-file "projectile" "\
Add the currently visited file to the cache.

\(fn)" t nil)

(autoload 'projectile-discover-projects-in-directory "projectile" "\
Discover any projects in DIRECTORY and add them to the projectile cache.
This function is not recursive and only adds projects with roots
at the top level of DIRECTORY.

\(fn DIRECTORY)" t nil)

(autoload 'projectile-discover-projects-in-search-path "projectile" "\
Discover projects in `projectile-project-search-path'.
Invoked automatically when `projectile-mode' is enabled.

\(fn)" t nil)

(autoload 'projectile-switch-to-buffer "projectile" "\
Switch to a project buffer.

\(fn)" t nil)

(autoload 'projectile-switch-to-buffer-other-window "projectile" "\
Switch to a project buffer and show it in another window.

\(fn)" t nil)

(autoload 'projectile-switch-to-buffer-other-frame "projectile" "\
Switch to a project buffer and show it in another window.

\(fn)" t nil)

(autoload 'projectile-display-buffer "projectile" "\
Display a project buffer in another window without selecting it.

\(fn)" t nil)

(autoload 'projectile-project-buffers-other-buffer "projectile" "\
Switch to the most recently selected buffer project buffer.
Only buffers not visible in windows are returned.

\(fn)" t nil)

(autoload 'projectile-multi-occur "projectile" "\
Do a `multi-occur' in the project's buffers.
With a prefix argument, show NLINES of context.

\(fn &optional NLINES)" t nil)

(autoload 'projectile-find-other-file "projectile" "\
Switch between files with the same name but different extensions.
With FLEX-MATCHING, match any file that contains the base name of current file.
Other file extensions can be customized with the variable `projectile-other-file-alist'.

\(fn &optional FLEX-MATCHING)" t nil)

(autoload 'projectile-find-other-file-other-window "projectile" "\
Switch between files with the same name but different extensions in other window.
With FLEX-MATCHING, match any file that contains the base name of current file.
Other file extensions can be customized with the variable `projectile-other-file-alist'.

\(fn &optional FLEX-MATCHING)" t nil)

(autoload 'projectile-find-other-file-other-frame "projectile" "\
Switch between files with the same name but different extensions in other window.
With FLEX-MATCHING, match any file that contains the base name of current file.
Other file extensions can be customized with the variable `projectile-other-file-alist'.

\(fn &optional FLEX-MATCHING)" t nil)

(autoload 'projectile-find-file-dwim "projectile" "\
Jump to a project's files using completion based on context.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

If point is on a filename, Projectile first tries to search for that
file in project:

- If it finds just a file, it switches to that file instantly.  This works even
if the filename is incomplete, but there's only a single file in the current project
that matches the filename at point.  For example, if there's only a single file named
\"projectile/projectile.el\" but the current filename is \"projectile/proj\" (incomplete),
`projectile-find-file-dwim' still switches to \"projectile/projectile.el\" immediately
 because this is the only filename that matches.

- If it finds a list of files, the list is displayed for selecting.  A list of
files is displayed when a filename appears more than one in the project or the
filename at point is a prefix of more than two files in a project.  For example,
if `projectile-find-file-dwim' is executed on a filepath like \"projectile/\", it lists
the content of that directory.  If it is executed on a partial filename like
 \"projectile/a\", a list of files with character 'a' in that directory is presented.

- If it finds nothing, display a list of all files in project for selecting.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-file-dwim-other-window "projectile" "\
Jump to a project's files using completion based on context in other window.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

If point is on a filename, Projectile first tries to search for that
file in project:

- If it finds just a file, it switches to that file instantly.  This works even
if the filename is incomplete, but there's only a single file in the current project
that matches the filename at point.  For example, if there's only a single file named
\"projectile/projectile.el\" but the current filename is \"projectile/proj\" (incomplete),
`projectile-find-file-dwim-other-window' still switches to \"projectile/projectile.el\"
immediately because this is the only filename that matches.

- If it finds a list of files, the list is displayed for selecting.  A list of
files is displayed when a filename appears more than one in the project or the
filename at point is a prefix of more than two files in a project.  For example,
if `projectile-find-file-dwim-other-window' is executed on a filepath like \"projectile/\", it lists
the content of that directory.  If it is executed on a partial filename
like \"projectile/a\", a list of files with character 'a' in that directory
is presented.

- If it finds nothing, display a list of all files in project for selecting.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-file-dwim-other-frame "projectile" "\
Jump to a project's files using completion based on context in other frame.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

If point is on a filename, Projectile first tries to search for that
file in project:

- If it finds just a file, it switches to that file instantly.  This works even
if the filename is incomplete, but there's only a single file in the current project
that matches the filename at point.  For example, if there's only a single file named
\"projectile/projectile.el\" but the current filename is \"projectile/proj\" (incomplete),
`projectile-find-file-dwim-other-frame' still switches to \"projectile/projectile.el\"
immediately because this is the only filename that matches.

- If it finds a list of files, the list is displayed for selecting.  A list of
files is displayed when a filename appears more than one in the project or the
filename at point is a prefix of more than two files in a project.  For example,
if `projectile-find-file-dwim-other-frame' is executed on a filepath like \"projectile/\", it lists
the content of that directory.  If it is executed on a partial filename
like \"projectile/a\", a list of files with character 'a' in that directory
is presented.

- If it finds nothing, display a list of all files in project for selecting.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-file "projectile" "\
Jump to a project's file using completion.
With a prefix arg INVALIDATE-CACHE invalidates the cache first.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-file-other-window "projectile" "\
Jump to a project's file using completion and show it in another window.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-file-other-frame "projectile" "\
Jump to a project's file using completion and show it in another frame.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-toggle-project-read-only "projectile" "\
Toggle project read only.

\(fn)" t nil)

(autoload 'projectile-find-dir "projectile" "\
Jump to a project's directory using completion.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-dir-other-window "projectile" "\
Jump to a project's directory in other window using completion.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-dir-other-frame "projectile" "\
Jump to a project's directory in other window using completion.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-find-test-file "projectile" "\
Jump to a project's test file using completion.

With a prefix arg INVALIDATE-CACHE invalidates the cache first.

\(fn &optional INVALIDATE-CACHE)" t nil)

(autoload 'projectile-project-info "projectile" "\
Display info for current project.

\(fn)" t nil)

(autoload 'projectile-find-implementation-or-test-other-window "projectile" "\
Open matching implementation or test file in other window.

\(fn)" t nil)

(autoload 'projectile-find-implementation-or-test-other-frame "projectile" "\
Open matching implementation or test file in other frame.

\(fn)" t nil)

(autoload 'projectile-toggle-between-implementation-and-test "projectile" "\
Toggle between an implementation file and its test file.

\(fn)" t nil)

(autoload 'projectile-grep "projectile" "\
Perform rgrep in the project.

With a prefix ARG asks for files (globbing-aware) which to grep in.
With prefix ARG of `-' (such as `M--'), default the files (without prompt),
to `projectile-grep-default-files'.

With REGEXP given, don't query the user for a regexp.

\(fn &optional REGEXP ARG)" t nil)

(autoload 'projectile-ag "projectile" "\
Run an ag search with SEARCH-TERM in the project.

With an optional prefix argument ARG SEARCH-TERM is interpreted as a
regular expression.

\(fn SEARCH-TERM &optional ARG)" t nil)

(autoload 'projectile-ripgrep "projectile" "\
Run a Ripgrep search with `SEARCH-TERM' at current project root.

SEARCH-TERM is a regexp.

\(fn SEARCH-TERM)" t nil)

(autoload 'projectile-regenerate-tags "projectile" "\
Regenerate the project's [e|g]tags.

\(fn)" t nil)

(autoload 'projectile-find-tag "projectile" "\
Find tag in project.

\(fn)" t nil)

(autoload 'projectile-run-command-in-root "projectile" "\
Invoke `execute-extended-command' in the project's root.

\(fn)" t nil)

(autoload 'projectile-run-shell-command-in-root "projectile" "\
Invoke `shell-command' in the project's root.

\(fn)" t nil)

(autoload 'projectile-run-async-shell-command-in-root "projectile" "\
Invoke `async-shell-command' in the project's root.

\(fn)" t nil)

(autoload 'projectile-run-shell "projectile" "\
Invoke `shell' in the project's root.

Switch to the project specific shell buffer if it already exists.

\(fn)" t nil)

(autoload 'projectile-run-eshell "projectile" "\
Invoke `eshell' in the project's root.

Switch to the project specific eshell buffer if it already exists.

\(fn)" t nil)

(autoload 'projectile-run-ielm "projectile" "\
Invoke `ielm' in the project's root.

Switch to the project specific ielm buffer if it already exists.

\(fn)" t nil)

(autoload 'projectile-run-term "projectile" "\
Invoke `term' in the project's root.

Switch to the project specific term buffer if it already exists.

\(fn PROGRAM)" t nil)

(autoload 'projectile-replace "projectile" "\
Replace literal string in project using non-regexp `tags-query-replace'.

With a prefix argument ARG prompts you for a directory on which
to run the replacement.

\(fn &optional ARG)" t nil)

(autoload 'projectile-replace-regexp "projectile" "\
Replace a regexp in the project using `tags-query-replace'.

With a prefix argument ARG prompts you for a directory on which
to run the replacement.

\(fn &optional ARG)" t nil)

(autoload 'projectile-kill-buffers "projectile" "\
Kill all project buffers.

\(fn)" t nil)

(autoload 'projectile-save-project-buffers "projectile" "\
Save all project buffers.

\(fn)" t nil)

(autoload 'projectile-dired "projectile" "\
Open `dired' at the root of the project.

\(fn)" t nil)

(autoload 'projectile-dired-other-window "projectile" "\
Open `dired'  at the root of the project in another window.

\(fn)" t nil)

(autoload 'projectile-dired-other-frame "projectile" "\
Open `dired' at the root of the project in another frame.

\(fn)" t nil)

(autoload 'projectile-vc "projectile" "\
Open `vc-dir' at the root of the project.

For git projects `magit-status-internal' is used if available.
For hg projects `monky-status' is used if available.

If PROJECT-ROOT is given, it is opened instead of the project
root directory of the current buffer file.  If interactively
called with a prefix argument, the user is prompted for a project
directory to open.

\(fn &optional PROJECT-ROOT)" t nil)

(autoload 'projectile-recentf "projectile" "\
Show a list of recently visited files in a project.

\(fn)" t nil)

(autoload 'projectile-configure-project "projectile" "\
Run project configure command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-compile-project "projectile" "\
Run project compilation command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-test-project "projectile" "\
Run project test command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-run-project "projectile" "\
Run project run command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-switch-project "projectile" "\
Switch to a project we have visited before.
Invokes the command referenced by `projectile-switch-project-action' on switch.
With a prefix ARG invokes `projectile-commander' instead of
`projectile-switch-project-action.'

\(fn &optional ARG)" t nil)

(autoload 'projectile-switch-open-project "projectile" "\
Switch to a project we have currently opened.
Invokes the command referenced by `projectile-switch-project-action' on switch.
With a prefix ARG invokes `projectile-commander' instead of
`projectile-switch-project-action.'

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-file-in-directory "projectile" "\
Jump to a file in a (maybe regular) DIRECTORY.

This command will first prompt for the directory the file is in.

\(fn &optional DIRECTORY)" t nil)

(autoload 'projectile-find-file-in-known-projects "projectile" "\
Jump to a file in any of the known projects.

\(fn)" t nil)

(autoload 'projectile-cleanup-known-projects "projectile" "\
Remove known projects that don't exist anymore.

\(fn)" t nil)

(autoload 'projectile-clear-known-projects "projectile" "\
Clear both `projectile-known-projects' and `projectile-known-projects-file'.

\(fn)" t nil)

(autoload 'projectile-remove-known-project "projectile" "\
Remove PROJECT from the list of known projects.

\(fn &optional PROJECT)" t nil)

(autoload 'projectile-remove-current-project-from-known-projects "projectile" "\
Remove the current project from the list of known projects.

\(fn)" t nil)

(autoload 'projectile-ibuffer "projectile" "\
Open an IBuffer window showing all buffers in the current project.

Let user choose another project when PROMPT-FOR-PROJECT is supplied.

\(fn PROMPT-FOR-PROJECT)" t nil)

(autoload 'projectile-commander "projectile" "\
Execute a Projectile command with a single letter.
The user is prompted for a single character indicating the action to invoke.
The `?' character describes then
available actions.

See `def-projectile-commander-method' for defining new methods.

\(fn)" t nil)

(autoload 'projectile-browse-dirty-projects "projectile" "\
Browse dirty version controlled projects.

With a prefix argument, or if CACHED is non-nil, try to use the cached
dirty project list.

\(fn &optional CACHED)" t nil)

(autoload 'projectile-edit-dir-locals "projectile" "\
Edit or create a .dir-locals.el file of the project.

\(fn)" t nil)

(defvar projectile-mode nil "\
Non-nil if Projectile mode is enabled.
See the `projectile-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `projectile-mode'.")

(custom-autoload 'projectile-mode "projectile" nil)

(autoload 'projectile-mode "projectile" "\
Minor mode to assist project management and navigation.

When called interactively, toggle `projectile-mode'.  With prefix
ARG, enable `projectile-mode' if ARG is positive, otherwise disable
it.

When called from Lisp, enable `projectile-mode' if ARG is omitted,
nil or positive.  If ARG is `toggle', toggle `projectile-mode'.
Otherwise behave as if called interactively.

\\{projectile-mode-map}

\(fn &optional ARG)" t nil)

(define-obsolete-function-alias 'projectile-global-mode 'projectile-mode "1.0")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "projectile" '("??" "def-projectile-commander-method" "projectile-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/markdown-mode-20180904.1601/markdown-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/markdown-mode-20180904.1601/markdown-mode-autoloads.el") (car load-path))))



(autoload 'markdown-mode "markdown-mode" "\
Major mode for editing Markdown files.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))

(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

(autoload 'gfm-mode "markdown-mode" "\
Major mode for editing GitHub Flavored Markdown files.

\(fn)" t nil)

(autoload 'markdown-view-mode "markdown-mode" "\
Major mode for viewing Markdown content.

\(fn)" t nil)

(autoload 'gfm-view-mode "markdown-mode" "\
Major mode for viewing GitHub Flavored Markdown content.

\(fn)" t nil)

(autoload 'markdown-live-preview-mode "markdown-mode" "\
Toggle native previewing on save for a specific markdown file.

If called interactively, enable Markdown-Live-Preview mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "markdown-mode" '("defun-markdown-" "gfm-" "markdown")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/graphql-20180912.31/graphql-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/graphql-20180912.31/graphql-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "graphql" '("graphql-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ghub-20181003.1456/ghub-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ghub-20181003.1456/ghub-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "buck" '("buck-default-host")))



(autoload 'ghub-create-token "ghub" "\
Create, store and return a new token.

HOST is the Github instance, usually \"api.github.com\".
USERNAME is the name of a user on that instance.
PACKAGE is the package that will use the token.
SCOPES are the scopes the token is given access to.

\(fn HOST USERNAME PACKAGE SCOPES)" t nil)

(autoload 'ghub-token-scopes "ghub" "\
Return and echo the scopes of the specified token.
This is intended for debugging purposes only.  The user
has to provide several values including their password.

\(fn HOST USERNAME PACKAGE)" t nil)

(autoload 'ghub-clear-caches "ghub" "\
Clear all caches that might negatively affect Ghub.

If a library that is used by Ghub caches incorrect information
such as a mistyped password, then that can prevent Ghub from
asking the user for the correct information again.

Set `url-http-real-basic-auth-storage' to nil
and call `auth-source-forget+'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ghub" '("auth-source-netrc-parse-next-interesting@save-match-data" "ghub-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ghub-graphql" '("ghub-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "glab" '("glab-default-host")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gogs" '("gogs-default-host")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gtea" '("gtea-default-host")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-commit-20180912.1012/git-commit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-commit-20180912.1012/git-commit-autoloads.el") (car load-path))))



(defvar global-git-commit-mode t "\
Non-nil if Global Git-Commit mode is enabled.
See the `global-git-commit-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-git-commit-mode'.")

(custom-autoload 'global-git-commit-mode "git-commit" nil)

(autoload 'global-git-commit-mode "git-commit" "\
Edit Git commit messages.
This global mode arranges for `git-commit-setup' to be called
when a Git commit message file is opened.  That usually happens
when Git uses the Emacsclient as $GIT_EDITOR to have the user
provide such a commit message.

If called interactively, enable Global Git-Commit mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defconst git-commit-filename-regexp "/\\(\\(\\(COMMIT\\|NOTES\\|PULLREQ\\|TAG\\)_EDIT\\|MERGE_\\|\\)MSG\\|\\(BRANCH\\|EDIT\\)_DESCRIPTION\\)\\'")

(autoload 'git-commit-setup-check-buffer "git-commit" "\


\(fn)" nil nil)

(autoload 'git-commit-setup "git-commit" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-commit" '("git-commit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/magit-popup-20181003.921/magit-popup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/magit-popup-20181003.921/magit-popup-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-popup" '("magit-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/magit-20181009.8/magit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/magit-20181009.8/magit-autoloads.el") (car load-path))))



(autoload 'git-rebase-mode "git-rebase" "\
Major mode for editing of a Git rebase file.

Rebase files are generated when you run 'git rebase -i' or run
`magit-interactive-rebase'.  They describe how Git should perform
the rebase.  See the documentation for git-rebase (e.g., by
running 'man git-rebase' at the command line) for details.

\(fn)" t nil)

(defconst git-rebase-filename-regexp "/git-rebase-todo\\'")

(add-to-list 'auto-mode-alist (cons git-rebase-filename-regexp 'git-rebase-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-rebase" '("git-rebase-")))


 (autoload 'magit-dispatch-popup "magit" nil t)
 (autoload 'magit-run-popup "magit" nil t)

(autoload 'magit-git-command "magit" "\
Execute COMMAND asynchronously; display output.

Interactively, prompt for COMMAND in the minibuffer. \"git \" is
used as initial input, but can be deleted to run another command.

With a prefix argument COMMAND is run in the top-level directory
of the current working tree, otherwise in `default-directory'.

\(fn COMMAND)" t nil)

(autoload 'magit-git-command-topdir "magit" "\
Execute COMMAND asynchronously; display output.

Interactively, prompt for COMMAND in the minibuffer. \"git \" is
used as initial input, but can be deleted to run another command.

COMMAND is run in the top-level directory of the current
working tree.

\(fn COMMAND)" t nil)

(autoload 'magit-shell-command "magit" "\
Execute COMMAND asynchronously; display output.

Interactively, prompt for COMMAND in the minibuffer.  With a
prefix argument COMMAND is run in the top-level directory of
the current working tree, otherwise in `default-directory'.

\(fn COMMAND)" t nil)

(autoload 'magit-shell-command-topdir "magit" "\
Execute COMMAND asynchronously; display output.

Interactively, prompt for COMMAND in the minibuffer.  COMMAND
is run in the top-level directory of the current working tree.

\(fn COMMAND)" t nil)

(autoload 'magit-version "magit" "\
Return the version of Magit currently in use.
If optional argument PRINT-DEST is non-nil, output
stream (interactively, the echo area, or the current buffer with
a prefix argument), also print the used versions of Magit, Git,
and Emacs to it.

\(fn &optional PRINT-DEST)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit" '("magit-")))



(autoload 'magit-stage-file "magit-apply" "\
Stage all changes to FILE.
With a prefix argument or when there is no file at point ask for
the file to be staged.  Otherwise stage the file at point without
requiring confirmation.

\(fn FILE)" t nil)

(autoload 'magit-stage-modified "magit-apply" "\
Stage all changes to files modified in the worktree.
Stage all new content of tracked files and remove tracked files
that no longer exist in the working tree from the index also.
With a prefix argument also stage previously untracked (but not
ignored) files.

\(fn &optional ALL)" t nil)

(autoload 'magit-unstage-file "magit-apply" "\
Unstage all changes to FILE.
With a prefix argument or when there is no file at point ask for
the file to be unstaged.  Otherwise unstage the file at point
without requiring confirmation.

\(fn FILE)" t nil)

(autoload 'magit-unstage-all "magit-apply" "\
Remove all changes from the staging area.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-apply" '("magit-")))



(defvar magit-auto-revert-mode (and (not global-auto-revert-mode) (not noninteractive)) "\
Non-nil if Magit-Auto-Revert mode is enabled.
See the `magit-auto-revert-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `magit-auto-revert-mode'.")

(custom-autoload 'magit-auto-revert-mode "magit-autorevert" nil)

(autoload 'magit-auto-revert-mode "magit-autorevert" "\
Toggle Auto-Revert mode in all buffers.
With prefix ARG, enable Magit-Auto-Revert mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Revert mode is enabled in all buffers where
`magit-turn-on-auto-revert-mode-if-desired' would do it.
See `auto-revert-mode' for more information on Auto-Revert mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-autorevert" '("auto-revert-buffer" "magit-")))


 (autoload 'magit-bisect-popup "magit-bisect" nil t)

(autoload 'magit-bisect-start "magit-bisect" "\
Start a bisect session.

Bisecting a bug means to find the commit that introduced it.
This command starts such a bisect session by asking for a know
good and a bad commit.  To move the session forward use the
other actions from the bisect popup (\\<magit-status-mode-map>\\[magit-bisect-popup]).

\(fn BAD GOOD)" t nil)

(autoload 'magit-bisect-reset "magit-bisect" "\
After bisecting, cleanup bisection state and return to original `HEAD'.

\(fn)" t nil)

(autoload 'magit-bisect-good "magit-bisect" "\
While bisecting, mark the current commit as good.
Use this after you have asserted that the commit does not contain
the bug in question.

\(fn)" t nil)

(autoload 'magit-bisect-bad "magit-bisect" "\
While bisecting, mark the current commit as bad.
Use this after you have asserted that the commit does contain the
bug in question.

\(fn)" t nil)

(autoload 'magit-bisect-skip "magit-bisect" "\
While bisecting, skip the current commit.
Use this if for some reason the current commit is not a good one
to test.  This command lets Git choose a different one.

\(fn)" t nil)

(autoload 'magit-bisect-run "magit-bisect" "\
Bisect automatically by running commands after each step.

Unlike `git bisect run' this can be used before bisecting has
begun.  In that case it behaves like `git bisect start; git
bisect run'.

\(fn CMDLINE &optional BAD GOOD)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-bisect" '("magit-")))



(autoload 'magit-blame-echo "magit-blame" "\
For each line show the revision in which it was added.
Show the information about the chunk at point in the echo area
when moving between chunks.  Unlike other blaming commands, do
not turn on `read-only-mode'.

\(fn)" t nil)

(autoload 'magit-blame "magit-blame" "\
For each line show the revision in which it was added.

\(fn)" t nil)

(autoload 'magit-blame-removal "magit-blame" "\
For each line show the revision in which it was removed.

\(fn)" t nil)

(autoload 'magit-blame-reverse "magit-blame" "\
For each line show the last revision in which it still exists.

\(fn)" t nil)
 (autoload 'magit-blame-popup "magit-blame" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-blame" '("magit-")))



(autoload 'magit-bookmark--status-jump "magit-bookmark" "\
Handle a Magit status BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--status-make-record "magit-bookmark" "\
Create a Magit status bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--refs-jump "magit-bookmark" "\
Handle a Magit refs BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--refs-make-record "magit-bookmark" "\
Create a Magit refs bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--log-jump "magit-bookmark" "\
Handle a Magit log BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--log-make-record "magit-bookmark" "\
Create a Magit log bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--reflog-jump "magit-bookmark" "\
Handle a Magit reflog BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--reflog-make-record "magit-bookmark" "\
Create a Magit reflog bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--stashes-jump "magit-bookmark" "\
Handle a Magit stash list BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--stashes-make-record "magit-bookmark" "\
Create a Magit stash list bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--cherry-jump "magit-bookmark" "\
Handle a Magit cherry BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--cherry-make-record "magit-bookmark" "\
Create a Magit cherry bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--diff-jump "magit-bookmark" "\
Handle a Magit diff BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--diff-make-record "magit-bookmark" "\
Create a Magit diff bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--revision-jump "magit-bookmark" "\
Handle a Magit revision BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--revision-make-record "magit-bookmark" "\
Create a Magit revision bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--stash-jump "magit-bookmark" "\
Handle a Magit stash BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--stash-make-record "magit-bookmark" "\
Create a Magit stash bookmark.

\(fn)" nil nil)

(autoload 'magit-bookmark--submodules-jump "magit-bookmark" "\
Handle a Magit submodule list BOOKMARK.

\(fn BOOKMARK)" nil nil)

(autoload 'magit-bookmark--submodules-make-record "magit-bookmark" "\
Create a Magit submodule list bookmark.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-bookmark" '("magit-bookmark--")))


 (autoload 'magit-branch-popup "magit" nil t)

(autoload 'magit-checkout "magit-branch" "\
Checkout REVISION, updating the index and the working tree.
If REVISION is a local branch, then that becomes the current
branch.  If it is something else, then `HEAD' becomes detached.
Checkout fails if the working tree or the staging area contain
changes.

\(git checkout REVISION).

\(fn REVISION)" t nil)

(autoload 'magit-branch "magit-branch" "\
Create BRANCH at branch or revision START-POINT.

\(git branch [ARGS] BRANCH START-POINT).

\(fn BRANCH START-POINT &optional ARGS)" t nil)

(autoload 'magit-branch-and-checkout "magit-branch" "\
Create and checkout BRANCH at branch or revision START-POINT.

\(git checkout [ARGS] -b BRANCH START-POINT).

\(fn BRANCH START-POINT &optional ARGS)" t nil)

(autoload 'magit-branch-or-checkout "magit-branch" "\
Hybrid between `magit-checkout' and `magit-branch-and-checkout'.

Ask the user for an existing branch or revision.  If the user
input actually can be resolved as a branch or revision, then
check that out, just like `magit-checkout' would.

Otherwise create and checkout a new branch using the input as
its name.  Before doing so read the starting-point for the new
branch.  This is similar to what `magit-branch-and-checkout'
does.

\(fn ARG &optional START-POINT)" t nil)

(autoload 'magit-branch-checkout "magit-branch" "\
Checkout an existing or new local branch.

Read a branch name from the user offering all local branches and
a subset of remote branches as candidates.  Omit remote branches
for which a local branch by the same name exists from the list
of candidates.  The user can also enter a completely new branch
name.

- If the user selects an existing local branch, then check that
  out.

- If the user selects a remote branch, then create and checkout
  a new local branch with the same name.  Configure the selected
  remote branch as push target.

- If the user enters a new branch name, then create and check
  that out, after also reading the starting-point from the user.

In the latter two cases the upstream is also set.  Whether it is
set to the chosen START-POINT or something else depends on the
value of `magit-branch-adjust-remote-upstream-alist', just like
when using `magit-branch-and-checkout'.

\(fn BRANCH &optional START-POINT)" t nil)

(autoload 'magit-branch-orphan "magit-branch" "\
Create and checkout an orphan BRANCH with contents from revision START-POINT.

\(git checkout --orphan [ARGS] BRANCH START-POINT).

\(fn BRANCH START-POINT &optional ARGS)" t nil)

(autoload 'magit-branch-pull-request "magit-branch" "\
Create and configure a new branch from a pull-request.
Please see the manual for more information.

\(fn PR)" t nil)

(autoload 'magit-branch-spinoff "magit-branch" "\
Create new branch from the unpushed commits.

Create and checkout a new branch starting at and tracking the
current branch.  That branch in turn is reset to the last commit
it shares with its upstream.  If the current branch has no
upstream or no unpushed commits, then the new branch is created
anyway and the previously current branch is not touched.

This is useful to create a feature branch after work has already
began on the old branch (likely but not necessarily \"master\").

If the current branch is a member of the value of option
`magit-branch-prefer-remote-upstream' (which see), then the
current branch will be used as the starting point as usual, but
the upstream of the starting-point may be used as the upstream
of the new branch, instead of the starting-point itself.

If optional FROM is non-nil, then the source branch is reset
to `FROM~', instead of to the last commit it shares with its
upstream.  Interactively, FROM is only ever non-nil, if the
region selects some commits, and among those commits, FROM is
the commit that is the fewest commits ahead of the source
branch.

The commit at the other end of the selection actually does not
matter, all commits between FROM and `HEAD' are moved to the new
branch.  If FROM is not reachable from `HEAD' or is reachable
from the source branch's upstream, then an error is raised.

\(fn BRANCH &optional FROM &rest ARGS)" t nil)

(autoload 'magit-branch-reset "magit-branch" "\
Reset a branch to the tip of another branch or any other commit.

When the branch being reset is the current branch, then do a
hard reset.  If there are any uncommitted changes, then the user
has to confirm the reset because those changes would be lost.

This is useful when you have started work on a feature branch but
realize it's all crap and want to start over.

When resetting to another branch and a prefix argument is used,
then also set the target branch as the upstream of the branch
that is being reset.

\(fn BRANCH TO &optional ARGS SET-UPSTREAM)" t nil)

(autoload 'magit-branch-delete "magit-branch" "\
Delete one or multiple branches.
If the region marks multiple branches, then offer to delete
those, otherwise prompt for a single branch to be deleted,
defaulting to the branch at point.

\(fn BRANCHES &optional FORCE)" t nil)

(autoload 'magit-branch-rename "magit-branch" "\
Rename the branch named OLD to NEW.

With a prefix argument FORCE, rename even if a branch named NEW
already exists.

If `branch.OLD.pushRemote' is set, then unset it.  Depending on
the value of `magit-branch-rename-push-target' (which see) maybe
set `branch.NEW.pushRemote' and maybe rename the push-target on
the remote.

\(fn OLD NEW &optional FORCE)" t nil)

(autoload 'magit-branch-shelve "magit-branch" "\
Shelve a BRANCH.
Rename \"refs/heads/BRANCH\" to \"refs/shelved/BRANCH\",
and also rename the respective reflog file.

\(fn BRANCH)" t nil)

(autoload 'magit-branch-unshelve "magit-branch" "\
Unshelve a BRANCH
Rename \"refs/shelved/BRANCH\" to \"refs/heads/BRANCH\",
and also rename the respective reflog file.

\(fn BRANCH)" t nil)

(autoload 'magit-branch-config-popup "magit-branch" "\
Popup console for setting branch variables.

\(fn BRANCH)" t nil)

(autoload 'magit-edit-branch*description "magit-branch" "\
Edit the description of the current branch.
With a prefix argument edit the description of another branch.

The description for the branch named NAME is stored in the Git
variable `branch.<name>.description'.

\(fn BRANCH)" t nil)

(autoload 'magit-set-branch*merge/remote "magit-branch" "\
Set or unset the upstream of the current branch.
With a prefix argument do so for another branch.

When the branch in question already has an upstream then simply
unsets it.  Invoke this command again to set another upstream.

Together the Git variables `branch.<name>.remote' and
`branch.<name>.merge' define the upstream branch of the local
branch named NAME.  The value of `branch.<name>.remote' is the
name of the upstream remote.  The value of `branch.<name>.merge'
is the full reference of the upstream branch, on the remote.

Non-interactively, when UPSTREAM is non-nil, then always set it
as the new upstream, regardless of whether another upstream was
already set.  When nil, then always unset.

\(fn BRANCH UPSTREAM)" t nil)

(autoload 'magit-cycle-branch*rebase "magit-branch" "\
Cycle the value of `branch.<name>.rebase' for the current branch.
With a prefix argument cycle the value for another branch.

The Git variables `branch.<name>.rebase' controls whether pulling
into the branch named NAME is done by rebasing that branch onto
the fetched branch or by merging that branch.

When `true' then pulling is done by rebasing.
When `false' then pulling is done by merging.

When that variable is undefined then the value of `pull.rebase'
is used instead.  It defaults to `false'.

\(fn BRANCH)" t nil)

(autoload 'magit-cycle-branch*pushRemote "magit-branch" "\
Cycle the value of `branch.<name>.pushRemote' for the current branch.
With a prefix argument cycle the value for another branch.

The Git variable `branch.<name>.pushRemote' specifies the remote
that the branch named NAME is usually pushed to.  The value has
to be the name of an existing remote.

If that variable is undefined, then the value of the Git variable
`remote.pushDefault' is used instead, provided that it is defined,
which by default it is not.

\(fn BRANCH)" t nil)

(autoload 'magit-cycle-pull\.rebase "magit-branch" "\
Cycle the repository-local value of `pull.rebase'.

The Git variable `pull.rebase' specifies whether pulling is done
by rebasing or by merging.  It can be overwritten using the Git
variable `branch.<name>.rebase'.

When `true' then pulling is done by rebasing.
When `false' (the default) then pulling is done by merging.

\(fn)" t nil)

(autoload 'magit-cycle-remote\.pushDefault "magit-branch" "\
Cycle the repository-local value of `remote.pushDefault'.

The Git variable `remote.pushDefault' specifies the remote that
local branches are usually pushed to.  It can be overwritten
using the Git variable `branch.<name>.pushRemote'.

\(fn)" t nil)

(autoload 'magit-cycle-branch*autoSetupMerge "magit-branch" "\
Cycle the repository-local value of `branch.autoSetupMerge'.

The Git variable `branch.autoSetupMerge' under what circumstances
creating a branch (named NAME) should result in the variables
`branch.<name>.merge' and `branch.<name>.remote' being set
according to the starting point used to create the branch.  If
the starting point isn't a branch, then these variables are never
set.

When `always' then the variables are set regardless of whether
the starting point is a local or a remote branch.

When `true' (the default) then the variable are set when the
starting point is a remote branch, but not when it is a local
branch.

When `false' then the variables are never set.

\(fn)" t nil)

(autoload 'magit-cycle-branch*autoSetupRebase "magit-branch" "\
Cycle the repository-local value of `branch.autoSetupRebase'.

The Git variable `branch.autoSetupRebase' specifies whether
creating a branch (named NAME) should result in the variable
`branch.<name>.rebase' being set to `true'.

When `always' then the variable is set regardless of whether the
starting point is a local or a remote branch.

When `local' then the variable are set when the starting point
is a local branch, but not when it is a remote branch.

When `remote' then the variable are set when the starting point
is a remote branch, but not when it is a local branch.

When `never' (the default) then the variable is never set.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-branch" '("magit-")))



(autoload 'magit-browse-pull-request "magit-collab" "\
Visit pull-request PR using `browse-url'.

Currently this only supports Github, but that restriction will
be lifted eventually to support other Git forges.

\(fn PR)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-collab" '("magit-")))



(autoload 'magit-commit "magit-commit" "\
Create a new commit on `HEAD'.
With a prefix argument, amend to the commit at `HEAD' instead.

\(git commit [--amend] ARGS)

\(fn &optional ARGS)" t nil)

(autoload 'magit-commit-amend "magit-commit" "\
Amend the last commit.

\(git commit --amend ARGS)

\(fn &optional ARGS)" t nil)

(autoload 'magit-commit-extend "magit-commit" "\
Amend the last commit, without editing the message.

With a prefix argument keep the committer date, otherwise change
it.  The option `magit-commit-extend-override-date' can be used
to inverse the meaning of the prefix argument.  
\(git commit
--amend --no-edit)

\(fn &optional ARGS OVERRIDE-DATE)" t nil)

(autoload 'magit-commit-reword "magit-commit" "\
Reword the last commit, ignoring staged changes.

With a prefix argument keep the committer date, otherwise change
it.  The option `magit-commit-reword-override-date' can be used
to inverse the meaning of the prefix argument.

Non-interactively respect the optional OVERRIDE-DATE argument
and ignore the option.

\(git commit --amend --only)

\(fn &optional ARGS OVERRIDE-DATE)" t nil)

(autoload 'magit-commit-fixup "magit-commit" "\
Create a fixup commit.

With a prefix argument the target COMMIT has to be confirmed.
Otherwise the commit at point may be used without confirmation
depending on the value of option `magit-commit-squash-confirm'.

\(fn &optional COMMIT ARGS)" t nil)

(autoload 'magit-commit-squash "magit-commit" "\
Create a squash commit, without editing the squash message.

With a prefix argument the target COMMIT has to be confirmed.
Otherwise the commit at point may be used without confirmation
depending on the value of option `magit-commit-squash-confirm'.

\(fn &optional COMMIT ARGS)" t nil)

(autoload 'magit-commit-augment "magit-commit" "\
Create a squash commit, editing the squash message.

With a prefix argument the target COMMIT has to be confirmed.
Otherwise the commit at point may be used without confirmation
depending on the value of option `magit-commit-squash-confirm'.

\(fn &optional COMMIT ARGS)" t nil)

(autoload 'magit-commit-instant-fixup "magit-commit" "\
Create a fixup commit targeting COMMIT and instantly rebase.

\(fn &optional COMMIT ARGS)" t nil)

(autoload 'magit-commit-instant-squash "magit-commit" "\
Create a squash commit targeting COMMIT and instantly rebase.

\(fn &optional COMMIT ARGS)" t nil)

(autoload 'magit-commit-reshelve "magit-commit" "\
Change the committer date and possibly the author date of `HEAD'.

If you are the author of `HEAD', then both dates are changed,
otherwise only the committer date.  The current time is used
as the initial minibuffer input and the original author (if
that is you) or committer date is available as the previous
history element.

\(fn DATE)" t nil)
 (autoload 'magit-commit-absorb-popup "magit-commit" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-commit" '("magit-")))



(autoload 'magit-diff-popup "magit-diff" "\
Popup console for diff commands.

\(fn ARG)" t nil)

(autoload 'magit-diff-buffer-file-popup "magit-diff" "\
Popup console for diff commands.

This is a variant of `magit-diff-popup' which shows the same popup
but which limits the diff to the file being visited in the current
buffer.

\(fn)" t nil)

(autoload 'magit-diff-dwim "magit-diff" "\
Show changes for the thing at point.

\(fn &optional ARGS FILES)" t nil)

(autoload 'magit-diff "magit-diff" "\
Show differences between two commits.

REV-OR-RANGE should be a range or a single revision.  If it is a
revision, then show changes in the working tree relative to that
revision.  If it is a range, but one side is omitted, then show
changes relative to `HEAD'.

If the region is active, use the revisions on the first and last
line of the region as the two sides of the range.  With a prefix
argument, instead of diffing the revisions, choose a revision to
view changes along, starting at the common ancestor of both
revisions (i.e., use a \"...\" range).

\(fn REV-OR-RANGE &optional ARGS FILES)" t nil)

(autoload 'magit-diff-working-tree "magit-diff" "\
Show changes between the current working tree and the `HEAD' commit.
With a prefix argument show changes between the working tree and
a commit read from the minibuffer.

\(fn &optional REV ARGS FILES)" t nil)

(autoload 'magit-diff-staged "magit-diff" "\
Show changes between the index and the `HEAD' commit.
With a prefix argument show changes between the index and
a commit read from the minibuffer.

\(fn &optional REV ARGS FILES)" t nil)

(autoload 'magit-diff-unstaged "magit-diff" "\
Show changes between the working tree and the index.

\(fn &optional ARGS FILES)" t nil)

(autoload 'magit-diff-unmerged "magit-diff" "\
Show changes that are being merged.

\(fn &optional ARGS FILES)" t nil)

(autoload 'magit-diff-while-committing "magit-diff" "\
While committing, show the changes that are about to be committed.
While amending, invoking the command again toggles between
showing just the new changes or all the changes that will
be committed.

\(fn &optional ARGS)" t nil)

(autoload 'magit-diff-buffer-file "magit-diff" "\
Show diff for the blob or file visited in the current buffer.

\(fn)" t nil)

(autoload 'magit-diff-paths "magit-diff" "\
Show changes between any two files on disk.

\(fn A B)" t nil)

(autoload 'magit-show-commit "magit-diff" "\
Visit the revision at point in another buffer.
If there is no revision at point or with a prefix argument prompt
for a revision.

\(fn REV &optional ARGS FILES MODULE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-diff" '("magit-")))


 (autoload 'magit-ediff-popup "magit-ediff" nil t)

(autoload 'magit-ediff-resolve "magit-ediff" "\
Resolve outstanding conflicts in FILE using Ediff.
FILE has to be relative to the top directory of the repository.

In the rare event that you want to manually resolve all
conflicts, including those already resolved by Git, use
`ediff-merge-revisions-with-ancestor'.

\(fn FILE)" t nil)

(autoload 'magit-ediff-stage "magit-ediff" "\
Stage and unstage changes to FILE using Ediff.
FILE has to be relative to the top directory of the repository.

\(fn FILE)" t nil)

(autoload 'magit-ediff-compare "magit-ediff" "\
Compare REVA:FILEA with REVB:FILEB using Ediff.

FILEA and FILEB have to be relative to the top directory of the
repository.  If REVA or REVB is nil, then this stands for the
working tree state.

If the region is active, use the revisions on the first and last
line of the region.  With a prefix argument, instead of diffing
the revisions, choose a revision to view changes along, starting
at the common ancestor of both revisions (i.e., use a \"...\"
range).

\(fn REVA REVB FILEA FILEB)" t nil)

(autoload 'magit-ediff-dwim "magit-ediff" "\
Compare, stage, or resolve using Ediff.
This command tries to guess what file, and what commit or range
the user wants to compare, stage, or resolve using Ediff.  It
might only be able to guess either the file, or range or commit,
in which case the user is asked about the other.  It might not
always guess right, in which case the appropriate `magit-ediff-*'
command has to be used explicitly.  If it cannot read the user's
mind at all, then it asks the user for a command to run.

\(fn)" t nil)

(autoload 'magit-ediff-show-staged "magit-ediff" "\
Show staged changes using Ediff.

This only allows looking at the changes; to stage, unstage,
and discard changes using Ediff, use `magit-ediff-stage'.

FILE must be relative to the top directory of the repository.

\(fn FILE)" t nil)

(autoload 'magit-ediff-show-unstaged "magit-ediff" "\
Show unstaged changes using Ediff.

This only allows looking at the changes; to stage, unstage,
and discard changes using Ediff, use `magit-ediff-stage'.

FILE must be relative to the top directory of the repository.

\(fn FILE)" t nil)

(autoload 'magit-ediff-show-working-tree "magit-ediff" "\
Show changes between `HEAD' and working tree using Ediff.
FILE must be relative to the top directory of the repository.

\(fn FILE)" t nil)

(autoload 'magit-ediff-show-commit "magit-ediff" "\
Show changes introduced by COMMIT using Ediff.

\(fn COMMIT)" t nil)

(autoload 'magit-ediff-show-stash "magit-ediff" "\
Show changes introduced by STASH using Ediff.
`magit-ediff-show-stash-with-index' controls whether a
three-buffer Ediff is used in order to distinguish changes in the
stash that were staged.

\(fn STASH)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-ediff" '("magit-ediff-")))



(autoload 'magit-run-git-gui "magit-extras" "\
Run `git gui' for the current git repository.

\(fn)" t nil)

(autoload 'magit-run-git-gui-blame "magit-extras" "\
Run `git gui blame' on the given FILENAME and COMMIT.
Interactively run it for the current file and the `HEAD', with a
prefix or when the current file cannot be determined let the user
choose.  When the current buffer is visiting FILENAME instruct
blame to center around the line point is on.

\(fn COMMIT FILENAME &optional LINENUM)" t nil)

(autoload 'magit-run-gitk "magit-extras" "\
Run `gitk' in the current repository.

\(fn)" t nil)

(autoload 'magit-run-gitk-branches "magit-extras" "\
Run `gitk --branches' in the current repository.

\(fn)" t nil)

(autoload 'magit-run-gitk-all "magit-extras" "\
Run `gitk --all' in the current repository.

\(fn)" t nil)

(autoload 'ido-enter-magit-status "magit-extras" "\
Drop into `magit-status' from file switching.

To make this command available use something like:

  (add-hook \\='ido-setup-hook
            (lambda ()
              (define-key ido-completion-map
                (kbd \"C-x g\") \\='ido-enter-magit-status)))

Starting with Emacs 25.1 the Ido keymaps are defined just once
instead of every time Ido is invoked, so now you can modify it
like pretty much every other keymap:

  (define-key ido-common-completion-map
    (kbd \"C-x g\") \\='ido-enter-magit-status)

\(fn)" t nil)

(autoload 'magit-dired-jump "magit-extras" "\
Visit file at point using Dired.
With a prefix argument, visit in another window.  If there
is no file at point, then instead visit `default-directory'.

\(fn &optional OTHER-WINDOW)" t nil)

(autoload 'magit-dired-log "magit-extras" "\
Show log for all marked files, or the current file.

\(fn &optional FOLLOW)" t nil)

(autoload 'magit-do-async-shell-command "magit-extras" "\
Open FILE with `dired-do-async-shell-command'.
Interactively, open the file at point.

\(fn FILE)" t nil)

(autoload 'magit-previous-line "magit-extras" "\
Like `previous-line' but with Magit-specific shift-selection.

Magit's selection mechanism is based on the region but selects an
area that is larger than the region.  This causes `previous-line'
when invoked while holding the shift key to move up one line and
thereby select two lines.  When invoked inside a hunk body this
command does not move point on the first invocation and thereby
it only selects a single line.  Which inconsistency you prefer
is a matter of preference.

\(fn &optional ARG TRY-VSCROLL)" t nil)

(function-put 'magit-previous-line 'interactive-only '"use `forward-line' with negative argument instead.")

(autoload 'magit-next-line "magit-extras" "\
Like `next-line' but with Magit-specific shift-selection.

Magit's selection mechanism is based on the region but selects
an area that is larger than the region.  This causes `next-line'
when invoked while holding the shift key to move down one line
and thereby select two lines.  When invoked inside a hunk body
this command does not move point on the first invocation and
thereby it only selects a single line.  Which inconsistency you
prefer is a matter of preference.

\(fn &optional ARG TRY-VSCROLL)" t nil)

(function-put 'magit-next-line 'interactive-only 'forward-line)

(autoload 'magit-clean "magit-extras" "\
Remove untracked files from the working tree.
With a prefix argument also remove ignored files,
with two prefix arguments remove ignored files only.

\(git clean -f -d [-x|-X])

\(fn &optional ARG)" t nil)
 (autoload 'magit-gitignore-popup "magit-extras" nil t)

(autoload 'magit-gitignore "magit-extras" "\
Instruct Git to ignore FILE-OR-PATTERN.
With a prefix argument only ignore locally.

\(fn FILE-OR-PATTERN &optional LOCAL)" t nil)

(autoload 'magit-gitignore-locally "magit-extras" "\
Instruct Git to locally ignore FILE-OR-PATTERN.

\(fn FILE-OR-PATTERN)" t nil)

(autoload 'magit-add-change-log-entry "magit-extras" "\
Find change log file and add date entry and item for current change.
This differs from `add-change-log-entry' (which see) in that
it acts on the current hunk in a Magit buffer instead of on
a position in a file-visiting buffer.

\(fn &optional WHOAMI FILE-NAME OTHER-WINDOW)" t nil)

(autoload 'magit-add-change-log-entry-other-window "magit-extras" "\
Find change log file in other window and add entry and item.
This differs from `add-change-log-entry-other-window' (which see)
in that it acts on the current hunk in a Magit buffer instead of
on a position in a file-visiting buffer.

\(fn &optional WHOAMI FILE-NAME)" t nil)

(autoload 'magit-edit-line-commit "magit-extras" "\
Edit the commit that added the current line.

With a prefix argument edit the commit that removes the line,
if any.  The commit is determined using `git blame' and made
editable using `git rebase --interactive' if it is reachable
from `HEAD', or by checking out the commit (or a branch that
points at it) otherwise.

\(fn &optional TYPE)" t nil)

(autoload 'magit-reshelve-since "magit-extras" "\
Change the author and committer dates of the commits since REV.

Ask the user for the first reachable commit whose dates should
be changed.  The read the new date for that commit.  The initial
minibuffer input and the previous history element offer good
values.  The next commit will be created one minute later and so
on.

This command is only intended for interactive use and should only
be used on highly rearranged and unpublished history.

\(fn REV)" t nil)

(autoload 'magit-pop-revision-stack "magit-extras" "\
Insert a representation of a revision into the current buffer.

Pop a revision from the `magit-revision-stack' and insert it into
the current buffer according to `magit-pop-revision-stack-format'.
Revisions can be put on the stack using `magit-copy-section-value'
and `magit-copy-buffer-revision'.

If the stack is empty or with a prefix argument, instead read a
revision in the minibuffer.  By using the minibuffer history this
allows selecting an item which was popped earlier or to insert an
arbitrary reference or revision without first pushing it onto the
stack.

When reading the revision from the minibuffer, then it might not
be possible to guess the correct repository.  When this command
is called inside a repository (e.g. while composing a commit
message), then that repository is used.  Otherwise (e.g. while
composing an email) then the repository recorded for the top
element of the stack is used (even though we insert another
revision).  If not called inside a repository and with an empty
stack, or with two prefix arguments, then read the repository in
the minibuffer too.

\(fn REV TOPLEVEL)" t nil)

(autoload 'magit-copy-section-value "magit-extras" "\
Save the value of the current section for later use.

Save the section value to the `kill-ring', and, provided that
the current section is a commit, branch, or tag section, push
the (referenced) revision to the `magit-revision-stack' for use
with `magit-pop-revision-stack'.

When the current section is a branch or a tag, and a prefix
argument is used, then save the revision at its tip to the
`kill-ring' instead of the reference name.

When the region is active, then save that to the `kill-ring',
like `kill-ring-save' would, instead of behaving as described
above.

\(fn)" t nil)

(autoload 'magit-copy-buffer-revision "magit-extras" "\
Save the revision of the current buffer for later use.

Save the revision shown in the current buffer to the `kill-ring'
and push it to the `magit-revision-stack'.

This command is mainly intended for use in `magit-revision-mode'
buffers, the only buffers where it is always unambiguous exactly
which revision should be saved.

Most other Magit buffers usually show more than one revision, in
some way or another, so this command has to select one of them,
and that choice might not always be the one you think would have
been the best pick.

In such buffers it is often more useful to save the value of
the current section instead, using `magit-copy-section-value'.

When the region is active, then save that to the `kill-ring',
like `kill-ring-save' would, instead of behaving as described
above.

\(fn)" t nil)

(autoload 'magit-abort-dwim "magit-extras" "\
Abort current operation.
Depending on the context, this will abort a merge, a rebase, a
patch application, a cherry-pick, a revert, or a bisect.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-extras" '("magit-")))



(autoload 'magit-find-file "magit-files" "\
View FILE from REV.
Switch to a buffer visiting blob REV:FILE,
creating one if none already exists.

\(fn REV FILE)" t nil)

(autoload 'magit-find-file-other-window "magit-files" "\
View FILE from REV, in another window.
Like `magit-find-file', but create a new window or reuse an
existing one.

\(fn REV FILE)" t nil)
 (autoload 'magit-file-popup "magit" nil t)

(defvar global-magit-file-mode t "\
Non-nil if Global Magit-File mode is enabled.
See the `global-magit-file-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-magit-file-mode'.")

(custom-autoload 'global-magit-file-mode "magit-files" nil)

(autoload 'global-magit-file-mode "magit-files" "\
Toggle Magit-File mode in all buffers.
With prefix ARG, enable Global Magit-File mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Magit-File mode is enabled in all buffers where
`magit-file-mode-turn-on' would do it.
See `magit-file-mode' for more information on Magit-File mode.

\(fn &optional ARG)" t nil)

(autoload 'magit-file-checkout "magit-files" "\
Checkout FILE from REV.

\(fn REV FILE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-files" '("magit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-git" '("magit-")))



(autoload 'magit-imenu--log-prev-index-position-function "magit-imenu" "\
Move point to previous line in current buffer.
This function is used as a value for
`imenu-prev-index-position-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--log-extract-index-name-function "magit-imenu" "\
Return imenu name for line at point.
This function is used as a value for
`imenu-extract-index-name-function'.  Point should be at the
beginning of the line.

\(fn)" nil nil)

(autoload 'magit-imenu--diff-prev-index-position-function "magit-imenu" "\
Move point to previous file line in current buffer.
This function is used as a value for
`imenu-prev-index-position-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--diff-extract-index-name-function "magit-imenu" "\
Return imenu name for line at point.
This function is used as a value for
`imenu-extract-index-name-function'.  Point should be at the
beginning of the line.

\(fn)" nil nil)

(autoload 'magit-imenu--status-create-index-function "magit-imenu" "\
Return an alist of all imenu entries in current buffer.
This function is used as a value for
`imenu-create-index-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--refs-create-index-function "magit-imenu" "\
Return an alist of all imenu entries in current buffer.
This function is used as a value for
`imenu-create-index-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--cherry-create-index-function "magit-imenu" "\
Return an alist of all imenu entries in current buffer.
This function is used as a value for
`imenu-create-index-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--submodule-prev-index-position-function "magit-imenu" "\
Move point to previous line in magit-submodule-list buffer.
This function is used as a value for
`imenu-prev-index-position-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--submodule-extract-index-name-function "magit-imenu" "\
Return imenu name for line at point.
This function is used as a value for
`imenu-extract-index-name-function'.  Point should be at the
beginning of the line.

\(fn)" nil nil)

(autoload 'magit-imenu--repolist-prev-index-position-function "magit-imenu" "\
Move point to previous line in magit-repolist buffer.
This function is used as a value for
`imenu-prev-index-position-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--repolist-extract-index-name-function "magit-imenu" "\
Return imenu name for line at point.
This function is used as a value for
`imenu-extract-index-name-function'.  Point should be at the
beginning of the line.

\(fn)" nil nil)

(autoload 'magit-imenu--process-prev-index-position-function "magit-imenu" "\
Move point to previous process in magit-process buffer.
This function is used as a value for
`imenu-prev-index-position-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--process-extract-index-name-function "magit-imenu" "\
Return imenu name for line at point.
This function is used as a value for
`imenu-extract-index-name-function'.  Point should be at the
beginning of the line.

\(fn)" nil nil)

(autoload 'magit-imenu--rebase-prev-index-position-function "magit-imenu" "\
Move point to previous commit in git-rebase buffer.
This function is used as a value for
`imenu-prev-index-position-function'.

\(fn)" nil nil)

(autoload 'magit-imenu--rebase-extract-index-name-function "magit-imenu" "\
Return imenu name for line at point.
This function is used as a value for
`imenu-extract-index-name-function'.  Point should be at the
beginning of the line.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-imenu" '("magit-imenu--index-function")))



(autoload 'magit-log-buffer-file-popup "magit-log" "\
Popup console for log commands.

This is a variant of `magit-log-popup' which shows the same popup
but which limits the log to the file being visited in the current
buffer.

\(fn)" t nil)

(autoload 'magit-log-current "magit-log" "\
Show log for the current branch.
When `HEAD' is detached or with a prefix argument show log for
one or more revs read from the minibuffer.

\(fn REVS &optional ARGS FILES)" t nil)

(autoload 'magit-log "magit-log" "\
Show log for one or more revs read from the minibuffer.
The user can input any revision or revisions separated by a
space, or even ranges, but only branches and tags, and a
representation of the commit at point, are available as
completion candidates.

\(fn REVS &optional ARGS FILES)" t nil)

(autoload 'magit-log-head "magit-log" "\
Show log for `HEAD'.

\(fn &optional ARGS FILES)" t nil)

(autoload 'magit-log-branches "magit-log" "\
Show log for all local branches and `HEAD'.

\(fn &optional ARGS FILES)" t nil)

(autoload 'magit-log-all-branches "magit-log" "\
Show log for all local and remote branches and `HEAD'.

\(fn &optional ARGS FILES)" t nil)

(autoload 'magit-log-all "magit-log" "\
Show log for all references and `HEAD'.

\(fn &optional ARGS FILES)" t nil)

(autoload 'magit-log-buffer-file "magit-log" "\
Show log for the blob or file visited in the current buffer.
With a prefix argument or when `--follow' is part of
`magit-log-arguments', then follow renames.  When the region is
active, restrict the log to the lines that the region touches.

\(fn &optional FOLLOW BEG END)" t nil)

(autoload 'magit-log-trace-definition "magit-log" "\
Show log for the definition at point.

\(fn FILE FN REV)" t nil)

(autoload 'magit-reflog-current "magit-log" "\
Display the reflog of the current branch.

\(fn)" t nil)

(autoload 'magit-reflog "magit-log" "\
Display the reflog of a branch.

\(fn REF)" t nil)

(autoload 'magit-reflog-head "magit-log" "\
Display the `HEAD' reflog.

\(fn)" t nil)

(autoload 'magit-log-move-to-parent "magit-log" "\
Move to the Nth parent of the current commit.

\(fn &optional N)" t nil)

(autoload 'magit-cherry "magit-log" "\
Show commits in a branch that are not merged in the upstream branch.

\(fn HEAD UPSTREAM)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-log" '("magit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-margin" '("magit-")))


 (autoload 'magit-merge-popup "magit" nil t)

(autoload 'magit-merge "magit-merge" "\
Merge commit REV into the current branch; using default message.

Unless there are conflicts or a prefix argument is used create a
merge commit using a generic commit message and without letting
the user inspect the result.  With a prefix argument pretend the
merge failed to give the user the opportunity to inspect the
merge.

\(git merge --no-edit|--no-commit [ARGS] REV)

\(fn REV &optional ARGS NOCOMMIT)" t nil)

(autoload 'magit-merge-editmsg "magit-merge" "\
Merge commit REV into the current branch; and edit message.
Perform the merge and prepare a commit message but let the user
edit it.

\(git merge --edit --no-ff [ARGS] REV)

\(fn REV &optional ARGS)" t nil)

(autoload 'magit-merge-nocommit "magit-merge" "\
Merge commit REV into the current branch; pretending it failed.
Pretend the merge failed to give the user the opportunity to
inspect the merge and change the commit message.

\(git merge --no-commit --no-ff [ARGS] REV)

\(fn REV &optional ARGS)" t nil)

(autoload 'magit-merge-into "magit-merge" "\
Merge the current branch into BRANCH and remove the former.

Before merging, force push the source branch to its push-remote,
provided the respective remote branch already exists, ensuring
that the respective pull-request (if any) won't get stuck on some
obsolete version of the commits that are being merged.  Finally
if `magit-branch-pull-request' was used to create the merged
branch, then also remove the respective remote branch.

\(fn BRANCH &optional ARGS)" t nil)

(autoload 'magit-merge-absorb "magit-merge" "\
Merge BRANCH into the current branch and remove the former.

Before merging, force push the source branch to its push-remote,
provided the respective remote branch already exists, ensuring
that the respective pull-request (if any) won't get stuck on some
obsolete version of the commits that are being merged.  Finally
if `magit-branch-pull-request' was used to create the merged
branch, then also remove the respective remote branch.

\(fn BRANCH &optional ARGS)" t nil)

(autoload 'magit-merge-squash "magit-merge" "\
Squash commit REV into the current branch; don't create a commit.

\(git merge --squash REV)

\(fn REV)" t nil)

(autoload 'magit-merge-preview "magit-merge" "\
Preview result of merging REV into the current branch.

\(fn REV)" t nil)

(autoload 'magit-merge-abort "magit-merge" "\
Abort the current merge operation.

\(git merge --abort)

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-merge" '("magit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-mode" '("disable-magit-save-buffers" "inhibit-magit-refresh" "magit-")))


 (autoload 'magit-notes-popup "magit" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-notes" '("magit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-process" '("magit-" "tramp-sh-handle-")))



(autoload 'magit-show-refs-popup "magit-refs" "\
Popup console for `magit-show-refs'.

\(fn &optional ARG)" t nil)

(autoload 'magit-show-refs-head "magit-refs" "\
List and compare references in a dedicated buffer.
Refs are compared with `HEAD'.

\(fn &optional ARGS)" t nil)

(autoload 'magit-show-refs-current "magit-refs" "\
List and compare references in a dedicated buffer.
Refs are compared with the current branch or `HEAD' if
it is detached.

\(fn &optional ARGS)" t nil)

(autoload 'magit-show-refs "magit-refs" "\
List and compare references in a dedicated buffer.
Refs are compared with a branch read from the user.

\(fn &optional REF ARGS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-refs" '("magit-")))



(autoload 'magit-clone "magit-remote" "\
Clone the REPOSITORY to DIRECTORY.
Then show the status buffer for the new repository.

\(fn REPOSITORY DIRECTORY)" t nil)
 (autoload 'magit-remote-popup "magit-remote" nil t)

(autoload 'magit-remote-add "magit-remote" "\
Add a remote named REMOTE and fetch it.

\(fn REMOTE URL &optional ARGS)" t nil)

(autoload 'magit-remote-rename "magit-remote" "\
Rename the remote named OLD to NEW.

\(fn OLD NEW)" t nil)

(autoload 'magit-remote-remove "magit-remote" "\
Delete the remote named REMOTE.

\(fn REMOTE)" t nil)

(autoload 'magit-remote-prune "magit-remote" "\
Remove stale remote-tracking branches for REMOTE.

\(fn REMOTE)" t nil)

(autoload 'magit-remote-prune-refspecs "magit-remote" "\
Remove stale refspecs for REMOTE.

A refspec is stale if there no longer exists at least one branch
on the remote that would be fetched due to that refspec.  A stale
refspec is problematic because its existence causes Git to refuse
to fetch according to the remaining non-stale refspecs.

If only stale refspecs remain, then offer to either delete the
remote or to replace the stale refspecs with the default refspec.

Also remove the remote-tracking branches that were created due to
the now stale refspecs.  Other stale branches are not removed.

\(fn REMOTE)" t nil)

(autoload 'magit-remote-set-head "magit-remote" "\
Set the local representation of REMOTE's default branch.
Query REMOTE and set the symbolic-ref refs/remotes/<remote>/HEAD
accordingly.  With a prefix argument query for the branch to be
used, which allows you to select an incorrect value if you fancy
doing that.

\(fn REMOTE &optional BRANCH)" t nil)

(autoload 'magit-remote-unset-head "magit-remote" "\
Unset the local representation of REMOTE's default branch.
Delete the symbolic-ref \"refs/remotes/<remote>/HEAD\".

\(fn REMOTE)" t nil)

(autoload 'magit-remote-config-popup "magit-remote" "\
Popup console for setting remote variables.

\(fn REMOTE)" t nil)
 (autoload 'magit-fetch-popup "magit-remote" nil t)

(autoload 'magit-fetch-from-pushremote "magit-remote" "\
Fetch from the push-remote of the current branch.

\(fn ARGS)" t nil)

(autoload 'magit-fetch-from-upstream "magit-remote" "\
Fetch from the upstream repository of the current branch.

\(fn ARGS)" t nil)

(autoload 'magit-fetch "magit-remote" "\
Fetch from another repository.

\(fn REMOTE ARGS)" t nil)

(autoload 'magit-fetch-branch "magit-remote" "\
Fetch a BRANCH from a REMOTE.

\(fn REMOTE BRANCH ARGS)" t nil)

(autoload 'magit-fetch-refspec "magit-remote" "\
Fetch a REFSPEC from a REMOTE.

\(fn REMOTE REFSPEC ARGS)" t nil)

(autoload 'magit-fetch-all "magit-remote" "\
Fetch from all remotes.

\(fn ARGS)" t nil)

(autoload 'magit-fetch-all-prune "magit-remote" "\
Fetch from all remotes, and prune.
Prune remote tracking branches for branches that have been
removed on the respective remote.

\(fn)" t nil)

(autoload 'magit-fetch-all-no-prune "magit-remote" "\
Fetch from all remotes.

\(fn)" t nil)

(autoload 'magit-fetch-modules "magit-remote" "\
Fetch all submodules.

Option `magit-fetch-modules-jobs' controls how many submodules
are being fetched in parallel.  Also fetch the super-repository,
because `git-fetch' does not support not doing that.  With a
prefix argument fetch all remotes.

\(fn &optional ALL)" t nil)
 (autoload 'magit-pull-popup "magit-remote" nil t)
 (autoload 'magit-pull-and-fetch-popup "magit-remote" nil t)

(autoload 'magit-pull-from-pushremote "magit-remote" "\
Pull from the push-remote of the current branch.

\(fn ARGS)" t nil)

(autoload 'magit-pull-from-upstream "magit-remote" "\
Pull from the upstream of the current branch.

\(fn ARGS)" t nil)

(autoload 'magit-pull "magit-remote" "\
Pull from a branch read in the minibuffer.

\(fn SOURCE ARGS)" t nil)
 (autoload 'magit-push-popup "magit-remote" nil t)

(autoload 'magit-push-current-to-pushremote "magit-remote" "\
Push the current branch to `branch.<name>.pushRemote'.
If that variable is unset, then push to `remote.pushDefault'.

When `magit-push-current-set-remote-if-missing' is non-nil and
the push-remote is not configured, then read the push-remote from
the user, set it, and then push to it.  With a prefix argument
the push-remote can be changed before pushed to it.

\(fn ARGS &optional PUSH-REMOTE)" t nil)

(autoload 'magit-push-current-to-upstream "magit-remote" "\
Push the current branch to its upstream branch.

When `magit-push-current-set-remote-if-missing' is non-nil and
the upstream is not configured, then read the upstream from the
user, set it, and then push to it.  With a prefix argument the
upstream can be changed before pushed to it.

\(fn ARGS &optional UPSTREAM)" t nil)

(autoload 'magit-push-current "magit-remote" "\
Push the current branch to a branch read in the minibuffer.

\(fn TARGET ARGS)" t nil)

(autoload 'magit-push "magit-remote" "\
Push an arbitrary branch or commit somewhere.
Both the source and the target are read in the minibuffer.

\(fn SOURCE TARGET ARGS)" t nil)

(autoload 'magit-push-refspecs "magit-remote" "\
Push one or multiple REFSPECS to a REMOTE.
Both the REMOTE and the REFSPECS are read in the minibuffer.  To
use multiple REFSPECS, separate them with commas.  Completion is
only available for the part before the colon, or when no colon
is used.

\(fn REMOTE REFSPECS ARGS)" t nil)

(autoload 'magit-push-matching "magit-remote" "\
Push all matching branches to another repository.
If multiple remotes exist, then read one from the user.
If just one exists, use that without requiring confirmation.

\(fn REMOTE &optional ARGS)" t nil)

(autoload 'magit-push-tags "magit-remote" "\
Push all tags to another repository.
If only one remote exists, then push to that.  Otherwise prompt
for a remote, offering the remote configured for the current
branch as default.

\(fn REMOTE &optional ARGS)" t nil)

(autoload 'magit-push-tag "magit-remote" "\
Push a tag to another repository.

\(fn TAG REMOTE &optional ARGS)" t nil)

(autoload 'magit-push-implicitly "magit-remote" "\
Push somewhere without using an explicit refspec.

This command simply runs \"git push -v [ARGS]\".  ARGS are the
arguments specified in the popup buffer.  No explicit refspec
arguments are used.  Instead the behavior depends on at least
these Git variables: `push.default', `remote.pushDefault',
`branch.<branch>.pushRemote', `branch.<branch>.remote',
`branch.<branch>.merge', and `remote.<remote>.push'.

To add this command to the push popup add this to your init file:

  (with-eval-after-load \\='magit-remote
    (magit-define-popup-action \\='magit-push-popup ?P
      \\='magit-push-implicitly--desc
      \\='magit-push-implicitly ?p t))

The function `magit-push-implicitly--desc' attempts to predict
what this command will do.  The value it returns is displayed in
the popup buffer.

\(fn ARGS)" t nil)

(autoload 'magit-push-to-remote "magit-remote" "\
Push to REMOTE without using an explicit refspec.
The REMOTE is read in the minibuffer.

This command simply runs \"git push -v [ARGS] REMOTE\".  ARGS
are the arguments specified in the popup buffer.  No refspec
arguments are used.  Instead the behavior depends on at least
these Git variables: `push.default', `remote.pushDefault',
`branch.<branch>.pushRemote', `branch.<branch>.remote',
`branch.<branch>.merge', and `remote.<remote>.push'.

To add this command to the push popup add this to your init file:

  (with-eval-after-load \\='magit-remote
    (magit-define-popup-action \\='magit-push-popup ?r
      \\='magit-push-to-remote--desc
      \\='magit-push-to-remote ?p t))

\(fn REMOTE ARGS)" t nil)
 (autoload 'magit-patch-popup "magit-remote" nil t)

(autoload 'magit-format-patch "magit-remote" "\
Create patches for the commits in RANGE.
When a single commit is given for RANGE, create a patch for the
changes introduced by that commit (unlike 'git format-patch'
which creates patches for all commits that are reachable from
`HEAD' but not from the specified commit).

\(fn RANGE ARGS)" t nil)

(autoload 'magit-request-pull "magit-remote" "\
Request upstream to pull from you public repository.

URL is the url of your publically accessible repository.
START is a commit that already is in the upstream repository.
END is the last commit, usually a branch name, which upstream
is asked to pull.  START has to be reachable from that commit.

\(fn URL START END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-remote" '("magit-")))



(autoload 'magit-list-repositories "magit-repos" "\
Display a list of repositories.

Use the options `magit-repository-directories' to control which
repositories are displayed.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-repos" '("magit-")))


 (autoload 'magit-reset-popup "magit" nil t)

(autoload 'magit-reset "magit-reset" "\
Reset the `HEAD' and index to COMMIT, but not the working tree.
With a prefix argument also reset the working tree.

\(git reset --mixed|--hard COMMIT)

\(fn COMMIT &optional HARD)" t nil)

(autoload 'magit-reset-head "magit-reset" "\
Reset the `HEAD' and index to COMMIT, but not the working tree.

\(git reset --mixed COMMIT)

\(fn COMMIT)" t nil)

(autoload 'magit-reset-soft "magit-reset" "\
Reset the `HEAD' to COMMIT, but not the index and working tree.

\(git reset --soft REVISION)

\(fn COMMIT)" t nil)

(autoload 'magit-reset-hard "magit-reset" "\
Reset the `HEAD', index, and working tree to COMMIT.

\(git reset --hard REVISION)

\(fn COMMIT)" t nil)

(autoload 'magit-reset-index "magit-reset" "\
Reset the index to COMMIT.
Keep the `HEAD' and working tree as-is, so if COMMIT refers to the
head this effectively unstages all changes.

\(git reset COMMIT .)

\(fn COMMIT)" t nil)

(autoload 'magit-reset-worktree "magit-reset" "\
Reset the worktree to COMMIT.
Keep the `HEAD' and index as-is.

\(fn COMMIT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-reset" '("magit-reset-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-section" '("magit-")))



(autoload 'magit-sequencer-continue "magit-sequence" "\
Resume the current cherry-pick or revert sequence.

\(fn)" t nil)

(autoload 'magit-sequencer-skip "magit-sequence" "\
Skip the stopped at commit during a cherry-pick or revert sequence.

\(fn)" t nil)

(autoload 'magit-sequencer-abort "magit-sequence" "\
Abort the current cherry-pick or revert sequence.
This discards all changes made since the sequence started.

\(fn)" t nil)
 (autoload 'magit-cherry-pick-popup "magit-sequence" nil t)

(autoload 'magit-cherry-pick "magit-sequence" "\
Copy COMMITS from another branch onto the current branch.
Prompt for a commit, defaulting to the commit at point.  If
the region selects multiple commits, then pick all of them,
without prompting.

\(fn COMMITS &optional ARGS)" t nil)

(autoload 'magit-cherry-apply "magit-sequence" "\
Apply the changes in COMMITS but do not commit them.
Prompt for a commit, defaulting to the commit at point.  If
the region selects multiple commits, then apply all of them,
without prompting.

\(fn COMMITS &optional ARGS)" t nil)

(autoload 'magit-cherry-harvest "magit-sequence" "\
Move COMMITS from another BRANCH onto the current branch.
Remove the COMMITS from BRANCH and stay on the current branch.
If a conflict occurs, then you have to fix that and finish the
process manually.

\(fn COMMITS BRANCH &optional ARGS)" t nil)

(autoload 'magit-cherry-donate "magit-sequence" "\
Move COMMITS from the current branch onto another existing BRANCH.
Remove COMMITS from the current branch and stay on that branch.
If a conflict occurs, then you have to fix that and finish the
process manually.

\(fn COMMITS BRANCH &optional ARGS)" t nil)

(autoload 'magit-cherry-spinout "magit-sequence" "\
Move COMMITS from the current branch onto a new BRANCH.
Remove COMMITS from the current branch and stay on that branch.
If a conflict occurs, then you have to fix that and finish the
process manually.

\(fn COMMITS BRANCH START-POINT &optional ARGS)" t nil)

(autoload 'magit-cherry-spinoff "magit-sequence" "\
Move COMMITS from the current branch onto a new BRANCH.
Remove COMMITS from the current branch and checkout BRANCH.
If a conflict occurs, then you have to fix that and finish
the process manually.

\(fn COMMITS BRANCH START-POINT &optional ARGS)" t nil)
 (autoload 'magit-revert-popup "magit-sequence" nil t)

(autoload 'magit-revert "magit-sequence" "\
Revert COMMIT by creating a new commit.
Prompt for a commit, defaulting to the commit at point.  If
the region selects multiple commits, then revert all of them,
without prompting.

\(fn COMMIT &optional ARGS)" t nil)

(autoload 'magit-revert-no-commit "magit-sequence" "\
Revert COMMIT by applying it in reverse to the worktree.
Prompt for a commit, defaulting to the commit at point.  If
the region selects multiple commits, then revert all of them,
without prompting.

\(fn COMMIT &optional ARGS)" t nil)
 (autoload 'magit-am-popup "magit-sequence" nil t)

(autoload 'magit-am-apply-patches "magit-sequence" "\
Apply the patches FILES.

\(fn &optional FILES ARGS)" t nil)

(autoload 'magit-am-apply-maildir "magit-sequence" "\
Apply the patches from MAILDIR.

\(fn &optional MAILDIR ARGS)" t nil)

(autoload 'magit-am-continue "magit-sequence" "\
Resume the current patch applying sequence.

\(fn)" t nil)

(autoload 'magit-am-skip "magit-sequence" "\
Skip the stopped at patch during a patch applying sequence.

\(fn)" t nil)

(autoload 'magit-am-abort "magit-sequence" "\
Abort the current patch applying sequence.
This discards all changes made since the sequence started.

\(fn)" t nil)
 (autoload 'magit-rebase-popup "magit-sequence" nil t)

(autoload 'magit-rebase-onto-pushremote "magit-sequence" "\
Rebase the current branch onto `branch.<name>.pushRemote'.
If that variable is unset, then rebase onto `remote.pushDefault'.

\(fn ARGS)" t nil)

(autoload 'magit-rebase-onto-upstream "magit-sequence" "\
Rebase the current branch onto its upstream branch.

\(fn ARGS)" t nil)

(autoload 'magit-rebase "magit-sequence" "\
Rebase the current branch onto a branch read in the minibuffer.
All commits that are reachable from `HEAD' but not from the
selected branch TARGET are being rebased.

\(fn TARGET ARGS)" t nil)

(autoload 'magit-rebase-subset "magit-sequence" "\
Rebase a subset of the current branch's history onto a new base.
Rebase commits from START to `HEAD' onto NEWBASE.
START has to be selected from a list of recent commits.

\(fn NEWBASE START ARGS)" t nil)

(autoload 'magit-rebase-interactive "magit-sequence" "\
Start an interactive rebase sequence.

\(fn COMMIT ARGS)" t nil)

(autoload 'magit-rebase-autosquash "magit-sequence" "\
Combine squash and fixup commits with their intended targets.

\(fn ARGS)" t nil)

(autoload 'magit-rebase-edit-commit "magit-sequence" "\
Edit a single older commit using rebase.

\(fn COMMIT ARGS)" t nil)

(autoload 'magit-rebase-reword-commit "magit-sequence" "\
Reword a single older commit using rebase.

\(fn COMMIT ARGS)" t nil)

(autoload 'magit-rebase-remove-commit "magit-sequence" "\
Remove a single older commit using rebase.

\(fn COMMIT ARGS)" t nil)

(autoload 'magit-rebase-continue "magit-sequence" "\
Restart the current rebasing operation.
In some cases this pops up a commit message buffer for you do
edit.  With a prefix argument the old message is reused as-is.

\(fn &optional NOEDIT)" t nil)

(autoload 'magit-rebase-skip "magit-sequence" "\
Skip the current commit and restart the current rebase operation.

\(fn)" t nil)

(autoload 'magit-rebase-edit "magit-sequence" "\
Edit the todo list of the current rebase operation.

\(fn)" t nil)

(autoload 'magit-rebase-abort "magit-sequence" "\
Abort the current rebase operation, restoring the original branch.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-sequence" '("magit-")))


 (autoload 'magit-stash-popup "magit-stash" nil t)

(autoload 'magit-stash "magit-stash" "\
Create a stash of the index and working tree.
Untracked files are included according to popup arguments.
One prefix argument is equivalent to `--include-untracked'
while two prefix arguments are equivalent to `--all'.

\(fn MESSAGE &optional INCLUDE-UNTRACKED)" t nil)

(autoload 'magit-stash-index "magit-stash" "\
Create a stash of the index only.
Unstaged and untracked changes are not stashed.  The stashed
changes are applied in reverse to both the index and the
worktree.  This command can fail when the worktree is not clean.
Applying the resulting stash has the inverse effect.

\(fn MESSAGE)" t nil)

(autoload 'magit-stash-worktree "magit-stash" "\
Create a stash of unstaged changes in the working tree.
Untracked files are included according to popup arguments.
One prefix argument is equivalent to `--include-untracked'
while two prefix arguments are equivalent to `--all'.

\(fn MESSAGE &optional INCLUDE-UNTRACKED)" t nil)

(autoload 'magit-stash-keep-index "magit-stash" "\
Create a stash of the index and working tree, keeping index intact.
Untracked files are included according to popup arguments.
One prefix argument is equivalent to `--include-untracked'
while two prefix arguments are equivalent to `--all'.

\(fn MESSAGE &optional INCLUDE-UNTRACKED)" t nil)

(autoload 'magit-snapshot "magit-stash" "\
Create a snapshot of the index and working tree.
Untracked files are included according to popup arguments.
One prefix argument is equivalent to `--include-untracked'
while two prefix arguments are equivalent to `--all'.

\(fn &optional INCLUDE-UNTRACKED)" t nil)

(autoload 'magit-snapshot-index "magit-stash" "\
Create a snapshot of the index only.
Unstaged and untracked changes are not stashed.

\(fn)" t nil)

(autoload 'magit-snapshot-worktree "magit-stash" "\
Create a snapshot of unstaged changes in the working tree.
Untracked files are included according to popup arguments.
One prefix argument is equivalent to `--include-untracked'
while two prefix arguments are equivalent to `--all'.

\(fn &optional INCLUDE-UNTRACKED)" t nil)

(autoload 'magit-stash-apply "magit-stash" "\
Apply a stash to the working tree.
Try to preserve the stash index.  If that fails because there
are staged changes, apply without preserving the stash index.

\(fn STASH)" t nil)

(autoload 'magit-stash-drop "magit-stash" "\
Remove a stash from the stash list.
When the region is active offer to drop all contained stashes.

\(fn STASH)" t nil)

(autoload 'magit-stash-clear "magit-stash" "\
Remove all stashes saved in REF's reflog by deleting REF.

\(fn REF)" t nil)

(autoload 'magit-stash-branch "magit-stash" "\
Create and checkout a new BRANCH from STASH.

\(fn STASH BRANCH)" t nil)

(autoload 'magit-stash-branch-here "magit-stash" "\
Create and checkout a new BRANCH and apply STASH.
The branch is created using `magit-branch', using the current
branch or `HEAD' as the string-point.

\(fn STASH BRANCH)" t nil)

(autoload 'magit-stash-format-patch "magit-stash" "\
Create a patch from STASH

\(fn STASH)" t nil)

(autoload 'magit-stash-list "magit-stash" "\
List all stashes in a buffer.

\(fn)" t nil)

(autoload 'magit-stash-show "magit-stash" "\
Show all diffs of a stash in a buffer.

\(fn STASH &optional ARGS FILES)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-stash" '("magit-")))



(autoload 'magit-init "magit-status" "\
Initialize a Git repository, then show its status.

If the directory is below an existing repository, then the user
has to confirm that a new one should be created inside.  If the
directory is the root of the existing repository, then the user
has to confirm that it should be reinitialized.

Non-interactively DIRECTORY is (re-)initialized unconditionally.

\(fn DIRECTORY)" t nil)

(autoload 'magit-status "magit-status" "\
Show the status of the current Git repository in a buffer.
With a prefix argument prompt for a repository to be shown.
With two prefix arguments prompt for an arbitrary directory.
If that directory isn't the root of an existing repository,
then offer to initialize it as a new repository.

\(fn &optional DIRECTORY CACHE)" t nil)

(autoload 'magit-status-internal "magit-status" "\


\(fn DIRECTORY)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-status" '("magit")))


 (autoload 'magit-submodule-popup "magit-submodule" nil t)

(autoload 'magit-submodule-add "magit-submodule" "\
Add the repository at URL as a module.

Optional PATH is the path to the module relative to the root of
the superproject.  If it is nil, then the path is determined
based on the URL.  Optional NAME is the name of the module.  If
it is nil, then PATH also becomes the name.

\(fn URL &optional PATH NAME ARGS)" t nil)

(autoload 'magit-submodule-read-name-for-path "magit-submodule" "\


\(fn PATH &optional PREFER-SHORT)" nil nil)

(autoload 'magit-submodule-register "magit-submodule" "\
Register MODULES.

With a prefix argument act on all suitable modules.  Otherwise,
if the region selects modules, then act on those.  Otherwise, if
there is a module at point, then act on that.  Otherwise read a
single module from the user.

\(fn MODULES)" t nil)

(autoload 'magit-submodule-populate "magit-submodule" "\
Create MODULES working directories, checking out the recorded commits.

With a prefix argument act on all suitable modules.  Otherwise,
if the region selects modules, then act on those.  Otherwise, if
there is a module at point, then act on that.  Otherwise read a
single module from the user.

\(fn MODULES)" t nil)

(autoload 'magit-submodule-update "magit-submodule" "\
Update MODULES by checking out the recorded commits.

With a prefix argument act on all suitable modules.  Otherwise,
if the region selects modules, then act on those.  Otherwise, if
there is a module at point, then act on that.  Otherwise read a
single module from the user.

\(fn MODULES ARGS)" t nil)

(autoload 'magit-submodule-synchronize "magit-submodule" "\
Synchronize url configuration of MODULES.

With a prefix argument act on all suitable modules.  Otherwise,
if the region selects modules, then act on those.  Otherwise, if
there is a module at point, then act on that.  Otherwise read a
single module from the user.

\(fn MODULES ARGS)" t nil)

(autoload 'magit-submodule-unpopulate "magit-submodule" "\
Remove working directories of MODULES.

With a prefix argument act on all suitable modules.  Otherwise,
if the region selects modules, then act on those.  Otherwise, if
there is a module at point, then act on that.  Otherwise read a
single module from the user.

\(fn MODULES ARGS)" t nil)

(autoload 'magit-submodule-remove "magit-submodule" "\
Unregister MODULES and remove their working directories.

For safety reasons, do not remove the gitdirs and if a module has
uncomitted changes, then do not remove it at all.  If a module's
gitdir is located inside the working directory, then move it into
the gitdir of the superproject first.

With the \"--force\" argument offer to remove dirty working
directories and with a prefix argument offer to delete gitdirs.
Both actions are very dangerous and have to be confirmed.  There
are additional safety precautions in place, so you might be able
to recover from making a mistake here, but don't count on it.

\(fn MODULES ARGS TRASH-GITDIRS)" t nil)

(autoload 'magit-insert-modules "magit-submodule" "\
Insert submodule sections.
Hook `magit-module-sections-hook' controls which module sections
are inserted, and option `magit-module-sections-nested' controls
whether they are wrapped in an additional section.

\(fn)" nil nil)

(autoload 'magit-insert-modules-overview "magit-submodule" "\
Insert sections for all modules.
For each section insert the path and the output of `git describe --tags',
or, failing that, the abbreviated HEAD commit hash.

\(fn)" nil nil)

(autoload 'magit-insert-modules-unpulled-from-upstream "magit-submodule" "\
Insert sections for modules that haven't been pulled from the upstream.
These sections can be expanded to show the respective commits.

\(fn)" nil nil)

(autoload 'magit-insert-modules-unpulled-from-pushremote "magit-submodule" "\
Insert sections for modules that haven't been pulled from the push-remote.
These sections can be expanded to show the respective commits.

\(fn)" nil nil)

(autoload 'magit-insert-modules-unpushed-to-upstream "magit-submodule" "\
Insert sections for modules that haven't been pushed to the upstream.
These sections can be expanded to show the respective commits.

\(fn)" nil nil)

(autoload 'magit-insert-modules-unpushed-to-pushremote "magit-submodule" "\
Insert sections for modules that haven't been pushed to the push-remote.
These sections can be expanded to show the respective commits.

\(fn)" nil nil)

(autoload 'magit-list-submodules "magit-submodule" "\
Display a list of the current repository's submodules.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-submodule" '("magit-")))


 (autoload 'magit-subtree-popup "magit-subtree" nil t)

(autoload 'magit-subtree-add "magit-subtree" "\
Add REF from REPOSITORY as a new subtree at PREFIX.

\(fn PREFIX REPOSITORY REF ARGS)" t nil)

(autoload 'magit-subtree-add-commit "magit-subtree" "\
Add COMMIT as a new subtree at PREFIX.

\(fn PREFIX COMMIT ARGS)" t nil)

(autoload 'magit-subtree-merge "magit-subtree" "\
Merge COMMIT into the PREFIX subtree.

\(fn PREFIX COMMIT ARGS)" t nil)

(autoload 'magit-subtree-pull "magit-subtree" "\
Pull REF from REPOSITORY into the PREFIX subtree.

\(fn PREFIX REPOSITORY REF ARGS)" t nil)

(autoload 'magit-subtree-push "magit-subtree" "\
Extract the history of the subtree PREFIX and push it to REF on REPOSITORY.

\(fn PREFIX REPOSITORY REF ARGS)" t nil)

(autoload 'magit-subtree-split "magit-subtree" "\
Extract the history of the subtree PREFIX.

\(fn PREFIX COMMIT ARGS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-subtree" '("magit-")))


 (autoload 'magit-tag-popup "magit" nil t)

(autoload 'magit-tag "magit-tag" "\
Create a new tag with the given NAME at REV.
With a prefix argument annotate the tag.

\(git tag [--annotate] NAME REV)

\(fn NAME REV &optional ARGS)" t nil)

(autoload 'magit-tag-delete "magit-tag" "\
Delete one or more tags.
If the region marks multiple tags (and nothing else), then offer
to delete those, otherwise prompt for a single tag to be deleted,
defaulting to the tag at point.

\(git tag -d TAGS)

\(fn TAGS)" t nil)

(autoload 'magit-tag-prune "magit-tag" "\
Offer to delete tags missing locally from REMOTE, and vice versa.

\(fn TAGS REMOTE-TAGS REMOTE)" t nil)

(autoload 'magit-tag-release "magit-tag" "\
Create an opinionated release tag.

Assume version tags that match \"\\\\`v?[0-9]\\\\(\\\\.[0-9]\\\\)*\\\\'\".
Prompt for the name of the new tag using the highest existing tag
as initial input and call \"git tag --annotate --sign -m MSG\" TAG,
regardless of whether these arguments are enabled in the popup.
Given a TAG \"v1.2.3\" and a repository \"/path/to/foo-bar\", the
MESSAGE would be \"Foo-Bar 1.2.3\".

Because it is so opinionated, this command is not available from
the tag popup by default.

\(fn TAG)" t nil)



(autoload 'magit-emacs-Q-command "magit-utils" "\
Show a shell command that runs an uncustomized Emacs with only Magit loaded.
See info node `(magit)Debugging Tools' for more information.

\(fn)" t nil)

(autoload 'Info-follow-nearest-node--magit-gitman "magit-utils" "\


\(fn FN &optional FORK)" nil nil)

(advice-add 'Info-follow-nearest-node :around 'Info-follow-nearest-node--magit-gitman)

(autoload 'org-man-export--magit-gitman "magit-utils" "\


\(fn FN LINK DESCRIPTION FORMAT)" nil nil)

(advice-add 'org-man-export :around 'org-man-export--magit-gitman)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-utils" '("magit-" "whitespace-dont-turn-on-in-magit-mode")))



(defvar magit-wip-after-save-mode nil "\
Non-nil if Magit-Wip-After-Save mode is enabled.
See the `magit-wip-after-save-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `magit-wip-after-save-mode'.")

(custom-autoload 'magit-wip-after-save-mode "magit-wip" nil)

(autoload 'magit-wip-after-save-mode "magit-wip" "\
Toggle Magit-Wip-After-Save-Local mode in all buffers.
With prefix ARG, enable Magit-Wip-After-Save mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Magit-Wip-After-Save-Local mode is enabled in all buffers where
`magit-wip-after-save-local-mode-turn-on' would do it.
See `magit-wip-after-save-local-mode' for more information on Magit-Wip-After-Save-Local mode.

\(fn &optional ARG)" t nil)

(defvar magit-wip-after-apply-mode nil "\
Non-nil if Magit-Wip-After-Apply mode is enabled.
See the `magit-wip-after-apply-mode' command
for a description of this minor mode.")

(custom-autoload 'magit-wip-after-apply-mode "magit-wip" nil)

(autoload 'magit-wip-after-apply-mode "magit-wip" "\
Commit to work-in-progress refs.

If called interactively, enable Magit-Wip-After-Apply mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

After applying a change using any \"apply variant\"
command (apply, stage, unstage, discard, and reverse) commit the
affected files to the current wip refs.  For each branch there
may be two wip refs; one contains snapshots of the files as found
in the worktree and the other contains snapshots of the entries
in the index.

\(fn &optional ARG)" t nil)

(defvar magit-wip-before-change-mode nil "\
Non-nil if Magit-Wip-Before-Change mode is enabled.
See the `magit-wip-before-change-mode' command
for a description of this minor mode.")

(custom-autoload 'magit-wip-before-change-mode "magit-wip" nil)

(autoload 'magit-wip-before-change-mode "magit-wip" "\
Commit to work-in-progress refs before certain destructive changes.

If called interactively, enable Magit-Wip-Before-Change mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Before invoking a revert command or an \"apply variant\"
command (apply, stage, unstage, discard, and reverse) commit the
affected tracked files to the current wip refs.  For each branch
there may be two wip refs; one contains snapshots of the files
as found in the worktree and the other contains snapshots of the
entries in the index.

Only changes to files which could potentially be affected by the
command which is about to be called are committed.

\(fn &optional ARG)" t nil)

(autoload 'magit-wip-commit-initial-backup "magit-wip" "\
Before saving, commit current file to a worktree wip ref.

The user has to add this function to `before-save-hook'.

Commit the current state of the visited file before saving the
current buffer to that file.  This backs up the same version of
the file as `backup-buffer' would, but stores the backup in the
worktree wip ref, which is also used by the various Magit Wip
modes, instead of in a backup file as `backup-buffer' would.

This function ignores the variables that affect `backup-buffer'
and can be used along-side that function, which is recommended
because this function only backs up files that are tracked in
a Git repository.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-wip" '("magit-")))


 (autoload 'magit-worktree-popup "magit-worktree" nil t)

(autoload 'magit-worktree-checkout "magit-worktree" "\
Checkout BRANCH in a new worktree at PATH.

\(fn PATH BRANCH)" t nil)

(autoload 'magit-worktree-branch "magit-worktree" "\
Create a new BRANCH and check it out in a new worktree at PATH.

\(fn PATH BRANCH START-POINT &optional FORCE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "magit-worktree" '("magit-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rustic-20180921.1013/rustic-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rustic-20180921.1013/rustic-autoloads.el") (car load-path))))



(add-to-list 'auto-mode-alist '("\\.rs\\'" . rustic-mode))

(autoload 'rustic-mode "rustic" "\
Major mode for Rust code.

\\{rustic-map}

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic" '("rustic-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-babel" '("org-babel-execute:rustic" "rustic-babel-")))



(autoload 'rustic-cargo-clippy "rustic-cargo" "\
Run `cargo clippy'.

\(fn)" t nil)

(autoload 'rustic-cargo-test "rustic-cargo" "\
Run 'cargo test'.

\(fn)" t nil)

(autoload 'rustic-cargo-build "rustic-cargo" "\


\(fn)" t nil)

(autoload 'rustic-cargo-run "rustic-cargo" "\


\(fn)" t nil)

(autoload 'rustic-cargo-clean "rustic-cargo" "\


\(fn)" t nil)

(autoload 'rustic-cargo-check "rustic-cargo" "\


\(fn)" t nil)

(autoload 'rustic-cargo-bench "rustic-cargo" "\


\(fn)" t nil)

(autoload 'rustic-cargo-new "rustic-cargo" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-cargo" '("rustic-")))



(autoload 'rustic-compile "rustic-compile" "\
Compile rust project.
If called without arguments use `rustic-compile-command'.

Otherwise use provided argument ARG and store it in
`compilation-arguments'.

\(fn &optional ARG)" t nil)

(autoload 'rustic-recompile "rustic-compile" "\
Re-compile the program using `compilation-arguments'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-compile" '("rust")))



(autoload 'rustic-flycheck-setup "rustic-flycheck" "\
Setup Rust in Flycheck.
If the current file is part of a Cargo project, configure
Flycheck according to the Cargo project layout.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-flycheck" '("rustic-flycheck-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-interaction" '("rustic-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-lsp" '("lsp-rust-" "rust")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-racer" '("racer-src-button" "rustic-racer-")))



(autoload 'rustic-format--enable-format-on-save "rustic-util" "\
Enable formatting using rustfmt when saving buffer.

\(fn)" t nil)

(autoload 'rustic-format--disable-format-on-save "rustic-util" "\
Disable formatting using rustfmt when saving buffer.

\(fn)" t nil)

(autoload 'rustic-cargo-fmt "rustic-util" "\
Use rustfmt via cargo.

\(fn)" t nil)

(autoload 'rustic-playpen "rustic-util" "\
Create a shareable URL for the contents of the current region, 
src-block or buffer on the Rust playpen.

\(fn BEGIN END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-util" '("rustic-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rust-playground-20180807.1158/rust-playground-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rust-playground-20180807.1158/rust-playground-autoloads.el") (car load-path))))



(autoload 'rust-playground "rust-playground" "\
Run playground for Rust language in a new buffer.

\(fn)" t nil)

(autoload 'rust-playground-rm "rust-playground" "\
Remove files of the current snippet together with directory of this snippet.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rust-playground" '("in-rust-playground" "rust-playground-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rust-mode-20181008.1628/rust-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rust-mode-20181008.1628/rust-mode-autoloads.el") (car load-path))))



(autoload 'rust-mode "rust-mode" "\
Major mode for Rust code.

\\{rust-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rust-mode" '("cargo-compilation-regexps" "rust")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rtags-20180925.641/rtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rtags-20180925.641/rtags-autoloads.el") (car load-path))))



(autoload 'rtags-set-periodic-reparse-timeout "rtags" "\
Set `rtags-periodic-reparse-timeout' to TIME.

\(fn TIME)" t nil)

(autoload 'rtags-call-bury-or-delete "rtags" "\
Call `rtags-bury-buffer-function' function.

\(fn)" t nil)

(autoload 'rtags-next-match "rtags" "\


\(fn)" t nil)

(autoload 'rtags-previous-match "rtags" "\


\(fn)" t nil)

(autoload 'rtags-next-diag "rtags" "\


\(fn)" t nil)

(autoload 'rtags-previous-diag "rtags" "\


\(fn)" t nil)

(autoload 'rtags-preprocess-file "rtags" "\
Preprocess selected region or buffer.
If optional BUFFER is given, use BUFFER instead of `current-buffer'.
It uses the stored compile command from the RTags database for preprocessing.

\(fn &optional BUFFER)" t nil)

(autoload 'rtags-set-current-project "rtags" "\
Set active project.
Uses `completing-read' to ask for the project.

\(fn)" t nil)

(autoload 'rtags-print-symbol-info "rtags" "\
Print information about the symbol under cursor.

\(fn &optional VERBOSE)" t nil)

(autoload 'rtags-symbol-type "rtags" "\
Print symbol type under cursor.

\(fn)" t nil)

(autoload 'rtags-print-dependencies "rtags" "\
Print dependency information of the file in buffer.

If optional PREFIX is given, a selection of what type of dependency
information should be shown will be offered. Currently only one can
be chosen.
\"includes\"        - Print includes the file in buffer includes.
\"included-by\"     - Print files which include the file in buffer.
\"depends-on\"      - Print files the file in buffer depends on.
\"depended-on\"     - ...
\"tree-depends-on\" - ...

If optional BUFFER is given print dependencies for file in BUFFER
instead of file from `current-buffer'.

\(fn &optional PREFIX BUFFER)" t nil)

(defvar rtags-dependency-tree-data nil)

(autoload 'rtags-references-tree "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-functions-called-by-this-function "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-all-functions-called-this-function "rtags" "\


\(fn)" nil nil)

(autoload 'rtags-list-results "rtags" "\
Show the RTags results buffer.

\(fn)" t nil)

(autoload 'rtags-print-source-arguments "rtags" "\


\(fn &optional BUFFER)" t nil)

(autoload 'rtags-print-class-hierarchy "rtags" "\


\(fn)" t nil)

(autoload 'rtags-print-enum-value-at-point "rtags" "\


\(fn &optional LOCATION)" t nil)

(autoload 'rtags-goto-offset "rtags" "\


\(fn POS)" t nil)

(autoload 'rtags-location-stack-filter "rtags" "\


\(fn PATH/LAMBDA/RX)" t nil)

(autoload 'rtags-location-stack-jump "rtags" "\


\(fn BY)" t nil)

(autoload 'rtags-location-stack-visualize-update "rtags" "\


\(fn)" nil nil)

(autoload 'rtags-enable-standard-keybindings "rtags" "\
Setup standard keybindings for the RTags commands.

If optional MAP is non-nil, add the keys to MAP instead of `c-mode-base-map'.
If optional PREFIX is non-nil, use PREFIX as prefix key for the commands,
default is \"C-c r \". It doesn't matter whether you add a space at the end
of PREFIX or not, if doesn't contain one, one will be added.

\(fn &optional MAP PREFIX)" t nil)

(autoload 'rtags-print-current-location "rtags" "\


\(fn)" t nil)

(autoload 'rtags-location-stack-forward "rtags" "\


\(fn)" t nil)

(autoload 'rtags-location-stack-back "rtags" "\


\(fn)" t nil)

(autoload 'rtags-location-stack-reset "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-symbol-at-point "rtags" "\
Find the natural target for the symbol under the cursor and moves to that location.
For references this means to jump to the definition/declaration of the referenced symbol (it jumps to the definition if it is indexed).
For definitions it jumps to the declaration (if there is only one) For declarations it jumps to the definition.
If called with prefix, open first match in other window

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-references-at-point "rtags" "\
Find all references to the symbol under the cursor.

If there's exactly one result jump directly to it, and if optional
PREFIX is given jump to it in other window. If there's more show a
buffer with the different alternatives and jump to the first one, if
`rtags-jump-to-first-match' is true. References to references will be
treated as references to the referenced symbol.

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-virtuals-at-point "rtags" "\
List all reimplementations of function under cursor.
This includes both declarations and definitions.

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-all-references-at-point "rtags" "\


\(fn &optional PREFIX)" t nil)

(autoload 'rtags-guess-function-at-point "rtags" "\


\(fn)" t nil)

(autoload 'rtags-rename-symbol "rtags" "\
Rename symbol (identifier) at point.

Normally this function will ask the user (via minibuffer) for the
replacement and then ask for confirmation.  However, when the scope
of the symbol at point is just one file (the file that's being
visited by current buffer), the variable `rtags-use-multiple-cursors'
is non-nil and the `multiple-cursors' package is available, then this
function will create fake cursors at all occurrences of the symbol.

The optional argument NO-CONFIRM means agree to all replacements and
can be specified with a prefix argument.

\(fn &optional NO-CONFIRM)" t nil)

(autoload 'rtags-find-symbol "rtags" "\


\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-references "rtags" "\


\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-symbol-current-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-references-current-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-symbol-current-dir "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-references-current-dir "rtags" "\


\(fn)" t nil)

(autoload 'rtags-clear-diagnostics-overlays "rtags" "\


\(fn &optional BUF)" t nil)

(autoload 'rtags-is-running "rtags" "\


\(fn)" t nil)

(autoload 'rtags-cycle-through-diagnostics "rtags" "\


\(fn)" t nil)

(autoload 'rtags-fix-fixit-at-point "rtags" "\
Apply compiler fix-it at point.

\(fn)" t nil)

(autoload 'rtags-restart-tracking-timer "rtags" "\


\(fn)" t nil)

(autoload 'rtags-post-command-hook "rtags" "\


\(fn)" t nil)

(autoload 'rtags-toggle-diagnostics-suspended "rtags" "\


\(fn &optional QUIET)" t nil)

(autoload 'rtags-set-diagnostics-suspended "rtags" "\


\(fn &optional QUIET)" t nil)

(autoload 'rtags-stop-diagnostics "rtags" "\


\(fn)" t nil)

(autoload 'rtags-clear-diagnostics "rtags" "\


\(fn)" t nil)

(autoload 'rtags-diagnostics "rtags" "\


\(fn &optional RESTART NODIRTY)" t nil)

(autoload 'rtags-compilation-flags "rtags" "\


\(fn)" t nil)

(autoload 'rtags-close-taglist "rtags" "\


\(fn)" t nil)

(autoload 'rtags-taglist "rtags" "\


\(fn &optional DEST-WINDOW)" t nil)

(autoload 'rtags-select "rtags" "\


\(fn &optional OTHER-WINDOW REMOVE SHOW)" t nil)

(autoload 'rtags-select-other-window "rtags" "\


\(fn &optional NOT-OTHER-WINDOW)" t nil)

(autoload 'rtags-select-caller "rtags" "\


\(fn &optional NOT-OTHER-WINDOW)" t nil)

(autoload 'rtags-select-caller-other-window "rtags" "\


\(fn)" t nil)

(autoload 'rtags-show-in-other-window "rtags" "\


\(fn)" t nil)

(autoload 'rtags-select-and-remove-rtags-buffer "rtags" "\


\(fn)" t nil)

(autoload 'rtags-imenu "rtags" "\


\(fn)" t nil)

(autoload 'rtags-flatten-max-depth-one "rtags" "\


\(fn UNFLATTENED)" nil nil)

(autoload 'rtags-create-index-function "rtags" "\


\(fn)" t nil)

(autoload 'rtags-activate-imenu "rtags" "\
Overrides imenu index generation function for the current function.

\(fn)" t nil)

(autoload 'rtags-copy-and-print-current-location "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-file "rtags" "\
Find files matching a file pattern in the RTags database.

With PREFIX and when `rtags-use-filename-completion' is nil,
negate `rtags-find-file-prefer-exact-match' when matching files.

Initial file pattern to match is obtained from `rtags-current-symbol'
which can be overridden by specifying DEFAULT-FILE

\(fn &optional PREFIX DEFAULT-FILE)" t nil)

(autoload 'rtags-show-rtags-buffer "rtags" "\


\(fn)" t nil)

(autoload 'rtags-fixit "rtags" "\


\(fn &optional EDIFF BUFFER)" t nil)

(autoload 'rtags-remove-other-window "rtags" "\


\(fn)" t nil)

(autoload 'rtags-update-current-project "rtags" "\


\(fn)" t nil)

(autoload 'rtags-show-target-in-other-window "rtags" "\
DEST-WINDOW : destination window. Can be nil; in this case the current window is split
according to `rtags-other-window-window-size-percentage'.
CENTER-WINDOW : if true the target window is centered.
TRY-DECLARATION-FIRST : first try to find the declaration of the item, then the
definition.

\(fn &optional DEST-WINDOW CENTER-WINDOW TRY-DECLARATION-FIRST)" t nil)

(autoload 'rtags-suspend-file "rtags" "\


\(fn &optional ARG)" t nil)

(autoload 'rtags-unsuspend-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-toggle-file-suspended "rtags" "\


\(fn)" t nil)

(autoload 'rtags-clear-suspended-files "rtags" "\


\(fn &optional A B)" t nil)

(autoload 'rtags-suspend-all-files "rtags" "\


\(fn &optional A)" t nil)

(autoload 'rtags-list-suspended-files "rtags" "\


\(fn)" t nil)

(autoload 'rtags-compile-file "rtags" "\


\(fn &optional BUFFER)" t nil)

(autoload 'rtags-recompile-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-quit-rdm "rtags" "\
Quit the RTags process (rdm).

\(fn)" t nil)

(autoload 'rtags-restart-process "rtags" "\
Restart the RTags process (rdm).

\(fn)" t nil)

(autoload 'rtags-start-process-unless-running "rtags" "\
Launch the RTags process (rdm) if it's not already started.

\(fn)" t nil)

(autoload 'rtags-reparse-file "rtags" "\
WAIT-REPARSING : t to wait for reparsing to finish, nil for async (no waiting).

\(fn &optional BUFFER PERIODIC)" t nil)

(autoload 'rtags-maybe-reparse-file "rtags" "\


\(fn &optional BUFFER)" t nil)

(autoload 'rtags-display-summary "rtags" "\
Display a short text describing the item at point.
See `rtags-get-summary-text' for details.
If `rtags-display-summary-as-tooltip' is t, a tooltip is displayed.

\(fn &optional HIDE-EMPTY POS)" t nil)

(autoload 'rtags-display-summary-as-message "rtags" "\
Display a short text in message area describing the item at point.
See `rtags-get-summary-text' for details.

\(fn)" t nil)

(autoload 'rtags-get-include-file-for-symbol "rtags" "\
Insert #include declaration to buffer corresponding to the input symbol.
With optional PREFIX insert include at point.

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-make-member "rtags" "\
Create a stub member functions. Type a declaration and then
`rtags-make-member' can be used to create the stub definition in
the class.

\(fn)" t nil)

(autoload 'rtags-check-includes "rtags" "\


\(fn)" t nil)

(autoload 'rtags-tokens "rtags" "\


\(fn &optional FROM TO CALLBACK)" t nil)

(autoload 'rtags-create-doxygen-comment "rtags" "\
Creates doxygen comment for function at point.

Comment will be inserted before current line. It uses yasnippet to let
the user enter missing field manually.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rtags" '("rtags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/restart-emacs-20180601.1031/restart-emacs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/restart-emacs-20180601.1031/restart-emacs-autoloads.el") (car load-path))))



(autoload 'restart-emacs-handle-command-line-args "restart-emacs" "\
Handle the --restart-emacs-desktop command line argument.

The value of the argument is the desktop file from which the frames should be
restored.  IGNORED are ignored.

\(fn &rest IGNORED)" nil nil)

(add-to-list 'command-switch-alist '("--restart-emacs-desktop" . restart-emacs-handle-command-line-args))

(autoload 'restart-emacs "restart-emacs" "\
Restart Emacs.

When called interactively ARGS is interpreted as follows

- with a single `universal-argument' (`C-u') Emacs is restarted
  with `--debug-init' flag
- with two `universal-argument' (`C-u') Emacs is restarted with
  `-Q' flag
- with three `universal-argument' (`C-u') the user prompted for
  the arguments

When called non-interactively ARGS should be a list of arguments
with which Emacs should be restarted.

\(fn &optional ARGS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "restart-emacs" '("restart-emacs-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/replace-symbol-20160518.12/replace-symbol-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/replace-symbol-20160518.12/replace-symbol-autoloads.el") (car load-path))))



(autoload 'replace-symbol-in-sexp "replace-symbol" "\
Replace the symbol FROM with TO in the sexp following the point.
If RECURSIVE is true, do not announce the number of replacements.

\(fn FROM TO &optional RECURSIVE)" t nil)

(autoload 'replace-symbol-in-buffer "replace-symbol" "\
Replace the symbol FROM with TO in the entire buffer.

\(fn FROM TO)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "replace-symbol" '("replace-symbol-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/replace-pairs-20160207.1251/replace-pairs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/replace-pairs-20160207.1251/replace-pairs-autoloads.el") (car load-path))))



(autoload 'query-replace-pairs "replace-pairs" "\
Query-replace pairs of things

For example replace `(' and `)' with `[' and `]' respectively.

Interface is identical to `query-replace'.

\(fn FROM-ITEM TO-ITEM DELIMITED START END BACKWARD)" t nil)

(autoload 'replace-pairs "replace-pairs" "\
Replace pairs of things

For example replace `(' and `)' with `[' and `]' respectively.

Interface is identical to `replace-string'.

\(fn FROM-ITEM TO-ITEM &optional DELIMITED START END BACKWARD)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "replace-pairs" '("replace-pairs-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/fullframe-20170816.1003/fullframe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/fullframe-20170816.1003/fullframe-autoloads.el") (car load-path))))



(autoload 'fullframe/current-buffer-window-config "fullframe" "\
Return the window-configuration stored for the current buffer.

\(fn)" nil nil)

(autoload 'fullframe/erase-current-buffer-window-config "fullframe" "\
Forget the window config associated with the current buffer.

\(fn)" nil nil)

(autoload 'fullframe/set-current-buffer-window-config "fullframe" "\
Associate the current buffer with the window-configuration WCONF.

\(fn WCONF)" nil nil)

(autoload 'fullframe/split-screen "fullframe" "\
After COMMAND-ON is executed and only one window present in
  the current frame, split the frame in two windows ('below or
  'right, depending on DIRECTION being `horizontal' or
  `vertical') and switch the new window to the buffer
  SECOND-BUFFER (name or symbol). If SWITCH-TO-SECOND-BUFFER is
  not `nil', the window holding SECOND-BUFFER will be activated.

\(fn COMMAND-ON COMMAND-OFF SECOND-BUFFER &optional DIRECTION SWITCH-TO-SECOND-BUFFER SIZE)" nil t)

(autoload 'fullframe "fullframe" "\
Save window/frame state when executing COMMAND-ON.

Advises COMMAND-ON so that the buffer it displays will appear in
a full-frame window.  The previous window configuration will be
restored when COMMAND-OFF is executed in that buffer.  If
KILL-ON-COFF is non-nil, then the buffer will also be killed
after COMMAND-OFF has completed.

This function uses `defadvice' on versions of emacs < 24.4,
`advice-add' otherwise.

AFTER-COMMAND-ON-FUNC is called after COMMAND-ON was called and
the window it generated is the only one in in the frame.

\(fn COMMAND-ON COMMAND-OFF &optional KILL-ON-COFF AFTER-COMMAND-ON-FUNC)" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fullframe" '("fullframe/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/repl-toggle-20180501.1028/repl-toggle-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/repl-toggle-20180501.1028/repl-toggle-autoloads.el") (car load-path))))



(autoload 'repl-toggle-mode "repl-toggle" "\
A minor mode to allow uniform repl buffer switching.

If called interactively, enable Repl-Mode mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'rtog/switch-to-shell-buffer "repl-toggle" "\
Make sure that `BUFFER-NAME' exists and is displayed.

Executes `SHELL-COMMAND', passing `SHELL-ARGS', if buffer
`BUFFER-NAME' doesn't exist.

\(fn BUFFER-NAME SHELL-COMMAND &optional SHELL-ARGS)" nil t)

(autoload 'rtog/add-repl "repl-toggle" "\
Associate MODE with REPL-CMD at runtime..

If in a buffer with `major-mode' MODE, execute REPL-CMD when
`rtog/toggle-repl' is called.

\(fn MODE REPL-CMD)" t nil)

(autoload 'rtog/toggle-repl "repl-toggle" "\
Switch to the repl asscociated with the current major mode.

If in a repl already switch back to the buffer we
came from.

If you provide PASSALONG? as a universal prefix with
\\[universal-argument], the current line or region is passed to
the repl buffer, using \\[universal-argument]
\\[universal-argument] the current function or definition is
passed, and finaly using
\\[universal-argument]\\[universal-argument]\\[universal-argument]
you can pass the whole current buffer.

Additional paramters passed will be IGNORED.

\(fn &optional PASSALONG\\=\\? &rest IGNORED)" t nil)

(autoload 'rtog/activate "repl-toggle" "\
Activate the repl-toggle minor mode.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "repl-toggle" '("repl-toggle-mode-map" "rtog/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/readline-complete-20150708.1437/readline-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/readline-complete-20150708.1437/readline-complete-autoloads.el") (car load-path))))



(autoload 'ac-rlc-setup-sources "readline-complete" "\
Add me to shell-mode-hook!

\(fn)" nil nil)

(autoload 'ac-rlc-prefix-shell-dispatcher "readline-complete" "\


\(fn)" nil nil)

(eval-after-load 'auto-complete '(eval '(ac-define-source shell '((candidates . rlc-candidates) (prefix . ac-rlc-prefix-shell-dispatcher) (requires . 0)))))

(autoload 'company-readline "readline-complete" "\
`company-mode' back-end using `readline-complete'.

\(fn COMMAND &optional ARG &rest IGNORE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "readline-complete" '("ac-" "rlc-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/faceup-20170925.1946/faceup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/faceup-20170925.1946/faceup-autoloads.el") (car load-path))))



(autoload 'faceup-view-buffer "faceup" "\
Display the faceup representation of the current buffer.

\(fn)" t nil)

(autoload 'faceup-write-file "faceup" "\
Save the faceup representation of the current buffer to the file FILE-NAME.

Unless a name is given, the file will be named xxx.faceup, where
xxx is the file name associated with the buffer.

If optional second arg CONFIRM is non-nil, this function
asks for confirmation before overwriting an existing file.
Interactively, confirmation is required unless you supply a prefix argument.

\(fn &optional FILE-NAME CONFIRM)" t nil)

(autoload 'faceup-render-view-buffer "faceup" "\
Convert BUFFER containing Faceup markup to a new buffer and display it.

\(fn &optional BUFFER)" t nil)

(autoload 'faceup-clean-buffer "faceup" "\
Remove faceup markup from buffer.

\(fn)" t nil)

(autoload 'faceup-defexplainer "faceup" "\
Defines an Ert explainer function for FUNCTION.

FUNCTION must return an explanation when the test fails and
`faceup-test-explain' is set.

\(fn FUNCTION)" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "faceup" '("faceup-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/racket-mode-20181004.309/racket-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/racket-mode-20181004.309/racket-mode-autoloads.el") (car load-path))))



(autoload 'racket-bug-report "racket-bug-report" "\
Fill a buffer with data to make a racket-mode bug report.

\(fn)" t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-collection" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-common" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-complete" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-custom" '("defface-racket" "racket-")))



(autoload 'racket--debug-send-definition "racket-debug" "\


\(fn BEG END)" nil nil)

(autoload 'racket--debug-on-break "racket-debug" "\


\(fn RESPONSE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-debug" '("racket-")))



(add-to-list 'hs-special-modes-alist '(racket-mode "(" ")" ";" nil nil))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-edit" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-font-lock" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-imenu" '("racket--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-indent" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-keywords-and-builtins" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-logger" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-make-doc" '("racket-make-doc/")))



(autoload 'racket-mode "racket-mode" "\
Major mode for editing Racket.
\\{racket-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.rkt[dl]?\\'" . racket-mode))

(modify-coding-system-alist 'file "\\.rkt[dl]?\\'" 'utf-8)

(add-to-list 'interpreter-mode-alist '("racket" . racket-mode))

(autoload 'racket-mode-start-faster "racket-mode" "\
Compile racket-mode's .rkt files for faster startup.

racket-mode is implemented as an Emacs Lisp \"front end\" that
talks to a Racket process \"back end\". Because racket-mode is
delivered as an Emacs package instead of a Racket package,
installing it does _not_ do the `raco setup` that is normally
done for Racket packages.

This command will do a `raco make` of racket-mode's .rkt files,
creating bytecode files in `compiled/` subdirectories. As a
result, when a `racket-run' or `racket-repl' command must start
the Racket process, it will start faster.

If you run this command, _ever_, you should run it _again_ after:

- Installing an updated version of racket-mode. Otherwise, you
  might lose some of the speed-up.

- Installing a new version of Racket and/or changing the value of
  the variable `racket-program'. Otherwise, you might get an
  error message due to the bytecode being different versions.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-mode" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-ppss" '("racket--ppss-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-profile" '("racket-")))



(autoload 'racket-repl "racket-repl" "\
Run the Racket REPL and display its buffer in some window.

If the Racket process is not already running, it is started.

If NOSELECT is not nil, does not select the REPL
window (preserves the originally selected window).

Commands that don't want the REPL to be displayed can instead use
`racket--repl-ensure-buffer-and-process'.

\(fn &optional NOSELECT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-repl" '("racket-" "with-racket-repl-buffer")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-stepper" '("racket-")))



(autoload 'racket-unicode-input-method-enable "racket-unicode-input-method" "\
Set input method to `racket-unicode`.

The `racket-unicode` input method lets you easily type various
Unicode symbols that might be useful when writing Racket
code.

To automatically enable the `racket-unicode` input method in
`racket-mode` buffers use `M-x customize-variable <RET>
racket-mode-hook` or put the following code in your Emacs init
file:

    (add-hook 'racket-mode-hook #'racket-unicode-input-method-enable)

Likewise for `racket-repl-mode` buffers:

    (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

To temporarily enable this input method for a single buffer you
can use `M-x racket-unicode-input-method-enable`.

Use `C-\\` to toggle the input method.

When the `racket-unicode` input method is active, you can for
example type `All` and it is immediately replaced with `∀`. A few
other examples:

    omega     ω
    x_1       x₁
    x^1       x¹
    |A|       𝔸
    test-->>E test-->>∃ (racket/redex)

To see a table of all key sequences use `M-x
describe-input-method <RET> racket-unicode`.

If you don’t like the highlighting of partially matching tokens you
can turn it off by setting `input-method-highlight-flag' to nil via
`M-x customize-variable`.

\(fn)" t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-util" '("racket--")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pos-tip-20150318.1513/pos-tip-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pos-tip-20150318.1513/pos-tip-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pos-tip" '("pos-tip-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/racer-20180709.625/racer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/racer-20180709.625/racer-autoloads.el") (car load-path))))



(autoload 'racer-find-definition "racer" "\
Run the racer find-definition command and process the results.

\(fn)" t nil)

(autoload 'racer-find-definition-other-window "racer" "\
Run the racer find-definition command and process the results.

\(fn)" t nil)

(autoload 'racer-find-definition-other-frame "racer" "\
Run the racer find-definition command and process the results.

\(fn)" t nil)

(autoload 'racer-mode "racer" "\
Minor mode for racer.

If called interactively, enable Racer mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racer" '("racer-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/quack-20160410.207/quack-autoloads.el"))
(add-to-list 'load-path (directory-file-name (or (file-name-directory "/home/lk/.emacs.d/elpa/quack-20160410.207/quack-autoloads.el") (car load-path))))



)
(let ((load-file-name "/home/lk/.emacs.d/elpa/preproc-font-lock-20151107.2018/preproc-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/preproc-font-lock-20151107.2018/preproc-font-lock-autoloads.el") (car load-path))))



(defvar preproc-font-lock-modes '(c-mode c++-mode objc-mode) "\
List of major modes where Preproc Font Lock Global mode should be enabled.")

(custom-autoload 'preproc-font-lock-modes "preproc-font-lock" t)

(autoload 'preproc-font-lock-mode "preproc-font-lock" "\
Minor mode that highlights preprocessor directives.

If called interactively, enable Preproc-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar preproc-font-lock-global-mode nil "\
Non-nil if Preproc-Font-Lock-Global mode is enabled.
See the `preproc-font-lock-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `preproc-font-lock-global-mode'.")

(custom-autoload 'preproc-font-lock-global-mode "preproc-font-lock" nil)

(autoload 'preproc-font-lock-global-mode "preproc-font-lock" "\
Toggle Preproc-Font-Lock mode in all buffers.
With prefix ARG, enable Preproc-Font-Lock-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Preproc-Font-Lock mode is enabled in all buffers where
`(lambda nil (when (apply 'derived-mode-p preproc-font-lock-modes) (preproc-font-lock-mode 1)))' would do it.
See `preproc-font-lock-mode' for more information on Preproc-Font-Lock mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "preproc-font-lock" '("preproc-font-lock-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/posframe-20180927.602/posframe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/posframe-20180927.602/posframe-autoloads.el") (car load-path))))



(autoload 'posframe-hide-all "posframe" "\
Hide all posframe's frames.

\(fn)" t nil)

(autoload 'posframe-delete-all "posframe" "\
Delete all posframe's frames and buffers.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "posframe" '("posframe-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/popwin-20150315.1300/popwin-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/popwin-20150315.1300/popwin-autoloads.el") (car load-path))))



(autoload 'popwin:popup-buffer "popwin" "\
Show BUFFER in a popup window and return the popup window. If
NOSELECT is non-nil, the popup window will not be selected. If
STICK is non-nil, the popup window will be stuck. If TAIL is
non-nil, the popup window will show the last contents. Calling
`popwin:popup-buffer' during `popwin:popup-buffer' is allowed. In
that case, the buffer of the popup window will be replaced with
BUFFER.

\(fn BUFFER &key (width popwin:popup-window-width) (height popwin:popup-window-height) (position popwin:popup-window-position) NOSELECT DEDICATED STICK TAIL)" t nil)

(autoload 'popwin:display-buffer "popwin" "\
Display BUFFER-OR-NAME, if possible, in a popup window, or as
usual. This function can be used as a value of
`display-buffer-function'.

\(fn BUFFER-OR-NAME &optional NOT-THIS-WINDOW)" t nil)

(autoload 'popwin:pop-to-buffer "popwin" "\
Same as `pop-to-buffer' except that this function will use
`popwin:display-buffer-1' instead of `display-buffer'.

\(fn BUFFER &optional OTHER-WINDOW NORECORD)" t nil)

(autoload 'popwin:universal-display "popwin" "\
Call the following command interactively with letting
`popwin:special-display-config' be
`popwin:universal-display-config'. This will be useful when
displaying buffers in popup windows temporarily.

\(fn)" t nil)

(autoload 'popwin:one-window "popwin" "\
Delete other window than the popup window. C-g restores the
original window configuration.

\(fn)" t nil)

(autoload 'popwin:popup-buffer-tail "popwin" "\
Same as `popwin:popup-buffer' except that the buffer will be
`recenter'ed at the bottom.

\(fn &rest SAME-AS-POPWIN:POPUP-BUFFER)" t nil)

(autoload 'popwin:find-file "popwin" "\
Edit file FILENAME with popup window by `popwin:popup-buffer'.

\(fn FILENAME &optional WILDCARDS)" t nil)

(autoload 'popwin:find-file-tail "popwin" "\
Edit file FILENAME with popup window by
`popwin:popup-buffer-tail'.

\(fn FILE &optional WILDCARD)" t nil)

(autoload 'popwin:messages "popwin" "\
Display *Messages* buffer in a popup window.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "popwin" '("popwin")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/popup-complete-20141109.308/popup-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/popup-complete-20141109.308/popup-complete-autoloads.el") (car load-path))))



(autoload 'popup-complete--in-region "popup-complete" "\


\(fn NEXT-FUNC START END COLLECTION &optional PREDICATE)" nil nil)

(add-hook 'completion-in-region-functions 'popup-complete--in-region)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "popup-complete" '("popup-complete-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pcache-20170105.2214/pcache-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pcache-20170105.2214/pcache-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcache" '("*pcache-repositor" "constructor" "pcache-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/list-utils-20160414.1402/list-utils-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/list-utils-20160414.1402/list-utils-autoloads.el") (car load-path))))



(let ((loads (get 'list-utils 'custom-loads))) (if (member '"list-utils" loads) nil (put 'list-utils 'custom-loads (cons '"list-utils" loads))))

(require 'cl)

(defstruct tconc head tail)

(autoload 'tconc-list "list-utils" "\
Efficiently append LIST to TC.

TC is a data structure created by `make-tconc'.

\(fn TC LIST)" nil nil)

(autoload 'tconc "list-utils" "\
Efficiently append ARGS to TC.

TC is a data structure created by `make-tconc'

Without ARGS, return the list held by TC.

\(fn TC &rest ARGS)" nil nil)

(autoload 'list-utils-cons-cell-p "list-utils" "\
Return non-nil if CELL holds a cons cell rather than a proper list.

A proper list is defined as a series of cons cells in which the
cdr slot of each cons holds a pointer to the next element of the
list, and the cdr slot in the final cons holds nil.

A plain cons cell, for the purpose of this function, is a single
cons in which the cdr holds data rather than a pointer to the
next cons cell, eg

    '(1 . 2)

In addition, a list which is not nil-terminated is not a proper
list and will be recognized by this function as a cons cell.
Such a list is printed using dot notation for the last two
elements, eg

    '(1 2 3 4 . 5)

Such improper lists are produced by `list*'.

\(fn CELL)" nil nil)

(autoload 'list-utils-make-proper-copy "list-utils" "\
Copy a cons cell or improper LIST into a proper list.

If optional TREE is non-nil, traverse LIST, making proper
copies of any improper lists contained within.

Optional RECUR-INTERNAL is for internal use only.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-make-proper-inplace "list-utils" "\
Make a cons cell or improper LIST into a proper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making any
improper lists contained within into proper lists.

Optional RECUR-INTERNAL is for internal use only.

Modifies LIST and returns the modified value.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-make-improper-copy "list-utils" "\
Copy a proper LIST into an improper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making proper
copies of any improper lists contained within.

Optional RECUR-INTERNAL is for internal use only.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-make-improper-inplace "list-utils" "\
Make proper LIST into an improper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making any
proper lists contained within into improper lists.

Optional RECUR-INTERNAL is for internal use only.

Modifies LIST and returns the modified value.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-linear-subseq "list-utils" "\
Return the linear elements from a partially cyclic LIST.

If there is no cycle in LIST, return LIST.  If all elements of
LIST are included in a cycle, return nil.

As an optimization, CYCLE-LENGTH may be specified if the length
of the cyclic portion is already known.  Otherwise it will be
calculated from LIST.

\(fn LIST &optional CYCLE-LENGTH)" nil nil)

(autoload 'list-utils-cyclic-subseq "list-utils" "\
Return any cyclic elements from LIST as a circular list.

The first element of the cyclic structure is not guaranteed to be
first element of the return value unless FROM-START is non-nil.

To linearize the return value, use `list-utils-make-linear-inplace'.

If there is no cycle in LIST, return nil.

\(fn LIST &optional FROM-START)" nil nil)

(autoload 'list-utils-cyclic-length "list-utils" "\
Return the number of cyclic elements in LIST.

If some portion of LIST is linear, only the cyclic
elements will be counted.

If LIST is completely linear, return 0.

\(fn LIST)" nil nil)

(autoload 'list-utils-cyclic-p "list-utils" "\
Return non-nil if LIST contains any cyclic structures.

If optional PERFECT is set, only return non-nil if LIST is a
perfect non-branching cycle in which the last element points
to the first.

\(fn LIST &optional PERFECT)" nil nil)

(autoload 'list-utils-linear-p "list-utils" "\
Return non-nil if LIST is linear (no cyclic structure).

\(fn LIST)" nil nil)

(defalias 'list-utils-improper-p 'list-utils-cons-cell-p)

(autoload 'list-utils-safe-length "list-utils" "\
Return the number of elements in LIST.

LIST may be linear or cyclic.

If LIST is not really a list, returns 0.

If LIST is an improper list, return the number of proper list
elements, like `safe-length'.

\(fn LIST)" nil nil)

(autoload 'list-utils-flat-length "list-utils" "\
Count simple elements from the beginning of LIST.

Stop counting when a cons is reached.  nil is not a cons,
and is considered to be a \"simple\" element.

If the car of LIST is a cons, return 0.

\(fn LIST)" nil nil)

(autoload 'list-utils-make-linear-copy "list-utils" "\
Return a linearized copy of LIST, which may be cyclic.

If optional TREE is non-nil, traverse LIST, substituting
linearized copies of any cyclic lists contained within.

\(fn LIST &optional TREE)" nil nil)

(autoload 'list-utils-make-linear-inplace "list-utils" "\
Linearize LIST, which may be cyclic.

Modifies LIST and returns the modified value.

If optional TREE is non-nil, traverse LIST, linearizing any
cyclic lists contained within.

\(fn LIST &optional TREE)" nil nil)

(autoload 'list-utils-safe-equal "list-utils" "\
Compare LIST-1 and LIST-2, which may be cyclic lists.

LIST-1 and LIST-2 may also contain cyclic lists, which are
each traversed and compared.  This function will not infloop
when cyclic lists are encountered.

Non-nil is returned only if the leaves of LIST-1 and LIST-2 are
`equal' and the structure is identical.

Optional TEST specifies a test, defaulting to `equal'.

If LIST-1 and LIST-2 are not actually lists, they are still
compared according to TEST.

\(fn LIST-1 LIST-2 &optional TEST)" nil nil)

(autoload 'list-utils-depth "list-utils" "\
Find the depth of LIST, which may contain other lists.

If LIST is not a list or is an empty list, returns a depth
of 0.

If LIST is a cons cell or a list which does not contain other
lists, returns a depth of 1.

\(fn LIST)" nil nil)

(autoload 'list-utils-flatten "list-utils" "\
Return a flattened copy of LIST, which may contain other lists.

This function flattens cons cells as lists, and
flattens circular list structures.

\(fn LIST)" nil nil)

(autoload 'list-utils-insert-before "list-utils" "\
Look in LIST for ELEMENT and insert NEW-ELEMENT before it.

Optional TEST sets the test used for a matching element, and
defaults to `equal'.

LIST is modified and the new value is returned.

\(fn LIST ELEMENT NEW-ELEMENT &optional TEST)" nil nil)

(autoload 'list-utils-insert-after "list-utils" "\
Look in LIST for ELEMENT and insert NEW-ELEMENT after it.

Optional TEST sets the test used for a matching element, and
defaults to `equal'.

LIST is modified and the new value is returned.

\(fn LIST ELEMENT NEW-ELEMENT &optional TEST)" nil nil)

(autoload 'list-utils-insert-before-pos "list-utils" "\
Look in LIST for position POS, and insert NEW-ELEMENT before.

POS is zero-indexed.

LIST is modified and the new value is returned.

\(fn LIST POS NEW-ELEMENT)" nil nil)

(autoload 'list-utils-insert-after-pos "list-utils" "\
Look in LIST for position POS, and insert NEW-ELEMENT after.

LIST is modified and the new value is returned.

\(fn LIST POS NEW-ELEMENT)" nil nil)

(autoload 'list-utils-and "list-utils" "\
Return the elements of LIST1 which are present in LIST2.

This is similar to `cl-intersection' (or `intersection') from
the cl library, except that `list-utils-and' preserves order,
does not uniquify the results, and exhibits more predictable
performance for large lists.

Order will follow LIST1.  Duplicates may be present in the result
as in LIST1.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed.  When FLIP is set, LIST2 will be the guide for the
order of the result, and will determine whether duplicates may
be returned.  Since this function preserves duplicates, setting
FLIP can change the number of elements in the result.

Performance: `list-utils-and' and friends use a general-purpose
hashing approach.  `intersection' and friends use pure iteration.
Iteration can be much faster in a few special cases, especially
when the number of elements is small.  In other scenarios,
iteration can be much slower.  Hashing has no worst-case
performance scenario, although it uses much more memory.  For
heavy-duty list operations, performance may be improved by
`let'ing `gc-cons-threshold' to a high value around sections that
make frequent use of this function.

\(fn LIST1 LIST2 &optional TEST HINT FLIP)" nil nil)

(autoload 'list-utils-not "list-utils" "\
Return the elements of LIST1 which are not present in LIST2.

This is similar to `cl-set-difference' (or `set-difference') from
the cl library, except that `list-utils-not' preserves order and
exhibits more predictable performance for large lists.  Order will
follow LIST1.  Duplicates may be present as in LIST1.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed, returning elements of LIST2 which are not present in
LIST1.  When FLIP is set, LIST2 will be the guide for the order
of the result, and will determine whether duplicates may be
returned.

Performance: see notes under `list-utils-and'.

\(fn LIST1 LIST2 &optional TEST HINT FLIP)" nil nil)

(autoload 'list-utils-xor "list-utils" "\
Return elements which are only present in either LIST1 or LIST2.

This is similar to `cl-set-exclusive-or' (or `set-exclusive-or')
from the cl library, except that `list-utils-xor' preserves order,
and exhibits more predictable performance for large lists.  Order
will follow LIST1, then LIST2.  Duplicates may be present as in
LIST1 or LIST2.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed, causing order and duplicates to follow LIST2, then
LIST1.

Performance: see notes under `list-utils-and'.

\(fn LIST1 LIST2 &optional TEST HINT FLIP)" nil nil)

(autoload 'list-utils-uniq "list-utils" "\
Return a uniquified copy of LIST, preserving order.

This is similar to `cl-remove-duplicates' (or `remove-duplicates')
from the cl library, except that `list-utils-uniq' preserves order,
and exhibits more predictable performance for large lists.  Order
will follow LIST.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-dupes "list-utils" "\
Return only duplicated elements from LIST, preserving order.

Duplicated elements may still exist in the result: this function
removes singlets.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-singlets "list-utils" "\
Return only singlet elements from LIST, preserving order.

Duplicated elements may not exist in the result.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-partition-dupes "list-utils" "\
Partition LIST into duplicates and singlets, preserving order.

The return value is an alist with two keys: 'dupes and 'singlets.
The two values of the alist are lists which, if combined, comprise
a complete copy of the elements of LIST.

Duplicated elements may still exist in the 'dupes partition.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-alist-or-flat-length "list-utils" "\
Count simple or cons-cell elements from the beginning of LIST.

Stop counting when a proper list of non-zero length is reached.

If the car of LIST is a list, return 0.

\(fn LIST)" nil nil)

(autoload 'list-utils-alist-flatten "list-utils" "\
Flatten LIST, which may contain other lists.  Do not flatten cons cells.

It is not guaranteed that the result contains *only* cons cells.
The result could contain other data types present in LIST.

This function simply avoids flattening single conses or improper
lists where the last two elements would be expressed as a dotted
pair.

\(fn LIST)" nil nil)

(autoload 'list-utils-plist-reverse "list-utils" "\
Return reversed copy of property-list PLIST, maintaining pair associations.

\(fn PLIST)" nil nil)

(autoload 'list-utils-plist-del "list-utils" "\
Delete from PLIST the property PROP and its associated value.

When PROP is not present in PLIST, there is no effect.

The new plist is returned; use `(setq x (list-utils-plist-del x prop))'
to be sure to use the new value.

This functionality overlaps with the undocumented `cl-do-remf'.

\(fn PLIST PROP)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "list-utils" '("list-utils-htt-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/persistent-soft-20150223.1853/persistent-soft-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/persistent-soft-20150223.1853/persistent-soft-autoloads.el") (car load-path))))



(let ((loads (get 'persistent-soft 'custom-loads))) (if (member '"persistent-soft" loads) nil (put 'persistent-soft 'custom-loads (cons '"persistent-soft" loads))))

(autoload 'persistent-soft-location-readable "persistent-soft" "\
Return non-nil if LOCATION is a readable persistent-soft data store.

\(fn LOCATION)" nil nil)

(autoload 'persistent-soft-location-destroy "persistent-soft" "\
Destroy LOCATION (a persistent-soft data store).

Returns non-nil on confirmed success.

\(fn LOCATION)" nil nil)

(autoload 'persistent-soft-exists-p "persistent-soft" "\
Return t if SYMBOL exists in the LOCATION persistent data store.

This is a noop unless LOCATION is a string and pcache is loaded.

Returns nil on failure, without throwing an error.

\(fn SYMBOL LOCATION)" nil nil)

(autoload 'persistent-soft-fetch "persistent-soft" "\
Return the value for SYMBOL in the LOCATION persistent data store.

This is a noop unless LOCATION is a string and pcache is loaded.

Returns nil on failure, without throwing an error.

\(fn SYMBOL LOCATION)" nil nil)

(autoload 'persistent-soft-flush "persistent-soft" "\
Flush data for the LOCATION data store to disk.

\(fn LOCATION)" nil nil)

(autoload 'persistent-soft-store "persistent-soft" "\
Under SYMBOL, store VALUE in the LOCATION persistent data store.

This is a noop unless LOCATION is a string and pcache is loaded.

Optional EXPIRATION sets an expiry time in seconds.

Returns a true value if storage was successful.  Returns nil
on failure, without throwing an error.

\(fn SYMBOL VALUE LOCATION &optional EXPIRATION)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "persistent-soft" '("persistent-soft-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/peg-20150708.641/peg-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/peg-20150708.641/peg-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "peg" '("peg-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/noflet-20141102.1454/noflet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/noflet-20141102.1454/noflet-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "noflet" '("letn" "ntake-all")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/kv-20140108.1534/kv-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/kv-20140108.1534/kv-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "kv" '("dotass" "keyword->symbol" "map-bind")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/creole-20140924.1500/creole-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/creole-20140924.1500/creole-autoloads.el") (car load-path))))



(autoload 'creole-wiki "creole" "\
Export WikiCreole SOURCE into HTML.

Returns the buffer where the HTML was exported. This could be a
user supplied buffer (see DESTINATION) or a buffer created based
on the filename of the source (or just automatically created).

SOURCE can be a buffer or plain text or something we might
recognize as a file.  A file-name is detected by a leading
'~' (meaning expand from the user root) or '/' (meaning rooted)
or './' (meaning expand from the root of the source creole file).

If SOURCE is a filename it is loaded with `creole/get-file'.


Keyword arguments are supported to change the way the HTML is
produced.

DESTINATION can be a buffer or a buffer name to write the HTML
into or it can be 't' to indicate the default output stream.  In
the latter case an automatic buffer is still created and the HTML
is sent to the default output stream when the export is done.

The DESTINATION buffer is always returned.

STRUCTURE-TRANSFORM-FN is a structure transformation function or
list of functions, see `creole-html' for details.

HTMLFONTIFY - use 'htmlfontify' to fontify any code blocks; this
is true by default.

Code blocks are marked up like pre-formatted areas but must begin
with a line stating the Emacs mode to fontify the text as; for
example:

 {{{
 ##! emacs-lisp
 (let ((x 1)) x)
 }}}

would cause Emacs Lisp to be fontified.

HTMLFONTIFY-STYLE - add an HTML-STYLE block for 'htmlfontify'
code blocks. If this is nil an HTML-STYLE block is NOT added.

BODY-HEADER - a string or a file-name with HTML code to be
inserted in the BODY of the HTML document before the Creole
markup export.  A file-name is detected in the same way as for
SOURCE.

BODY-FOOTER - a string or a file-name with HTML code to be
inserted in the BODY of the HTML document after the Creole markup
export.  A file-name is detected in the same way as for SOURCE.

The BODY-HEADER and the BODY-FOOTER are treated as moustache
templates and expanded before being inserted.  See
'creole-moustache' for a description.  Variables passed to
'creole-moustache' with the template are:

  text - the creole source text of the page

or any variable in VARIABLES, which is an alist of
symbols -> values.

DOCROOT - base any files to be served.  Any file-name reference
for CSS or JavaScript, if residing under this docroot, will be
linked to the document rather than embedded.

DOCROOT-ALIAS - is the docroot path to use in any links as an
alias for the docroot.

CSS - a list of cascading style sheets, each entry can either be
a file-name (a file-name is detected in the same way as
for SOURCE) or a string with W3C-CSS statements in it.

If a DOCROOT is specified then any cascading style sheets
file-name is LINKed into the resulting document, if not then the
statements are embedded directly.

JAVASCRIPT - a list of JavaScript, as for CSS, each entry can
be either a string of the JavaScript to be directly embedded or a
file-name reference (as in SOURCE).  As for :CSS if
a :DOCROOT is specified then the scripts will be loaded as links
but otherwise will be embedded.

META - a list of strings specifying resulting HTML-META elements.
For example:

 :meta '(\"name='description'
          content='Free Web tutorials on HTML, CSS, XML'\")

:OTHER-LINK - a list of string specifying resulting HTML-LINK
elements, for example:

 :other-link '(\"rel='alternate' href='/my-feed.rss'\")

:DOCTYPE may be nil, in which case nothing is added or it may be
a string in which case it is inserted directly before the <html>
element, or it may be one of the symbols 'xhtml or 'html5 in
which case the right doctype is added.

All, any or none of these keys may be specified.

\(fn SOURCE &key DESTINATION STRUCTURE-TRANSFORM-FN (htmlfontify t) (htmlfontify-style t) BODY-HEADER BODY-FOOTER VARIABLES DOCROOT DOCROOT-ALIAS CSS JAVASCRIPT META OTHER-LINK DOCTYPE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "creole" '("creole" "when1")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/fakir-20140729.1652/fakir-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/fakir-20140729.1652/fakir-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fakir" '("fakir")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/db-20140421.2111/db-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/db-20140421.2111/db-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "db" '("db-" "db/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elnode-20140203.2306/elnode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elnode-20140203.2306/elnode-autoloads.el") (car load-path))))



(defconst elnode-config-directory (expand-file-name (concat user-emacs-directory "elnode/")) "\
The config directory for elnode to store peripheral files.

This is used as a base for other constant directory or file
names (the elnode auth database is a file in this directory, the
elnode webserver has a docroot directory in this directory).

It is based on the `user-emacs-directory' which always seems to
be set, even when emacs is started with -Q.")

(autoload 'elnode-app "elnode" "\
A macro that sets up the boring boilerplate for Elnode apps.

This sets up lexical binding, captures the module's parent
directory in DIR-VAR, requires `cl' and any other features you
list.  Use it like this:

 (elnode-app my-app-dir esxml mongo-elnode)

Once used you can access the variable `my-app-dir' as the dirname
of your module (which is useful for serving files and such).

\(fn DIR-VAR &rest FEATURES)" nil t)

(function-put 'elnode-app 'lisp-indent-function '1)

(autoload 'elnode-start "elnode" "\
Start a server using REQUEST-HANDLER.

REQUEST-HANDLER will handle requests on PORT on HOST (which is
'localhost' by default).

REQUEST-HANDLER is a function which is called with the request.
The function is called with one argument, which is the
http-connection.

You can use functions such as `elnode-http-start' and
`elnode-http-send-body' to send the http response.

Example:

  (defun nic-server (httpcon)
    (elnode-http-start httpcon 200 '(\"Content-Type\" . \"text/html\"))
    (elnode-http-return httpcon \"<html><b>BIG!</b></html>\"))
  (elnode-start 'nic-server)

Now visit http://127.0.0.1:8000

If PORT is non-nil, then run server on PORT, otherwise default to
8000.

If HOST is non-nil, then run the server on the specified local IP
address, otherwise use localhost.  A few names are predefined:

  \"localhost\" is 127.0.0.1
  \"*\" is 0.0.0.0

Additionally, you may specifiy an IP address, e.g \"1.2.3.4\"

Note that although HOST may be specified, elnode does not
disambiguate on running servers by HOST.  So you cannot start two
elnode servers on the same port on different hosts.

DEFER-MODE may be used to control how deferred handlers are
managed for this server.

SERVICE-MAPPINGS is an alist of service resource symbols mapped
to integer port numbers.  This can be supplied to elnode-start to
allow it to map service resources defined by handlers to
different TCP ports and therefore different Emacs instances.

The list of SERVICE-MAPPINGS is also used to start ancilliary
port servers.  Ancilliary port servers should be automatically
stopped when the main server is stopped.

\(fn REQUEST-HANDLER &key PORT (host \"localhost\") (defer-mode :managed) SERVICE-MAPPINGS)" t nil)

(defvar elnode-hostpath-default-table '(("[^/]+//wiki/\\(.*\\)" . elnode-wikiserver) ("[^/]+//\\(.*\\)" . elnode-webserver)) "\
Defines mappings for `elnode-hostpath-default-handler'.

This is the default mapping table for Elnode, out of the box. If
you customize this then elnode will serve these hostpath mappings
by just loading Elnode.

By default the table maps everything to
`elnode-webserver'. Unless you're happy with the default you
should probably get rid of the everything path because it will
interfere with any other mappings you add.")

(custom-autoload 'elnode-hostpath-default-table "elnode" t)

(defconst elnode-config-directory (expand-file-name (concat user-emacs-directory "elnode/")) "\
The config directory for elnode to store peripheral files.

This is used as a base for other constant directory or file
names (the elnode auth database is a file in this directory, the
elnode webserver has a docroot directory in this directory).

It is based on the `user-emacs-directory' which always seems to
be set, even when emacs is started with -Q.")

(autoload 'elnode--webserver-handler-proc "elnode" "\
Actual webserver implementation.

Do webserving to HTTPCON from the DOCROOT using the MIME-TYPES
for meta information.

This is not a real handler (because it takes more than the
HTTPCON) but it is called directly by the real webserver
handlers.

\(fn HTTPCON DOCROOT MIME-TYPES)" nil nil)

(autoload 'elnode-make-webserver "elnode" "\
Make a webserver interactively, for DOCROOT on PORT.

An easy way for a user to make a webserver for a particular
directory.

\(fn DOCROOT PORT &optional HOST)" t nil)

(autoload 'elnode-webserver "elnode" "\
A simple webserver that serves documents out of `elnode-webserver-docroot'.

This is just an example of an elnode webserver, but it may be all
that is needed most of the time.

See `elnode-webserver-handler-maker' for more possibilities for
making webserver functions.

HTTPCON is the HTTP connection to the user agent.

\(fn HTTPCON)" nil nil)

(autoload 'elnode-init "elnode" "\
Bootstraps the elnode environment when the Lisp is loaded.

It's useful to have elnode start automatically... on Lisp
load.  If the variable `elnode-init-port' is set then this
function will launch a server on it.

The server is started with `elnode-hostpath-default-handler' as
the handler and listening on `elnode-init-host'

\(fn)" t nil)

(defvar elnode-do-init nil "\
Should elnode start a server on load?

The server that is started is controlled by more elnode
customizations.

`elnode-hostpath-default-table' defines the mappings from
hostpath regexs to handler functions. By default elnode ships
with this customization setup to serve the document root defined
in `elnode-webserver-docroot', which by default is ~/public_html.")

(custom-autoload 'elnode-do-init "elnode" t)

(eval-after-load 'elnode '(if (and (boundp 'elnode-do-init) elnode-do-init (or (not (boundp 'elnode--inited)) (not elnode--inited))) (progn (elnode-init) (setq elnode--inited nil))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elnode" '("ELNODE-FORM-DATA-TYPE" "elnode" "http-referrer" "if-elnode-auth" "should-" "with-")))



(autoload 'elnode-deferred-queue "elnode-lists" "\
Message the length of the deferred queue.

\(fn ARG)" t nil)

(autoload 'elnode-deferred-list "elnode-lists" "\
List the currently deferred Elnode handlers.

\(fn &optional PREFIX)" t nil)

(defalias 'list-elnode-deferreds 'elnode-deferred-list)

(autoload 'elnode-server-list "elnode-lists" "\
List the currently running Elnode servers.

\(fn &optional PREFIX)" t nil)

(defalias 'list-elnode-servers 'elnode-server-list)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elnode-lists" '("elnode-")))



(autoload 'elnode-log-mode "elnode-log-mode" "\
Elnode log viewing mode.

For viewing access log files from Elnode.

\(fn)" t nil)



(autoload 'elnode-make-proxy "elnode-proxy" "\
Make a proxy handler sending requests to URL.

See `elnode-proxy-do' for how URL is handled.

An HTTP user-agent with a specified HTTP proxy sends the full
request as the path, eg:

  GET http://somehost:port/path?query HTTP/1.1

So `elnode-make-proxy' can make (something like) a full proxy
server with:

  (elnode-make-proxy \"${path}${query}\")

There may be many things that a full proxy does that this does
not do however.

Reverse proxying is a simpler and perhaps more useful.

\(fn URL)" nil nil)

(autoload 'elnode-make-proxy-server "elnode-proxy" "\
Make a proxy server on the specified PORT.

Optionally have requests go to URL.  If URL is not specified it
is \"${path}${query}\".

Interactively use C-u to specify the URL.

\(fn PORT &optional URL)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elnode-proxy" '("elnode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elnode-rle" '("elnode-" "with-elnode-rle-wait")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elnode-testsupport" '("elnode-")))



(defconst elnode-wikiserver-wikiroot-default (expand-file-name (concat elnode-config-directory "wiki/")) "\
The default location of the wiki root.

This is used to detect whether elnode needs to create this
directory or not.")

(defvar elnode-wikiserver-wikiroot elnode-wikiserver-wikiroot-default "\
The root for the Elnode wiki files.

This is where elnode-wikiserver serves wiki files from.")

(custom-autoload 'elnode-wikiserver-wikiroot "elnode-wiki" t)

(autoload 'elnode-wikiserver-test "elnode-wiki" "\
Test whether we should serve Wiki or not.

\(fn)" nil nil)

(autoload 'elnode-wikiserver "elnode-wiki" "\
Serve Wiki pages from `elnode-wikiserver-wikiroot'.

HTTPCON is the request.

The Wiki server is only available if the `creole' package is
provided. Otherwise it will just error.

\(fn HTTPCON)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elnode-wiki" '("elnode-wiki")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/peek-mode-20130620.1946/peek-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/peek-mode-20130620.1946/peek-mode-autoloads.el") (car load-path))))



(autoload 'peek-mode "peek-mode" "\
Serves the buffer live over HTTP.

If called interactively, enable Peek mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "peek-mode" '("peek-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pdf-tools-20181008.1926/pdf-tools-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pdf-tools-20181008.1926/pdf-tools-autoloads.el") (car load-path))))



(autoload 'pdf-annot-minor-mode "pdf-annot" "\
Support for PDF Annotations.

If called interactively, enable Pdf-Annot minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{pdf-annot-minor-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-annot" '("pdf-annot-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-cache" '("boundingbox" "define-pdf-cache-function" "page" "pdf-cache-" "textregions")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-dev" '("pdf-dev-")))



(autoload 'pdf-history-minor-mode "pdf-history" "\
Keep a history of previously visited pages.

If called interactively, enable Pdf-History minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

This is a simple stack-based history.  Turning the page or
following a link pushes the left-behind page on the stack, which
may be navigated with the following keys.

\\{pdf-history-minor-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-history" '("pdf-history-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-info" '("pdf-info-")))



(autoload 'pdf-isearch-minor-mode "pdf-isearch" "\
Isearch mode for PDF buffer.

If called interactively, enable Pdf-Isearch minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When this mode is enabled \\[isearch-forward], among other keys,
starts an incremental search in this PDF document.  Since this mode
uses external programs to highlight found matches via
image-processing, proceeding to the next match may be slow.

Therefore two isearch behaviours have been defined: Normal isearch and
batch mode.  The later one is a minor mode
\(`pdf-isearch-batch-mode'), which when activated inhibits isearch
from stopping at and highlighting every single match, but rather
display them batch-wise.  Here a batch means a number of matches
currently visible in the selected window.

The kind of highlighting is determined by three faces
`pdf-isearch-match' (for the current match), `pdf-isearch-lazy'
\(for all other matches) and `pdf-isearch-batch' (when in batch
mode), which see.

Colors may also be influenced by the minor-mode
`pdf-view-dark-minor-mode'.  If this is minor mode enabled, each face's
dark colors, are used (see e.g. `frame-background-mode'), instead
of the light ones.

\\{pdf-isearch-minor-mode-map}
While in `isearch-mode' the following keys are available. Note
that not every isearch command work as expected.

\\{pdf-isearch-active-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-isearch" '("pdf-isearch-")))



(autoload 'pdf-links-minor-mode "pdf-links" "\
Handle links in PDF documents.\\<pdf-links-minor-mode-map>

If called interactively, enable Pdf-Links minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

If this mode is enabled, most links in the document may be
activated by clicking on them or by pressing \\[pdf-links-action-perform] and selecting
one of the displayed keys, or by using isearch limited to
links via \\[pdf-links-isearch-link].

\\{pdf-links-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'pdf-links-action-perform "pdf-links" "\
Follow LINK, depending on its type.

This may turn to another page, switch to another PDF buffer or
invoke `pdf-links-browse-uri-function'.

Interactively, link is read via `pdf-links-read-link-action'.
This function displays characters around the links in the current
page and starts reading characters (ignoring case).  After a
sufficient number of characters have been read, the corresponding
link's link is invoked.  Additionally, SPC may be used to
scroll the current page.

\(fn LINK)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-links" '("pdf-links-")))



(autoload 'pdf-loader-install "pdf-loader" "\
Prepare Emacs for using PDF Tools.

This function acts as a replacement for `pdf-tools-install' and
makes Emacs load and use PDF Tools as soon as a PDF file is
opened, but not sooner.

The arguments are passed verbatim to `pdf-tools-install', which
see.

\(fn &optional NO-QUERY-P SKIP-DEPENDENCIES-P NO-ERROR-P FORCE-DEPENDENCIES-P)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-loader" '("pdf-loader--")))



(autoload 'pdf-misc-minor-mode "pdf-misc" "\
FIXME:  Not documented.

If called interactively, enable Pdf-Misc minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'pdf-misc-size-indication-minor-mode "pdf-misc" "\
Provide a working size indication in the mode-line.

If called interactively, enable Pdf-Misc-Size-Indication minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'pdf-misc-menu-bar-minor-mode "pdf-misc" "\
Display a PDF Tools menu in the menu-bar.

If called interactively, enable Pdf-Misc-Menu-Bar minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'pdf-misc-context-menu-minor-mode "pdf-misc" "\
Provide a right-click context menu in PDF buffers.

If called interactively, enable Pdf-Misc-Context-Menu minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{pdf-misc-context-menu-minor-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-misc" '("pdf-misc-")))



(autoload 'pdf-occur "pdf-occur" "\
List lines matching STRING or PCRE.

Interactively search for a regexp. Unless a prefix arg was given,
in which case this functions performs a string search.

If `pdf-occur-prefer-string-search' is non-nil, the meaning of
the prefix-arg is inverted.

\(fn STRING &optional REGEXP-P)" t nil)

(autoload 'pdf-occur-multi-command "pdf-occur" "\
Perform `pdf-occur' on multiple buffer.

For a programmatic search of multiple documents see
`pdf-occur-search'.

\(fn)" t nil)

(defvar pdf-occur-global-minor-mode nil "\
Non-nil if Pdf-Occur-Global minor mode is enabled.
See the `pdf-occur-global-minor-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `pdf-occur-global-minor-mode'.")

(custom-autoload 'pdf-occur-global-minor-mode "pdf-occur" nil)

(autoload 'pdf-occur-global-minor-mode "pdf-occur" "\
Enable integration of Pdf Occur with other modes.

If called interactively, enable Pdf-Occur-Global minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

This global minor mode enables (or disables)
`pdf-occur-ibuffer-minor-mode' and `pdf-occur-dired-minor-mode'
in all current and future ibuffer/dired buffer.

\(fn &optional ARG)" t nil)

(autoload 'pdf-occur-ibuffer-minor-mode "pdf-occur" "\
Hack into ibuffer's do-occur binding.

If called interactively, enable Pdf-Occur-Ibuffer minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

This mode remaps `ibuffer-do-occur' to
`pdf-occur-ibuffer-do-occur', which will start the PDF Tools
version of `occur', if all marked buffer's are in `pdf-view-mode'
and otherwise fallback to `ibuffer-do-occur'.

\(fn &optional ARG)" t nil)

(autoload 'pdf-occur-dired-minor-mode "pdf-occur" "\
Hack into dired's `dired-do-search' binding.

If called interactively, enable Pdf-Occur-Dired minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

This mode remaps `dired-do-search' to
`pdf-occur-dired-do-search', which will start the PDF Tools
version of `occur', if all marked buffer's are in `pdf-view-mode'
and otherwise fallback to `dired-do-search'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-occur" '("pdf-occur-")))



(autoload 'pdf-outline-minor-mode "pdf-outline" "\
Display an outline of a PDF document.

If called interactively, enable Pdf-Outline minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

This provides a PDF's outline on the menu bar via imenu.
Additionally the same outline may be viewed in a designated
buffer.

\\{pdf-outline-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'pdf-outline "pdf-outline" "\
Display an PDF outline of BUFFER.

BUFFER defaults to the current buffer.  Select the outline
buffer, unless NO-SELECT-WINDOW-P is non-nil.

\(fn &optional BUFFER NO-SELECT-WINDOW-P)" t nil)

(autoload 'pdf-outline-imenu-enable "pdf-outline" "\
Enable imenu in the current PDF buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-outline" '("pdf-outline")))



(autoload 'pdf-sync-minor-mode "pdf-sync" "\
Correlate a PDF position with the TeX file.
\\<pdf-sync-minor-mode-map>
This works via SyncTeX, which means the TeX sources need to have
been compiled with `--synctex=1'.  In AUCTeX this can be done by
setting `TeX-source-correlate-method' to 'synctex (before AUCTeX
is loaded) and enabling `TeX-source-correlate-mode'.

If called interactively, enable Pdf-Sync minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Then \\[pdf-sync-backward-search-mouse] in the PDF buffer will open the
corresponding TeX location.

If AUCTeX is your preferred tex-mode, this library arranges to
bind `pdf-sync-forward-display-pdf-key' (the default is `C-c C-g')
to `pdf-sync-forward-search' in `TeX-source-correlate-map'.  This
function displays the PDF page corresponding to the current
position in the TeX buffer.  This function only works together
with AUCTeX.

\(fn &optional ARG)" t nil)

(define-obsolete-variable-alias 'pdf-sync-tex-display-pdf-key 'pdf-sync-forward-display-pdf-key nil)

(define-obsolete-variable-alias 'pdf-sync-goto-tex-hook 'pdf-sync-backward-hook nil)

(define-obsolete-variable-alias 'pdf-sync-display-pdf-hook 'pdf-sync-forward-hook nil)

(define-obsolete-variable-alias 'pdf-sync-display-pdf-action 'pdf-sync-forward-display-action nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-sync" '("pdf-sync-")))



(defvar pdf-tools-handle-upgrades t "\
Whether PDF Tools should handle upgrading itself.")

(custom-autoload 'pdf-tools-handle-upgrades "pdf-tools" t)

(autoload 'pdf-tools-install "pdf-tools" "\
Install PDF-Tools in all current and future PDF buffers.

If the `pdf-info-epdfinfo-program' is not running or does not
appear to be working, attempt to rebuild it.  If this build
succeeded, continue with the activation of the package.
Otherwise fail silently, i.e. no error is signaled.

Build the program (if necessary) without asking first, if
NO-QUERY-P is non-nil.

Don't attempt to install system packages, if SKIP-DEPENDENCIES-P
is non-nil.

Do not signal an error in case the build failed, if NO-ERROR-P is
non-nil.

Attempt to install system packages (even if it is deemed
unnecessary), if FORCE-DEPENDENCIES-P is non-nil.

Note that SKIP-DEPENDENCIES-P and FORCE-DEPENDENCIES-P are
mutually exclusive.

Note further, that you can influence the installation directory
by setting `pdf-info-epdfinfo-program' to an appropriate
value (e.g. ~/bin/epdfinfo) before calling this function.

See `pdf-view-mode' and `pdf-tools-enabled-modes'.

\(fn &optional NO-QUERY-P SKIP-DEPENDENCIES-P NO-ERROR-P FORCE-DEPENDENCIES-P)" t nil)

(autoload 'pdf-tools-enable-minor-modes "pdf-tools" "\
Enable MODES in the current buffer.

MODES defaults to `pdf-tools-enabled-modes'.

\(fn &optional MODES)" t nil)

(autoload 'pdf-tools-help "pdf-tools" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-tools" '("pdf-tools-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-util" '("display-buffer-split-below-and-attach" "pdf-util-")))



(autoload 'pdf-view-bookmark-jump-handler "pdf-view" "\
The bookmark handler-function interface for bookmark BMK.

See also `pdf-view-bookmark-make-record'.

\(fn BMK)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-view" '("pdf-view-")))



(autoload 'pdf-virtual-edit-mode "pdf-virtual" "\
Major mode when editing a virtual PDF buffer.

\(fn)" t nil)

(autoload 'pdf-virtual-view-mode "pdf-virtual" "\
Major mode in virtual PDF buffers.

\(fn)" t nil)

(defvar pdf-virtual-global-minor-mode nil "\
Non-nil if Pdf-Virtual-Global minor mode is enabled.
See the `pdf-virtual-global-minor-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `pdf-virtual-global-minor-mode'.")

(custom-autoload 'pdf-virtual-global-minor-mode "pdf-virtual" nil)

(autoload 'pdf-virtual-global-minor-mode "pdf-virtual" "\
Enable recognition and handling of VPDF files.

If called interactively, enable Pdf-Virtual-Global minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'pdf-virtual-buffer-create "pdf-virtual" "\


\(fn &optional FILENAMES BUFFER-NAME DISPLAY-P)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pdf-virtual" '("pdf-virtual-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pcmpl-git-20170121.59/pcmpl-git-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pcmpl-git-20170121.59/pcmpl-git-autoloads.el") (car load-path))))



(autoload 'pcomplete/git "pcmpl-git" "\
Completion rules for the `git' command.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcmpl-git" '("pcmpl-git-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcmpl-git-parse" '("git-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pcmpl-args-20120912.524/pcmpl-args-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pcmpl-args-20120912.524/pcmpl-args-autoloads.el") (car load-path))))


 (dolist (func '(pcomplete/chgrp pcomplete/chmod pcomplete/chown pcomplete/chroot pcomplete/cp pcomplete/date pcomplete/dd pcomplete/dir pcomplete/echo pcomplete/env pcomplete/false pcomplete/groups pcomplete/id pcomplete/ln pcomplete/ls pcomplete/mv pcomplete/nice pcomplete/nohup pcomplete/printenv pcomplete/printf pcomplete/rm pcomplete/rmdir pcomplete/sort pcomplete/stat pcomplete/test pcomplete/true pcomplete/vdir pcomplete/basename pcomplete/cat pcomplete/cksum pcomplete/comm pcomplete/csplit pcomplete/cut pcomplete/df pcomplete/dircolors pcomplete/dirname pcomplete/du pcomplete/expand pcomplete/expr pcomplete/factor pcomplete/fmt pcomplete/fold pcomplete/head pcomplete/hostid pcomplete/install pcomplete/join pcomplete/link pcomplete/logname pcomplete/md5sum pcomplete/mkdir pcomplete/mkfifo pcomplete/mknod pcomplete/mktemp pcomplete/nl pcomplete/od pcomplete/paste pcomplete/pathchk pcomplete/pinky pcomplete/pr pcomplete/ptx pcomplete/pwd pcomplete/readlink pcomplete/seq pcomplete/sha1sum pcomplete/shred pcomplete/sleep pcomplete/split pcomplete/stty pcomplete/sum pcomplete/sync pcomplete/tac pcomplete/tail pcomplete/tee pcomplete/touch pcomplete/tr pcomplete/tsort pcomplete/tty pcomplete/uname pcomplete/unexpand pcomplete/uniq pcomplete/unlink pcomplete/users pcomplete/wc pcomplete/whoami pcomplete/who pcomplete/yes pcomplete/man pcomplete/info pcomplete/find pcomplete/command pcomplete/time pcomplete/which pcomplete/coproc pcomplete/do pcomplete/elif pcomplete/else pcomplete/exec pcomplete/if pcomplete/then pcomplete/until pcomplete/whatis pcomplete/whence pcomplete/where pcomplete/whereis pcomplete/while pcomplete/gzip pcomplete/bzip2 pcomplete/xz pcomplete/tar pcomplete/perl pcomplete/python pcomplete/bzr pcomplete/hg pcomplete/git pcomplete/etags pcomplete/ctags pcomplete/ctags-exuberant pcomplete/cmp pcomplete/curl pcomplete/dict pcomplete/enscript pcomplete/gcc pcomplete/gdb pcomplete/gprof pcomplete/grep pcomplete/egrep pcomplete/fgrep pcomplete/rgrep pcomplete/make pcomplete/rsync pcomplete/sudo pcomplete/vlc pcomplete/xargs pcomplete/configure pcomplete/nosetests pcomplete/a2ps pcomplete/ack-grep pcomplete/agrep pcomplete/automake pcomplete/awk pcomplete/bash pcomplete/bc pcomplete/bison pcomplete/cal pcomplete/dc pcomplete/diff pcomplete/emacs pcomplete/gawk pcomplete/gperf pcomplete/indent pcomplete/locate pcomplete/ld pcomplete/ldd pcomplete/m4 pcomplete/ncal pcomplete/netstat pcomplete/nm pcomplete/objcopy pcomplete/objdump pcomplete/patch pcomplete/pgrep pcomplete/ps pcomplete/readelf pcomplete/sed pcomplete/shar pcomplete/strip pcomplete/texindex pcomplete/traceroute pcomplete/wget)) (autoload func "pcmpl-args"))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcmpl-args" '("pcmpl-args-" "pcomplete/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/parinfer-20180904.844/parinfer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/parinfer-20180904.844/parinfer-autoloads.el") (car load-path))))



(autoload 'parinfer-mode "parinfer" "\
Parinfer mode.

If called interactively, enable Parinfer mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'parinfer-region-mode "parinfer" "\
Available when region is active.

If called interactively, enable Parinfer-Region mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parinfer" '("parinfer-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parinfer-ext" '("parinfer-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parinferlib" '("parinferlib-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/paren-face-20180318.2025/paren-face-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/paren-face-20180318.2025/paren-face-autoloads.el") (car load-path))))



(autoload 'paren-face-mode "paren-face" "\
Use a dedicated face just for parentheses.

If called interactively, enable Paren-Face mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-paren-face-mode nil "\
Non-nil if Global Paren-Face mode is enabled.
See the `global-paren-face-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-paren-face-mode'.")

(custom-autoload 'global-paren-face-mode "paren-face" nil)

(autoload 'global-paren-face-mode "paren-face" "\
Toggle Paren-Face mode in all buffers.
With prefix ARG, enable Global Paren-Face mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Paren-Face mode is enabled in all buffers where
`turn-on-paren-face-mode-if-desired' would do it.
See `paren-face-mode' for more information on Paren-Face mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "paren-face" '("paren-face-" "turn-on-paren-face-mode-if-desired")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/paredit-20171127.205/paredit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/paredit-20171127.205/paredit-autoloads.el") (car load-path))))



(autoload 'paredit-mode "paredit" "\
Minor mode for pseudo-structurally editing Lisp code.
With a prefix argument, enable Paredit Mode even if there are
  unbalanced parentheses in the buffer.
Paredit behaves badly if parentheses are unbalanced, so exercise
  caution when forcing Paredit Mode to be enabled, and consider
  fixing unbalanced parentheses instead.
\\<paredit-mode-map>

If called interactively, enable Paredit mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'enable-paredit-mode "paredit" "\
Turn on pseudo-structural editing of Lisp code.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "paredit" '("?\\" "disable-paredit-mode" "paredit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/packed-20180318.1729/packed-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/packed-20180318.1729/packed-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "packed" '("packed-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/package-safe-delete-20150116.1607/package-safe-delete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/package-safe-delete-20150116.1607/package-safe-delete-autoloads.el") (car load-path))))



(autoload 'package-safe-delete-packages "package-safe-delete" "\
Delete PACKAGES.

PACKAGES is a list of package name symbols.
None of the PACKAGES are deleted when there's a package depending on one of
them, or if one of the PACKAGES is not installed.
With FORCE non-nil, the user is not prompted for confirmation before the
packages are deleted.

\(fn PACKAGES &optional FORCE)" nil nil)

(autoload 'package-safe-delete "package-safe-delete" "\
Delete a PACKAGE.

PACKAGE is a package name symbol.
PACKAGE is not deleted when there are other packages requiring it.
Interactively, prompt for its name.

\(fn PACKAGE)" t nil)

(autoload 'package-safe-delete-packages-recursively "package-safe-delete" "\
Delete PACKAGES.
Each of the PACKAGES and all packages required only by the PACKAGES are deleted.

PACKAGES is a list of package name symbols.
None of the PACKAGES are deleted when there's a package depending on one of
them, or if one of the PACKAGES is not installed.
With FORCE non-nil, the user is not prompted for confirmation before the
packages are deleted.

\(fn PACKAGES &optional FORCE)" nil nil)

(autoload 'package-safe-delete-recursively "package-safe-delete" "\
Recursively delete a PACKAGE.
PACKAGE and all packages required only by it are deleted.

PACKAGE is a package name symbol.
PACKAGE is not deleted when there are other packages requiring it.
Interactively, prompt for its name.

\(fn PACKAGE)" t nil)

(autoload 'package-safe-delete-all "package-safe-delete" "\
Delete all packages not explicitly required.

With FORCE non-nil, the user is not prompted for confirmation before the
packages are deleted.

\(fn &optional FORCE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "package-safe-delete" '("package-safe-delete-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/opencl-mode-20170816.1249/opencl-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/opencl-mode-20170816.1249/opencl-mode-autoloads.el") (car load-path))))



(autoload 'opencl-mode "opencl-mode" "\
Major mode for opencl kernel editing

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "opencl-mode" '("opencl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ob-rust-20180911.1535/ob-rust-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ob-rust-20180911.1535/ob-rust-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-rust" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "test-ob-rust" '("ob-rust-test-" "org-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/nrepl-sync-20140807.1554/nrepl-sync-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/nrepl-sync-20140807.1554/nrepl-sync-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-sync" '("nrepl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-20181002.1151/highlight-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-20181002.1151/highlight-autoloads.el") (car load-path))))



(defvar hlt-auto-face-foreground nil "\
*Foreground color for pseudo faces created from a chosen background.
The value is either a color (name or #RGB hex triplet) or nil.  A nil
value means that highlighting does not change the existing foreground
color.")

(custom-autoload 'hlt-auto-face-foreground "highlight" t)

(defvar hlt-auto-faces-flag nil "\
*Non-nil means highlighting can automatically choose faces.
Highlighting action can use the next background color or face in
`hlt-auto-face-backgrounds'.  When a given item in the list is a color
name, not a face, `hlt-auto-face-foreground' is used as the
corresponding foreground.

This option has no effect on unhighlighting.")

(custom-autoload 'hlt-auto-faces-flag "highlight" t)

(defvar hlt-default-copy/yank-props '(face) "\
*Properties that `hlt-copy-props' and `hlt-yank-props' use by default.
You can use a prefix argument with those commands to override the
default behavior.
Either a list of properties (symbols) or `t', meaning all properties.")

(custom-autoload 'hlt-default-copy/yank-props "highlight" t)

(defvar hlt-face-prop (if (< emacs-major-version 22) 'face 'font-lock-face) "\
*Face property used for highlighting: `face' or `font-lock-face'.
If the value is `font-lock-face' then highlighting by library
`highlight.el' disappears when `font-lock-mode' is turned off.

If the value is `face', and if library`font-lock+.el' has been loaded,
then highlighting persists - it is independent of font-locking.

For Emacs 20 or 21, font-locking does not recognize property
`font-lock-face', so just use `face' (the default value for these
versions), not `font-lock-face' - do not change the value.")

(custom-autoload 'hlt-face-prop "highlight" t)

(defvar hlt-line-dups-ignore-regexp "[ \11]*" "\
Regexp to ignore leading and trailing text for duplicate lines.
Or nil if no such text is to be ignored.
Used by `hlt-highlight-line-dups-region' to determine whether two
lines are duplicates.")

(custom-autoload 'hlt-line-dups-ignore-regexp "highlight" t)

(defvar hlt-max-region-no-warning 100000 "\
*Maximum size (chars) of region to highlight without confirmation.
This is used only for highlighting of a regexp, which can be slow.")

(custom-autoload 'hlt-max-region-no-warning "highlight" t)

(defvar hlt-overlays-priority 0 "\
*Priority of the overlays created by `hlt-*' functions.")

(custom-autoload 'hlt-overlays-priority "highlight" t)

(defvar hlt-use-overlays-flag 'only "\
*Non-nil means use overlays to highlight; nil means use text properties.
This value also affects some actions, such as unhighlighting, for text
that is highlighted.  If the value is `only' (the default value), then
those actions only affect overlay highlighting.  Otherwise, they
affect both kinds of highlighting.")

(custom-autoload 'hlt-use-overlays-flag "highlight" t)

(autoload 'hlt-choose-default-face "highlight" "\
Choose a face for highlighting.
Set `hlt-last-face' to the face, and return it.

You can choose a face name or a color name.  If a color is chosen, it
is used for the face background.  The face foreground is determined by
the value of `hlt-auto-face-foreground'.

\(fn FACE)" t nil)

(autoload 'hlt-next-face "highlight" "\
Choose the next face for highlighting and unhighlighting.
Use `hlt-auto-face-backgrounds' and `hlt-auto-face-foreground'.

A non-negative numeric prefix arg N means use the Nth entry of
`hlt-auto-face-backgrounds'.  Counting is 0-based.

A negative numeric prefix arg N means count from the end, not the
beginning, of `hlt-auto-face-backgrounds': -1 means the last entry, -2
means the next-to-last, etc. (counting from the end is 1-based, not
0-based).

From LISP, if the first argument is `previous' then choose the
previous face, not the next one.

\(fn &optional FACE-NB MSGP)" t nil)

(autoload 'hlt-previous-face "highlight" "\
Like `hlt-next-face', but previous, not next.
Use of a numeric prefix arg is the same as for `hlt-next-face'.

\(fn &optional FACE-NB MSGP)" t nil)

(autoload 'hlt-highlighter "highlight" "\
Highlight the text you drag the mouse over.
The face used is the last face that was used for highlighting.
You can use command `hlt-choose-default-face' to choose the default
face to use.

If `hlt-auto-faces-flag' is non-nil then this command cycles to the
next color/face.  This is the case even if you do not drag the
mouse (empty highlight).  A message tells you what the face is.

A numeric prefix arg N means use the face represented by the Nth entry
of `hlt-auto-face-backgrounds' (uses `hlt-next-face').

\(fn START-EVENT &optional FACE-NB)" t nil)

(autoload 'hlt-eraser "highlight" "\
Erase highlights that you click or drag the mouse over.
If `hlt-use-overlays-flag' is non-nil, then remove overlay
highlighting for the last face that was used for highlighting.  (You
can use command `hlt-choose-default-face' first to choose a different
face.)

If `hlt-use-overlays-flag' is not `only', then remove text-property
highlighting for *ALL* faces (not just highlighting faces).  This
means, in particular, that a value of nil erases both overlays for the
last face and text properties for all faces.

With a numeric prefix arg N, if `hlt-use-overlays-flag' is `only',
erase the face represented by the Nth entry of
`hlt-auto-face-backgrounds' (uses `hlt-next-face').

\(fn START-EVENT &optional FACE-NB)" t nil)

(autoload 'hlt-highlighter-mouse "highlight" "\
Same as `hlt-highlighter', but for binding to a menu item.

\(fn)" t nil)

(autoload 'hlt-eraser-mouse "highlight" "\
Same as `hlt-eraser', but for binding to a menu item.

\(fn)" t nil)

(autoload 'hlt-highlight "highlight" "\
Highlight or unhighlight.
If the region is not active or it is empty, then use the whole buffer.
The face used is the last face that was used for highlighting.
You can use command `hlt-choose-default-face' to choose a different face.

This is several commands rolled into one, depending on the prefix arg:

* No prefix arg: highlight all text in region/buffer
* Plain prefix arg (`C-u') or zero prefix arg (`C-0'): UNhighlight all
* Positive prefix arg (`C-1'): highlight regexp matches
* Negative prefix arg (`C--'): UNhighlight regexp matches

You can also use the individual commands:

* `hlt-highlight-region'          - same as no prefix arg
* `hlt-unhighlight-region'        - same as `C-u' or `C-0'
* `hlt-highlight-regexp-region'   - same as `C-1'
* `hlt-unhighlight-regexp-region' - same as `C--'

\(fn &optional PREFIX)" t nil)

(autoload 'hlt-highlight-region-in-buffers "highlight" "\
Use `hlt-highlight-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means highlight with `mouse-face', not `face'.
A prefix arg <= 0 means highlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to highlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is highlighted.

Non-nil optional arg MSGP means show status messages.

\(fn BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-highlight-region "highlight" "\
Highlight either the region/buffer or new input that you type.
Use the region if active, or the buffer otherwise.

If *ALL* of the following are true then apply the last-used face as a
text property to the next and subsequent characters that you type, and
add that face to a Facemenu menu (`Text Properties' or one of its
submenus):

 * You call this command interactively.
 * You use no prefix arg.
 * Option `hlt-use-overlays-flag' is nil
 * The last property used for highlighting was `face'.

Otherwise, the behavior respects `hlt-use-overlays-flag' and depends
on the optional arguments, as follows:

Optional args START and END are the limits of the area to act on.
  They default to the region limits.  If the region is not active or
  it is empty, then use the whole buffer.  (But see BUFFERS, below.)

Optional 3rd arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different face.)

Optional 4th arg MSGP non-nil means to display a progress message.
  Interactively, MSGP is t.

Optional 5th arg MOUSEP non-nil means use `mouse-face', not `face'.
  Interactively, MOUSEP is provided by the prefix arg.

Optional 6th arg BUFFERS is the list of buffers to highlight.
  If non-nil and this command is called interactively then explicit
  START and END values are ignored, and the actual values are
  determined automatically for each buffer, based on whether the
  region is active there.

\(fn &optional START END FACE MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-unhighlight-region-in-buffers "highlight" "\
Use `hlt-unhighlight-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means unhighlight `mouse-face', not `face'.
A prefix arg <= 0 means unhighlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to unhighlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is unhighlighted.

Non-nil optional arg MSGP means show status messages.

\(fn BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-unhighlight-region "highlight" "\
Remove all highlighting in region or buffer.
Use the region if active, or the buffer otherwise.
The arguments are the same as for `hlt-highlight-region'.

If `hlt-use-overlays-flag' is non-nil, then remove overlay highlighting.
If `hlt-use-overlays-flag' is not `only', then remove text-property
highlighting.  This means, in particular, that a value of nil removes
both overlays and text properties.

\(fn &optional START END FACE MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-highlight-regexp-region-in-buffers "highlight" "\
Use `hlt-highlight-regexp-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means highlight with `mouse-face', not `face'.
A prefix arg <= 0 means highlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to highlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is highlighted.

See `hlt-highlight-regexp-region' for other arguments.

\(fn REGEXP BUFFERS &optional FACE MSGP MOUSEP NTH)" t nil)

(autoload 'hlt-highlight-regexp-region "highlight" "\
Highlight regular expression REGEXP in region/buffer.
Use the region if active, or the buffer otherwise.

Optional args START and END are the limits of the area to act on.
  They default to the region limits.  (But see BUFFERS, below.)
Optional 4th arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different face.)
Optional 5th arg MSGP:
  t means to treat this as an interactive call when deciding to
    display all messages.
  non-nil & non-t means to display only error and warning messages.
Optional 6th arg MOUSEP non-nil means to use `mouse-face' property,
  not `face'.  Interactively, this is provided by the prefix arg.
Optional 7th arg NTH determines which regexp subgroup is highlighted.
  If nil or 0, the entire regexp is highlighted.  Otherwise, the NTH
  regexp subgroup (\"\\\\(...\\\\)\" expression) is highlighted.
  (NTH is not available interactively.)
Optional 6th arg BUFFERS is the list of buffers to highlight.
  If non-nil then explicit START and END values are ignored, and the
  actual values are determined automatically for each buffer, based on
  whether the region is active there.

\(fn &optional START END REGEXP FACE MSGP MOUSEP NTH BUFFERS)" t nil)

(autoload 'hlt-unhighlight-regexp-region-in-buffers "highlight" "\
Use `hlt-unhighlight-regexp-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means unhighlight `mouse-face', not `face'.
A prefix arg <= 0 means unhighlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to unhighlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is unhighlighted.

See `hlt-highlight-regexp-region' for other arguments.

\(fn REGEXP BUFFERS &optional NTH MSGP)" t nil)

(autoload 'hlt-unhighlight-regexp-region "highlight" "\
Unhighlight text matching regular expression REGEXP in region/buffer.
This is like `hlt-highlight-regexp-region' (which see), but opposite.
Where `hlt-highlight-regexp-region' highlights REGEXP matches, this
unhighlights the matches.

\(fn &optional START END REGEXP FACE MSGP MOUSEP NTH BUFFERS)" t nil)

(autoload 'hlt-highlight-regexp-to-end "highlight" "\
Highlight text after cursor that matches REGEXP.
The behavior respects `hlt-use-overlays-flag' and depends on the
optional arguments, as follows:

 Optional 2nd arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different
  face.)

 Optional 3rd arg MSGP non-nil means to display a progress message.
  Interactively, MSGP is t.

 Optional 4th arg MOUSEP non-nil means use property `mouse-face', not
 `face'.  Interactively, MOUSEP is provided by the prefix arg.

 Optional 5th arg NTH determines which regexp subgroup is highlighted.
  If nil or 0, the entire regexp is highlighted.  Otherwise, the NTH
  regexp subgroup (\"\\\\(...\\\\)\" expression) is highlighted.
  (NTH is not available interactively.)

\(fn REGEXP &optional FACE MSGP MOUSEP NTH)" t nil)

(autoload 'hlt-unhighlight-regexp-to-end "highlight" "\
UNhighlight text after cursor that matches REGEXP.
This is like `hlt-highlight-regexp-to-end' (which see), but opposite.
Where `hlt-highlight-regexp-to-end' highlights REGEXP matches, this
unhighlights the matches.

\(fn REGEXP &optional FACE MSGP MOUSEP NTH)" t nil)

(autoload 'hlt-highlight-regexp-groups-region "highlight" "\
Like `hlt-highlight-regexp-region', but highlight regexp groups.
Highlight regular expression REGEXP in region/buffer.
Use the region if active, or the buffer otherwise.

Up to 8 group levels are highlighted, using faces `hlt-regexp-level-1'
through `hlt-regexp-level-8'.  The current default highlighting face
is used to highlight the non-group matches. You can change the default
face using command `hlt-choose-default-face'.

Optional args START and END are the limits of the area to act on.
  They default to the region limits.
Optional 4th arg MSGP:
  t means to treat this as an interactive call when deciding to
    display all messages.
  non-nil & non-t means to display only error and warning messages.
Optional 5th arg MOUSEP non-nil means to use `mouse-face' property,
  not `face'.  Interactively, this is provided by the prefix arg.

\(fn &optional START END REGEXP MSGP MOUSEP)" t nil)

(autoload 'hlt-unhighlight-regexp-groups-region "highlight" "\
Like `hlt-highlight-regexp-groups-region', but opposite.
Where `hlt-highlight-regexp-groups-region' highlights REGEXP matches,
this unhighlights the matches.

\(fn &optional START END REGEXP MSGP MOUSEP)" t nil)

(autoload 'hlt-unhighlight-region-for-face-in-buffers "highlight" "\
Use `hlt-unhighlight-region-for-face' in each buffer of list BUFFERS.
A prefix arg >= 0 means unhighlight `mouse-face', not `face'.
A prefix arg <= 0 means unhighlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to unhighlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is unhighlighted.

See `hlt-unhighlight-region-for-face' for other arguments.

\(fn FACE BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-unhighlight-region-for-face "highlight" "\
Remove any highlighting in the region that uses FACE.
Same as `hlt-unhighlight-region', but removes only highlighting
that uses FACE.  Interactively, you are prompted for the face.

This works only for overlay highlighting, not text-property
highlighting.

Note: When text in the region has been highlighted using more than one
face, unhighlighting for one of those faces can mean that adjacent
highlighting outside the region appears to change.  That outside text
still has the same multiple-overlay face highlighting, but the overlay
stacking order is not the same as it was.

Optional arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different face.)
Optional args START and END are the limits of the area to act on.
  They default to the region limits.  (But see BUFFERS, below.)
Optional arg MSGP non-nil means show status messages.
Optional arg MOUSEP non-nil means use `mouse-face' property, not
  `face'.  Interactively, MOUSEP is provided by the prefix arg.
Optional arg BUFFERS is the list of buffers to unhighlight for FACE.
  If non-nil then explicit START and END values are ignored, and the
  actual values are determined automatically for each buffer, based on
  whether the region is active there.

\(fn &optional FACE START END MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-replace-highlight-face-in-buffers "highlight" "\
Use `hlt-replace-highlight-face' in each buffer of list BUFFERS.
A prefix arg >= 0 means highlight with `mouse-face', not `face'.
A prefix arg <= 0 means highlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to highlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is highlighted.

See `hlt-replace-highlight-face' for other arguments.

\(fn OLD-FACE NEW-FACE BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-replace-highlight-face "highlight" "\
Replace OLD-FACE by NEW-FACE in overlay highlighting in the region.
This command applies only to overlay highlighting created by library
`highlight.el'.

Update the last-used highlighting face.

With a prefix argument, replace OLD-FACE as the `mouse-face' property,
 not the `face' property.

Other arguments:
 Optional args START and END are the limits of the area to act on.
  They default to the region limits.  If the region is not active or
  it is empty, then use the whole buffer.
 Optional arg MSGP non-nil means display a progress message.
 Optional arg MOUSEP non-nil means use `mouse-face' property, not
  `face'.  Interactively, MOUSEP is provided by the prefix arg.

\(fn OLD-FACE NEW-FACE &optional START END MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-highlight-symbol "highlight" "\
Highlight occurrences of SYMBOL.
The symbol at point is used by default, or the symbol under the mouse
pointer if the command is invoked using the mouse.

Highlight over the region if active, or the buffer otherwise.
With a prefix arg, use all buffers that are visible or iconified.
\(This first unhighlights occurrences, to prevent stacking up multiple
highlighting on the same occurrences.)

When called from Lisp:
* ALL-BUFFERS-P corresponds to the prefix-argument behavior.
* FACE is the face to use.

\(fn SYMBOL &optional ALL-BUFFERS-P FACE)" t nil)

(autoload 'hlt-unhighlight-symbol "highlight" "\
Unhighlight occurrences of SYMBOL.
The symbol at point is used by default, or the symbol under the mouse
pointer if the command is invoked using the mouse.

Unhighlight over the region if active, or the buffer otherwise.
With a prefix arg, use all buffers that are visible or iconified.

When called from Lisp:
* ALL-BUFFERS-P corresponds to the prefix-argument behavior.
* FACE is the face to unhighlight.

\(fn SYMBOL &optional ALL-BUFFERS-P FACE)" t nil)

(autoload 'hlt-highlight-enclosing-list "highlight" "\
Highlight the ARGth level sexp enclosing point.
ARG is the numeric prefix value.

A negative prefix arg prompts you for the face to use.  This face is
used by default from then on.  You can also choose the default face
using command `hlt-choose-default-face'.  The same face is used as the
default for all `hlt-*' functions.

When used in Lisp code:
 MOUSEP non-nil means use property `mouse-face', not `face'.

\(fn ARG &optional FACE MOUSEP)" t nil)

(autoload 'hlt-highlight-single-quotations "highlight" "\
Highlight single-quoted text in the region.
This means, for example, commands and keys between `'s: `foobar'.
If the region is not active or it is empty, then use the whole buffer.
With a prefix argument, prompt for the highlighting face to use.
Otherwise, use the last face used for highlighting.
 You can also use command `hlt-choose-default-face' to choose a
 different face.

\(fn &optional FACE)" t nil)

(autoload 'hlt-highlight-line-dups-region "highlight" "\
Highlight sets of duplicate lines in the region.
Each set is given a different background, according to user option
`hlt-auto-face-backgrounds'.

Whether leading and trailing whitespace is ignored is controlled by
option `hlt-line-dups-ignore-regexp'.  But a prefix argument reverses
this: if the option value is \"\" then whitespace defined by
\"[ 	]*\" is ignored, and otherwise whitespace is not ignored.

\(fn &optional START END MSGP FLIP)" t nil)

(autoload 'hlt-highlight-lines "highlight" "\
Highlight full lines in region, window-wide.

\(fn START END FACE MSGP)" t nil)

(autoload 'hlt-mouse-face-each-line "highlight" "\
Put `mouse-face' on each line of buffer in region.
If the region is active and not empty, then limit mouse-face
highlighting to the region.  Otherwise, use the whole buffer.
With a prefix argument, prompt for the highlighting face to use.
Otherwise, use the last face used for highlighting.
 You can also use command `hlt-choose-default-face' to choose a
 different face.
Optional args START and END are the limits of the area to act on.
  They default to the region limits.
Optional arg MSGP non-nil means display a progress message.

\(fn &optional START END FACE MSGP)" t nil)

(autoload 'hlt-toggle-use-overlays-flag "highlight" "\
Toggle `hlt-use-overlays-flag'.
If the current value is non-nil, it is set to nil.
If the current value is nil, it is set to the last non-nil value.

\(fn)" t nil)

(defalias 'hlt-paste-props 'hlt-yank-props)

(autoload 'hlt-yank-props "highlight" "\
Yank (paste) copied text properties over the active region.
Interactively, do nothing if there is no nonempty active region.
By default, yank only the copied properties defined by
 `hlt-default-copy/yank-props'.
With a plain or non-negative prefix arg, yank all copied properties.
With a negative prefix arg, you are prompted for the copied properties
 to yank.  To finish entering properties, hit `RET RET' (i.e., twice).

NOTE: If the list of copied text properties is empty, then yanking
      REMOVES ALL PROPERTIES from the text in the region.  This
      provides an easy way to UNpropertize text.

\(fn START END &optional ARG MSGP)" t nil)

(autoload 'hlt-mouse-copy-props "highlight" "\
Same as `hlt-copy-props', but copy at mouse pointer, not at point.

\(fn &optional EVENT ARG MSGP)" t nil)

(autoload 'hlt-copy-props "highlight" "\
Copy text properties at point for use by `hlt-yank-props'.
Properties are copied to `hlt-copied-props'.
By default, copy the properties defined by
 `hlt-default-copy/yank-props'.
With a plain or non-negative prefix arg, copy all properties.
With a negative prefix arg, you are prompted for the properties to
 copy.  To finish entering properties, hit `RET RET' (i.e., twice).

\(fn &optional POSITION ARG MSGP)" t nil)

(autoload 'hlt-highlight-isearch-matches "highlight" "\
Highlight matches of the current Isearch search pattern using FACE.
If the region is active then it limits highlighting.  If inactive then
highlight matches throughout the buffer, or the list of BUFFERS.  If
this is accessed from a `multi-search' command then the BUFFERS are
the buffers being searched.

With no prefix arg:
 * If `hlt-auto-faces-flag' is nil then use the last highlighting face
   used or chosen with command `hlt-choose-default-face'.
 * If non-nil then use the next highlighting face.

With a non-negative prefix arg, prompt for the face to use.
With a non-positive prefix arg, use `mouse-face' instead of `face'.

To use a prefix argument you must set either `isearch-allow-scroll' or
`isearch-allow-prefix' (if available) to non-nil.  Otherwise, a prefix
arg during Isearch exits Isearch.

\(fn &optional FACE MSGP MOUSEP BUFFERS STRING)" t nil)

(autoload 'hlt-unhighlight-isearch-matches "highlight" "\
Unhighlight matches of the current Isearch search pattern.
With no prefix arg, unhighlight all faces.
With a non-negative prefix arg, prompt for the face to unhighlight.
With a non-positive prefix arg, use `mouse-face' instead of `face'.
With any other prefix arg, unhighlight the last highlighting face used
 or chosen with command `hlt-choose-default-face'.
 (`hlt-auto-faces-flag' has no effect.)

To use a prefix argument you must set either `isearch-allow-scroll' or
`isearch-allow-prefix' (if available) to non-nil.  Otherwise, a prefix
arg during Isearch exits Isearch.

Non-interactively, FACE = nil means unhighlight all faces.

\(fn &optional FACE MSGP MOUSEP BUFFERS STRING)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight" '("hlt-" "menu-bar-edit-menu")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/nrepl-eval-sexp-fu-20140311.1041/nrepl-eval-sexp-fu-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/nrepl-eval-sexp-fu-20140311.1041/nrepl-eval-sexp-fu-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-eval-sexp-fu" '("define-n" "nesf-" "nrepl-eval-sexp-fu-" "turn-on-nrepl-eval-sexp-fu-flash-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/esxml-20171129.807/esxml-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/esxml-20171129.807/esxml-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "esxml" '("attr" "esxml-" "pp-esxml-to-xml" "string-trim-whitespace" "sxml-to-" "xml-to-esxml")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "esxml-query" '("esxml-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/nov-20180930.2042/nov-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/nov-20180930.2042/nov-autoloads.el") (car load-path))))



(autoload 'nov-mode "nov" "\
Major mode for reading EPUB documents

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nov" '("nov-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/nasm-mode-20180711.1909/nasm-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/nasm-mode-20180711.1909/nasm-mode-autoloads.el") (car load-path))))



(autoload 'nasm-mode "nasm-mode" "\
Major mode for editing NASM assembly programs.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nasm-mode" '("nasm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/multiple-cursors-20180913.1237/multiple-cursors-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/multiple-cursors-20180913.1237/multiple-cursors-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-cycle-cursors" '("mc/")))



(autoload 'mc/edit-lines "mc-edit-lines" "\
Add one cursor to each line of the active region.
Starts from mark and moves in straight down or up towards the
line point is on.

What is done with lines which are not long enough is governed by
`mc/edit-lines-empty-lines'.  The prefix argument ARG can be used
to override this.  If ARG is a symbol (when called from Lisp),
that symbol is used instead of `mc/edit-lines-empty-lines'.
Otherwise, if ARG negative, short lines will be ignored.  Any
other non-nil value will cause short lines to be padded.

\(fn &optional ARG)" t nil)

(autoload 'mc/edit-ends-of-lines "mc-edit-lines" "\
Add one cursor to the end of each line in the active region.

\(fn)" t nil)

(autoload 'mc/edit-beginnings-of-lines "mc-edit-lines" "\
Add one cursor to the beginning of each line in the active region.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-edit-lines" '("mc/edit-lines-empty-lines")))



(autoload 'mc-hide-unmatched-lines-mode "mc-hide-unmatched-lines-mode" "\
Minor mode when enabled hides all lines where no cursors (and
also hum/lines-to-expand below and above) To make use of this
mode press \"C-'\" while multiple-cursor-mode is active. You can
still edit lines while you are in mc-hide-unmatched-lines
mode. To leave this mode press <return> or \"C-g\"

If called interactively, enable Mc-Hide-Unmatched-Lines mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-hide-unmatched-lines-mode" '("hum/")))



(autoload 'mc/mark-next-like-this "mc-mark-more" "\
Find and mark the next part of the buffer matching the currently active region
If no region is active add a cursor on the next line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-like-this-word "mc-mark-more" "\
Find and mark the next part of the buffer matching the currently active region
If no region is active, mark the word at the point and find the next match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-word-like-this "mc-mark-more" "\
Find and mark the next word of the buffer matching the currently active region
The matching region must be a whole word to be a match
If no region is active, mark the symbol at the point and find the next match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-symbol-like-this "mc-mark-more" "\
Find and mark the next symbol of the buffer matching the currently active region
The matching region must be a whole symbol to be a match
If no region is active, mark the symbol at the point and find the next match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
If no region is active add a cursor on the previous line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-like-this-word "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
If no region is active, mark the word at the point and find the previous match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark previous.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-word-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
The matching region must be a whole word to be a match
If no region is active add a cursor on the previous line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-symbol-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
The matching region must be a whole symbol to be a match
If no region is active add a cursor on the previous line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-lines "mc-mark-more" "\


\(fn ARG)" t nil)

(autoload 'mc/mark-previous-lines "mc-mark-more" "\


\(fn ARG)" t nil)

(autoload 'mc/unmark-next-like-this "mc-mark-more" "\
Deselect next part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/unmark-previous-like-this "mc-mark-more" "\
Deselect prev part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/skip-to-next-like-this "mc-mark-more" "\
Skip the current one and select the next part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/skip-to-previous-like-this "mc-mark-more" "\
Skip the current one and select the prev part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/mark-all-like-this "mc-mark-more" "\
Find and mark all the parts of the buffer matching the currently active region

\(fn)" t nil)

(autoload 'mc/mark-all-words-like-this "mc-mark-more" "\


\(fn)" t nil)

(autoload 'mc/mark-all-symbols-like-this "mc-mark-more" "\


\(fn)" t nil)

(autoload 'mc/mark-all-in-region "mc-mark-more" "\
Find and mark all the parts in the region matching the given search

\(fn BEG END &optional SEARCH)" t nil)

(autoload 'mc/mark-all-in-region-regexp "mc-mark-more" "\
Find and mark all the parts in the region matching the given regexp.

\(fn BEG END)" t nil)

(autoload 'mc/mark-more-like-this-extended "mc-mark-more" "\
Like mark-more-like-this, but then lets you adjust with arrows key.
The adjustments work like this:

   <up>    Mark previous like this and set direction to 'up
   <down>  Mark next like this and set direction to 'down

If direction is 'up:

   <left>  Skip past the cursor furthest up
   <right> Remove the cursor furthest up

If direction is 'down:

   <left>  Remove the cursor furthest down
   <right> Skip past the cursor furthest down

The bindings for these commands can be changed. See `mc/mark-more-like-this-extended-keymap'.

\(fn)" t nil)

(autoload 'mc/mark-all-like-this-dwim "mc-mark-more" "\
Tries to guess what you want to mark all of.
Can be pressed multiple times to increase selection.

With prefix, it behaves the same as original `mc/mark-all-like-this'

\(fn ARG)" t nil)

(autoload 'mc/mark-all-dwim "mc-mark-more" "\
Tries even harder to guess what you want to mark all of.

If the region is active and spans multiple lines, it will behave
as if `mc/mark-all-in-region'. With the prefix ARG, it will call
`mc/edit-lines' instead.

If the region is inactive or on a single line, it will behave like
`mc/mark-all-like-this-dwim'.

\(fn ARG)" t nil)

(autoload 'mc/mark-all-like-this-in-defun "mc-mark-more" "\
Mark all like this in defun.

\(fn)" t nil)

(autoload 'mc/mark-all-words-like-this-in-defun "mc-mark-more" "\
Mark all words like this in defun.

\(fn)" t nil)

(autoload 'mc/mark-all-symbols-like-this-in-defun "mc-mark-more" "\
Mark all symbols like this in defun.

\(fn)" t nil)

(autoload 'mc/toggle-cursor-on-click "mc-mark-more" "\
Add a cursor where you click, or remove a fake cursor that is
already there.

\(fn EVENT)" t nil)

(defalias 'mc/add-cursor-on-click 'mc/toggle-cursor-on-click)

(autoload 'mc/mark-sgml-tag-pair "mc-mark-more" "\
Mark the tag we're in and its pair for renaming.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-mark-more" '("mc--" "mc/")))



(autoload 'mc/mark-pop "mc-mark-pop" "\
Add a cursor at the current point, pop off mark ring and jump
to the popped mark.

\(fn)" t nil)



(autoload 'mc/insert-numbers "mc-separate-operations" "\
Insert increasing numbers for each cursor, starting at
`mc/insert-numbers-default' or ARG.

\(fn ARG)" t nil)

(autoload 'mc/insert-letters "mc-separate-operations" "\
Insert increasing letters for each cursor, starting at 0 or ARG.
     Where letter[0]=a letter[2]=c letter[26]=aa

\(fn ARG)" t nil)

(autoload 'mc/reverse-regions "mc-separate-operations" "\


\(fn)" t nil)

(autoload 'mc/sort-regions "mc-separate-operations" "\


\(fn)" t nil)

(autoload 'mc/vertical-align "mc-separate-operations" "\
Aligns all cursors vertically with a given CHARACTER to the one with the
highest colum number (the rightest).
Might not behave as intended if more than one cursors are on the same line.

\(fn CHARACTER)" t nil)

(autoload 'mc/vertical-align-with-space "mc-separate-operations" "\
Aligns all cursors with whitespace like `mc/vertical-align' does

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-separate-operations" '("mc--" "mc/insert-numbers-default")))



(autoload 'multiple-cursors-mode "multiple-cursors-core" "\
Mode while multiple cursors are active.

If called interactively, enable Multiple-Cursors mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "multiple-cursors-core" '("activate-cursor-for-undo" "deactivate-cursor-after-undo" "multiple-cursors-mode" "unsupported-cmd")))



(autoload 'set-rectangular-region-anchor "rectangular-region-mode" "\
Anchors the rectangular region at point.

Think of this one as `set-mark' except you're marking a rectangular region. It is
an exceedingly quick way of adding multiple cursors to multiple lines.

\(fn)" t nil)

(autoload 'rectangular-region-mode "rectangular-region-mode" "\
A mode for creating a rectangular region to edit

If called interactively, enable Rectangular-Region mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rectangular-region-mode" '("rectangular-region-mode" "rrm/")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/monroe-20180703.1746/monroe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/monroe-20180703.1746/monroe-autoloads.el") (car load-path))))



(autoload 'monroe-interaction-mode "monroe" "\
Minor mode for Monroe interaction from a Clojure buffer.

If called interactively, enable Monroe-Interaction mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

The following keys are available in `monroe-interaction-mode`:

  \\{monroe-interaction-mode}

\(fn &optional ARG)" t nil)

(autoload 'monroe "monroe" "\
Load monroe by setting up appropriate mode, asking user for
connection endpoint.

\(fn HOST-AND-PORT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "monroe" '("clojure-enable-monroe" "monroe-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/modern-cpp-font-lock-20180110.2031/modern-cpp-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/modern-cpp-font-lock-20180110.2031/modern-cpp-font-lock-autoloads.el") (car load-path))))



(autoload 'modern-c++-font-lock-mode "modern-cpp-font-lock" "\
Provides font-locking as a Minor Mode for Modern C++

If called interactively, enable Modern-C++-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar modern-c++-font-lock-global-mode nil "\
Non-nil if Modern-C++-Font-Lock-Global mode is enabled.
See the `modern-c++-font-lock-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `modern-c++-font-lock-global-mode'.")

(custom-autoload 'modern-c++-font-lock-global-mode "modern-cpp-font-lock" nil)

(autoload 'modern-c++-font-lock-global-mode "modern-cpp-font-lock" "\
Toggle Modern-C++-Font-Lock mode in all buffers.
With prefix ARG, enable Modern-C++-Font-Lock-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Modern-C++-Font-Lock mode is enabled in all buffers where
`(lambda nil (when (apply 'derived-mode-p '(c++-mode)) (modern-c++-font-lock-mode 1)))' would do it.
See `modern-c++-font-lock-mode' for more information on Modern-C++-Font-Lock mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "modern-cpp-font-lock" '("modern-c++-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mmt-20180101.619/mmt-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mmt-20180101.619/mmt-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mmt" '("mmt-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/minimap-1.2/minimap-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/minimap-1.2/minimap-autoloads.el") (car load-path))))



(defvar minimap-mode nil "\
Non-nil if Minimap mode is enabled.
See the `minimap-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `minimap-mode'.")

(custom-autoload 'minimap-mode "minimap" nil)

(autoload 'minimap-mode "minimap" "\
Toggle minimap mode.

If called interactively, enable Minimap mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "minimap" '("minimap-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/minimal-session-saver-20140508.2041/minimal-session-saver-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/minimal-session-saver-20140508.2041/minimal-session-saver-autoloads.el") (car load-path))))



(autoload 'minimal-session-saver-customize-set-hooks "minimal-session-saver" "\
Set function which adds or removes hooks.

SYMBOL and VALUE are passed to `custom-set-default'.

\(fn SYMBOL VALUE)" nil nil)

(let ((loads (get 'minimal-session-saver 'custom-loads))) (if (member '"minimal-session-saver" loads) nil (put 'minimal-session-saver 'custom-loads (cons '"minimal-session-saver" loads))))

(defvar minimal-session-saver-store-on-exit nil "\
Automatically store the session data every time you quit Emacs.

This value may also be a string representing a separate data file
to be used for store-on-exit session data.")

(custom-autoload 'minimal-session-saver-store-on-exit "minimal-session-saver" nil)

(defvar minimal-session-saver-install-short-aliases nil "\
Install short aliases such as `mss-load' for `minimal-session-saver-load'.")

(custom-autoload 'minimal-session-saver-install-short-aliases "minimal-session-saver" t)

(autoload 'minimal-session-saver-install-aliases "minimal-session-saver" "\
Install aliases outside the \"minimal-session-saver-\" namespace.

With optional negative ARG, uninstall aliases.

The following aliases will be installed

   mss-store                for   minimal-session-saver-store
   mss-load                 for   minimal-session-saver-load
   mss-store-frame          for   minimal-session-saver-store-frame
   mss-load-frame           for   minimal-session-saver-load-frame
   mss-add-buffer           for   minimal-session-saver-add-buffer
   mss-remove-buffer        for   minimal-session-saver-remove-buffer
   mss-mark-stored-buffers  for   minimal-session-saver-mark-stored-buffers

\(fn &optional ARG)" nil nil)

(when minimal-session-saver-install-short-aliases (minimal-session-saver-install-aliases))

(autoload 'minimal-session-saver-store "minimal-session-saver" "\
Save the list of currently visited files to PATH.

Optional FILE-LIST overrides the list of currently visited
files.

With universal prefix argument, enter PATH interactively.

\(fn &optional PATH FILE-LIST)" t nil)

(autoload 'minimal-session-saver-store-frame "minimal-session-saver" "\
Save currently visited files associated with the current frame to PATH.

Requires frame-bufs.el.

When PATH is not supplied, prompts to enter value interactively.

\(fn &optional PATH)" t nil)

(autoload 'minimal-session-saver-load "minimal-session-saver" "\
Load the saved set of visited files from PATH.

With universal prefix argument, enter PATH interactively.

\(fn &optional PATH)" t nil)

(autoload 'minimal-session-saver-load-frame "minimal-session-saver" "\
Load the saved set of visited files from PATH into a new frame.

Requires frame-bufs.el.

When PATH is not supplied, prompts to enter value interactively.

\(fn &optional PATH)" t nil)

(autoload 'minimal-session-saver-add-buffer "minimal-session-saver" "\
Add the current buffer to the saved set of visited files in PATH.

With universal prefix argument, enter PATH interactively.

BUFFER is optional, and defaults to the currently visited buffer.
When BUFFER is not visiting a file, there is no effect.

\(fn &optional PATH BUFFER)" t nil)

(autoload 'minimal-session-saver-remove-buffer "minimal-session-saver" "\
Remove the current buffer from the saved set of visited files in PATH.

With universal prefix argument, enter PATH interactively.

BUFFER is optional, and defaults to the currently visited buffer.
When the BUFFER is not visiting a file, or is visiting a file
which was not in the list, there is no effect.

\(fn &optional PATH BUFFER)" t nil)

(autoload 'minimal-session-saver-mark-stored-buffers "minimal-session-saver" "\
Mark buff-menu entries matching the saved set of visited files in PATH.

With universal prefix argument, enter PATH interactively.

Optional CHAR defaults to `buff-menu-marker-char' or ?> if that
variable is not defined.

Optional COL is a 0-indexed position in the line at which to draw
the requested marker character.  Default is 0.

This command can only be called from within a `buff-menu' buffer.

\(fn &optional PATH CHAR COL)" t nil)

(autoload 'minimal-session-saver-kill-emacs-hook "minimal-session-saver" "\
Optionally save session data at shutdown time.

This function has not effect unless the variable
`minimal-session-saver-store-on-exit' is non-nil.

\(fn)" nil nil)

(when minimal-session-saver-store-on-exit (add-hook 'kill-emacs-hook 'minimal-session-saver-kill-emacs-hook))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "minimal-session-saver" '("minimal-session-saver-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mic-paren-20170731.1907/mic-paren-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mic-paren-20170731.1907/mic-paren-autoloads.el") (car load-path))))



(autoload 'paren-activate "mic-paren" "\
Activate mic-paren parenthesis highlighting.
Note: This also deactivates the paren.el
and stig-paren.el packages if they are active!

The following options are available via the customize-feature:
  `paren-priority'
  `paren-overlay-priority'
  `paren-sexp-mode'
  `paren-highlight-at-point'
  `paren-highlight-offscreen'
  `paren-display-message'
  `paren-message-linefeed-display'
  `paren-message-no-match'
  `paren-message-show-linenumber'
  `paren-message-truncate-lines'
  `paren-ding-unmatched'
  `paren-delay'
  `paren-dont-touch-blink'
  `paren-match-face'
  `paren-mismatch-face'
  `paren-no-match-face'
  `paren-bind-modified-sexp-functions'

The following options are settable via toggling functions (look at the
documentation of these options for the names of these functions):
  `paren-match-quoted-paren'
  `paren-match-paired-delimiter'
  `paren-open-paren-context-backward'

\(fn)" t nil)

(autoload 'paren-deactivate "mic-paren" "\
Deactivate mic-paren parenthesis highlighting.

\(fn)" t nil)

(autoload 'paren-toggle-matching-paired-delimiter "mic-paren" "\
Toggle matching paired delimiter.
Force on with positive ARG.  Use this in mode hooks to activate or
deactivate paired delimiter matching.  If optional second argument
NO-MESSAGE is non-nil then don't display a message about the
current activation state of the paired-delimiter-matching feature.

\(fn ARG &optional NO-MESSAGE)" t nil)

(autoload 'paren-toggle-matching-quoted-paren "mic-paren" "\
Toggle matching quoted parens.
Force on with positive ARG.  Use this in mode hooks to activate or
deactivate quoted paren matching.  If optional second argument
NO-MESSAGE is non-nil then don't display a message about the
current activation state of the quoted-paren-matching feature.

\(fn ARG &optional NO-MESSAGE)" t nil)

(autoload 'paren-toggle-open-paren-context "mic-paren" "\
Toggle whether or not to determine context of the matching open-paren.
Force backward context with positive ARG.  Use this in mode-hooks.
See `paren-open-paren-context-backward'.

\(fn ARG)" t nil)

(autoload 'paren-forward-sexp "mic-paren" "\
Act like `forward-sexp' but also handle quoted parens.
See `paren-match-quoted-paren'.

\(fn &optional ARG)" t nil)

(autoload 'paren-backward-sexp "mic-paren" "\
Act like `backward-sexp' but also match quoted parens.
See `paren-match-quoted-paren'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mic-paren" '("mic-paren-" "paren-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mc-extras-20180520.439/mc-extras-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mc-extras-20180520.439/mc-extras-autoloads.el") (car load-path))))



(autoload 'mc/cua-rectangle-to-multiple-cursors "mc-cua" "\
Turn CUA rectangle mode into multiple-cursors mode, keeping insert positions and selections.

\(fn)" t nil)

(autoload 'mc/cua-rectangle-setup "mc-cua" "\
Enable interaction between multiple cursors and CUA rectangle copy & paste.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-cua" '("mc/cua-saved-kill-ring")))



(autoload 'mc/freeze-fake-cursors "mc-freeze" "\
Freeze fake cursors for later reactivation.

With ARG or when there is no fake cursor, create a fake cursor at
point before freezing fake cursors.

\(fn &optional ARG)" t nil)

(autoload 'mc/unfreeze-fake-cursors "mc-freeze" "\
Unfreeze frozen fake cursors.

\(fn)" t nil)

(autoload 'mc/freeze-fake-cursors-dwim "mc-freeze" "\
Freeze or unfreeze fake cursors depending on the current state.

With ARG, always create a fake cursor at point then freeze fake
cursors.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-freeze" '("mc-freeze--")))



(autoload 'mc/mark-next-sexps "mc-mark-extras" "\
Mark next ARG sexps.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-sexps "mc-mark-extras" "\
Mark previous ARG sexps.

\(fn ARG)" t nil)

(autoload 'mc/mark-all-below "mc-mark-extras" "\
Mark lines below until the cursor hits a line shorter than the current column position.

\(fn)" t nil)

(autoload 'mc/mark-all-above "mc-mark-extras" "\
Mark lines above until the cursor hits a line shorter than the current column position.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-mark-extras" '("mc/mark-sexps")))



(autoload 'mc/move-to-column "mc-move" "\
Move every cursor to column COLUMN.
If COLUMN is omitted, move every fake cursor to the same column as the real cursor.

\(fn COLUMN)" t nil)

(autoload 'mc/compare-chars "mc-move" "\
Compare the character at point with that at each fake cursor, and move forward as far as they all match.
With an optional argument, move backwards by calling `mc/compare-chars-backward'.
This command pushes the mark before moving cursors.

\(fn &optional ARG)" t nil)

(autoload 'mc/compare-chars-forward "mc-move" "\
Compare the character at point with that at each fake cursor, and move forward as far as they all match.
This command pushes the mark before moving cursors.

\(fn)" t nil)

(autoload 'mc/compare-chars-backward "mc-move" "\
Backwards version of `mc/compare-chars-forward'.

\(fn)" t nil)



(autoload 'mc/rect-rectangle-to-multiple-cursors "mc-rect" "\
Turn rectangle-mark-mode into multiple-cursors mode, keeping selections.

\(fn START END)" t nil)



(autoload 'mc/remove-current-cursor "mc-remove" "\
Remove the current cursor by replacing the next fake cursor with the real cursor.

\(fn)" t nil)

(autoload 'mc/remove-duplicated-cursors "mc-remove" "\
Remove duplicated fake cursors, including ones that overlap the real cursor.

\(fn)" t nil)

(autoload 'mc/remove-cursors-at-eol "mc-remove" "\
Remove cursors at EOL, either fake or real.

\(fn)" t nil)

(autoload 'mc/remove-cursors-on-blank-lines "mc-remove" "\
Remove cursors on blank lines, either fake or real.

\(fn)" t nil)




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/maxframe-20170120.1705/maxframe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/maxframe-20170120.1705/maxframe-autoloads.el") (car load-path))))



(autoload 'w32-maximize-frame "maxframe" "\
Maximize the current frame (windows only)

\(fn)" t nil)

(autoload 'w32-restore-frame "maxframe" "\
Restore a minimized/maximized frame (windows only)

\(fn)" t nil)

(autoload 'x-maximize-frame "maxframe" "\
Maximize the current frame (x or mac only)

\(fn &optional THE-FRAME)" t nil)

(autoload 'x-restore-frame "maxframe" "\
Restore the current frame (x or mac only)

\(fn &optional THE-FRAME)" t nil)

(autoload 'maximize-frame "maxframe" "\
Maximizes the frame to fit the display if under a windowing
system.

\(fn &optional THE-FRAME)" t nil)

(autoload 'restore-frame "maxframe" "\
Restores a maximized frame.  See `maximize-frame'.

\(fn &optional THE-FRAME)" t nil)

(defalias 'mf 'maximize-frame)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "maxframe" '("mf-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-core-20180826.515/helm-core-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-core-20180826.515/helm-core-autoloads.el") (car load-path))))



(autoload 'helm-define-multi-key "helm" "\
In KEYMAP, define key sequence KEY for function list FUNCTIONS.
Each function runs sequentially for each KEY press.
If DELAY is specified, switch back to initial function of FUNCTIONS list
after DELAY seconds.
The functions in FUNCTIONS list take no args.
e.g
    (defun foo ()
      (interactive)
      (message \"Run foo\"))
    (defun bar ()
      (interactive)
      (message \"Run bar\"))
    (defun baz ()
      (interactive)
      (message \"Run baz\"))

\(helm-define-multi-key global-map (kbd \"<f5> q\") '(foo bar baz) 2)

Each time \"<f5> q\" is pressed, the next function is executed. Waiting
more than 2 seconds between key presses switches back to executing the first
function on the next hit.

\(fn KEYMAP KEY FUNCTIONS &optional DELAY)" nil nil)

(autoload 'helm-multi-key-defun "helm" "\
Define NAME as a multi-key command running FUNS.
After DELAY seconds, the FUNS list is reinitialized.
See `helm-define-multi-key'.

\(fn NAME DOCSTRING FUNS &optional DELAY)" nil t)

(function-put 'helm-multi-key-defun 'lisp-indent-function '2)

(autoload 'helm-define-key-with-subkeys "helm" "\
Defines in MAP a KEY and SUBKEY to COMMAND.

This allows typing KEY to call COMMAND the first time and
type only SUBKEY on subsequent calls.

Arg MAP is the keymap to use, SUBKEY is the initial short key-binding to
call COMMAND.

Arg OTHER-SUBKEYS is an alist specifying other short key-bindings
to use once started e.g:

    (helm-define-key-with-subkeys global-map
       (kbd \"C-x v n\") ?n 'git-gutter:next-hunk '((?p . git-gutter:previous-hunk)))


In this example, `C-x v n' will run `git-gutter:next-hunk'
subsequent \"n\"'s run this command again
and subsequent \"p\"'s run `git-gutter:previous-hunk'.

If specified PROMPT can be displayed in minibuffer to
describe SUBKEY and OTHER-SUBKEYS.
Arg EXIT-FN specifies a function to run on exit.

For any other keys pressed, run their assigned command as defined
in MAP and then exit the loop running EXIT-FN, if specified.

NOTE: SUBKEY and OTHER-SUBKEYS bindings support only char syntax and
vectors, so don't use strings to define them.

\(fn MAP KEY SUBKEY COMMAND &optional OTHER-SUBKEYS PROMPT EXIT-FN)" nil nil)

(function-put 'helm-define-key-with-subkeys 'lisp-indent-function '1)

(autoload 'helm-debug-open-last-log "helm" "\
Open helm log file or buffer of last helm session.

\(fn)" t nil)

(autoload 'helm "helm" "\
Main function to execute helm sources.

PLIST is a list like

\(:key1 val1 :key2 val2 ...)

 or

\(&optional sources input prompt resume preselect
            buffer keymap default history allow-nest).

** Keywords

Keywords supported:

- :sources
- :input
- :prompt
- :resume
- :preselect
- :buffer
- :keymap
- :default
- :history
- :allow-nest

Extra LOCAL-VARS keywords are supported, see the \"** Other
keywords\" section below.

Basic keywords are the following:

*** :sources

One of the following:

- List of sources
- Symbol whose value is a list of sources
- Alist representing a Helm source.
  - In this case the source has no name and is referenced in
    `helm-sources' as a whole alist.

*** :input

Initial input of minibuffer (temporary value of `helm-pattern')

*** :prompt

Minibuffer prompt. Default value is `helm--prompt'.

*** :resume

If t, allow resumption of the previous session of this Helm
command, skipping initialization.

If 'noresume, this instance of `helm' cannot be resumed.

*** :preselect

Initially selected candidate (string or regexp).

*** :buffer

Buffer name for this Helm session. `helm-buffer' will take this value.

*** :keymap

\[Obsolete]

Keymap used at the start of this Helm session.

It is overridden by keymaps specified in sources, and is kept
only for backward compatibility.

Keymaps should be specified in sources using the :keymap slot
instead. See `helm-source'.

This keymap is not restored by `helm-resume'.

*** :default

Default value inserted into the minibuffer with
\\<minibuffer-local-map>\\[next-history-element].

It can be a string or a list of strings, in this case
\\<minibuffer-local-map>\\[next-history-element] cycles through
the list items, starting with the first.

If nil, `thing-at-point' is used.

If `helm--maybe-use-default-as-input' is non-`nil', display is
updated using this value, unless :input is specified, in which
case that value is used instead.

*** :history

Minibuffer input, by default, is pushed to `minibuffer-history'.

When an argument HISTORY is provided, input is pushed to
HISTORY. HISTORY should be a valid symbol.

*** :allow-nest

Allow running this Helm command in a running Helm session.

** Other keywords

Other keywords are interpreted as local variables of this Helm
session. The `helm-' prefix can be omitted. For example,

\(helm :sources 'helm-source-buffers-list
       :buffer \"*helm buffers*\"
       :candidate-number-limit 10)

starts a Helm session with the variable
`helm-candidate-number-limit' set to 10.

** Backward compatibility

For backward compatibility, positional parameters are
supported:

\(helm sources input prompt resume preselect
       buffer keymap default history allow-nest)

However, the use of non-keyword args is deprecated.

\(fn &key SOURCES INPUT PROMPT RESUME PRESELECT BUFFER KEYMAP DEFAULT HISTORY ALLOW-NEST OTHER-LOCAL-VARS)" nil nil)

(autoload 'helm-cycle-resume "helm" "\
Cycle in `helm-buffers' list and resume when waiting more than 1.2s.

\(fn)" t nil)

(autoload 'helm-other-buffer "helm" "\
Simplified `helm' interface with other `helm-buffer'.
Call `helm' only with ANY-SOURCES and ANY-BUFFER as args.

\(fn ANY-SOURCES ANY-BUFFER)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm" '("helm-" "with-helm-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-lib" '("helm-" "with-helm-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-multi-match" '("helm-m")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-source" '("helm-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-20181005.1844/helm-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-20181005.1844/helm-autoloads.el") (car load-path))))



(defvar helm-adaptive-mode nil "\
Non-nil if Helm-Adaptive mode is enabled.
See the `helm-adaptive-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-adaptive-mode'.")

(custom-autoload 'helm-adaptive-mode "helm-adaptive" nil)

(autoload 'helm-adaptive-mode "helm-adaptive" "\
Toggle adaptive sorting in all sources.

If called interactively, enable Helm-Adaptive mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'helm-reset-adaptive-history "helm-adaptive" "\
Delete all `helm-adaptive-history' and his file.
Useful when you have a old or corrupted `helm-adaptive-history-file'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-adaptive" '("helm-adapt")))



(autoload 'helm-bookmarks "helm-bookmark" "\
Preconfigured `helm' for bookmarks.

\(fn)" t nil)

(autoload 'helm-filtered-bookmarks "helm-bookmark" "\
Preconfigured helm for bookmarks (filtered by category).
Optional source `helm-source-bookmark-addressbook' is loaded
only if external addressbook-bookmark package is installed.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-bookmark" '("bmkext-jump-" "bookmark" "helm-")))



(autoload 'helm-buffers-list "helm-buffers" "\
Preconfigured `helm' to list buffers.

\(fn)" t nil)

(autoload 'helm-mini "helm-buffers" "\
Preconfigured `helm' lightweight version (buffer -> recentf).

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-buffers" '("helm-")))



(autoload 'helm-colors "helm-color" "\
Preconfigured `helm' for color.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-color" '("helm-")))



(autoload 'helm-M-x "helm-command" "\
Preconfigured `helm' for Emacs commands.
It is `helm' replacement of regular `M-x' `execute-extended-command'.

Unlike regular `M-x' emacs vanilla `execute-extended-command' command,
the prefix args if needed, can be passed AFTER starting `helm-M-x'.
When a prefix arg is passed BEFORE starting `helm-M-x', the first `C-u'
while in `helm-M-x' session will disable it.

You can get help on each command by persistent action.

\(fn ARG &optional COMMAND-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-command" '("helm-")))



(autoload 'helm-configuration "helm-config" "\
Customize `helm'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-config" '("helm-")))



(autoload 'helm-dabbrev "helm-dabbrev" "\
Preconfigured helm for dynamic abbreviations.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-dabbrev" '("helm-dabbrev-")))



(autoload 'helm-lisp-completion-at-point "helm-elisp" "\
Preconfigured helm for lisp symbol completion at point.

\(fn)" t nil)

(autoload 'helm-complete-file-name-at-point "helm-elisp" "\
Preconfigured helm to complete file name at point.

\(fn &optional FORCE)" t nil)

(autoload 'helm-lisp-indent "helm-elisp" "\


\(fn)" t nil)

(autoload 'helm-lisp-completion-or-file-name-at-point "helm-elisp" "\
Preconfigured helm to complete lisp symbol or filename at point.
Filename completion happen if string start after or between a double quote.

\(fn)" t nil)

(autoload 'helm-apropos "helm-elisp" "\
Preconfigured helm to describe commands, functions, variables and faces.
In non interactives calls DEFAULT argument should be provided as a string,
i.e the `symbol-name' of any existing symbol.

\(fn DEFAULT)" t nil)

(autoload 'helm-manage-advice "helm-elisp" "\
Preconfigured `helm' to disable/enable function advices.

\(fn)" t nil)

(autoload 'helm-locate-library "helm-elisp" "\
Preconfigured helm to locate elisp libraries.

\(fn)" t nil)

(autoload 'helm-timers "helm-elisp" "\
Preconfigured `helm' for timers.

\(fn)" t nil)

(autoload 'helm-complex-command-history "helm-elisp" "\
Preconfigured helm for complex command history.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-elisp" '("helm-" "with-helm-show-completion")))



(autoload 'helm-list-elisp-packages "helm-elisp-package" "\
Preconfigured helm for listing and handling emacs packages.

\(fn ARG)" t nil)

(autoload 'helm-list-elisp-packages-no-fetch "helm-elisp-package" "\
Preconfigured helm for emacs packages.

Same as `helm-list-elisp-packages' but don't fetch packages on remote.
Called with a prefix ARG always fetch packages on remote.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-elisp-package" '("helm-")))



(autoload 'helm-esh-pcomplete "helm-eshell" "\
Preconfigured helm to provide helm completion in eshell.

\(fn)" t nil)

(autoload 'helm-eshell-history "helm-eshell" "\
Preconfigured helm for eshell history.

\(fn)" t nil)

(autoload 'helm-eshell-prompts "helm-eshell" "\
Pre-configured `helm' to browse the prompts of the current Eshell.

\(fn)" t nil)

(autoload 'helm-eshell-prompts-all "helm-eshell" "\
Pre-configured `helm' to browse the prompts of all Eshell sessions.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-eshell" '("helm-e")))



(autoload 'helm-eval-expression "helm-eval" "\
Preconfigured helm for `helm-source-evaluation-result'.

\(fn ARG)" t nil)

(autoload 'helm-eval-expression-with-eldoc "helm-eval" "\
Preconfigured helm for `helm-source-evaluation-result' with `eldoc' support. 

\(fn)" t nil)

(autoload 'helm-calcul-expression "helm-eval" "\
Preconfigured helm for `helm-source-calculation-result'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-eval" '("helm-")))



(autoload 'helm-run-external-command "helm-external" "\
Preconfigured `helm' to run External PROGRAM asyncronously from Emacs.
If program is already running exit with error.
You can set your own list of commands with
`helm-external-commands-list'.

\(fn PROGRAM)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-external" '("helm-")))



(autoload 'helm-projects-history "helm-files" "\


\(fn)" t nil)

(autoload 'helm-browse-project "helm-files" "\
Preconfigured helm to browse projects.
Browse files and see status of project with its vcs.
Only HG and GIT are supported for now.
Fall back to `helm-browse-project-find-files'
if current directory is not under control of one of those vcs.
With a prefix ARG browse files recursively, with two prefix ARG
rebuild the cache.
If the current directory is found in the cache, start
`helm-browse-project-find-files' even with no prefix ARG.
NOTE: The prefix ARG have no effect on the VCS controlled directories.

Needed dependencies for VCS:
<https://github.com/emacs-helm/helm-ls-git>
and
<https://github.com/emacs-helm/helm-ls-hg>.

\(fn ARG)" t nil)

(autoload 'helm-find-files "helm-files" "\
Preconfigured `helm' for helm implementation of `find-file'.
Called with a prefix arg show history if some.
Don't call it from programs, use `helm-find-files-1' instead.
This is the starting point for nearly all actions you can do on files.

\(fn ARG)" t nil)

(autoload 'helm-delete-tramp-connection "helm-files" "\
Allow deleting tramp connection or marked tramp connections at once.

This replace `tramp-cleanup-connection' which is partially broken in
emacs < to 25.1.50.1 (See Emacs Bug#24432).

It allows additionally to delete more than one connection at once.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-files" '("eshell-command-aliases-list" "helm-")))



(autoload 'helm-find "helm-find" "\
Preconfigured `helm' for the find shell command.

Recursively find files whose names are matched by all specified
globbing PATTERNs under the current directory using the external
program specified in `find-program' (usually \"find\").  Every
input PATTERN is silently wrapped into two stars: *PATTERN*.

With prefix argument, prompt for a directory to search.

When user option `helm-findutils-search-full-path' is non-nil,
match against complete paths, otherwise, against file names
without directory part.

The (possibly empty) list of globbing PATTERNs can be followed by
the separator \"*\" plus any number of additional arguments that
are passed to \"find\" literally.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-find" '("helm-")))



(autoload 'helm-select-xfont "helm-font" "\
Preconfigured `helm' to select Xfont.

\(fn)" t nil)

(autoload 'helm-ucs "helm-font" "\
Preconfigured helm for `ucs-names'.

Called with a prefix arg force reloading cache.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-font" '("helm-")))



(autoload 'helm-for-files "helm-for-files" "\
Preconfigured `helm' for opening files.
Run all sources defined in `helm-for-files-preferred-list'.

\(fn)" t nil)

(autoload 'helm-multi-files "helm-for-files" "\
Preconfigured helm like `helm-for-files' but running locate only on demand.

Allow toggling back and forth from locate to others sources with
`helm-multi-files-toggle-locate-binding' key.
This avoid launching needlessly locate when what you search is already
found.

\(fn)" t nil)

(autoload 'helm-recentf "helm-for-files" "\
Preconfigured `helm' for `recentf'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-for-files" '("helm-")))



(autoload 'helm-goto-precedent-file "helm-grep" "\
Go to precedent file in helm grep/etags buffers.

\(fn)" t nil)

(autoload 'helm-goto-next-file "helm-grep" "\
Go to precedent file in helm grep/etags buffers.

\(fn)" t nil)

(autoload 'helm-do-grep-ag "helm-grep" "\
Preconfigured helm for grepping with AG in `default-directory'.
With prefix-arg prompt for type if available with your AG version.

\(fn ARG)" t nil)

(autoload 'helm-grep-do-git-grep "helm-grep" "\
Preconfigured helm for git-grepping `default-directory'.
With a prefix arg ARG git-grep the whole repository.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-grep" '("helm-")))



(autoload 'helm-documentation "helm-help" "\
Preconfigured Helm for Helm documentation.
With a prefix arg refresh the documentation.

Find here the documentation of all documented sources.

\(fn)" t nil)

(defvar helm-comp-read-mode-line "\\<helm-comp-read-map>C/\\[helm-cr-empty-string]:Empty \\<helm-map>\\[helm-help]:Help \\[helm-select-action]:Act \\[helm-maybe-exit-minibuffer]/f1/f2/f-n:NthAct \\[helm-toggle-suspend-update]:Tog.suspend")

(defvar helm-read-file-name-mode-line-string "\\<helm-read-file-map>\\[helm-help]:Help C/\\[helm-cr-empty-string]:Empty \\<helm-map>\\[helm-select-action]:Act \\[helm-maybe-exit-minibuffer]/f1/f2/f-n:NthAct \\[helm-toggle-suspend-update]:Tog.suspend" "\
String displayed in mode-line in `helm-source-find-files'.")

(defvar helm-top-mode-line "\\<helm-top-map>\\[helm-help]:Help \\<helm-map>\\[helm-select-action]:Act \\[helm-maybe-exit-minibuffer]/f1/f2/f-n:NthAct \\[helm-toggle-suspend-update]:Tog.suspend")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-help" '("helm-")))



(autoload 'helm-gid "helm-id-utils" "\
Preconfigured helm for `gid' command line of `ID-Utils'.
Need A database created with the command `mkid'
above `default-directory'.
Need id-utils as dependency which provide `mkid', `gid' etc...
See <https://www.gnu.org/software/idutils/>.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-id-utils" '("helm-gid-")))



(autoload 'helm-imenu "helm-imenu" "\
Preconfigured `helm' for `imenu'.

\(fn)" t nil)

(autoload 'helm-imenu-in-all-buffers "helm-imenu" "\
Preconfigured helm for fetching imenu entries in all buffers with similar mode as current.
A mode is similar as current if it is the same, it is derived i.e `derived-mode-p'
or it have an association in `helm-imenu-all-buffer-assoc'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-imenu" '("helm-")))



(autoload 'helm-info "helm-info" "\
Preconfigured `helm' for searching Info files' indices.

With a prefix argument \\[universal-argument], set REFRESH to non-nil.

Optional parameter REFRESH, when non-nil, reevaluates
`helm-default-info-index-list'.  If the variable has been
customized, set it to its saved value.  If not, set it to its
standard value.  See `custom-reevaluate-setting' for more.

REFRESH is useful when new Info files are installed.  If
`helm-default-info-index-list' has not been customized, the new
Info files are made available.

\(fn &optional REFRESH)" t nil)

(autoload 'helm-info-at-point "helm-info" "\
Preconfigured `helm' for searching info at point.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-info" '("helm-")))



(autoload 'helm-projects-find-files "helm-locate" "\
Find files with locate in `helm-locate-project-list'.
With a prefix arg refresh the database in each project.

\(fn UPDATE)" t nil)

(autoload 'helm-locate "helm-locate" "\
Preconfigured `helm' for Locate.
Note: you can add locate options after entering pattern.
See 'man locate' for valid options and also `helm-locate-command'.

You can specify a local database with prefix argument ARG.
With two prefix arg, refresh the current local db or create it
if it doesn't exists.

To create a user specific db, use
\"updatedb -l 0 -o db_path -U directory\".
Where db_path is a filename matched by
`helm-locate-db-file-regexp'.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-locate" '("helm-")))



(autoload 'helm-man-woman "helm-man" "\
Preconfigured `helm' for Man and Woman pages.
With a prefix arg reinitialize the cache.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-man" '("helm-")))



(autoload 'helm-world-time "helm-misc" "\
Preconfigured `helm' to show world time.
Default action change TZ environment variable locally to emacs.

\(fn)" t nil)

(autoload 'helm-insert-latex-math "helm-misc" "\
Preconfigured helm for latex math symbols completion.

\(fn)" t nil)

(autoload 'helm-ratpoison-commands "helm-misc" "\
Preconfigured `helm' to execute ratpoison commands.

\(fn)" t nil)

(autoload 'helm-stumpwm-commands "helm-misc" "\
Preconfigured helm for stumpwm commands.

\(fn)" t nil)

(autoload 'helm-minibuffer-history "helm-misc" "\
Preconfigured `helm' for `minibuffer-history'.

\(fn)" t nil)

(autoload 'helm-comint-input-ring "helm-misc" "\
Preconfigured `helm' that provide completion of `comint' history.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-misc" '("helm-")))



(autoload 'helm-comp-read "helm-mode" "\
Read a string in the minibuffer, with helm completion.

It is helm `completing-read' equivalent.

- PROMPT is the prompt name to use.

- COLLECTION can be a list, vector, obarray or hash-table.
  It can be also a function that receives three arguments:
  the values string, predicate and t. See `all-completions' for more details.

Keys description:

- TEST: A predicate called with one arg i.e candidate.

- INITIAL-INPUT: Same as input arg in `helm'.

- PRESELECT: See preselect arg of `helm'.

- DEFAULT: This option is used only for compatibility with regular
  Emacs `completing-read' (Same as DEFAULT arg of `completing-read').

- BUFFER: Name of helm-buffer.

- MUST-MATCH: Candidate selected must be one of COLLECTION.

- FUZZY: Enable fuzzy matching.

- REVERSE-HISTORY: When non--nil display history source after current
  source completion.

- REQUIRES-PATTERN: Same as helm attribute, default is 0.

- HISTORY: A list containing specific history, default is nil.
  When it is non--nil, all elements of HISTORY are displayed in
  a special source before COLLECTION.

- INPUT-HISTORY: A symbol. the minibuffer input history will be
  stored there, if nil or not provided, `minibuffer-history'
  will be used instead.

- CASE-FOLD: Same as `helm-case-fold-search'.

- DEL-INPUT: Boolean, when non--nil (default) remove the partial
  minibuffer input from HISTORY is present.

- PERSISTENT-ACTION: A function called with one arg i.e candidate.

- PERSISTENT-HELP: A string to document PERSISTENT-ACTION.

- MODE-LINE: A string or list to display in mode line.
  Default is `helm-comp-read-mode-line'.

- KEYMAP: A keymap to use in this `helm-comp-read'.
  (the keymap will be shared with history source)

- NAME: The name related to this local source.

- HEADER-NAME: A function to alter NAME, see `helm'.

- EXEC-WHEN-ONLY-ONE: Bound `helm-execute-action-at-once-if-one'
  to non--nil. (possibles values are t or nil).

- VOLATILE: Use volatile attribute.

- SORT: A predicate to give to `sort' e.g `string-lessp'
  Use this only on small data as it is ineficient.
  If you want to sort faster add a sort function to
  FC-TRANSFORMER.
  Note that FUZZY when enabled is already providing a sort function.

- FC-TRANSFORMER: A `filtered-candidate-transformer' function
  or a list of functions.

- HIST-FC-TRANSFORMER: A `filtered-candidate-transformer'
  function for the history source.

- MARKED-CANDIDATES: If non--nil return candidate or marked candidates as a list.

- NOMARK: When non--nil don't allow marking candidates.

- ALISTP: (default is non--nil) See `helm-comp-read-get-candidates'.

- CANDIDATES-IN-BUFFER: when non--nil use a source build with
  `helm-source-in-buffer' which is much faster.
  Argument VOLATILE have no effect when CANDIDATES-IN-BUFFER is non--nil.

- MATCH-PART: Allow matching only one part of candidate.
  See match-part documentation in `helm-source'.

- ALLOW-NEST: Allow nesting this `helm-comp-read' in a helm session.
  See `helm'.

- MULTILINE: See multiline in `helm-source'.

Any prefix args passed during `helm-comp-read' invocation will be recorded
in `helm-current-prefix-arg', otherwise if prefix args were given before
`helm-comp-read' invocation, the value of `current-prefix-arg' will be used.
That's mean you can pass prefix args before or after calling a command
that use `helm-comp-read' See `helm-M-x' for example.

\(fn PROMPT COLLECTION &key TEST INITIAL-INPUT DEFAULT PRESELECT (BUFFER \"*Helm Completions*\") MUST-MATCH FUZZY REVERSE-HISTORY (REQUIRES-PATTERN 0) HISTORY INPUT-HISTORY (CASE-FOLD helm-comp-read-case-fold-search) (DEL-INPUT t) (PERSISTENT-ACTION nil) (PERSISTENT-HELP \"DoNothing\") (MODE-LINE helm-comp-read-mode-line) HELP-MESSAGE (KEYMAP helm-comp-read-map) (NAME \"Helm Completions\") HEADER-NAME CANDIDATES-IN-BUFFER MATCH-PART EXEC-WHEN-ONLY-ONE QUIT-WHEN-NO-CAND (VOLATILE t) SORT FC-TRANSFORMER HIST-FC-TRANSFORMER MARKED-CANDIDATES NOMARK (ALISTP t) (CANDIDATE-NUMBER-LIMIT helm-candidate-number-limit) MULTILINE ALLOW-NEST)" nil nil)

(autoload 'helm-read-file-name "helm-mode" "\
Read a file name with helm completion.
It is helm `read-file-name' emulation.

Argument PROMPT is the default prompt to use.

Keys description:

- NAME: Source name, default to \"Read File Name\".

- INITIAL-INPUT: Where to start read file name, default to `default-directory'.

- BUFFER: `helm-buffer' name default to \"*Helm Completions*\".

- TEST: A predicate called with one arg 'candidate'.

- CASE-FOLD: Same as `helm-case-fold-search'.

- PRESELECT: helm preselection.

- HISTORY: Display HISTORY in a special source.

- MUST-MATCH: Can be 'confirm, nil, or t.

- FUZZY: Enable fuzzy matching when non-nil (Enabled by default).

- MARKED-CANDIDATES: When non--nil return a list of marked candidates.

- NOMARK: When non--nil don't allow marking candidates.

- ALISTP: Don't use `all-completions' in history (take effect only on history).

- PERSISTENT-ACTION-IF: a persistent if action function.

- PERSISTENT-HELP: persistent help message.

- MODE-LINE: A mode line message, default is `helm-read-file-name-mode-line-string'.

\(fn PROMPT &key (NAME \"Read File Name\") (INITIAL-INPUT default-directory) (BUFFER \"*Helm file completions*\") TEST (CASE-FOLD helm-file-name-case-fold-search) PRESELECT HISTORY MUST-MATCH (FUZZY t) DEFAULT MARKED-CANDIDATES (CANDIDATE-NUMBER-LIMIT helm-ff-candidate-number-limit) NOMARK (ALISTP t) (PERSISTENT-ACTION-IF \\='helm-find-files-persistent-action-if) (PERSISTENT-HELP \"Hit1 Expand Candidate, Hit2 or (C-u) Find file\") (MODE-LINE helm-read-file-name-mode-line-string))" nil nil)

(defvar helm-mode nil "\
Non-nil if Helm mode is enabled.
See the `helm-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-mode'.")

(custom-autoload 'helm-mode "helm-mode" nil)

(autoload 'helm-mode "helm-mode" "\
Toggle generic helm completion.

All functions in Emacs that use `completing-read'
or `read-file-name' and friends will use helm interface
when this mode is turned on.

However you can modify this behavior for functions of your choice
with `helm-completing-read-handlers-alist'.

Also commands using `completion-in-region' will be helmized when
`helm-mode-handle-completion-in-region' is non nil, you can modify
this behavior with `helm-mode-no-completion-in-region-in-modes'.

Called with a positive arg, turn on unconditionally, with a
negative arg turn off.
You can turn it on with `helm-mode'.

Some crap emacs functions may not be supported,
e.g `ffap-alternate-file' and maybe others
You can add such functions to `helm-completing-read-handlers-alist'
with a nil value.

About `ido-mode':
When you are using `helm-mode', DO NOT use `ido-mode', instead if you
want some commands use `ido', add these commands to
`helm-completing-read-handlers-alist' with `ido' as value.

Note: This mode is incompatible with Emacs23.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-mode" '("helm-")))



(autoload 'helm-browse-url-firefox "helm-net" "\
Same as `browse-url-firefox' but detach from emacs.

So when you quit emacs you can keep your firefox session open
and not be prompted to kill firefox process.

NOTE: Probably not supported on some systems (e.g Windows).

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-opera "helm-net" "\
Browse URL with opera browser and detach from emacs.

So when you quit emacs you can keep your opera session open
and not be prompted to kill opera process.

NOTE: Probably not supported on some systems (e.g Windows).

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-chromium "helm-net" "\
Browse URL with google chrome browser.

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-uzbl "helm-net" "\
Browse URL with uzbl browser.

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-conkeror "helm-net" "\
Browse URL with conkeror browser.

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-surfraw "helm-net" "\
Preconfigured `helm' to search PATTERN with search ENGINE.

\(fn PATTERN ENGINE)" t nil)

(autoload 'helm-google-suggest "helm-net" "\
Preconfigured `helm' for google search with google suggest.

\(fn)" t nil)

(autoload 'helm-wikipedia-suggest "helm-net" "\
Preconfigured `helm' for Wikipedia lookup with Wikipedia suggest.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-net" '("helm-")))



(autoload 'helm-org-agenda-files-headings "helm-org" "\
Preconfigured helm for org files headings.

\(fn)" t nil)

(autoload 'helm-org-in-buffer-headings "helm-org" "\
Preconfigured helm for org buffer headings.

\(fn)" t nil)

(autoload 'helm-org-parent-headings "helm-org" "\
Preconfigured helm for org headings that are parents of the
current heading.

\(fn)" t nil)

(autoload 'helm-org-capture-templates "helm-org" "\
Preconfigured helm for org templates.

\(fn)" t nil)

(autoload 'helm-org-completing-read-tags "helm-org" "\
Completing read function for Org tags.

This function is used as a `completing-read' function in
`helm-completing-read-handlers-alist' by `org-set-tags' and
`org-capture'.

NOTE: Org tag completion will work only if you disable org fast tag
selection, see (info \"(org) setting tags\").

\(fn PROMPT COLLECTION PRED REQ INITIAL HIST DEF INHERIT-INPUT-METHOD NAME BUFFER)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-org" '("helm-")))



(autoload 'helm-moccur-mode "helm-regexp" "\
Major mode to provide actions in helm moccur saved buffer.

Special commands:
\\{helm-moccur-mode-map}

\(fn)" t nil)

(autoload 'helm-regexp "helm-regexp" "\
Preconfigured helm to build regexps.
`query-replace-regexp' can be run from there against found regexp.

\(fn)" t nil)

(autoload 'helm-occur "helm-regexp" "\
Preconfigured helm for searching lines matching pattern in `current-buffer'.

When `helm-source-occur' is member of
`helm-sources-using-default-as-input' which is the default,
symbol at point is searched at startup.

When a region is marked search only in this region by narrowing.

To search in multiples buffers start from one of the commands listing
buffers (i.e. a helm command using `helm-source-buffers-list' like
`helm-mini') and use the multi occur buffers action.

This is the helm implementation that collect lines matching pattern
like vanilla emacs `occur' but have nothing to do with it, the search
engine beeing completely different.

\(fn)" t nil)

(autoload 'helm-occur-from-isearch "helm-regexp" "\
Invoke `helm-occur' from isearch.

\(fn)" t nil)

(autoload 'helm-multi-occur-from-isearch "helm-regexp" "\
Invoke `helm-multi-occur' from isearch.

With a prefix arg, reverse the behavior of
`helm-moccur-always-search-in-current'.
The prefix arg can be set before calling
`helm-multi-occur-from-isearch' or during the buffer selection.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-regexp" '("helm-")))



(autoload 'helm-mark-ring "helm-ring" "\
Preconfigured `helm' for `helm-source-mark-ring'.

\(fn)" t nil)

(autoload 'helm-global-mark-ring "helm-ring" "\
Preconfigured `helm' for `helm-source-global-mark-ring'.

\(fn)" t nil)

(autoload 'helm-all-mark-rings "helm-ring" "\
Preconfigured `helm' for `helm-source-global-mark-ring' and `helm-source-mark-ring'.

\(fn)" t nil)

(autoload 'helm-register "helm-ring" "\
Preconfigured `helm' for Emacs registers.

\(fn)" t nil)

(autoload 'helm-show-kill-ring "helm-ring" "\
Preconfigured `helm' for `kill-ring'.
It is drop-in replacement of `yank-pop'.

First call open the kill-ring browser, next calls move to next line.

\(fn)" t nil)

(autoload 'helm-execute-kmacro "helm-ring" "\
Preconfigured helm for keyboard macros.
Define your macros with `f3' and `f4'.
See (info \"(emacs) Keyboard Macros\") for detailed infos.
This command is useful when used with persistent action.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-ring" '("helm-")))



(autoload 'helm-semantic "helm-semantic" "\
Preconfigured `helm' for `semantic'.
If ARG is supplied, pre-select symbol at point instead of current

\(fn ARG)" t nil)

(autoload 'helm-semantic-or-imenu "helm-semantic" "\
Preconfigured helm for `semantic' or `imenu'.
If ARG is supplied, pre-select symbol at point instead of current
semantic tag in scope.

If `semantic-mode' is active in the current buffer, then use
semantic for generating tags, otherwise fall back to `imenu'.
Fill in the symbol at point by default.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-semantic" '("helm-s")))



(defvar helm-top-poll-mode nil "\
Non-nil if Helm-Top-Poll mode is enabled.
See the `helm-top-poll-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-top-poll-mode'.")

(custom-autoload 'helm-top-poll-mode "helm-sys" nil)

(autoload 'helm-top-poll-mode "helm-sys" "\
Refresh automatically helm top buffer once enabled.

If called interactively, enable Helm-Top-Poll mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'helm-top "helm-sys" "\
Preconfigured `helm' for top command.

\(fn)" t nil)

(autoload 'helm-list-emacs-process "helm-sys" "\
Preconfigured `helm' for emacs process.

\(fn)" t nil)

(autoload 'helm-xrandr-set "helm-sys" "\
Preconfigured helm for xrandr.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-sys" '("helm-")))



(autoload 'helm-etags-select "helm-tags" "\
Preconfigured helm for etags.
If called with a prefix argument REINIT
or if any of the tag files have been modified, reinitialize cache.

This function aggregates three sources of tag files:

  1) An automatically located file in the parent directories,
     by `helm-etags-get-tag-file'.
  2) `tags-file-name', which is commonly set by `find-tag' command.
  3) `tags-table-list' which is commonly set by `visit-tags-table' command.

\(fn REINIT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-tags" '("helm-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-types" '("helm-")))



(defvar helm-popup-tip-mode nil "\
Non-nil if Helm-Popup-Tip mode is enabled.
See the `helm-popup-tip-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-popup-tip-mode'.")

(custom-autoload 'helm-popup-tip-mode "helm-utils" nil)

(autoload 'helm-popup-tip-mode "helm-utils" "\
Show help-echo informations in a popup tip at end of line.

If called interactively, enable Helm-Popup-Tip mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-utils" '("helm-" "with-helm-display-marked-candidates")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-x-files" '("helm-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/math-symbols-20170818.1459/math-symbols-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/math-symbols-20170818.1459/math-symbols-autoloads.el") (car load-path))))



(autoload 'math-symbols-input-activate "math-symbols" "\
Activating Math Input method.

\(fn NAME)" nil nil)

(register-input-method "math-symbols-bold" "math" 'math-symbols-input-activate "mBo")

(autoload 'math-symbols-bold-region "math-symbols" "\
Convert REGION to bold style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-string "math-symbols" "\
Convert STRING to bold style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-italic" "math" 'math-symbols-input-activate "mIt")

(autoload 'math-symbols-italic-region "math-symbols" "\
Convert REGION to italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-italic-string "math-symbols" "\
Convert STRING to italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-bold-italic" "math" 'math-symbols-input-activate "mBoIt")

(autoload 'math-symbols-bold-italic-region "math-symbols" "\
Convert REGION to bold-italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-italic-string "math-symbols" "\
Convert STRING to bold-italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-script" "math" 'math-symbols-input-activate "mSc")

(autoload 'math-symbols-script-region "math-symbols" "\
Convert REGION to script style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-script-string "math-symbols" "\
Convert STRING to script style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-bold-script" "math" 'math-symbols-input-activate "mBoSc")

(autoload 'math-symbols-bold-script-region "math-symbols" "\
Convert REGION to bold-script style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-script-string "math-symbols" "\
Convert STRING to bold-script style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-fraktur" "math" 'math-symbols-input-activate "mFr")

(autoload 'math-symbols-fraktur-region "math-symbols" "\
Convert REGION to fraktur style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-fraktur-string "math-symbols" "\
Convert STRING to fraktur style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-bold-fraktur" "math" 'math-symbols-input-activate "mBoFr")

(autoload 'math-symbols-bold-fraktur-region "math-symbols" "\
Convert REGION to bold-fraktur style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-fraktur-string "math-symbols" "\
Convert STRING to bold-fraktur style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-double-struck" "math" 'math-symbols-input-activate "mDoSt")

(autoload 'math-symbols-double-struck-region "math-symbols" "\
Convert REGION to double-struck style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-double-struck-string "math-symbols" "\
Convert STRING to double-struck style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif" "math" 'math-symbols-input-activate "mSaSe")

(autoload 'math-symbols-sans-serif-region "math-symbols" "\
Convert REGION to sans-serif style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-string "math-symbols" "\
Convert STRING to sans-serif style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif-bold" "math" 'math-symbols-input-activate "mSaSeBo")

(autoload 'math-symbols-sans-serif-bold-region "math-symbols" "\
Convert REGION to sans-serif-bold style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-bold-string "math-symbols" "\
Convert STRING to sans-serif-bold style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif-italic" "math" 'math-symbols-input-activate "mSaSeIt")

(autoload 'math-symbols-sans-serif-italic-region "math-symbols" "\
Convert REGION to sans-serif-italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-italic-string "math-symbols" "\
Convert STRING to sans-serif-italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif-bold-italic" "math" 'math-symbols-input-activate "mSaSeBoIt")

(autoload 'math-symbols-sans-serif-bold-italic-region "math-symbols" "\
Convert REGION to sans-serif-bold-italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-bold-italic-string "math-symbols" "\
Convert STRING to sans-serif-bold-italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-monospace" "math" 'math-symbols-input-activate "mMo")

(autoload 'math-symbols-monospace-region "math-symbols" "\
Convert REGION to monospace style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-monospace-string "math-symbols" "\
Convert STRING to monospace style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-superscript" "math" 'math-symbols-input-activate "mSu")

(autoload 'math-symbols-superscript-region "math-symbols" "\
Convert REGION to superscript style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-superscript-string "math-symbols" "\
Convert STRING to superscript style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-subscript" "math" 'math-symbols-input-activate "mSu")

(autoload 'math-symbols-subscript-region "math-symbols" "\
Convert REGION to subscript style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-subscript-string "math-symbols" "\
Convert STRING to subscript style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-tex" "math" 'math-symbols-input-activate "mt")

(autoload 'math-symbols-from-tex-region "math-symbols" "\
Convert TeX commands in REGION to math symbols.
For example, 'Phi' will be converted to '𝛷'.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-to-tex-region "math-symbols" "\
Convert math symbols to TeX command in REGION.
For example, `𝒫' will be converted to `mathcal{P}'.
Optional argument UNICODE specifies to use unicode-math package.

\(fn FROM TO &optional UNICODE)" t nil)

(autoload 'math-symbols-to-tex-unicode-region "math-symbols" "\


\(fn FROM TO)" t nil)

(autoload 'math-symbols-insert "math-symbols" "\
Interactively input math characters from symbols.

\(fn NAME)" t nil)

(autoload 'math-symbols-helm "math-symbols" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "math-symbols" '("math-symbols-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/math-symbol-lists-20170221.1353/math-symbol-lists-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/math-symbol-lists-20170221.1353/math-symbol-lists-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "math-symbol-lists" '("math-symbol-list-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "msl-build" '("gen-scirpted-alist" "msl--" "subscripts" "superscripts" "unicode-name-table")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mark-multiple-20121118.1554/mark-multiple-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mark-multiple-20121118.1554/mark-multiple-autoloads.el") (car load-path))))



(autoload 'inline-string-rectangle "inline-string-rectangle" "\


\(fn)" t nil)



(autoload 'mark-next-like-this "mark-more-like-this" "\
Find and mark the next part of the buffer matching the currently active region
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mark-previous-like-this "mark-more-like-this" "\
Find and mark the previous part of the buffer matching the currently active region
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark previous.

\(fn ARG)" t nil)

(autoload 'mark-all-like-this "mark-more-like-this" "\
Find and mark all the parts of the buffer matching the currently active region

\(fn)" t nil)

(autoload 'mark-all-like-this-in-region "mark-more-like-this" "\
Find and mark all the parts in the region matching the given search

\(fn REG-START REG-END)" t nil)

(autoload 'mark-more-like-this "mark-more-like-this" "\
Marks next part of buffer that matches the currently active region ARG times.
Given a negative ARG it searches backwards instead.

\(fn ARG)" t nil)

(autoload 'mark-more-like-this-extended "mark-more-like-this" "\
Like mark-more-like-this, but then lets you adjust with arrows key.
The actual adjustment made depends on the final component of the
key-binding used to invoke the command, with all modifiers removed:

   <up>    Mark previous like this
   <down>  Mark next like this
   <left>  If last was previous, skip it
           If last was next, remove it
   <right> If last was next, skip it
           If last was previous, remove it

Then, continue to read input events and further add or move marks
as long as the input event read (with all modifiers removed)
is one of the above.

\(fn)" t nil)



(autoload 'mm/deactivate-region-or-clear-all "mark-multiple" "\
Deactivate mark if active, otherwise clear all.

\(fn)" t nil)

(autoload 'mm/deactivate-region-and-clear-all "mark-multiple" "\
Deactivate mark and clear all.

\(fn)" t nil)

(autoload 'mm/clear-all "mark-multiple" "\
Remove all marks

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mark-multiple" '("mm/")))



(autoload 'rename-sgml-tag "rename-sgml-tag" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rename-sgml-tag" '("rst--inside-tag-p")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/manage-minor-mode-20140310.1600/manage-minor-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/manage-minor-mode-20140310.1600/manage-minor-mode-autoloads.el") (car load-path))))



(autoload 'manage-minor-mode-set "manage-minor-mode" "\


\(fn)" nil nil)

(autoload 'manage-minor-mode "manage-minor-mode" "\


\(fn &optional $LAST-TOGGLED-ITEM)" t nil)

(autoload 'manage-minor-mode-bals "manage-minor-mode" "\

Eradicate all minor-modes in the current buffer.
This command may cause unexpected effect even to other buffers.
However, don't worry, restore command exists:
 `manage-minor-mode-restore-from-bals'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "manage-minor-mode" '("manage-minor-mode-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/malinka-20171202.1021/malinka-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/malinka-20171202.1021/malinka-autoloads.el") (car load-path))))



(autoload 'malinka-project-configure "malinka" "\
Configure a project by querying for both NAME and GIVEN-ROOT-DIR.

If multiple projects with the same name in different directories may
exist then it's nice to provide the ROOT-DIR of the project to configure

\(fn NAME GIVEN-ROOT-DIR)" t nil)

(autoload 'malinka-project-select "malinka" "\
Select a project by querying for both NAME and GIVEN-ROOT-DIR.

If multiple projects with the same name in different directories may
exist then it's nice to provide the ROOT-DIR of the project to configure

\(fn NAME GIVEN-ROOT-DIR)" t nil)

(autoload 'malinka-mode "malinka" "\
Enables all malinka functionality for the current buffer

If called interactively, enable Malinka mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "malinka" '("async-shell-command-to-string" "malinka-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/makey-20131231.1430/makey-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/makey-20131231.1430/makey-autoloads.el") (car load-path))))



(autoload 'makey-initialize-key-groups "makey" "\
Initializes KEY-GROUP and creates all the relevant interactive commands.

\(fn KEY-GROUP)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "makey" '("makey-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/makefile-executor-20180720.832/makefile-executor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/makefile-executor-20180720.832/makefile-executor-autoloads.el") (car load-path))))



(autoload 'makefile-executor-execute-target "makefile-executor" "\
Execute a Makefile target from FILENAME.

FILENAME defaults to current buffer.

\(fn FILENAME &optional TARGET)" t nil)

(autoload 'makefile-executor-execute-project-target "makefile-executor" "\
Choose a Makefile target from all of the Makefiles in the project.

If there are several Makefiles, a prompt to select one of them is shown.
If so, the parent directory of the closest Makefile is added
as initial input for convenience in executing the most relevant Makefile.

\(fn)" t nil)

(autoload 'makefile-executor-execute-dedicated-buffer "makefile-executor" "\
Runs a makefile target in a dedicated compile buffer.

The dedicated buffer will be named \"*<target>*\".  If
`projectile' is installed and the makefile is in a project the
project name will be prepended to the dedicated buffer name.

\(fn FILENAME &optional TARGET)" t nil)

(autoload 'makefile-executor-execute-last "makefile-executor" "\
Execute the most recently executed Makefile target.

If none is set, prompt for it using
`makefile-executor-execute-project-target'.  If the universal
argument is given, always prompt.

\(fn ARG)" t nil)

(autoload 'makefile-executor-goto-makefile "makefile-executor" "\
Interactively choose a Makefile to visit.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "makefile-executor" '("makefile-executor-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/macro-math-20130328.1604/macro-math-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/macro-math-20130328.1604/macro-math-autoloads.el") (car load-path))))



(autoload 'macro-math-eval-region "macro-math" "\
Evaluate the marked mathematical expression and replace it with the result.
With arg COPY-TO-KILL-RING or prefix arg, don't replace the region, but
save the result to the kill-ring.  When DIGITS is non-nil, or a numeric
prefix arg is given, it determines the number of decimal digits to round
to.

\(fn BEG END &optional COPY-TO-KILL-RING DIGITS)" t nil)

(autoload 'macro-math-eval-and-round-region "macro-math" "\
Call `macro-math-eval-region' and round the number to DIGITS places.
If DIGITS is nil, `macro-math-rounding-precision' will be used.

\(fn BEG END &optional DIGITS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macro-math" '("macro-math-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/dash-functional-20180107.1618/dash-functional-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/dash-functional-20180107.1618/dash-functional-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dash-functional" '("-a" "-c" "-f" "-iteratefn" "-juxt" "-not" "-o" "-p" "-rpartial")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-20180907.1319/flycheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-20180907.1319/flycheck-autoloads.el") (car load-path))))



(autoload 'flycheck-manual "flycheck" "\
Open the Flycheck manual.

\(fn)" t nil)

(autoload 'flycheck-mode "flycheck" "\
Minor mode for on-the-fly syntax checking.

When called interactively, toggle `flycheck-mode'.  With prefix
ARG, enable `flycheck-mode' if ARG is positive, otherwise disable
it.

When called from Lisp, enable `flycheck-mode' if ARG is omitted,
nil or positive.  If ARG is `toggle', toggle `flycheck-mode'.
Otherwise behave as if called interactively.

In `flycheck-mode' the buffer is automatically syntax-checked
using the first suitable syntax checker from `flycheck-checkers'.
Use `flycheck-select-checker' to select a checker for the current
buffer manually.

\\{flycheck-mode-map}

\(fn &optional ARG)" t nil)

(defvar global-flycheck-mode nil "\
Non-nil if Global Flycheck mode is enabled.
See the `global-flycheck-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-flycheck-mode'.")

(custom-autoload 'global-flycheck-mode "flycheck" nil)

(autoload 'global-flycheck-mode "flycheck" "\
Toggle Flycheck mode in all buffers.
With prefix ARG, enable Global Flycheck mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Flycheck mode is enabled in all buffers where
`flycheck-mode-on-safe' would do it.
See `flycheck-mode' for more information on Flycheck mode.

\(fn &optional ARG)" t nil)

(autoload 'flycheck-define-error-level "flycheck" "\
Define a new error LEVEL with PROPERTIES.

The following PROPERTIES constitute an error level:

`:severity SEVERITY'
     A number denoting the severity of this level.  The higher
     the number, the more severe is this level compared to other
     levels.  Defaults to 0.

     The severity is used by `flycheck-error-level-<' to
     determine the ordering of errors according to their levels.

`:compilation-level LEVEL'

     A number indicating the broad class of messages that errors
     at this level belong to: one of 0 (info), 1 (warning), or
     2 or nil (error).  Defaults to nil.

     This is used by `flycheck-checker-pattern-to-error-regexp'
     to map error levels into `compilation-mode''s hierarchy and
     to get proper highlighting of errors in `compilation-mode'.

`:overlay-category CATEGORY'
     A symbol denoting the overlay category to use for error
     highlight overlays for this level.  See Info
     node `(elisp)Overlay Properties' for more information about
     overlay categories.

     A category for an error level overlay should at least define
     the `face' property, for error highlighting.  Another useful
     property for error level categories is `priority', to
     influence the stacking of multiple error level overlays.

`:fringe-bitmap BITMAP'
     A fringe bitmap symbol denoting the bitmap to use for fringe
     indicators for this level.  See Info node `(elisp)Fringe
     Bitmaps' for more information about fringe bitmaps,
     including a list of built-in fringe bitmaps.

`:fringe-face FACE'
     A face symbol denoting the face to use for fringe indicators
     for this level.

`:error-list-face FACE'
     A face symbol denoting the face to use for messages of this
     level in the error list.  See `flycheck-list-errors'.

\(fn LEVEL &rest PROPERTIES)" nil nil)

(function-put 'flycheck-define-error-level 'lisp-indent-function '1)

(autoload 'flycheck-define-command-checker "flycheck" "\
Define SYMBOL as syntax checker to run a command.

Define SYMBOL as generic syntax checker via
`flycheck-define-generic-checker', which uses an external command
to check the buffer.  SYMBOL and DOCSTRING are the same as for
`flycheck-define-generic-checker'.

In addition to the properties understood by
`flycheck-define-generic-checker', the following PROPERTIES
constitute a command syntax checker.  Unless otherwise noted, all
properties are mandatory.  Note that the default `:error-filter'
of command checkers is `flycheck-sanitize-errors'.

`:command COMMAND'
     The command to run for syntax checking.

     COMMAND is a list of the form `(EXECUTABLE [ARG ...])'.

     EXECUTABLE is a string with the executable of this syntax
     checker.  It can be overridden with the variable
     `flycheck-SYMBOL-executable'.  Note that this variable is
     NOT implicitly defined by this function.  Use
     `flycheck-def-executable-var' to define this variable.

     Each ARG is an argument to the executable, either as string,
     or as special symbol or form for
     `flycheck-substitute-argument', which see.

`:error-patterns PATTERNS'
     A list of patterns to parse the output of the `:command'.

     Each ITEM in PATTERNS is a list `(LEVEL SEXP ...)', where
     LEVEL is a Flycheck error level (see
     `flycheck-define-error-level'), followed by one or more RX
     `SEXP's which parse an error of that level and extract line,
     column, file name and the message.

     See `rx' for general information about RX, and
     `flycheck-rx-to-string' for some special RX forms provided
     by Flycheck.

     All patterns are applied in the order of declaration to the
     whole output of the syntax checker.  Output already matched
     by a pattern will not be matched by subsequent patterns.  In
     other words, the first pattern wins.

     This property is optional.  If omitted, however, an
     `:error-parser' is mandatory.

`:error-parser FUNCTION'
     A function to parse errors with.

     The function shall accept three arguments OUTPUT CHECKER
     BUFFER.  OUTPUT is the syntax checker output as string,
     CHECKER the syntax checker that was used, and BUFFER a
     buffer object representing the checked buffer.  The function
     must return a list of `flycheck-error' objects parsed from
     OUTPUT.

     This property is optional.  If omitted, it defaults to
     `flycheck-parse-with-patterns'.  In this case,
     `:error-patterns' is mandatory.

`:standard-input t'
     Whether to send the buffer contents on standard input.

     If this property is given and has a non-nil value, send the
     contents of the buffer on standard input.

     Defaults to nil.

Note that you may not give `:start', `:interrupt', and
`:print-doc' for a command checker.  You can give a custom
`:verify' function, though, whose results will be appended to the
default `:verify' function of command checkers.

\(fn SYMBOL DOCSTRING &rest PROPERTIES)" nil nil)

(function-put 'flycheck-define-command-checker 'lisp-indent-function '1)

(function-put 'flycheck-define-command-checker 'doc-string-elt '2)

(autoload 'flycheck-def-config-file-var "flycheck" "\
Define SYMBOL as config file variable for CHECKER, with default FILE-NAME.

SYMBOL is declared as customizable variable using `defcustom', to
provide a configuration file for the given syntax CHECKER.
CUSTOM-ARGS are forwarded to `defcustom'.

FILE-NAME is the initial value of the new variable.  If omitted,
the default value is nil.

Use this together with the `config-file' form in the `:command'
argument to `flycheck-define-checker'.

\(fn SYMBOL CHECKER &optional FILE-NAME &rest CUSTOM-ARGS)" nil t)

(function-put 'flycheck-def-config-file-var 'lisp-indent-function '3)

(autoload 'flycheck-def-option-var "flycheck" "\
Define SYMBOL as option variable with INIT-VALUE for CHECKER.

SYMBOL is declared as customizable variable using `defcustom', to
provide an option for the given syntax CHECKERS (a checker or a
list of checkers).  INIT-VALUE is the initial value of the
variable, and DOCSTRING is its docstring.  CUSTOM-ARGS are
forwarded to `defcustom'.

Use this together with the `option', `option-list' and
`option-flag' forms in the `:command' argument to
`flycheck-define-checker'.

\(fn SYMBOL INIT-VALUE CHECKERS DOCSTRING &rest CUSTOM-ARGS)" nil t)

(function-put 'flycheck-def-option-var 'lisp-indent-function '3)

(function-put 'flycheck-def-option-var 'doc-string-elt '4)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck" '("contains-rebar-config" "flycheck-" "help-flycheck-checker-d" "list-flycheck-errors" "locate-rebar3-project-root" "read-flycheck-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-buttercup" '("flycheck-buttercup-format-error-list")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-ert" '("flycheck-er")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-mode-20181003.1559/lsp-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-mode-20181003.1559/lsp-mode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-common" '("lsp-" "when-lsp-workspace" "with-lsp-workspace")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-imenu" '("lsp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-io" '("lsp-")))



(let ((loads (get 'lsp-mode 'custom-loads))) (if (member '"lsp-methods" loads) nil (put 'lsp-mode 'custom-loads (cons '"lsp-methods" loads))))

(let ((loads (get 'lsp-faces 'custom-loads))) (if (member '"lsp-methods" loads) nil (put 'lsp-faces 'custom-loads (cons '"lsp-methods" loads))))

(defvar lsp-document-sync-method nil "\
How to sync the document with the language server.")

(custom-autoload 'lsp-document-sync-method "lsp-methods" t)

(defvar lsp-project-blacklist nil "\
A list of project directory regexps for which LSP shouldn't be initialized.
LSP should be initialized if the given project root matches one pattern in the
whitelist, or does not match any pattern in the blacklist.")

(custom-autoload 'lsp-project-blacklist "lsp-methods" t)

(defvar lsp-enable-eldoc t "\
Enable `eldoc-mode' integration.")

(custom-autoload 'lsp-enable-eldoc "lsp-methods" t)

(defvar lsp-eldoc-render-all t "\
Define whether all of the returned by document/onHover will be displayed.

If `lsp-markup-display-all' is set to nil `eldoc' will show only
the symbol information.")

(custom-autoload 'lsp-eldoc-render-all "lsp-methods" t)

(defvar lsp-highlight-symbol-at-point t "\
Highlight the symbol under the point.")

(custom-autoload 'lsp-highlight-symbol-at-point "lsp-methods" t)

(defvar lsp-enable-codeaction t "\
Enable code action processing.")

(custom-autoload 'lsp-enable-codeaction "lsp-methods" t)

(defvar lsp-enable-completion-at-point t "\
Enable `completion-at-point' integration.")

(custom-autoload 'lsp-enable-completion-at-point "lsp-methods" t)

(defvar lsp-enable-xref t "\
Enable xref integration.")

(custom-autoload 'lsp-enable-xref "lsp-methods" t)

(defvar lsp-enable-indentation t "\
Indent regions using the file formatting functionality provided by the language server.")

(custom-autoload 'lsp-enable-indentation "lsp-methods" t)

(defvar lsp-before-save-edits t "\
If non-nil, `lsp-mode' will apply edits suggested by the language server
before saving a document.")

(custom-autoload 'lsp-before-save-edits "lsp-methods" t)

(defvar lsp-hover-text-function 'lsp--text-document-hover-string "\
The LSP method to use to display text on hover.")

(custom-autoload 'lsp-hover-text-function "lsp-methods" t)

(defface lsp-face-highlight-textual '((((background dark)) :background "saddle brown") (((background light)) :background "yellow")) "\
Face used for textual occurances of symbols." :group 'lsp-faces)

(defface lsp-face-highlight-read '((((background dark)) :background "firebrick") (((background light)) :background "red")) "\
Face used for highlighting symbols being read." :group 'lsp-faces)

(defface lsp-face-highlight-write '((((background dark)) :background "sea green") (((background light)) :background "green")) "\
Face used for highlighting symbols being written to." :group 'lsp-faces)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-methods" '("lsp-")))



(autoload 'lsp-mode "lsp-mode" "\


\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-mode" '("lsp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-notifications" '("lsp-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-ui-20181007.2219/lsp-ui-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-ui-20181007.2219/lsp-ui-autoloads.el") (car load-path))))



(autoload 'lsp-ui-mode "lsp-ui" "\
Toggle language server UI mode on or off.
‘lsp-ui-mode’ is a minor mode that contains a series of useful UI
integrations for ‘lsp-mode’.  With a prefix argument ARG, enable
language server UI mode if ARG is positive, and disable it
otherwise.  If called from Lisp, enable the mode if ARG is
omitted or nil, and toggle it if ARG is ‘toggle’.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui" '("lsp-ui-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-doc" '("lsp-ui-doc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-flycheck" '("lsp-ui-flycheck-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-imenu" '("lsp-ui-imenu")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-peek" '("lsp-ui-peek-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-sideline" '("lsp-ui-sideline")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-rust-20180305.1308/lsp-rust-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-rust-20180305.1308/lsp-rust-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-rust" '("lsp-rust-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-clangd-20180828.1657/lsp-clangd-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-clangd-20180828.1657/lsp-clangd-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-clangd" '("lsp-clangd-executable")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/log4e-20170401.1304/log4e-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/log4e-20170401.1304/log4e-autoloads.el") (car load-path))))



(autoload 'log4e-mode "log4e" "\
Major mode for browsing a buffer made by log4e.

\\<log4e-mode-map>
\\{log4e-mode-map}

\(fn)" t nil)

(autoload 'log4e:insert-start-log-quickly "log4e" "\
Insert logging statment for trace level log at start of current function/macro.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "log4e" '("log4e")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ht-20180129.2234/ht-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ht-20180129.2234/ht-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ht" 'nil))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/list-packages-ext-20151115.1716/list-packages-ext-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/list-packages-ext-20151115.1716/list-packages-ext-autoloads.el") (car load-path))))



(autoload 'lpe:edit-package-notes "list-packages-ext" "\
Opens a buffer where the user can enter notes about PACKAGE.

\(fn PACKAGE)" t nil)

(autoload 'list-packages-ext-mode "list-packages-ext" "\
Some extras for the *Packages* buffer (see `list-packages').
Provides:
- package tagging
- package hiding (with the tag 'hidden'
- package filtering by tag expressions/regexp
- package annotations
\\{list-packages-ext-mode-map}

If called interactively, enable List-Packages-Ext mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'lpe:tag "list-packages-ext" "\
Applies the tags in TAGLIST to the package at the current
line, or to the packages in the active region.

When called interactively, it prompts the user for the list of
comma separated tags to apply to the package at the current line
or to the packages in the active region.

When called on a region, or on a single line with prefix argument,
the command will work in 'Modify' mode: the tags entered by the user
will be merged with the already present tags; a tag can be removed
from a package applying it in its negated form. The negation of a
tag is expressed prepending `!' to the tag,
e.g. to remove a tag 'foo', one would tag the package with '!foo'.

If calling it with no active region, or to the active region with
a prefix command, the command works in 'Set' mode: the tags
entered by the user will substitute the current tag set of the
package, or list of packages if the region is active.

\(fn TAGLIST &optional ADD)" t nil)

(autoload 'lpe:hide-package "list-packages-ext" "\
Hides a package from the package list (applying the 'hidden' tag).

\(fn)" t nil)

(autoload 'lpe:apply-last-tags "list-packages-ext" "\
Apply the last tags applied with `lpe:tag'.

\(fn)" t nil)

(autoload 'lpe:star "list-packages-ext" "\
Toggles the starred tag to the current package or the packages in region if it is active.

\(fn)" t nil)

(autoload 'lpe:show-hidden-toggle "list-packages-ext" "\
Toggles showing of hidden packages.

\(fn)" t nil)

(autoload 'lpe:filter-by-tag-expr "list-packages-ext" "\
Filters the list of packages with FILTER-STR.
When called interactively, it prompts the user for a tag filter expression.
A tag filter like
  (tag1 AND tag2 AND NOT tag3) or tag4
is expressed as (using the default operator syntax)
  tag1,tag2,!tag3/tag4
The syntax for the operators can be controlled binding
`lpe::*tag-expr-and*', `lpe::*tag-expr-or*' and `lpe::*tag-expr-not*' 

\(fn FILTER-STR)" t nil)

(autoload 'lpe:filter-with-regex "list-packages-ext" "\
Filters the packages using regex. By default, only the packages name are searched.
To activate searching in the package summary, see `lpe:search-in-summary-toggle'.

\(fn REGEX)" t nil)

(autoload 'lpe:search-in-summary-toggle "list-packages-ext" "\
Toggles searching in package summary with `lpe:filter-with-regex'.

\(fn)" t nil)

(autoload 'lpe:filters-history-forward "list-packages-ext" "\
Goes forward to the next search in the search history.

\(fn)" t nil)

(autoload 'lpe:filters-history-backward "list-packages-ext" "\
Goes back to the previous search.

\(fn)" t nil)

(autoload 'lpe:refresh "list-packages-ext" "\
Refreshes the buffer.

\(fn)" t nil)

(autoload 'lpe::post-command-hook "list-packages-ext" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "list-packages-ext" '("list-packages-ext-mode-" "lpe:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lisp-extra-font-lock-20181008.1921/lisp-extra-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lisp-extra-font-lock-20181008.1921/lisp-extra-font-lock-autoloads.el") (car load-path))))



(defvar lisp-extra-font-lock-modes '(emacs-lisp-mode lisp-mode) "\
List of modes where Lisp Extra Font Lock Global mode should be enabled.")

(custom-autoload 'lisp-extra-font-lock-modes "lisp-extra-font-lock" t)

(autoload 'lisp-extra-font-lock-mode "lisp-extra-font-lock" "\
Minor mode that highlights bound variables and quoted expressions in lisp.

If called interactively, enable Lisp-Extra-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar lisp-extra-font-lock-global-mode nil "\
Non-nil if Lisp-Extra-Font-Lock-Global mode is enabled.
See the `lisp-extra-font-lock-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `lisp-extra-font-lock-global-mode'.")

(custom-autoload 'lisp-extra-font-lock-global-mode "lisp-extra-font-lock" nil)

(autoload 'lisp-extra-font-lock-global-mode "lisp-extra-font-lock" "\
Toggle Lisp-Extra-Font-Lock mode in all buffers.
With prefix ARG, enable Lisp-Extra-Font-Lock-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Lisp-Extra-Font-Lock mode is enabled in all buffers where
`(lambda nil (when (apply 'derived-mode-p lisp-extra-font-lock-modes) (lisp-extra-font-lock-mode 1)))' would do it.
See `lisp-extra-font-lock-mode' for more information on Lisp-Extra-Font-Lock mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lisp-extra-font-lock" '("lisp-extra-font-lock-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/levenshtein-20090830.1040/levenshtein-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/levenshtein-20090830.1040/levenshtein-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "levenshtein" '("levenshtein-distance")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/language-detection-20161123.1813/language-detection-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/language-detection-20161123.1813/language-detection-autoloads.el") (car load-path))))



(autoload 'language-detection-buffer "language-detection" "\
Predict the programming language of the current buffer and output it to messages.

\(fn &optional PRINT-MESSAGE)" t nil)

(autoload 'language-detection-string "language-detection" "\
Return the predicted programming language of STRING as a symbol.

\(fn STRING)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "language-detection" '("language-detection-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/json-snatcher-20150512.347/json-snatcher-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/json-snatcher-20150512.347/json-snatcher-autoloads.el") (car load-path))))



(autoload 'jsons-print-path "json-snatcher" "\
Print the path to the JSON value under point, and save it in the kill ring.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-snatcher" '("jsons-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/json-reformat-20160212.853/json-reformat-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/json-reformat-20160212.853/json-reformat-autoloads.el") (car load-path))))



(autoload 'json-reformat-region "json-reformat" "\
Reformat the JSON in the specified region.

If you want to customize the reformat style,
please see the documentation of `json-reformat:indent-width'
and `json-reformat:pretty-string?'.

\(fn BEGIN END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-reformat" '("json-reformat")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/json-mode-20180718.809/json-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/json-mode-20180718.809/json-mode-autoloads.el") (car load-path))))



(defconst json-mode-standard-file-ext '(".json" ".jsonld") "\
List of JSON file extensions.")

(defsubst json-mode--update-auto-mode (filenames) "\
Update the `json-mode' entry of `auto-mode-alist'.

FILENAMES should be a list of file as string.
Return the new `auto-mode-alist' entry" (let* ((new-regexp (rx-to-string `(seq (eval (cons 'or (append json-mode-standard-file-ext ',filenames))) eot))) (new-entry (cons new-regexp 'json-mode)) (old-entry (when (boundp 'json-mode--auto-mode-entry) json-mode--auto-mode-entry))) (setq auto-mode-alist (delete old-entry auto-mode-alist)) (add-to-list 'auto-mode-alist new-entry) new-entry))

(defvar json-mode-auto-mode-list '(".babelrc" ".bowerrc" "composer.lock") "\
List of filename as string to pass for the JSON entry of
`auto-mode-alist'.

Note however that custom `json-mode' entries in `auto-mode-alist'
won’t be affected.")

(custom-autoload 'json-mode-auto-mode-list "json-mode" nil)

(defvar json-mode--auto-mode-entry (json-mode--update-auto-mode json-mode-auto-mode-list) "\
Regexp generated from the `json-mode-auto-mode-list'.")

(autoload 'json-mode "json-mode" "\
Major mode for editing JSON files

\(fn)" t nil)

(autoload 'json-mode-show-path "json-mode" "\
Print the path to the node at point to the minibuffer, and yank to the kill ring.

\(fn)" t nil)

(autoload 'json-mode-kill-path "json-mode" "\


\(fn)" t nil)

(autoload 'json-mode-beautify "json-mode" "\
Beautify / pretty-print the active region (or the entire buffer if no active region).

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-mode" '("json-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/jdecomp-20170224.2200/jdecomp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/jdecomp-20170224.2200/jdecomp-autoloads.el") (car load-path))))



(autoload 'jdecomp-preview-mode "jdecomp" "\
Major mode for previewing decompiled Java class files.

\\{jdecomp-preview-mode-map}

\(fn)" t nil)

(autoload 'jdecomp-decompile "jdecomp" "\
Decompile FILE and return buffer of decompiled contents.

FILE must be a Java class file.

Optional parameter JAR is the name of the JAR archive FILE is
in.

\(fn FILE &optional JAR)" nil nil)

(autoload 'jdecomp-decompile-and-view "jdecomp" "\
Decompile FILE and view buffer of decompiled contents.

FILE must be a Java class file.  If called interactively, FILE is
the name of the file the current buffer is visiting.

Optional parameter JAR is the JAR file containing FILE, if
applicable.

\(fn FILE &optional JAR)" t nil)

(defvar jdecomp-mode nil "\
Non-nil if Jdecomp mode is enabled.
See the `jdecomp-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `jdecomp-mode'.")

(custom-autoload 'jdecomp-mode "jdecomp" nil)

(autoload 'jdecomp-mode "jdecomp" "\
Automatically decompile Java class files.

If called interactively, enable Jdecomp mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "jdecomp" '("jdecomp-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/javap-mode-20120223.2208/javap-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/javap-mode-20120223.2208/javap-mode-autoloads.el") (car load-path))))



(autoload 'javap-mode "javap-mode" "\
A major mode for viewing javap files.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "javap-mode" '("javap-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/javadoc-lookup-20160214.31/javadoc-lookup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/javadoc-lookup-20160214.31/javadoc-lookup-autoloads.el") (car load-path))))



(autoload 'javadoc-sort-imports "javadoc-import" "\
Sort the imports in the import section in proper order.

\(fn)" t nil)

(define-obsolete-function-alias 'sort-java-imports 'javadoc-sort-imports "1.1.0")

(autoload 'javadoc-add-import "javadoc-import" "\
Insert an import statement at import section at the top of the file.

\(fn)" t nil)

(define-obsolete-function-alias 'add-java-import 'javadoc-add-import "1.1.0")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "javadoc-import" '("jdl/")))



(autoload 'javadoc-lookup "javadoc-lookup" "\
Lookup based on class name.

\(fn NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "javadoc-lookup" '("javadoc-" "jdl/")))



(autoload 'javadoc-add-artifacts "maven-fetch" "\
Add Maven repository artifacts to the javadoc-lookup index.
An artifact is specified by a sequence of three strings:
 [groupId artifactId version].

\(fn &rest ARTIFACTS)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "maven-fetch" '("maven-" "unzip-program-name")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/java-imports-20170913.1410/java-imports-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/java-imports-20170913.1410/java-imports-autoloads.el") (car load-path))))



(autoload 'java-imports-scan-file "java-imports" "\
Scans a java-mode buffer, adding any import class -> package
mappings to the import cache. If called with a prefix arguments
overwrites any existing cache entries for the file.

\(fn)" t nil)

(autoload 'java-imports-list-imports "java-imports" "\
Return a list of all fully-qualified packages in the current
Java-mode buffer

\(fn)" t nil)

(autoload 'java-imports-add-import-with-package "java-imports" "\
Add an import for the class for the name and package. Uses no caching.

\(fn CLASS-NAME PACKAGE)" t nil)

(autoload 'java-imports-add-import "java-imports" "\
Import the Java class for the symbol at point. Uses the symbol
at the point for the class name, ask for a confirmation of the
class name before adding it.

Checks the import cache to see if a package entry exists for the
given class. If found, adds an import statement for the class. If
not found, prompts for the package and saves it to the cache.

If called with a prefix argument, overwrites the package for an
already-existing class name.

\(fn CLASS-NAME)" t nil)

(autoload 'java-imports-add-import-dwim "java-imports" "\
Add an import statement for the class at point. If no class is
found, prompt for the class name. If the class's package already
exists in the cache, add it and return, otherwise prompt for the
package and cache it for future statements.

\(fn)" t nil)

(autoload 'java-imports-scan-local-jars "java-imports" "\


\(fn &optional LOCAL-REPO)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "java-imports" '("java-imports-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hydra-20180918.1529/hydra-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hydra-20180918.1529/hydra-autoloads.el") (car load-path))))



(autoload 'defhydra "hydra" "\
Create a Hydra - a family of functions with prefix NAME.

NAME should be a symbol, it will be the prefix of all functions
defined here.

BODY has the format:

    (BODY-MAP BODY-KEY &rest BODY-PLIST)

DOCSTRING will be displayed in the echo area to identify the
Hydra.  When DOCSTRING starts with a newline, special Ruby-style
substitution will be performed by `hydra--format'.

Functions are created on basis of HEADS, each of which has the
format:

    (KEY CMD &optional HINT &rest PLIST)

BODY-MAP is a keymap; `global-map' is used quite often.  Each
function generated from HEADS will be bound in BODY-MAP to
BODY-KEY + KEY (both are strings passed to `kbd'), and will set
the transient map so that all following heads can be called
though KEY only.  BODY-KEY can be an empty string.

CMD is a callable expression: either an interactive function
name, or an interactive lambda, or a single sexp (it will be
wrapped in an interactive lambda).

HINT is a short string that identifies its head.  It will be
printed beside KEY in the echo erea if `hydra-is-helpful' is not
nil.  If you don't even want the KEY to be printed, set HINT
explicitly to nil.

The heads inherit their PLIST from BODY-PLIST and are allowed to
override some keys.  The keys recognized are :exit and :bind.
:exit can be:

- nil (default): this head will continue the Hydra state.
- t: this head will stop the Hydra state.

:bind can be:
- nil: this head will not be bound in BODY-MAP.
- a lambda taking KEY and CMD used to bind a head.

It is possible to omit both BODY-MAP and BODY-KEY if you don't
want to bind anything.  In that case, typically you will bind the
generated NAME/body command.  This command is also the return
result of `defhydra'.

\(fn NAME BODY &optional DOCSTRING &rest HEADS)" nil t)

(function-put 'defhydra 'lisp-indent-function 'defun)

(function-put 'defhydra 'doc-string-elt '3)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hydra" '("defhydradio" "hydra-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hydra-examples" '("hydra-" "org-agenda-cts" "whitespace-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hydra-ox" '("hydra-ox")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lv" '("lv-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ivy-hydra-20180614.2200/ivy-hydra-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ivy-hydra-20180614.2200/ivy-hydra-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy-hydra" '("hydra-ivy" "ivy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/counsel-20180927.942/counsel-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/counsel-20180927.942/counsel-autoloads.el") (car load-path))))



(autoload 'counsel-el "counsel" "\
Elisp completion at point.

\(fn)" t nil)

(autoload 'counsel-cl "counsel" "\
Common Lisp completion at point.

\(fn)" t nil)

(autoload 'counsel-clj "counsel" "\
Clojure completion at point.

\(fn)" t nil)

(autoload 'counsel-company "counsel" "\
Complete using `company-candidates'.

\(fn)" t nil)

(autoload 'counsel-irony "counsel" "\
Inline C/C++ completion using Irony.

\(fn)" t nil)

(autoload 'counsel-describe-variable "counsel" "\
Forward to `describe-variable'.

Variables declared using `defcustom' are highlighted according to
`ivy-highlight-face'.

\(fn)" t nil)

(autoload 'counsel-describe-function "counsel" "\
Forward to `describe-function'.

Interactive functions (i.e., commands) are highlighted according
to `ivy-highlight-face'.

\(fn)" t nil)

(autoload 'counsel-set-variable "counsel" "\
Set a variable, with completion.

When the selected variable is a `defcustom' with the type boolean
or radio, offer completion of all possible values.

Otherwise, offer a variant of `eval-expression', with the initial
input corresponding to the chosen variable.

With a prefix arg, restrict list to variables defined using
`defcustom'.

\(fn SYM)" t nil)

(autoload 'counsel-apropos "counsel" "\
Show all matching symbols.
See `apropos' for further information on what is considered
a symbol and how to search for them.

\(fn)" t nil)

(autoload 'counsel-info-lookup-symbol "counsel" "\
Forward to `info-lookup-symbol' with ivy completion.

\(fn SYMBOL &optional MODE)" t nil)

(autoload 'counsel-M-x "counsel" "\
Ivy version of `execute-extended-command'.
Optional INITIAL-INPUT is the initial input in the minibuffer.
This function integrates with either the `amx' or `smex' package
when available, in that order of precedence.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-load-library "counsel" "\
Load a selected the Emacs Lisp library.
The libraries are offered from `load-path'.

\(fn)" t nil)

(autoload 'counsel-find-library "counsel" "\
Visit a selected the Emacs Lisp library.
The libraries are offered from `load-path'.

\(fn)" t nil)

(autoload 'counsel-load-theme "counsel" "\
Forward to `load-theme'.
Usable with `ivy-resume', `ivy-next-line-and-call' and
`ivy-previous-line-and-call'.

\(fn)" t nil)

(autoload 'counsel-descbinds "counsel" "\
Show a list of all defined keys and their definitions.
If non-nil, show only bindings that start with PREFIX.
BUFFER defaults to the current one.

\(fn &optional PREFIX BUFFER)" t nil)

(autoload 'counsel-faces "counsel" "\
Complete faces with preview.
Actions are provided by default for describing or customizing the
selected face.

\(fn)" t nil)

(autoload 'counsel-git "counsel" "\
Find file in the current Git repository.
INITIAL-INPUT can be given as the initial minibuffer input.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-git-grep "counsel" "\
Grep for a string in the current git repository.
When CMD is a string, use it as a \"git grep\" command.
When CMD is non-nil, prompt for a specific \"git grep\" command.
INITIAL-INPUT can be given as the initial minibuffer input.

\(fn &optional CMD INITIAL-INPUT)" t nil)

(autoload 'counsel-git-stash "counsel" "\
Search through all available git stashes.

\(fn)" t nil)

(autoload 'counsel-git-change-worktree "counsel" "\
Find the file corresponding to the current buffer on a different worktree.

\(fn)" t nil)

(autoload 'counsel-git-checkout "counsel" "\
Call the \"git checkout\" command.

\(fn)" t nil)

(autoload 'counsel-git-log "counsel" "\
Call the \"git log --grep\" shell command.

\(fn)" t nil)

(autoload 'counsel-find-file "counsel" "\
Forward to `find-file'.
When INITIAL-INPUT is non-nil, use it in the minibuffer during completion.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-recentf "counsel" "\
Find a file on `recentf-list'.

\(fn)" t nil)

(autoload 'counsel-bookmark "counsel" "\
Forward to `bookmark-jump' or `bookmark-set' if bookmark doesn't exist.

\(fn)" t nil)

(autoload 'counsel-bookmarked-directory "counsel" "\
Ivy interface for bookmarked directories.

With a prefix argument, this command creates a new bookmark which points to the
current value of `default-directory'.

\(fn)" t nil)

(autoload 'counsel-file-register "counsel" "\
Search file in register.

You cannot use Emacs' normal register commands to create file
registers.  Instead you must use the `set-register' function like
so: `(set-register ?i \"/home/eric/.emacs.d/init.el\")'.  Now you
can use `C-x r j i' to open that file.

\(fn)" t nil)

(autoload 'counsel-locate "counsel" "\
Call the \"locate\" shell command.
INITIAL-INPUT can be given as the initial minibuffer input.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-fzf "counsel" "\
Open a file using the fzf shell command.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
FZF-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY FZF-PROMPT)" t nil)

(autoload 'counsel-dpkg "counsel" "\
Call the \"dpkg\" shell command.

\(fn)" t nil)

(autoload 'counsel-rpm "counsel" "\
Call the \"rpm\" shell command.

\(fn)" t nil)

(autoload 'counsel-file-jump "counsel" "\
Jump to a file below the current directory.
List all files within the current directory or any of its subdirectories.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY)" t nil)

(autoload 'counsel-dired-jump "counsel" "\
Jump to a directory (in dired) below the current directory.
List all subdirectories within the current directory.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY)" t nil)

(autoload 'counsel-ag "counsel" "\
Grep for a string in the current directory using ag.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
EXTRA-AG-ARGS string, if non-nil, is appended to `counsel-ag-base-command'.
AG-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY EXTRA-AG-ARGS AG-PROMPT)" t nil)

(autoload 'counsel-pt "counsel" "\
Grep for a string in the current directory using pt.
INITIAL-INPUT can be given as the initial minibuffer input.
This uses `counsel-ag' with `counsel-pt-base-command' instead of
`counsel-ag-base-command'.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-ack "counsel" "\
Grep for a string in the current directory using ack.
INITIAL-INPUT can be given as the initial minibuffer input.
This uses `counsel-ag' with `counsel-ack-base-command' replacing
`counsel-ag-base-command'.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-rg "counsel" "\
Grep for a string in the current directory using rg.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
EXTRA-RG-ARGS string, if non-nil, is appended to `counsel-rg-base-command'.
RG-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY EXTRA-RG-ARGS RG-PROMPT)" t nil)

(autoload 'counsel-grep "counsel" "\
Grep for a string in the file visited by the current buffer.
When non-nil, INITIAL-INPUT is the initial search pattern.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-grep-or-swiper "counsel" "\
Call `swiper' for small buffers and `counsel-grep' for large ones.
When non-nil, INITIAL-INPUT is the initial search pattern.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-org-tag "counsel" "\
Add or remove tags in `org-mode'.

\(fn)" t nil)

(autoload 'counsel-org-tag-agenda "counsel" "\
Set tags for the current agenda item.

\(fn)" t nil)

(defalias 'counsel-org-goto #'counsel-outline)

(autoload 'counsel-org-goto-all "counsel" "\
Go to a different location in any org file.

\(fn)" t nil)

(autoload 'counsel-org-file "counsel" "\
Browse all attachments for current Org file.

\(fn)" t nil)

(autoload 'counsel-org-entity "counsel" "\
Complete Org entities using Ivy.

\(fn)" t nil)

(autoload 'counsel-org-capture "counsel" "\
Capture something.

\(fn)" t nil)

(autoload 'counsel-org-agenda-headlines "counsel" "\
Choose from headers of `org-mode' files in the agenda.

\(fn)" t nil)

(autoload 'counsel-tmm "counsel" "\
Text-mode emulation of looking and choosing from a menubar.

\(fn)" t nil)

(autoload 'counsel-yank-pop "counsel" "\
Ivy replacement for `yank-pop'.
With a plain prefix argument (\\[universal-argument]),
temporarily toggle the value of `counsel-yank-pop-after-point'.
Any other value of ARG has the same meaning as in `yank-pop', but
`counsel-yank-pop-preselect-last' determines its default value.
See also `counsel-yank-pop-filter' for how to filter candidates.

Note: Duplicate elements of `kill-ring' are always deleted.

\(fn &optional ARG)" t nil)

(autoload 'counsel-imenu "counsel" "\
Jump to a buffer position indexed by imenu.

\(fn)" t nil)

(autoload 'counsel-list-processes "counsel" "\
Offer completion for `process-list'.
The default action deletes the selected process.
An extra action allows to switch to the process buffer.

\(fn)" t nil)

(autoload 'counsel-expression-history "counsel" "\
Select an element of `read-expression-history'.
And insert it into the minibuffer.  Useful during `eval-expression'.

\(fn)" t nil)

(autoload 'counsel-shell-command-history "counsel" "\
Browse shell command history.

\(fn)" t nil)

(autoload 'counsel-minibuffer-history "counsel" "\
Browse minibuffer history.

\(fn)" t nil)

(autoload 'counsel-esh-history "counsel" "\
Browse Eshell history.

\(fn)" t nil)

(autoload 'counsel-shell-history "counsel" "\
Browse shell history.

\(fn)" t nil)

(autoload 'counsel-outline "counsel" "\
Jump to an outline heading with completion.

\(fn)" t nil)

(autoload 'counsel-ibuffer "counsel" "\
Use ibuffer to switch to another buffer.
NAME specifies the name of the buffer (defaults to \"*Ibuffer*\").

\(fn &optional NAME)" t nil)

(autoload 'counsel-switch-to-shell-buffer "counsel" "\
Switch to a shell buffer, or create one.

\(fn)" t nil)

(autoload 'counsel-unicode-char "counsel" "\
Insert COUNT copies of a Unicode character at point.
COUNT defaults to 1.

\(fn &optional COUNT)" t nil)

(autoload 'counsel-colors-emacs "counsel" "\
Show a list of all supported colors for a particular frame.

You can insert or kill the name or hexadecimal RGB value of the
selected color.

\(fn)" t nil)

(autoload 'counsel-colors-web "counsel" "\
Show a list of all W3C web colors for use in CSS.

You can insert or kill the name or hexadecimal RGB value of the
selected color.

\(fn)" t nil)

(autoload 'counsel-rhythmbox "counsel" "\
Choose a song from the Rhythmbox library to play or enqueue.

\(fn)" t nil)

(autoload 'counsel-linux-app "counsel" "\
Launch a Linux desktop application, similar to Alt-<F2>.

\(fn)" t nil)

(defvar counsel-mode nil "\
Non-nil if Counsel mode is enabled.
See the `counsel-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `counsel-mode'.")

(custom-autoload 'counsel-mode "counsel" nil)

(autoload 'counsel-mode "counsel" "\
Toggle Counsel mode on or off.
Turn Counsel mode on if ARG is positive, off otherwise. Counsel
mode remaps built-in emacs functions that have counsel
replacements.

Local bindings (`counsel-mode-map'):
\\{counsel-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "counsel" '("counsel-" "ivy-function-called-at-point" "tmm-km-list")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ivy-dired-history-20170626.556/ivy-dired-history-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ivy-dired-history-20170626.556/ivy-dired-history-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy-dired-history" '("ivy-dired-history-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/isearch-symbol-at-point-20130728.2221/isearch-symbol-at-point-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/isearch-symbol-at-point-20130728.2221/isearch-symbol-at-point-autoloads.el") (car load-path))))



(autoload 'isearch-symbol-at-point "isearch-symbol-at-point" "\
Incremental search forward with symbol under point.

  Prefixed with \\[universal-argument] will find all partial
  matches.

\(fn &optional PARTIALP)" t nil)

(autoload 'isearch-backward-symbol-at-point "isearch-symbol-at-point" "\
Incremental search backward with symbol under point.

  Prefixed with \\[universal-argument] will find all partial
  matches.

\(fn &optional PARTIALP)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "isearch-symbol-at-point" '("isearch-yank-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/irony-20180703.1740/irony-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/irony-20180703.1740/irony-autoloads.el") (car load-path))))



(defvar irony-additional-clang-options nil "\
Additional command line options to pass down to libclang.

Please, do NOT use this variable to add header search paths, only
additional warnings or compiler options.

These compiler options will be prepended to the command line, in
order to not override the value coming from a compilation
database.")

(custom-autoload 'irony-additional-clang-options "irony" t)

(autoload 'irony-mode "irony" "\
Minor mode for C, C++ and Objective-C, powered by libclang.

If called interactively, enable Irony mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'irony-version "irony" "\
Return the version number of the file irony.el.

If called interactively display the version in the echo area.

\(fn &optional SHOW-VERSION)" t nil)

(autoload 'irony-server-kill "irony" "\
Kill the running irony-server process, if any.

\(fn)" t nil)

(autoload 'irony-get-type "irony" "\
Get the type of symbol under cursor.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony" '("irony-")))



(autoload 'irony-cdb-autosetup-compile-options "irony-cdb" "\


\(fn)" t nil)

(autoload 'irony-cdb-menu "irony-cdb" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-cdb" '("irony-cdb-")))



(autoload 'irony-cdb-clang-complete "irony-cdb-clang-complete" "\


\(fn COMMAND &rest ARGS)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-cdb-clang-complete" '("irony-cdb-clang-complete--")))



(autoload 'irony-cdb-json "irony-cdb-json" "\


\(fn COMMAND &rest ARGS)" nil nil)

(autoload 'irony-cdb-json-add-compile-commands-path "irony-cdb-json" "\
Add an out-of-source compilation database.

Files below the PROJECT-ROOT directory will use the JSON
Compilation Database as specified by COMPILE-COMMANDS-PATH.

The JSON Compilation Database are often generated in the build
directory. This functions helps mapping out-of-source build
directories to project directory.

\(fn PROJECT-ROOT COMPILE-COMMANDS-PATH)" t nil)

(autoload 'irony-cdb-json-select "irony-cdb-json" "\
Select CDB to use with a prompt.

It is useful when you have several CDBs with the same project
root.

The completion function used internally is `completing-read' so
it could easily be used with other completion functions by
temporarily using a let-bind on `completing-read-function'. Or
even helm by enabling `helm-mode' before calling the function.

\(fn)" t nil)

(autoload 'irony-cdb-json-select-most-recent "irony-cdb-json" "\
Select CDB that is most recently modified.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-cdb-json" '("irony-cdb-json--")))



(autoload 'irony-cdb-libclang "irony-cdb-libclang" "\


\(fn COMMAND &rest ARGS)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-cdb-libclang" '("irony-cdb-libclang--")))



(autoload 'irony-completion-at-point "irony-completion" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-completion" '("irony-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-diagnostics" '("irony-diagnostics-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-iotask" '("irony-iotask-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-snippet" '("irony-snippet-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/irony-eldoc-20170502.1908/irony-eldoc-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/irony-eldoc-20170502.1908/irony-eldoc-autoloads.el") (car load-path))))



(autoload 'irony-eldoc "irony-eldoc" "\
Eldoc support in irony-mode.

If called interactively, enable Irony-Eldoc mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

eldoc is a built-in Emacs mode for displaying documentation about
a symbol or function call at point in the message buffer (see
`eldoc-mode').

To use:

- Enable the minor mode `irony-eldoc', as well as
  `eldoc-mode'. For an example, place point on top of a symbol,
  or inside a function call.

- It is easiest to add `irony-eldoc' to `irony-mode-hook', if you
  already have `irony-mode' set up.

Notes:

- Sometimes the information `irony-eldoc' uses can go out of
  date. In that case, try calling `irony-eldoc-reset'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "irony-eldoc" '("irony-eldoc-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ipretty-20180606.522/ipretty-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ipretty-20180606.522/ipretty-autoloads.el") (car load-path))))



(autoload 'ipretty-last-sexp "ipretty" "\
Pretty-print the last sexp into the current buffer.
When TRUNCATE is non-nil or with a prefix argument, long output
is truncated. See the documentation of `eval-print-last-sexp' for
more information on what affects truncation.

\(fn &optional TRUNCATE)" t nil)

(autoload 'ipretty-last-sexp-other-buffer "ipretty" "\
Display the last sexp pretty-printed in other buffer.
If BUFFER-NAME (a string)is provided it will be used to name the
buffer, otherwise the default `*pp-display-expression*' is used.

\(fn &optional BUFFER-NAME)" t nil)

(defvar ipretty-mode nil "\
Non-nil if Ipretty mode is enabled.
See the `ipretty-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ipretty-mode'.")

(custom-autoload 'ipretty-mode "ipretty" nil)

(autoload 'ipretty-mode "ipretty" "\
Toggle ipretty mode globally.
   With no argument, this command toggles the mode.
   Non-null prefix argument turns on the mode.
   Null prefix argument turns off the mode.

If called interactively, enable Ipretty mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/inflections-20170913.916/inflections-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/inflections-20170913.916/inflections-autoloads.el") (car load-path))))



(autoload 'inflection-singularize-string "inflections" "\
Return the singularized version of STR.

\(fn STR)" nil nil)

(define-obsolete-function-alias 'singularize-string 'inflection-singularize-string)

(autoload 'inflection-pluralize-string "inflections" "\
Return the pluralized version of STR.

\(fn STR)" nil nil)

(define-obsolete-function-alias 'pluralize-string 'inflection-pluralize-string)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inflections" '("define-inflectors" "inflection-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/inf-clojure-20180402.2103/inf-clojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/inf-clojure-20180402.2103/inf-clojure-autoloads.el") (car load-path))))



(autoload 'inf-clojure-minor-mode "inf-clojure" "\
Minor mode for interacting with the inferior Clojure process buffer.

If called interactively, enable Inf-Clojure minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

The following commands are available:

\\{inf-clojure-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'inf-clojure "inf-clojure" "\
Run an inferior Clojure process, input and output via buffer `*inf-clojure*'.
If there is a process already running in `*inf-clojure*', just switch
to that buffer.
With argument, allows you to edit the CMD used to launch
it (default is value of `inf-clojure-*-cmd').  Runs the hooks
from `inf-clojure-mode-hook' (after the `comint-mode-hook' is
run).
\(Type \\[describe-mode] in the process buffer for a list of commands.)

\(fn CMD)" t nil)

(autoload 'inf-clojure-connect "inf-clojure" "\
Connect to a running socket-repl via `inf-clojure'.
HOST is the host the process is running on, PORT is where it's listening.

\(fn HOST PORT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inf-clojure" '("inf-clojure-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/iedit-20180919.323/iedit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/iedit-20180919.323/iedit-autoloads.el") (car load-path))))



(autoload 'iedit-mode "iedit" "\
Toggle Iedit mode.
This command behaves differently, depending on the mark, point,
prefix argument and variable `iedit-transient-mark-sensitive'.

If Iedit mode is off, turn Iedit mode on.

When Iedit mode is turned on, all the occurrences of the current
region in the buffer (possibly narrowed) or a region are
highlighted.  If one occurrence is modified, the change are
propagated to all other occurrences simultaneously.

If region is not active, `iedit-default-occurrence' is called to
get an occurrence candidate, according to the thing at point.  It
might be url, email address, markup tag or current symbol(or
word).

In the above two situations, with digit prefix argument 0, only
occurrences in current function are matched.  This is good for
renaming refactoring in programming.

You can also switch to Iedit mode from isearch mode directly. The
current search string is used as occurrence.  All occurrences of
the current search string are highlighted.

With an universal prefix argument, the occurrence when Iedit mode
is turned off last time in current buffer is used as occurrence.
This is intended to recover last Iedit mode which is turned off.
If region active, Iedit mode is limited within the current
region.

With repeated universal prefix argument, the occurrence when
Iedit mode is turned off last time (might be in other buffer) is
used as occurrence.  If region active, Iedit mode is limited
within the current region.

With digital prefix argument 1, Iedit mode is limited on the
current symbol or the active region, which means just one
instance is highlighted.  This behavior serves as a start point
of incremental selection work flow.

If Iedit mode is on and region is active, Iedit mode is
restricted in the region, e.g. the occurrences outside of the
region is excluded.

If Iedit mode is on and region is active, with an universal
prefix argument, Iedit mode is restricted outside of the region,
e.g. the occurrences in the region is excluded.

Turn off Iedit mode in other situations.

Commands:
\\{iedit-mode-keymap}
Keymap used within overlays:
\\{iedit-mode-occurrence-keymap}

\(fn &optional ARG)" t nil)

(autoload 'iedit-mode-toggle-on-function "iedit" "\
Toggle Iedit mode on current function.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "iedit" '("iedit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "iedit-lib" '("iedit-")))



(autoload 'iedit-rectangle-mode "iedit-rect" "\
Toggle Iedit-rect mode.

When Iedit-rect mode is on, a rectangle is started with visible
rectangle highlighting.  Rectangle editing support is based on
Iedit mechanism.

Commands:
\\{iedit-rect-keymap}

\(fn &optional BEG END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "iedit-rect" '("iedit-rect")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ido-at-point-20151021.757/ido-at-point-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ido-at-point-20151021.757/ido-at-point-autoloads.el") (car load-path))))



(autoload 'ido-at-point-mode "ido-at-point" "\
Global minor mode to use ido for `completion-at-point'.

When called interactively, toggle `ido-at-point-mode'.  With
prefix ARG, enable `ido-at-point-mode' if ARG is positive,
otherwise disable it.

When called from Lisp, enable `ido-at-point-mode' if ARG is
omitted, nil or positive.  If ARG is `toggle', toggle
`ido-at-point-mode'.  Otherwise behave as if called
interactively.

With `ido-at-point-mode' use ido for `completion-at-point'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ido-at-point" '("ido-at-point-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/htmlize-20180923.1829/htmlize-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/htmlize-20180923.1829/htmlize-autoloads.el") (car load-path))))



(autoload 'htmlize-buffer "htmlize" "\
Convert BUFFER to HTML, preserving colors and decorations.

The generated HTML is available in a new buffer, which is returned.
When invoked interactively, the new buffer is selected in the current
window.  The title of the generated document will be set to the buffer's
file name or, if that's not available, to the buffer's name.

Note that htmlize doesn't fontify your buffers, it only uses the
decorations that are already present.  If you don't set up font-lock or
something else to fontify your buffers, the resulting HTML will be
plain.  Likewise, if you don't like the choice of colors, fix the mode
that created them, or simply alter the faces it uses.

\(fn &optional BUFFER)" t nil)

(autoload 'htmlize-region "htmlize" "\
Convert the region to HTML, preserving colors and decorations.
See `htmlize-buffer' for details.

\(fn BEG END)" t nil)

(autoload 'htmlize-file "htmlize" "\
Load FILE, fontify it, convert it to HTML, and save the result.

Contents of FILE are inserted into a temporary buffer, whose major mode
is set with `normal-mode' as appropriate for the file type.  The buffer
is subsequently fontified with `font-lock' and converted to HTML.  Note
that, unlike `htmlize-buffer', this function explicitly turns on
font-lock.  If a form of highlighting other than font-lock is desired,
please use `htmlize-buffer' directly on buffers so highlighted.

Buffers currently visiting FILE are unaffected by this function.  The
function does not change current buffer or move the point.

If TARGET is specified and names a directory, the resulting file will be
saved there instead of to FILE's directory.  If TARGET is specified and
does not name a directory, it will be used as output file name.

\(fn FILE &optional TARGET)" t nil)

(autoload 'htmlize-many-files "htmlize" "\
Convert FILES to HTML and save the corresponding HTML versions.

FILES should be a list of file names to convert.  This function calls
`htmlize-file' on each file; see that function for details.  When
invoked interactively, you are prompted for a list of files to convert,
terminated with RET.

If TARGET-DIRECTORY is specified, the HTML files will be saved to that
directory.  Normally, each HTML file is saved to the directory of the
corresponding source file.

\(fn FILES &optional TARGET-DIRECTORY)" t nil)

(autoload 'htmlize-many-files-dired "htmlize" "\
HTMLize dired-marked files.

\(fn ARG &optional TARGET-DIRECTORY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "htmlize" '("htmlize-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hippie-namespace-20140508.2041/hippie-namespace-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hippie-namespace-20140508.2041/hippie-namespace-autoloads.el") (car load-path))))



(let ((loads (get 'hippie-namespace 'custom-loads))) (if (member '"hippie-namespace" loads) nil (put 'hippie-namespace 'custom-loads (cons '"hippie-namespace" loads))))

(let ((loads (get 'hippie-namespace-global 'custom-loads))) (if (member '"hippie-namespace" loads) nil (put 'hippie-namespace-global 'custom-loads (cons '"hippie-namespace" loads))))

(put 'hippie-namespace-local-list 'safe-local-variable 'listp)

(autoload 'hippie-namespace-populate-list "hippie-namespace" "\
Populate `hippie-namespace-computed-list' from buffer contents.

When optional FORCE is set, repopulate even if
`hippie-namespace-computed-list' is already set.

\(fn &optional FORCE)" nil nil)

(autoload 'hippie-namespace-mark-symbol-portion "hippie-namespace" "\
Mark the namespace or non-namespace portion of a symbol under the point.

Intended for use with `expand-region' as an element of
`er/try-expand-list'.

If the point is in the namespace or non-namespace portion of
a symbol, mark only that portion of the symbol.

If the point is in a symbol which does not match a namespace,
there is no effect.

\(fn)" t nil)

(autoload 'hippie-namespace-mode "hippie-namespace" "\
Turn on hippie-namespace-mode.

If called interactively, enable Hippie-Namespace mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When called interactively with no prefix argument this command
toggles the mode.  With a prefix argument, it enables the mode
if the argument is positive and otherwise disables the mode.

When called from Lisp, this command enables the mode if the
argument is omitted or nil, and toggles the mode if the argument
is 'toggle.

\(fn &optional ARG)" t nil)

(defvar global-hippie-namespace-mode nil "\
Non-nil if Global Hippie-Namespace mode is enabled.
See the `global-hippie-namespace-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-hippie-namespace-mode'.")

(custom-autoload 'global-hippie-namespace-mode "hippie-namespace" nil)

(autoload 'global-hippie-namespace-mode "hippie-namespace" "\
Toggle Hippie-Namespace mode in all buffers.
With prefix ARG, enable Global Hippie-Namespace mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Hippie-Namespace mode is enabled in all buffers where
`hippie-namespace-maybe-turn-on' would do it.
See `hippie-namespace-mode' for more information on Hippie-Namespace mode.

\(fn &optional ARG)" t nil)

(autoload 'hippie-namespace-reload "hippie-namespace" "\
Force a refresh of `hippie-namespace-computed-list'.

`hippie-namespace-computed-list' is used by `try-expand-namespace'.

With prefix ARG, also wipe `hippie-namespace-manual-list'.

\(fn ARG)" t nil)

(autoload 'hippie-namespace-add "hippie-namespace" "\
Manually add NAMESPACE to the list available to `try-expand-namespace'.

Modifies `hippie-namespace-manual-list', and refreshes by running
`hippie-namespace-populate-list'.

\(fn NAMESPACE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hippie-namespace" '("he-namespace-beg" "hippie-namespace-" "try-expand-namespace")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hippie-exp-ext-20160502.2326/hippie-exp-ext-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hippie-exp-ext-20160502.2326/hippie-exp-ext-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hippie-exp-ext" '("he-" "hippie-expand-" "try-expand-dabbrev-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-unique-symbol-20130612.542/highlight-unique-symbol-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-unique-symbol-20130612.542/highlight-unique-symbol-autoloads.el") (car load-path))))



(autoload 'highlight-unique-symbol "highlight-unique-symbol" "\
Start highlighting unique symbols

\(fn START)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-unique-symbol" '("highlight-unique-symbol:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-thing-20170919.1404/highlight-thing-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-thing-20170919.1404/highlight-thing-autoloads.el") (car load-path))))



(autoload 'highlight-thing-mode "highlight-thing" "\
Minor mode that highlights things at point

If called interactively, enable Highlight-Thing mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-highlight-thing-mode nil "\
Non-nil if Global Highlight-Thing mode is enabled.
See the `global-highlight-thing-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-highlight-thing-mode'.")

(custom-autoload 'global-highlight-thing-mode "highlight-thing" nil)

(autoload 'global-highlight-thing-mode "highlight-thing" "\
Toggle Highlight-Thing mode in all buffers.
With prefix ARG, enable Global Highlight-Thing mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Thing mode is enabled in all buffers where
`highlight-thing-mode-maybe-activate' would do it.
See `highlight-thing-mode' for more information on Highlight-Thing mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-thing" '("highlight-thing-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-symbol-20160102.2009/highlight-symbol-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-symbol-20160102.2009/highlight-symbol-autoloads.el") (car load-path))))



(autoload 'highlight-symbol-mode "highlight-symbol" "\
Minor mode that highlights the symbol under point throughout the buffer.
Highlighting takes place after `highlight-symbol-idle-delay'.

If called interactively, enable Highlight-Symbol mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defalias 'highlight-symbol-at-point 'highlight-symbol)

(autoload 'highlight-symbol "highlight-symbol" "\
Toggle highlighting of the symbol at point.
This highlights or unhighlights the symbol at point using the first
element in of `highlight-symbol-faces'.

\(fn &optional SYMBOL)" t nil)

(autoload 'highlight-symbol-remove-all "highlight-symbol" "\
Remove symbol highlighting in buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-list-all "highlight-symbol" "\
List all symbols highlighted in the buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-count "highlight-symbol" "\
Print the number of occurrences of symbol at point.

\(fn &optional SYMBOL MESSAGE-P)" t nil)

(autoload 'highlight-symbol-next "highlight-symbol" "\
Jump to the next location of the symbol at point within the buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-prev "highlight-symbol" "\
Jump to the previous location of the symbol at point within the buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-next-in-defun "highlight-symbol" "\
Jump to the next location of the symbol at point within the defun.

\(fn)" t nil)

(autoload 'highlight-symbol-prev-in-defun "highlight-symbol" "\
Jump to the previous location of the symbol at point within the defun.

\(fn)" t nil)

(autoload 'highlight-symbol-nav-mode "highlight-symbol" "\
Navigate occurrences of the symbol at point.

When called interactively, toggle `highlight-symbol-nav-mode'.
With prefix ARG, enable `highlight-symbol-nav-mode' if ARG is
positive, otherwise disable it.

When called from Lisp, enable `highlight-symbol-nav-mode' if ARG
is omitted, nil or positive.  If ARG is `toggle', toggle
`highlight-symbol-nav-mode'.  Otherwise behave as if called
interactively.

In `highlight-symbol-nav-mode' provide the following key bindings
to navigate between occurrences of the symbol at point in the
current buffer.

\\{highlight-symbol-nav-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'highlight-symbol-query-replace "highlight-symbol" "\
Replace the symbol at point with REPLACEMENT.

\(fn REPLACEMENT)" t nil)

(autoload 'highlight-symbol-occur "highlight-symbol" "\
Call `occur' with the symbol at point.
Each line is displayed with NLINES lines before and after, or -NLINES
before if NLINES is negative.

\(fn &optional NLINES)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-symbol" '("highlight-symbol")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-stages-20161212.1457/highlight-stages-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-stages-20161212.1457/highlight-stages-autoloads.el") (car load-path))))



(autoload 'highlight-stages-mode "highlight-stages" "\
Highlight staged (quasi-quoted) expressions

If called interactively, enable Highlight-Stages mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar highlight-stages-global-mode nil "\
Non-nil if Highlight-Stages-Global mode is enabled.
See the `highlight-stages-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `highlight-stages-global-mode'.")

(custom-autoload 'highlight-stages-global-mode "highlight-stages" nil)

(autoload 'highlight-stages-global-mode "highlight-stages" "\
Toggle Highlight-Stages mode in all buffers.
With prefix ARG, enable Highlight-Stages-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Stages mode is enabled in all buffers where
`(lambda nil (highlight-stages-mode 1))' would do it.
See `highlight-stages-mode' for more information on Highlight-Stages mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-stages" '("highlight-stages-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-refontification-20170211.2024/highlight-refontification-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-refontification-20170211.2024/highlight-refontification-autoloads.el") (car load-path))))



(autoload 'highlight-refontification-mode "highlight-refontification" "\
Minor mode that highlight bad whitespace and out-of-place characters.

If called interactively, enable Highlight-Refontification mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-refontification" '("highlight-refontification-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-quoted-20140916.1822/highlight-quoted-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-quoted-20140916.1822/highlight-quoted-autoloads.el") (car load-path))))



(autoload 'highlight-quoted-mode "highlight-quoted" "\
Highlight Lisp quotes and quoted symbols.

Toggle Highlight-Quoted mode on or off.
With a prefix argument ARG, enable Highlight-Quoted mode if ARG is positive, and
disable it otherwise.  If called from Lisp, enable the mode if ARG is omitted or
nil, and toggle it if ARG is `toggle'.
\\{highlight-quoted-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-quoted" '("highlight-quoted-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-parentheses-20180704.1102/highlight-parentheses-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-parentheses-20180704.1102/highlight-parentheses-autoloads.el") (car load-path))))



(autoload 'highlight-parentheses-mode "highlight-parentheses" "\
Minor mode to highlight the surrounding parentheses.

If called interactively, enable Highlight-Parentheses mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-highlight-parentheses-mode nil "\
Non-nil if Global Highlight-Parentheses mode is enabled.
See the `global-highlight-parentheses-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-highlight-parentheses-mode'.")

(custom-autoload 'global-highlight-parentheses-mode "highlight-parentheses" nil)

(autoload 'global-highlight-parentheses-mode "highlight-parentheses" "\
Toggle Highlight-Parentheses mode in all buffers.
With prefix ARG, enable Global Highlight-Parentheses mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Parentheses mode is enabled in all buffers where
`(lambda nil (highlight-parentheses-mode 1))' would do it.
See `highlight-parentheses-mode' for more information on Highlight-Parentheses mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-parentheses" '("hl-paren-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-operators-20170213.2220/highlight-operators-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-operators-20170213.2220/highlight-operators-autoloads.el") (car load-path))))



(autoload 'highlight-operators-mode "highlight-operators" "\
Extra highlighting for operators in programming modes.

If called interactively, enable Highlight-Operators mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-highlight-operators-mode nil "\
Non-nil if Global Highlight-Operators mode is enabled.
See the `global-highlight-operators-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-highlight-operators-mode'.")

(custom-autoload 'global-highlight-operators-mode "highlight-operators" nil)

(autoload 'global-highlight-operators-mode "highlight-operators" "\
Toggle Highlight-Operators mode in all buffers.
With prefix ARG, enable Global Highlight-Operators mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Operators mode is enabled in all buffers where
`(lambda nil (highlight-operators-mode 1))' would do it.
See `highlight-operators-mode' for more information on Highlight-Operators mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-operators" '("highlight-operators-regexp")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-function-calls-20170908.500/highlight-function-calls-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-function-calls-20170908.500/highlight-function-calls-autoloads.el") (car load-path))))



(autoload 'highlight-function-calls-mode "highlight-function-calls" "\
Highlight function calls.

Toggle highlighting of function calls on or off.

With a prefix argument ARG, enable if ARG is positive, and
disable it otherwise. If called from Lisp, enable the mode if ARG
is omitted or nil, and toggle it if ARG is `toggle'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-function-calls" '("highlight-function-calls-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-escape-sequences-20171117.1237/highlight-escape-sequences-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-escape-sequences-20171117.1237/highlight-escape-sequences-autoloads.el") (car load-path))))



(autoload 'turn-on-hes-mode "highlight-escape-sequences" "\
Turn on highlighting of escape sequences.

\(fn)" t nil)

(autoload 'turn-off-hes-mode "highlight-escape-sequences" "\
Turn off highlighting of escape sequences

\(fn)" t nil)

(defvar hes-mode nil "\
Non-nil if Hes mode is enabled.
See the `hes-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `hes-mode'.")

(custom-autoload 'hes-mode "highlight-escape-sequences" nil)

(autoload 'hes-mode "highlight-escape-sequences" "\
Toggle highlighting of escape sequences.

If called interactively, enable Hes mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-escape-sequences" '("hes-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-defined-20141225.1530/highlight-defined-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-defined-20141225.1530/highlight-defined-autoloads.el") (car load-path))))



(autoload 'highlight-defined-mode "highlight-defined" "\
Minor mode for highlighting known Emacs Lisp functions and variables.

Toggle highlight defined mode on or off.

With a prefix argument ARG, enable highlight defined mode if ARG is
positive, and disable it otherwise. If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-defined" '("highlight-defined--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-xref-20180528.1516/helm-xref-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-xref-20180528.1516/helm-xref-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-xref" '("helm-xref-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-rtags-20170813.411/helm-rtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-rtags-20170813.411/helm-rtags-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-rtags" '("create-helm-rtags-source" "helm-rtags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-proc-20161006.305/helm-proc-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-proc-20161006.305/helm-proc-autoloads.el") (car load-path))))



(autoload 'helm-proc "helm-proc" "\
Preconfigured helm for processes.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-proc" '("helm-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-mode-manager-20151124.938/helm-mode-manager-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-mode-manager-20151124.938/helm-mode-manager-autoloads.el") (car load-path))))



(autoload 'helm-enable-minor-mode "helm-mode-manager" "\


\(fn)" t nil)

(autoload 'helm-disable-minor-mode "helm-mode-manager" "\


\(fn)" t nil)

(autoload 'helm-switch-major-mode "helm-mode-manager" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-mode-manager" '("helm-mode-manager-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-gtags-20170116.529/helm-gtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-gtags-20170116.529/helm-gtags-autoloads.el") (car load-path))))



(autoload 'helm-gtags-clear-all-cache "helm-gtags" "\


\(fn)" t nil)

(autoload 'helm-gtags-clear-cache "helm-gtags" "\


\(fn)" t nil)

(autoload 'helm-gtags-next-history "helm-gtags" "\
Jump to next position on context stack

\(fn)" t nil)

(autoload 'helm-gtags-previous-history "helm-gtags" "\
Jump to previous position on context stack

\(fn)" t nil)

(autoload 'helm-gtags-select "helm-gtags" "\


\(fn)" t nil)

(autoload 'helm-gtags-select-path "helm-gtags" "\


\(fn)" t nil)

(autoload 'helm-gtags-tags-in-this-function "helm-gtags" "\
Show tagnames which are referenced in this function and jump to it.

\(fn)" t nil)

(autoload 'helm-gtags-create-tags "helm-gtags" "\


\(fn DIR LABEL)" t nil)

(autoload 'helm-gtags-delete-tags "helm-gtags" "\
Delete file GTAGS, GRTAGS, GPATH, ID etc. generated by gtags.

\(fn)" t nil)

(autoload 'helm-gtags-find-tag "helm-gtags" "\
Jump to definition

\(fn TAG)" t nil)

(autoload 'helm-gtags-find-tag-other-window "helm-gtags" "\
Jump to definition in other window.

\(fn TAG)" t nil)

(autoload 'helm-gtags-find-rtag "helm-gtags" "\
Jump to referenced point

\(fn TAG)" t nil)

(autoload 'helm-gtags-find-symbol "helm-gtags" "\
Jump to the symbol location

\(fn TAG)" t nil)

(autoload 'helm-gtags-find-pattern "helm-gtags" "\
Grep and jump by gtags tag files.

\(fn PATTERN)" t nil)

(autoload 'helm-gtags-find-files "helm-gtags" "\
Find file from tagged with gnu global.

\(fn FILE)" t nil)

(autoload 'helm-gtags-find-tag-from-here "helm-gtags" "\
Jump point by current point information.
Jump to definition point if cursor is on its reference.
Jump to reference point if curosr is on its definition

\(fn)" t nil)

(autoload 'helm-gtags-dwim "helm-gtags" "\
Find by context. Here is
- on include statement then jump to included file
- on symbol definition then jump to its references
- on reference point then jump to its definition.

\(fn)" t nil)

(autoload 'helm-gtags-parse-file "helm-gtags" "\
Parse current file with gnu global. This is similar to `imenu'.
You can jump definitions of functions, symbols in this file.

\(fn)" t nil)

(autoload 'helm-gtags-pop-stack "helm-gtags" "\
Jump to previous point on the context stack and pop it from stack.

\(fn)" t nil)

(autoload 'helm-gtags-show-stack "helm-gtags" "\
Show current context stack.

\(fn)" t nil)

(autoload 'helm-gtags-clear-stack "helm-gtags" "\
Clear current context stack.

\(fn)" t nil)

(autoload 'helm-gtags-clear-all-stacks "helm-gtags" "\
Clear all context stacks.

\(fn)" t nil)

(autoload 'helm-gtags-update-tags "helm-gtags" "\
Update TAG file. Update All files with `C-u' prefix.
Generate new TAG file in selected directory with `C-u C-u'

\(fn)" t nil)

(autoload 'helm-gtags-resume "helm-gtags" "\
Resurrect previously invoked `helm-gtags` command.

\(fn)" t nil)

(autoload 'helm-gtags-mode "helm-gtags" "\
Toggle Helm-Gtags mode on or off.

If called interactively, enable Helm-Gtags mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{helm-gtags-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-gtags" '("helm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-frame-20170515.1950/helm-frame-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-frame-20170515.1950/helm-frame-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-frame" '("helm-frame-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-flymake-20160610.2/helm-flymake-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-flymake-20160610.2/helm-flymake-autoloads.el") (car load-path))))



(autoload 'helm-flymake "helm-flymake" "\
helm interface for flymake.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-flymake" '("helm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-flycheck-20160710.829/helm-flycheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-flycheck-20160710.829/helm-flycheck-autoloads.el") (car load-path))))



(autoload 'helm-flycheck "helm-flycheck" "\
Show flycheck errors with `helm'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-flycheck" '("helm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-etags-plus-20170113.1414/helm-etags-plus-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-etags-plus-20170113.1414/helm-etags-plus-autoloads.el") (car load-path))))



(autoload 'helm-etags-plus-select "helm-etags-plus" "\
Find Tag using `etags' and `helm'

\(fn &optional ARG)" t nil)

(autoload 'helm-etags-plus-history-go-back "helm-etags-plus" "\
Go Back.

\(fn)" t nil)

(autoload 'helm-etags-plus-history-go-forward "helm-etags-plus" "\
Go Forward.

\(fn)" t nil)

(autoload 'helm-etags-plus-history "helm-etags-plus" "\
show all tag historys using `helm'

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-etags-plus" '("helm-etags-plus-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-cscope-20170326.722/helm-cscope-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-cscope-20170326.722/helm-cscope-autoloads.el") (car load-path))))



(autoload 'helm-cscope-find-this-symbol "helm-cscope" "\
Locate a symbol in source code.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-global-definition "helm-cscope" "\
Find a symbol's global definition.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-called-function "helm-cscope" "\
Display functions called by a function.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-calling-this-function "helm-cscope" "\
Display functions calling a function.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-this-text-string "helm-cscope" "\
Locate where a text string occurs.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-egrep-pattern "helm-cscope" "\
Run egrep over the cscope database.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-this-file "helm-cscope" "\
Locate a file.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-files-including-file "helm-cscope" "\
Locate all files #including a file.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-find-assignments-to-this-symbol "helm-cscope" "\
Locate assignments to a symbol in the source code.

\(fn SYMBOL)" t nil)

(autoload 'helm-cscope-mode "helm-cscope" "\
Toggle Helm-Cscope mode on or off.

If called interactively, enable Helm-Cscope mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{helm-cscope-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-cscope" '("helm-cscope-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-company-20180828.1612/helm-company-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-company-20180828.1612/helm-company-autoloads.el") (car load-path))))



(autoload 'helm-company "helm-company" "\
Select `company-complete' candidates by `helm'.
It is useful to narrow candidates.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-company" '("helm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-codesearch-20180204.433/helm-codesearch-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-codesearch-20180204.433/helm-codesearch-autoloads.el") (car load-path))))



(autoload 'helm-codesearch-find-pattern "helm-codesearch" "\
Find pattern.

\(fn)" t nil)

(autoload 'helm-codesearch-find-file "helm-codesearch" "\
Find file.

\(fn)" t nil)

(autoload 'helm-codesearch-create-csearchindex "helm-codesearch" "\
Create index file at DIR.

\(fn DIR)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-codesearch" '("helm-codesearch-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/edn-20160215.1219/edn-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/edn-20160215.1219/edn-autoloads.el") (car load-path))))



(autoload 'edn-time-to-inst "edn" "\
Turn a `time-date' TIME into our internal representation of an inst.

\(fn TIME)" nil nil)

(autoload 'edn-inst-to-time "edn" "\
Turn an `edn-inst', INST, into a TIME from `time-date'.

\(fn INST)" nil nil)

(autoload 'edn-string-to-uuid "edn" "\
Create an `edn-uuid' from a string, S, containing a uuid.

\(fn S)" nil nil)

(autoload 'edn-uuid-to-string "edn" "\
Turn our internal representation of a UUID into a string.

\(fn UUID)" nil nil)

(autoload 'edn-read "edn" "\
Read one edn value from SOURCE.

SOURCE is either a string of edn data or nil.  If no source is
given the next edn value will be read from POINT in the current
buffer.

You can use `edn-add-reader' to add your own readers for unknown
tags.

\(fn &optional SOURCE)" nil nil)

(autoload 'edn-list-to-set "edn" "\
Turn a list into `edn''s internal set representation.

If COMPARE-FN is provided this function is used to uniquify the
list.  Otherwise it's expected that l is without duplicates.

\(fn L &optional COMPARE-FN)" nil nil)

(autoload 'edn-set-to-list "edn" "\
Turn `edn''s internal set representation into a list.

\(fn S)" nil nil)

(autoload 'edn-add-reader "edn" "\
Add a READER function for TAG.

TAG is either a string, symbol or keyword. e.g. :my/type

\(fn TAG READER)" nil nil)

(autoload 'edn-add-writer "edn" "\
Add a WRITER function for types satisfying PRED.

\(fn PRED WRITER)" nil nil)

(autoload 'edn-remove-reader "edn" "\
Remove a previously registered handler for TAG.

\(fn TAG)" nil nil)

(autoload 'edn-remove-writer "edn" "\
The remove the writer WRITER.

\(fn WRITER)" nil nil)

(autoload 'edn-print-string "edn" "\
Serialize the lisp form DATUM into edn.

You can use `edn-add-writer' to add writers capable of writing
your own tagged data.

\(fn DATUM)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "edn" '("edn--" "hash-table-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-clojuredocs-20160405.723/helm-clojuredocs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-clojuredocs-20160405.723/helm-clojuredocs-autoloads.el") (car load-path))))



(autoload 'helm-clojuredocs "helm-clojuredocs" "\
Preconfigured `helm' for searching in clojuredocs.org

\(fn)" t nil)

(autoload 'helm-clojuredocs-at-point "helm-clojuredocs" "\
Preconfigured `helm' for searching in clojuredocs.org with symbol at point

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-clojuredocs" '("helm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-cider-history-20150719.2120/helm-cider-history-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-cider-history-20150719.2120/helm-cider-history-autoloads.el") (car load-path))))



(autoload 'helm-cider-history "helm-cider-history" "\
Show `cider-input-history` in `helm`.

\(fn)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-cider-20180307.458/helm-cider-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-cider-20180307.458/helm-cider-autoloads.el") (car load-path))))



(autoload 'helm-cider-apropos-symbol "helm-cider" "\
Choose Clojure symbols across namespaces.

Each Helm source is a Clojure namespace (ns), and candidates are
symbols in the namespace.

If both NS and SYMBOL are supplied, puts selection line on
first SYMBOL of NS.

If NS is supplied, puts the selection line on the first
candidate of source with name NS.

If SYMBOL is supplied, puts the selection line on the
first candidate matching SYMBOL.

If neither NS nor SYMBOL is supplied, tries to put the
selection line on candidate matching symbol at point.

If DOC is true, include symbol documentation in candidate.

If FULL-DOC is true, include full instead of short documentation.

Set `helm-cider-apropos-follow' to true to turn on function
`helm-follow-mode' for all sources.  This is useful for quickly
browsing documentation.

\(fn &optional NS SYMBOL DOC FULL-DOC)" t nil)

(autoload 'helm-cider-apropos-symbol-doc "helm-cider" "\
Choose Clojure SYMBOLs, with docs, across namespaces.

Optional arguments NS and SYMBOL are as in
`helm-cider-apropos-symbol'.

\(fn &optional NS SYMBOL)" t nil)

(autoload 'helm-cider-apropos-ns "helm-cider" "\
Choose Clojure namespace to call Helm CIDER apropos on.

NS-OR-QUALIFIED-NAME is a Clojure
namespace (e.g. \"clojure.core\") or a qualified symbol
name (e.g. \"clojure.core/reduce\").  If supplied, it is used as
the default selection.

\(fn &optional NS-OR-QUALIFIED-NAME)" t nil)

(autoload 'helm-cider-apropos "helm-cider" "\
Helm interface to CIDER apropos.

If ARG is raw prefix argument \\[universal-argument], include
symbol documentation.

If ARG is raw prefix argument \\[universal-argument]
\\[universal-argument], choose namespace before symbol.

\(fn &optional ARG)" t nil)

(defvar helm-cider-mode nil "\
Non-nil if Helm-Cider mode is enabled.
See the `helm-cider-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-cider-mode'.")

(custom-autoload 'helm-cider-mode "helm-cider" nil)

(autoload 'helm-cider-mode "helm-cider" "\
Use Helm for CIDER.

If called interactively, enable Helm-Cider mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-cider" '("helm-cider-")))



(autoload 'helm-cider-cheatsheet "helm-cider-cheatsheet" "\
Use Helm to show a Clojure cheatsheet.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-cider-cheatsheet" '("helm-cider-cheatsheet--")))



(autoload 'helm-cider-repl-history-insert "helm-cider-repl" "\
Insert candidate at the last CIDER REPL prompt.

Existing input at the prompt is cleared.

This function is meant to be one of `helm-cider-repl-history-actions'.

\(fn CANDIDATE)" nil nil)

(autoload 'helm-cider-repl-history-delete "helm-cider-repl" "\
Delete marked candidates from `cider-repl-input-history'.

This function is meant to be one of `helm-cider-repl-history-actions'.

\(fn CANDIDATE)" nil nil)

(autoload 'helm-cider-repl-history "helm-cider-repl" "\
Helm interface to CIDER REPL history.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-cider-repl" '("helm-cider-repl-")))



(autoload 'helm-cider-spec-symbol "helm-cider-spec" "\
Choose Clojure specs across namespaces.

Each Helm source is a Clojure namespace (ns), and candidates are
spec keywords in the namespace.

If both NS and NAME are supplied, puts selection line on
first NAME of NS.

If NS is supplied, puts the selection line on the first
candidate of source with name NS.

If NAME is supplied, puts the selection line on the
first candidate matching NAME.

Set `helm-cider-spec-follow' to non-nil to turn on function
`helm-follow-mode' for all sources.  This is useful for quickly
viewing specs.

\(fn &optional NS NAME)" t nil)

(autoload 'helm-cider-spec-ns "helm-cider-spec" "\
Choose spec namespace to call `helm-cider-browse-spec' on.

KW-NS-OR-QUALIFIED-NAME is a spec keyword namespace
 (e.g. \":ring.core\") or a qualified keyword
name (e.g. \":ring.core/error\").  If supplied, it is used as the
default selection.

\(fn &optional KW-NS-OR-QUALIFIED-NAME)" t nil)

(autoload 'helm-cider-spec "helm-cider-spec" "\
Helm interface to CIDER specs.

If ARG is raw prefix argument \\[universal-argument]
\\[universal-argument], choose namespace before symbol.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-cider-spec" '("helm-cider-spec-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-cider-util" '("helm-cider--" "wrap-helm-cider-action")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-c-yasnippet-20170128.1542/helm-c-yasnippet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-c-yasnippet-20170128.1542/helm-c-yasnippet-autoloads.el") (car load-path))))



(autoload 'helm-yas-complete "helm-c-yasnippet" "\
List of yasnippet snippets using `helm' interface.

\(fn)" t nil)

(autoload 'helm-yas-visit-snippet-file "helm-c-yasnippet" "\
List of yasnippet snippet files

\(fn)" t nil)

(autoload 'helm-yas-create-snippet-on-region "helm-c-yasnippet" "\
Create a snippet from region.

\(fn &optional START END FILE-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-c-yasnippet" '("helm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/google-c-style-20180130.1736/google-c-style-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/google-c-style-20180130.1736/google-c-style-autoloads.el") (car load-path))))



(defconst google-c-style `((c-recognize-knr-p) (c-enable-xemacs-performance-kludge-p . t) (c-basic-offset . 2) (indent-tabs-mode) (c-comment-only-line-offset . 0) (c-hanging-braces-alist (defun-open after) (defun-close before after) (class-open after) (class-close before after) (inexpr-class-open after) (inexpr-class-close before) (namespace-open after) (inline-open after) (inline-close before after) (block-open after) (block-close . c-snug-do-while) (extern-lang-open after) (extern-lang-close after) (statement-case-open after) (substatement-open after)) (c-hanging-colons-alist (case-label) (label after) (access-label after) (member-init-intro before) (inher-intro)) (c-hanging-semi&comma-criteria c-semi&comma-no-newlines-for-oneline-inliners c-semi&comma-inside-parenlist c-semi&comma-no-newlines-before-nonblanks) (c-indent-comments-syntactically-p . t) (comment-column . 40) (c-indent-comment-alist (other space . 2)) (c-cleanup-list brace-else-brace brace-elseif-brace brace-catch-brace empty-defun-braces defun-close-semi list-close-comma scope-operator) (c-offsets-alist (arglist-intro google-c-lineup-expression-plus-4) (func-decl-cont . ++) (member-init-intro . ++) (inher-intro . ++) (comment-intro . 0) (arglist-close . c-lineup-arglist) (topmost-intro . 0) (block-open . 0) (inline-open . 0) (substatement-open . 0) (statement-cont ,(when (fboundp 'c-no-indent-after-java-annotations) 'c-no-indent-after-java-annotations) ,(when (fboundp 'c-lineup-assignments) 'c-lineup-assignments) ++) (label . /) (case-label . +) (statement-case-open . +) (statement-case-intro . +) (access-label . /) (innamespace . 0))) "\
Google C/C++ Programming Style.")

(autoload 'google-set-c-style "google-c-style" "\
Set the current buffer's c-style to Google C/C++ Programming
  Style. Meant to be added to `c-mode-common-hook'.

\(fn)" t nil)

(autoload 'google-make-newline-indent "google-c-style" "\
Sets up preferred newline behavior. Not set by default. Meant
  to be added to `c-mode-common-hook'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "google-c-style" '("google-c-lineup-expression-plus-4")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/golden-ratio-scroll-screen-20170224.229/golden-ratio-scroll-screen-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/golden-ratio-scroll-screen-20170224.229/golden-ratio-scroll-screen-autoloads.el") (car load-path))))



(autoload 'golden-ratio-scroll-screen-up "golden-ratio-scroll-screen" "\
scroll half screen up

\(fn)" t nil)

(autoload 'golden-ratio-scroll-screen-down "golden-ratio-scroll-screen" "\
scroll half screen down

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "golden-ratio-scroll-screen" '("golden-ratio-scroll-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gnome-c-style-0.1/gnome-c-style-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gnome-c-style-0.1/gnome-c-style-autoloads.el") (car load-path))))



(autoload 'gnome-c-align-arglist-at-point "gnome-c-align" "\
Reformat argument list at point, aligning argument to the right end.

\(fn &optional IDENTIFIER-START-COLUMN)" t nil)

(autoload 'gnome-c-align-set-column "gnome-c-align" "\
Set alignment column of SYMBOL.

\(fn SYMBOL)" t nil)

(autoload 'gnome-c-align-guess-optimal-columns "gnome-c-align" "\
Compute the optimal alignment rule from the declarations in BEG and END.

This sets `gnome-c-align-identifier-start-column',
`gnome-c-align-arglist-start-column', and
`gnome-c-align-arglist-identifier-start-column'.

\(fn BEG END)" t nil)

(autoload 'gnome-c-align-guess-columns "gnome-c-align" "\
Guess the existing alignment rule from the declarations in BEG and END.

This sets `gnome-c-align-identifier-start-column',
`gnome-c-align-arglist-start-column', and
`gnome-c-align-arglist-identifier-start-column'.

\(fn BEG END)" t nil)

(autoload 'gnome-c-align-decls-region "gnome-c-align" "\
Reformat function declarations in the region between BEG and END.

\(fn BEG END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gnome-c-align" '("gnome-c-align-")))



(autoload 'gnome-c-snippet-insert-package_class "gnome-c-snippet" "\
Insert the class name before the current point.

\(fn PACKAGE CLASS)" t nil)

(autoload 'gnome-c-snippet-insert-PACKAGE_CLASS "gnome-c-snippet" "\
Insert the class name before the current point.

\(fn PACKAGE CLASS)" t nil)

(autoload 'gnome-c-snippet-insert-PackageClass "gnome-c-snippet" "\
Insert the class name (in CamelCase) before the current point.

\(fn PACKAGE CLASS)" t nil)

(autoload 'gnome-c-snippet-insert "gnome-c-snippet" "\


\(fn SNIPPET)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gnome-c-snippet" '("gnome-c-snippet-")))



(autoload 'gnome-c-style-mode "gnome-c-style" "\
A minor-mode for editing GNOME-style C source code.

If called interactively, enable GNOME-C-Style mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gnome-c-style" '("gnome-c-style-mode-map")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gnome-c-tests" '("gnome-c-test-program-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gited-0.5.3/gited-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gited-0.5.3/gited-autoloads.el") (car load-path))))



(autoload 'gited-list-branches "gited" "\
List all branches or tags for the current repository.
Optional arg PATTERN if non-nil, then must be \"local\", \"remote\",
 or \"tags\".  That lists local branches, remote branches and tags,
 respectively.  When PATTERN is nil, then list the local branches.
Optional arg OTHER-WINDOW means to display the Gited buffer in another window.
Optional arg UPDATE if non-nil, then force to update the gited buffer.
 Otherwise, just switch to the Gited buffer if already exists.
When called interactively prompt for PATTERN.
When called interactively with a prefix set OTHER-WINDOW non-nil.

\(fn &optional PATTERN OTHER-WINDOW UPDATE)" t nil)

(defalias 'gited-list 'gited-list-branches)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gited" '("gited-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gited-ci" '("gited-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gitconfig-mode-20180318.1956/gitconfig-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gitconfig-mode-20180318.1956/gitconfig-mode-autoloads.el") (car load-path))))



(autoload 'gitconfig-mode "gitconfig-mode" "\
A major mode for editing .gitconfig files.

\(fn)" t nil)

(dolist (pattern '("/\\.gitconfig\\'" "/\\.git/config\\'" "/modules/.*/config\\'" "/git/config\\'" "/\\.gitmodules\\'" "/etc/gitconfig\\'")) (add-to-list 'auto-mode-alist (cons pattern 'gitconfig-mode)))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitconfig-mode" '("gitconfig-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gitconfig-20130718.935/gitconfig-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gitconfig-20130718.935/gitconfig-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitconfig" '("gitconfig-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-wip-timemachine-20150408.1006/git-wip-timemachine-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-wip-timemachine-20150408.1006/git-wip-timemachine-autoloads.el") (car load-path))))



(autoload 'git-wip-timemachine "git-wip-timemachine" "\
Enable git-wip timemachine for file of current buffer.

\(fn)" t nil)

(autoload 'git-wip-timemachine-toggle "git-wip-timemachine" "\
Toggle `git-wip-timemachine' mode.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-wip-timemachine" '("git-wip-timemachine-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-timemachine-20180607.820/git-timemachine-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-timemachine-20180607.820/git-timemachine-autoloads.el") (car load-path))))



(autoload 'git-timemachine-toggle "git-timemachine" "\
Toggle git timemachine mode.

\(fn)" t nil)

(autoload 'git-timemachine "git-timemachine" "\
Enable git timemachine for file of current buffer.

\(fn)" t nil)

(autoload 'git-timemachine-switch-branch "git-timemachine" "\
Enable git timemachine for current buffer, switching to GIT-BRANCH.

\(fn GIT-BRANCH)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-timemachine" '("git-timemachine-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-msg-prefix-20180118.1446/git-msg-prefix-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-msg-prefix-20180118.1446/git-msg-prefix-autoloads.el") (car load-path))))



(autoload 'git-msg-prefix "git-msg-prefix" "\
Insert the relevant part of the chosen commit.
Relevant meaning the result of `git-msg-prefix-regex'
substitution.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-msg-prefix" '("git-msg-prefix-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-messenger-20170102.440/git-messenger-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-messenger-20170102.440/git-messenger-autoloads.el") (car load-path))))



(autoload 'git-messenger:popup-message "git-messenger" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-messenger" '("git-messenger")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-link-20180708.1643/git-link-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-link-20180708.1643/git-link-autoloads.el") (car load-path))))



(autoload 'git-link "git-link" "\
Create a URL representing the current buffer's location in its
GitHub/Bitbucket/GitLab/... repository at the current line number
or active region. The URL will be added to the kill ring. If
`git-link-open-in-browser' is non-`nil' also call `browse-url'.

With a prefix argument prompt for the remote's name.
Defaults to \"origin\".

\(fn REMOTE START END)" t nil)

(autoload 'git-link-commit "git-link" "\
Create a URL representing the commit for the hash under point
in the current buffer's GitHub/Bitbucket/GitLab/...
repository. The URL will be added to the kill ring.

With a prefix argument prompt for the remote's name.
Defaults to \"origin\".

\(fn REMOTE)" t nil)

(autoload 'git-link-homepage "git-link" "\
Create a URL for the current buffer's REMOTE repository homepage.
The URL will be added to the kill ring.  If `git-link-open-in-browser'
is non-nil also call `browse-url'.

\(fn REMOTE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-link" '("git-link-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-lens-20180328.1417/git-lens-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-lens-20180328.1417/git-lens-autoloads.el") (car load-path))))



(autoload 'git-lens "git-lens" "\
Start git lens.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-lens" '("git-lens-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-io-20180317.1752/git-io-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-io-20180317.1752/git-io-autoloads.el") (car load-path))))



(autoload 'git-io-shorten "git-io" "\
Replace thing at point with shortened URL.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-io" '("git-io-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-dwim-20170126.1214/git-dwim-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-dwim-20170126.1214/git-dwim-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-dwim" '("gd-" "git-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-command-20160111.1303/git-command-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-command-20160111.1303/git-command-autoloads.el") (car load-path))))



(autoload 'git-command "git-command" "\
Invoke git shell command.
While running git command, $GIT_EDITOR and $GIT_PAGER are set to use emacsclient
to open files and get outputs.

CMD is shell command string to run.
Called interactively, asks users what shell command to invoke.

If NEW-BUFFER-P is non-nil, generate new buffer for running command.
Interactively, give prefix argument for new buffer.

\(fn CMD &optional NEW-BUFFER-P)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-command" '("git-command-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-auto-commit-mode-20161229.1617/git-auto-commit-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-auto-commit-mode-20161229.1617/git-auto-commit-mode-autoloads.el") (car load-path))))



(autoload 'git-auto-commit-mode "git-auto-commit-mode" "\
Automatically commit any changes made when saving with this
mode turned on and optionally push them too.

If called interactively, enable Git-Auto-Commit mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-auto-commit-mode" '("gac-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-attr-20180925.2003/git-attr-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-attr-20180925.2003/git-attr-autoloads.el") (car load-path))))



(autoload 'git-attr "git-attr" "\
Get git attributes for current buffer file and set in buffer local variable `git-attr'.

\(fn)" t nil)

(autoload 'git-attr-get "git-attr" "\
Get the git attribute named ATTR for the file in current buffer.

 * t for git attributes with the value `set'
 * nil for git attributes with the value `unset'
 * 'undecided for git attributes that are `unspecified'
 * and the value if the git attribute is set to a value

\(fn ATTR)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-attr" '("git-attr")))



(autoload 'git-attr-linguist "git-attr-linguist" "\
Make vendored and generated files read only.

\(fn)" nil nil)

(add-hook 'find-file-hook 'git-attr-linguist)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-attr-linguist" '("git-attr-linguist-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-20140128.1041/git-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-20140128.1041/git-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git" '("git-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ggtags-20180725.1713/ggtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ggtags-20180725.1713/ggtags-autoloads.el") (car load-path))))



(autoload 'ggtags-find-project "ggtags" "\


\(fn)" nil nil)

(autoload 'ggtags-find-tag-dwim "ggtags" "\
Find NAME by context.
If point is at a definition tag, find references, and vice versa.
If point is at a line that matches `ggtags-include-pattern', find
the include file instead.

When called interactively with a prefix arg, always find
definition tags.

\(fn NAME &optional WHAT)" t nil)

(autoload 'ggtags-mode "ggtags" "\
Toggle Ggtags mode on or off.

If called interactively, enable Ggtags mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{ggtags-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'ggtags-build-imenu-index "ggtags" "\
A function suitable for `imenu-create-index-function'.

\(fn)" nil nil)

(autoload 'ggtags-try-complete-tag "ggtags" "\
A function suitable for `hippie-expand-try-functions-list'.

\(fn OLD)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ggtags" '("ggtags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/fuzzy-20150730.337/fuzzy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/fuzzy-20150730.337/fuzzy-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fuzzy" '("fuzzy-" "turn-o")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/function-args-20171031.1704/function-args-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/function-args-20171031.1704/function-args-autoloads.el") (car load-path))))



(autoload 'function-args-mode "function-args" "\
Minor mode for C++ code completion bindings.

If called interactively, enable Function-Args mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{function-args-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'fa-config-default "function-args" "\
Set up default key bindings.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "function-args" '("fa-" "filter" "function-args-mode-map" "moo-" "turn-on-function-args-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "semantic-directory" '("sd-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/foreign-regexp-20180224.1121/foreign-regexp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/foreign-regexp-20180224.1121/foreign-regexp-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "foreign-regexp" '("foreign-regexp/")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/font-lock-studio-20170127.2051/font-lock-studio-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/font-lock-studio-20170127.2051/font-lock-studio-autoloads.el") (car load-path))))



(autoload 'font-lock-studio "font-lock-studio" "\
Interactively debug the font-lock keywords of the current buffer.

With \\[universal-argument] prefix, create a new, unique, interface buffer.

\(fn &optional ARG)" t nil)

(autoload 'font-lock-studio-region "font-lock-studio" "\
Interactively debug the font-lock keywords in the region.

With \\[universal-argument] prefix, create a new, unique, interface buffer.

\(fn BEG END &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "font-lock-studio" '("font-lock-studio-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/font-lock-profiler-20170208.2008/font-lock-profiler-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/font-lock-profiler-20170208.2008/font-lock-profiler-autoloads.el") (car load-path))))



(autoload 'font-lock-profiler-region "font-lock-profiler" "\
Profile font-lock from BEG to END and present report.

\(fn BEG END)" t nil)

(autoload 'font-lock-profiler-buffer "font-lock-profiler" "\
Profile font-locking buffer and present report.

\(fn)" t nil)

(autoload 'font-lock-profiler-start "font-lock-profiler" "\
Start recording font-lock profiling information.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "font-lock-profiler" '("font-lock-profiler-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/font-lock+-20170222.1755/font-lock+-autoloads.el"))
(add-to-list 'load-path (directory-file-name (or (file-name-directory "/home/lk/.emacs.d/elpa/font-lock+-20170222.1755/font-lock+-autoloads.el") (car load-path))))



)
(let ((load-file-name "/home/lk/.emacs.d/elpa/fn-20170210.204/fn-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/fn-20170210.204/fn-autoloads.el") (car load-path))))



(autoload 'fn "fn" "\
Return a function defined by BODY.

Intended for inline use where concision is desired.  If creating a function to
bind as a function value, use `lambda' or `-lambda'.

The definition BODY may use anaphoric parameters to refer to the arguments. For
a single-argument function, <> can be used. For a multiple-argument function,
use <1> to refer to the first argument, <2> to refer to the second, and so on
up to <9>. The parameter <rest> refers to a list containing the (n+1)st and
later arguments, where <n> is the highest numerical parameter supplied.

If applied to a literal, creates a constant function, or equivalently, a thunk
\(since it can be called with any number of arguments).

Examples:

  (-map (fn (* <> <>)) (number-sequence 0 10))
  ;; (0 1 4 9 16 25 36 49 64 81 100)

  (-map (fn (/ (-sum <>)
               (length <>)))
        '((3.0 4.0 5.0 5.0 10.0)
          (1.5 2.5 2.0)
          (1 5)))
  ;; (5.4 2.0 3)
  ;; find average of each list

  (-filter (fn (zerop (mod <> 3)))
           (number-sequence 1 10))
  ;; (3 6 9)

  (funcall (fn 7))
  ;; 7

  (funcall (fn (-map #'list <rest>)) 1 2 3 4)
  ;; ((1) (2) (3) (4))

\(fn &rest BODY)" nil t)

(autoload 'fn: "fn" "\
Return a function defined by (BODY).

Intended for inline use where concision is desired.  If creating a function to
bind as a function value, use `lambda' or `-lambda'.

Identical to `fn' except that BODY is automatically parenthesized.

The definition BODY may use the anaphoric parameter <> for the sole argument,
or <1> ... <9> to refer to multiple positional arguments. The parameter
<rest> refers to a list containing the (n+1)st and later arguments, where <n> is
the highest numerical parameter supplied.

Examples:

  (-map (fn: * <> <>) (number-sequence 0 10))
  ;; (0 1 4 9 16 25 36 49 64 81 100)

  (-filter (fn: > <> 0)
           '(-5 2 0 0 3 -1 0 4))
  ;; (2 3 4)

\(fn &rest BODY)" nil t)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flyparens-20140723.1846/flyparens-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flyparens-20140723.1846/flyparens-autoloads.el") (car load-path))))



(autoload 'flyparens-mode "flyparens" "\
 FlyParens

If called interactively, enable Flyparens mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flyparens" '("flyparens-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flyparens-config-example-1" '("my-flyparens-function")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-easy-20140818.755/flymake-easy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-easy-20140818.755/flymake-easy-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-easy" '("flymake-easy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-shell-20170723.146/flymake-shell-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-shell-20170723.146/flymake-shell-autoloads.el") (car load-path))))



(autoload 'flymake-shell-load "flymake-shell" "\
Configure flymake mode to check the current buffer's shell-script syntax.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-shell" '("flymake-shell-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-rust-20170729.2139/flymake-rust-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-rust-20170729.2139/flymake-rust-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-rust" '("flymake-rust-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-racket-20180912.109/flymake-racket-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-racket-20180912.109/flymake-racket-autoloads.el") (car load-path))))



(autoload 'flymake-racket-setup "flymake-racket" "\
Set up Flymake for Racket.

\(fn)" t nil)

(autoload 'flymake-racket-add-hook "flymake-racket" "\
Add `flymake-racket-lint' to `flymake-diagnostic-functions'.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-racket" '("flymake-racket-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-gradle-20180924.200/flymake-gradle-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-gradle-20180924.200/flymake-gradle-autoloads.el") (car load-path))))



(autoload 'flymake-gradle-setup "flymake-gradle" "\
Set up Flymake for Gradle.

\(fn)" t nil)

(autoload 'flymake-gradle-add-hook "flymake-gradle" "\
Add `flymake-gradle-lint' to `flymake-diagnostic-functions'.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-gradle" '("flymake-gradle-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-google-cpplint-20140205.1325/flymake-google-cpplint-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-google-cpplint-20140205.1325/flymake-google-cpplint-autoloads.el") (car load-path))))



(autoload 'flymake-google-cpplint-load "flymake-google-cpplint" "\
Configure flymake mode to check the current buffer's C/C++ source.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-google-cpplint" '("flymake-google-cpplint-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-cursor-20120322.1757/flymake-cursor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-cursor-20120322.1757/flymake-cursor-autoloads.el") (car load-path))))



(autoload 'flymake-cursor-mode "flymake-cursor" "\
Minor mode to show `flymake-mode' errors for the current line in the
message area.
When called interactively, toggles the minor mode.
With arg, turn Flymake Cursor mode on if and only if arg is positive.

Usually `flymake-cursor-mode' is enabled and disabled automatically with
`flymake-mode' for the current buffer and you will not need to toggle
the mode directly.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-cursor" '("flymake-cursor-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-cppcheck-20140415.1257/flymake-cppcheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-cppcheck-20140415.1257/flymake-cppcheck-autoloads.el") (car load-path))))



(autoload 'flymake-cppcheck-load "flymake-cppcheck" "\
Configure flymake mode to check the current buffer's C/C++ source.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-cppcheck" '("flymake-cppcheck-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-ycmd-20180207.1643/flycheck-ycmd-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-ycmd-20180207.1643/flycheck-ycmd-autoloads.el") (car load-path))))



(autoload 'flycheck-ycmd-setup "flycheck-ycmd" "\
Convenience function to setup the ycmd flycheck checker.

This adds a hook to watch for ycmd parse results, and it adds the
ycmd checker to the list of flycheck checkers.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-ycmd" '("flycheck-ycmd--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-tip-20171020.1048/flycheck-tip-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-tip-20171020.1048/flycheck-tip-autoloads.el") (car load-path))))



(autoload 'error-tip-error-p "error-tip" "\
Return non-nil if error is occurred in current buffer.
This function can catch error against flycheck, and flymake.

\(fn)" nil nil)

(autoload 'error-tip-cycle-dwim "error-tip" "\
Showing error function.
This function switches proper error showing function by context.
 (whether flycheck or flymake) The REVERSE option jumps by inverse if
the value is non-nil.

\(fn &optional REVERSE)" t nil)

(autoload 'error-tip-cycle-dwim-reverse "error-tip" "\
Same as ‘error-tip-cycle-dwim’, but it jumps to inverse direction.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "error-tip" '("error-tip-")))



(autoload 'flycheck-tip-cycle "flycheck-tip" "\
Move to next error if it's exists.
If it wasn't exists then move to previous error.
Move to previous error if REVERSE is non-nil.

\(fn &optional REVERSE)" t nil)

(autoload 'flycheck-tip-cycle-reverse "flycheck-tip" "\
Do `flycheck-tip-cycle by reverse order.

\(fn)" t nil)

(autoload 'flycheck-tip--get "flycheck-tip" "\


\(fn ELEMENT ERR)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-tip" '("flycheck-tip-")))



(autoload 'flymake-tip-cycle "flymake-tip" "\


\(fn REVERSE)" t nil)

(autoload 'flymake-tip-cycle-reverse "flymake-tip" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-tip" '("flymake-tip--err-info-function")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-swiftlint-20180830.340/flycheck-swiftlint-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-swiftlint-20180830.340/flycheck-swiftlint-autoloads.el") (car load-path))))



(autoload 'flycheck-swiftlint-setup "flycheck-swiftlint" "\
Setup Flycheck for Swiftlint.

\(fn)" t nil)

(autoload 'flycheck-swiftlint-autocorrect "flycheck-swiftlint" "\
Automatically fix Swiftlint errors.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-swiftlint" '("flycheck-swiftlint-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-rust-20180904.1117/flycheck-rust-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-rust-20180904.1117/flycheck-rust-autoloads.el") (car load-path))))



(autoload 'flycheck-rust-setup "flycheck-rust" "\
Setup Rust in Flycheck.

If the current file is part of a Cargo project, configure
Flycheck according to the Cargo project layout.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-rust" '("flycheck-rust-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-rtags-20180619.824/flycheck-rtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-rtags-20180619.824/flycheck-rtags-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-rtags" '("flycheck-rtags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-posframe-20180322.607/flycheck-posframe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-posframe-20180322.607/flycheck-posframe-autoloads.el") (car load-path))))



(autoload 'flycheck-posframe-configure-pretty-defaults "flycheck-posframe" "\
Configure some nicer settings for prettier display.

\(fn)" nil nil)

(autoload 'flycheck-posframe-mode "flycheck-posframe" "\
A minor mode to show Flycheck error messages in a posframe.

If called interactively, enable Flycheck-Posframe mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-posframe" '("flycheck-posframe-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-pos-tip-20180610.1615/flycheck-pos-tip-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-pos-tip-20180610.1615/flycheck-pos-tip-autoloads.el") (car load-path))))



(defvar flycheck-pos-tip-mode nil "\
Non-nil if Flycheck-Pos-Tip mode is enabled.
See the `flycheck-pos-tip-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `flycheck-pos-tip-mode'.")

(custom-autoload 'flycheck-pos-tip-mode "flycheck-pos-tip" nil)

(autoload 'flycheck-pos-tip-mode "flycheck-pos-tip" "\
A minor mode to show Flycheck error messages in a popup.

When called interactively, toggle `flycheck-pos-tip-mode'.  With
prefix ARG, enable `flycheck-pos-tip-mode' if ARG is positive,
otherwise disable it.

When called from Lisp, enable `flycheck-pos-tip-mode' if ARG is
omitted, nil or positive.  If ARG is `toggle', toggle
`flycheck-pos-tip-mode'.  Otherwise behave as if called
interactively.

In `flycheck-pos-tip-mode' show Flycheck's error messages in a
GUI tooltip.  Falls back to `flycheck-display-error-messages' on
TTY frames.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-pos-tip" '("flycheck-pos-tip-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-popup-tip-20170812.2351/flycheck-popup-tip-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-popup-tip-20170812.2351/flycheck-popup-tip-autoloads.el") (car load-path))))



(autoload 'flycheck-popup-tip-mode "flycheck-popup-tip" "\
A minor mode to show Flycheck error messages in a popup.

If called interactively, enable Flycheck-Popup-Tip mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-popup-tip" '("flycheck-popup-tip-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-pkg-config-20180430.2243/flycheck-pkg-config-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-pkg-config-20180430.2243/flycheck-pkg-config-autoloads.el") (car load-path))))



(autoload 'flycheck-pkg-config "flycheck-pkg-config" "\
Configure flycheck to use additional includes
when checking the current buffer.

\(fn LIB-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-pkg-config" '("flycheck-pkg-config--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-joker-20180913.504/flycheck-joker-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-joker-20180913.504/flycheck-joker-autoloads.el") (car load-path))))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-irony-20180604.2152/flycheck-irony-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-irony-20180604.2152/flycheck-irony-autoloads.el") (car load-path))))



(autoload 'flycheck-irony-setup "flycheck-irony" "\
Setup Flycheck Irony.

Add `irony' to `flycheck-checkers'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-irony" '("flycheck-irony-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-inline-20180821.849/flycheck-inline-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-inline-20180821.849/flycheck-inline-autoloads.el") (car load-path))))



(defvar flycheck-inline-mode nil "\
Non-nil if Flycheck-Inline mode is enabled.
See the `flycheck-inline-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `flycheck-inline-mode'.")

(custom-autoload 'flycheck-inline-mode "flycheck-inline" nil)

(autoload 'flycheck-inline-mode "flycheck-inline" "\
A minor mode to show Flycheck error messages line.

When called interactively, toggle `flycheck-inline-mode'.  With
prefix ARG, enable `flycheck-inline-mode' if ARG is positive,
otherwise disable it.

When called from Lisp, enable `flycheck-inline-mode' if ARG is
omitted, nil or positive.  If ARG is `toggle', toggle
`flycheck-inline-mode'.  Otherwise behave as if called
interactively.

In `flycheck-inline-mode', show Flycheck error messages inline,
directly below the error reported location.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-inline" '("flycheck-inline-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-cstyle-20160905.2341/flycheck-cstyle-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-cstyle-20160905.2341/flycheck-cstyle-autoloads.el") (car load-path))))



(autoload 'flycheck-cstyle-setup "flycheck-cstyle" "\
Setup flycheck-cstyle.

Add `cstyle' to `flycheck-checkers'.

\(fn)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-color-mode-line-20171122.707/flycheck-color-mode-line-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-color-mode-line-20171122.707/flycheck-color-mode-line-autoloads.el") (car load-path))))



(autoload 'flycheck-color-mode-line-mode "flycheck-color-mode-line" "\
Minor mode to color the mode line with the Flycheck status.

When called interactively, toggle
`flycheck-color-mode-line-mode'.  With prefix ARG, enable
`flycheck-color-mode-line-mode' if ARG is positive, otherwise
disable it.

When called from Lisp, enable `flycheck-color-mode-line-mode' if ARG is omitted,
nil or positive.  If ARG is `toggle', toggle `flycheck-color-mode-line-mode'.
Otherwise behave as if called interactively.

\(fn &optional ARG)" t nil)

(custom-add-frequent-value 'flycheck-mode-hook 'flycheck-color-mode-line-mode)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-color-mode-line" '("flycheck-color-mode-line-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clojure-20180721.1412/flycheck-clojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clojure-20180721.1412/flycheck-clojure-autoloads.el") (car load-path))))



(autoload 'flycheck-clojure-parse-cider-errors "flycheck-clojure" "\
Parse cider errors from JSON VALUE from CHECKER.

Return a list of parsed `flycheck-error' objects.

\(fn VALUE CHECKER)" nil nil)

(autoload 'flycheck-clojure-setup "flycheck-clojure" "\
Setup Flycheck for Clojure.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clojure" '("cider-flycheck-eval" "flycheck-clojure-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clangcheck-20150712.710/flycheck-clangcheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clangcheck-20150712.710/flycheck-clangcheck-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clangcheck" '("flycheck-clangcheck-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clang-tidy-20171024.808/flycheck-clang-tidy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clang-tidy-20171024.808/flycheck-clang-tidy-autoloads.el") (car load-path))))



(autoload 'flycheck-clang-tidy-setup "flycheck-clang-tidy" "\
Setup Flycheck clang-tidy.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clang-tidy" '("flycheck-clang-tidy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clang-analyzer-20180917.1425/flycheck-clang-analyzer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clang-analyzer-20180917.1425/flycheck-clang-analyzer-autoloads.el") (car load-path))))



(autoload 'flycheck-clang-analyzer-setup "flycheck-clang-analyzer" "\
Setup flycheck-clang-analyzer.

Add `clang-analyzer' to `flycheck-checkers'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clang-analyzer" '("flycheck-clang-analyzer--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-checkbashisms-20160224.1706/flycheck-checkbashisms-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-checkbashisms-20160224.1706/flycheck-checkbashisms-autoloads.el") (car load-path))))



(autoload 'flycheck-checkbashisms-setup "flycheck-checkbashisms" "\
Setup Flycheck checkbashisms.
Add `sh-checkbashisms' to the end of `flycheck-checkers'.

\(fn)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flx-20151030.1812/flx-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flx-20151030.1812/flx-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flx" '("flx-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flx-isearch-20180103.514/flx-isearch-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flx-isearch-20180103.514/flx-isearch-autoloads.el") (car load-path))))



(autoload 'flx-isearch-forward "flx-isearch" "\
Start a fuzzy forward isearch

\(fn &optional REGEXP-P NO-RECURSIVE-EDIT)" t nil)

(autoload 'flx-isearch-backward "flx-isearch" "\
Start a fuzzy backward isearch

\(fn &optional REGEXP-P NO-RECURSIVE-EDIT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flx-isearch" '("flx-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flx-ido-20180117.1519/flx-ido-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flx-ido-20180117.1519/flx-ido-autoloads.el") (car load-path))))



(defvar flx-ido-mode nil "\
Non-nil if Flx-Ido mode is enabled.
See the `flx-ido-mode' command
for a description of this minor mode.")

(custom-autoload 'flx-ido-mode "flx-ido" nil)

(autoload 'flx-ido-mode "flx-ido" "\
Toggle flx ido mode

If called interactively, enable Flx-Ido mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flx-ido" '("flx-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/evalator-20160213.128/evalator-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/evalator-20160213.128/evalator-autoloads.el") (car load-path))))



(autoload 'evalator-insert-equiv-expr "evalator" "\
Insert the equivalent expression of the previous evalator session into the current buffer.

\(fn)" t nil)

(autoload 'evalator-resume "evalator" "\
Resume last evalator session.

\(fn)" t nil)

(autoload 'evalator "evalator" "\
Start an evalator session.

Function accepts an optional MODE keyword and a CONTEXT symbol.

If MODE is non-nil and a currently supported mode value then that mode
will be used for the session.

Below are currently supported values for MODE:

`:explicit'

If MODE is nil evalator will start in normal mode.

If CONTEXT is non-nil, then the result of calling CONTEXT's function
definition will be used as the session's evaluation context.

If CONTEXT is nil, then the current buffer's major mode will be
searched for in `evalator-config-mode-context-alist'.  If a match is
found, the context associated with that major mode is used in the
evalator session.  If no match is found, an elisp evaluation context
is used instead.

\(fn &optional MODE CONTEXT)" t nil)

(autoload 'evalator-explicit "evalator" "\
Helper function to start an evalator-session in explicit mode.

In explicit mode the data generated will always be represented as a
single candidate.  This is the only mode that allows an equivalent
expression of the session to be generated through
`evalator-insert-equiv-expr'.

\(fn &optional CONTEXT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator" '("evalator-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-config" '("evalator-config-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-context" '("evalator-context")))



(autoload 'evalator-elisp-context "evalator-elisp" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-elisp" '("evalator-elisp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-history" '("evalator-history")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-key-map" '("evalator-key-map")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-state" '("evalator-state")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-utils" '("evalator-utils-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/evalator-clojure-20160208.2148/evalator-clojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/evalator-clojure-20160208.2148/evalator-clojure-autoloads.el") (car load-path))))



(autoload 'evalator-clojure-context "evalator-clojure" "\


\(fn)" nil nil)

(autoload 'evalator-clojure "evalator-clojure" "\


\(fn &optional MODE)" t nil)

(autoload 'evalator-clojure-explicit "evalator-clojure" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-clojure" '("evalator-clojure-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eval-sexp-fu-20180510.203/eval-sexp-fu-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eval-sexp-fu-20180510.203/eval-sexp-fu-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-sexp-fu" '("define-e" "esf-" "eval-sexp-fu-" "turn-on-eval-sexp-fu-flash-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/avy-20181001.837/avy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/avy-20181001.837/avy-autoloads.el") (car load-path))))



(autoload 'avy-goto-char "avy" "\
Jump to the currently visible CHAR.
The window scope is determined by `avy-all-windows' (ARG negates it).

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-char-in-line "avy" "\
Jump to the currently visible CHAR in the current line.

\(fn CHAR)" t nil)

(autoload 'avy-goto-char-2 "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

\(fn CHAR1 CHAR2 &optional ARG BEG END)" t nil)

(autoload 'avy-goto-char-2-above "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR1 CHAR2 &optional ARG)" t nil)

(autoload 'avy-goto-char-2-below "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR1 CHAR2 &optional ARG)" t nil)

(autoload 'avy-isearch "avy" "\
Jump to one of the current isearch candidates.

\(fn)" t nil)

(autoload 'avy-goto-word-0 "avy" "\
Jump to a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

\(fn ARG &optional BEG END)" t nil)

(autoload 'avy-goto-word-1 "avy" "\
Jump to the currently visible CHAR at a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.
When SYMBOL is non-nil, jump to symbol start instead of word start.

\(fn CHAR &optional ARG BEG END SYMBOL)" t nil)

(autoload 'avy-goto-word-1-above "avy" "\
Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-word-1-below "avy" "\
Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1 "avy" "\
Jump to the currently visible CHAR at a symbol start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1-above "avy" "\
Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1-below "avy" "\
Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-subword-0 "avy" "\
Jump to a word or subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).

When PREDICATE is non-nil it's a function of zero parameters that
should return true.

BEG and END narrow the scope where candidates are searched.

\(fn &optional ARG PREDICATE BEG END)" t nil)

(autoload 'avy-goto-subword-1 "avy" "\
Jump to the currently visible CHAR at a subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).
The case of CHAR is ignored.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-word-or-subword-1 "avy" "\
Forward to `avy-goto-subword-1' or `avy-goto-word-1'.
Which one depends on variable `subword-mode'.

\(fn)" t nil)

(autoload 'avy-goto-line "avy" "\
Jump to a line start in current buffer.

When ARG is 1, jump to lines currently visible, with the option
to cancel to `goto-line' by entering a number.

When ARG is 4, negate the window scope determined by
`avy-all-windows'.

Otherwise, forward to `goto-line' with ARG.

\(fn &optional ARG)" t nil)

(autoload 'avy-goto-line-above "avy" "\
Goto visible line above the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

\(fn &optional OFFSET BOTTOM-UP)" t nil)

(autoload 'avy-goto-line-below "avy" "\
Goto visible line below the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

\(fn &optional OFFSET BOTTOM-UP)" t nil)

(autoload 'avy-goto-end-of-line "avy" "\
Call `avy-goto-line' and move to the end of the line.

\(fn &optional ARG)" t nil)

(autoload 'avy-copy-line "avy" "\
Copy a selected line above the current line.
ARG lines can be used.

\(fn ARG)" t nil)

(autoload 'avy-move-line "avy" "\
Move a selected line above the current line.
ARG lines can be used.

\(fn ARG)" t nil)

(autoload 'avy-copy-region "avy" "\
Select two lines and copy the text between them to point.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

\(fn ARG)" t nil)

(autoload 'avy-move-region "avy" "\
Select two lines and move the text between them above the current line.

\(fn)" t nil)

(autoload 'avy-kill-region "avy" "\
Select two lines and kill the region between them.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

\(fn ARG)" t nil)

(autoload 'avy-kill-ring-save-region "avy" "\
Select two lines and save the region between them to the kill ring.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn ARG)" t nil)

(autoload 'avy-kill-whole-line "avy" "\
Select line and kill the whole selected line.

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\\[universal-argument] 3 \\[avy-kil-whole-line] kill three lines
starting from the selected line.  \\[universal-argument] -3

\\[avy-kill-whole-line] kill three lines backward including the
selected line.

\(fn ARG)" t nil)

(autoload 'avy-kill-ring-save-whole-line "avy" "\
Select line and save the whole selected line as if killed, but don’t kill it.

This command is similar to `avy-kill-whole-line', except that it
saves the line(s) as if killed, but does not kill it(them).

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\(fn ARG)" t nil)

(autoload 'avy-setup-default "avy" "\
Setup the default shortcuts.

\(fn)" nil nil)

(autoload 'avy-goto-char-timer "avy" "\
Read one or many consecutive chars and jump to the first one.
The window scope is determined by `avy-all-windows' (ARG negates it).

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "avy" '("avy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ace-window-20181008.1549/ace-window-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ace-window-20181008.1549/ace-window-autoloads.el") (car load-path))))



(autoload 'ace-select-window "ace-window" "\
Ace select window.

\(fn)" t nil)

(autoload 'ace-delete-window "ace-window" "\
Ace delete window.

\(fn)" t nil)

(autoload 'ace-swap-window "ace-window" "\
Ace swap window.

\(fn)" t nil)

(autoload 'ace-delete-other-windows "ace-window" "\
Ace delete other windows.

\(fn)" t nil)

(autoload 'ace-window "ace-window" "\
Select a window.
Perform an action based on ARG described below.

By default, behaves like extended `other-window'.

Prefixed with one \\[universal-argument], does a swap between the
selected window and the current window, so that the selected
buffer moves to current window (and current buffer moves to
selected window).

Prefixed with two \\[universal-argument]'s, deletes the selected
window.

\(fn ARG)" t nil)

(defvar ace-window-display-mode nil "\
Non-nil if Ace-Window-Display mode is enabled.
See the `ace-window-display-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ace-window-display-mode'.")

(custom-autoload 'ace-window-display-mode "ace-window" nil)

(autoload 'ace-window-display-mode "ace-window" "\
Minor mode for showing the ace window key in the mode line.

If called interactively, enable Ace-Window-Display mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ace-window" '("ace-window-mode" "aw-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eval-in-repl-20171122.1343/eval-in-repl-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eval-in-repl-20171122.1343/eval-in-repl-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl" '("eir-")))



(autoload 'eir-eval-in-cider "eval-in-repl-cider" "\
eval-in-repl for cider.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-cider" '("eir-")))



(autoload 'eir-eval-in-elm "eval-in-repl-elm" "\
Provides eval-in-repl for Elm.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-elm" '("eir-send-to-elm")))



(autoload 'eir-eval-in-erlang "eval-in-repl-erlang" "\
Provides eval-in-repl for Erlang.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-erlang" '("eir-send-to-erlang")))



(autoload 'eir-eval-in-geiser "eval-in-repl-geiser" "\
eval-in-repl for Geiser.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-geiser" '("eir-send-to-geiser")))



(autoload 'eir-eval-in-hy "eval-in-repl-hy" "\
eval-in-repl for Hy.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-hy" '("eir-")))



(autoload 'eir-eval-in-ielm "eval-in-repl-ielm" "\
eval-in-repl for IELM.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-ielm" '("eir-")))



(autoload 'eir-eval-in-iex "eval-in-repl-iex" "\
Provides eval-in-repl for Elixir.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-iex" '("eir-send-to-iex")))



(autoload 'eir-eval-in-javascript "eval-in-repl-javascript" "\
eval-in-repl for Javascript.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-javascript" '("eir-send-to-javascript")))



(autoload 'eir-eval-in-lua "eval-in-repl-lua" "\
eval-in-repl for Lua.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-lua" '("eir-send-to-lua" "eval-in-repl-run-lua")))



(autoload 'eir-eval-in-ocaml "eval-in-repl-ocaml" "\
eval-in-repl for OCaml.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-ocaml" '("eir-send-to-ocaml")))



(autoload 'eir-eval-in-prolog "eval-in-repl-prolog" "\
eval-in-repl for SWI Prolog.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-prolog" '("eir-send-to-prolog")))



(autoload 'eir-eval-in-python "eval-in-repl-python" "\
eval-in-repl for Python.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-python" '("eir-")))



(autoload 'eir-eval-in-racket "eval-in-repl-racket" "\
eval-in-repl for Racket.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-racket" '("eir-send-to-racket")))



(autoload 'eir-eval-in-ruby "eval-in-repl-ruby" "\
eval-in-repl for Ruby.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-ruby" '("eir-send-to-ruby")))



(autoload 'eir-eval-in-scala "eval-in-repl-scala" "\
Provides eval-in-repl for Scala.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-scala" '("eir-send-to-scala")))



(autoload 'eir-eval-in-scheme "eval-in-repl-scheme" "\
eval-in-repl for Scheme.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-scheme" '("eir-send-to-scheme")))



(autoload 'eir-eval-in-shell "eval-in-repl-shell" "\
eval-in-repl for shell.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-shell" '("eir-send-to-shell")))



(autoload 'eir-eval-in-slime "eval-in-repl-slime" "\
eval-in-repl for SLIME.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-slime" '("eir-send-to-slime")))



(autoload 'eir-eval-in-sml "eval-in-repl-sml" "\
eval-in-repl for Standard ML.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-sml" '("eir-send-to-sml")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eval-expr-20120619.647/eval-expr-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eval-expr-20120619.647/eval-expr-autoloads.el") (car load-path))))



(defvar eval-expr-error-message-delay 3 "\
*Amount of time, in seconds, to display in echo area before continuing.")

(custom-autoload 'eval-expr-error-message-delay "eval-expr" t)

(defvar eval-expr-prompt "Eval: " "\
*Prompt used by eval-expr.")

(custom-autoload 'eval-expr-prompt "eval-expr" t)

(defvar eval-expr-honor-debug-on-error t "\
*If non-nil, do not trap evaluation errors.
Instead, allow errors to throw user into the debugger, provided
debug-on-error specifies that the particular error is a debuggable condition.")

(custom-autoload 'eval-expr-honor-debug-on-error "eval-expr" t)

(defvar eval-expr-use-echo-area-or-buffer 1 "\
*Preference for when to use echo area of a temporary buffer for results.

If set to t or `buffer', always put results into a temporary buffer.
If set to `nil' or `echo-area', always display results in echo area.
If an integer N, use the echo area unless the results would require more
than N lines to display; in that case, use a temporary buffer.

Some versions of emacs can display arbitrarily large output in the echo
area by dynamically resizing it, so a temporary buffer is not necessary
unless you expect the output to exceed the limits of the resize thresholds
or want to be able to edit the results.")

(custom-autoload 'eval-expr-use-echo-area-or-buffer "eval-expr" t)

(defvar eval-expr-print-level (cond ((boundp 'eval-expression-print-level) (default-value 'eval-expression-print-level)) ((boundp 'print-level) (default-value 'print-level))) "\
*Like print-level, but affect results printed by `eval-expr' only.")

(custom-autoload 'eval-expr-print-level "eval-expr" t)

(defvar eval-expr-print-length (cond ((boundp 'eval-expression-print-length) (default-value 'eval-expression-print-length)) ((boundp 'print-length) (default-value 'print-length))) "\
*Like print-length, but affect results printed by `eval-expr' only.")

(custom-autoload 'eval-expr-print-length "eval-expr" t)

(defvar eval-expr-print-function (if (fboundp 'pp) 'pp 'prin1) "\
*Function to use for printing objects.
E.g. this can be set to `pp' to generate pretty-printed results,
or `prin1' for unformatted results.")

(custom-autoload 'eval-expr-print-function "eval-expr" t)

(autoload 'eval-expr-install "eval-expr" "\
Replace standard eval-expression command with enhanced eval-expr.

\(fn)" t nil)

(autoload 'eval-expr "eval-expr" "\
Evaluate EXPRESSION and print value in minibuffer, temp, or current buffer.
A temp output buffer is used if there is more than one line in the
evaluated result.
If invoked with a prefix arg, or second lisp argument EE::INSERT-VALUE is
non-nil, then insert final value into the current buffer at point.

Value is also consed on to front of the variable `values'.

\(fn EE::EXPRESSION &optional EE::INSERT-VALUE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-expr" '("eval-expr-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eterm-256color-20180520.1223/eterm-256color-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eterm-256color-20180520.1223/eterm-256color-autoloads.el") (car load-path))))



(autoload 'eterm-256color-mode "eterm-256color" "\
Minor mode that adds 256color support to term/ansi-term.

If called interactively, enable Eterm-256color mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eterm-256color" '("eterm-256color-" "term-terminal-previous-parameter-2")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/es-lib-20141111.1830/es-lib-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/es-lib-20141111.1830/es-lib-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-buffer-local-set-key" '("es-buffer-local-")))



(autoload 'es-kill-buffer-dont-ask "es-lib-core-functions" "\


\(fn &optional BUFFER)" t nil)

(autoload 'es-find-function-bound-to "es-lib-core-functions" "\


\(fn KEY-SEQUENCE)" t nil)

(autoload 'es-push-line "es-lib-core-functions" "\
beginning-of-line + open line.

\(fn)" t nil)

(autoload 'es-jump-line "es-lib-core-functions" "\
end-of-line + newline.

\(fn)" t nil)

(autoload 'es-new-empty-buffer "es-lib-core-functions" "\


\(fn)" t nil)

(defvar es-highlighter-colors '("DeepPink" "cyan" "MediumPurple1" "SpringGreen1" "DarkOrange" "HotPink1" "RoyalBlue1" "OliveDrab"))

(autoload 'es-mouse-copy-symbol "es-lib-core-functions" "\


\(fn EVENT)" t nil)

(autoload 'es-mouse-yank-replace-symbol "es-lib-core-functions" "\


\(fn EVENT)" t nil)

(autoload 'es-c-expand-region "es-lib-core-functions" "\
A simplee version of expand-region for c-like languages.
Marks the symbol on first call, then marks the statement.

\(fn)" t nil)

(autoload 'es-comment-dwim "es-lib-core-functions" "\


\(fn &optional ARG)" t nil)

(autoload 'es-ido-like-helm "es-lib-core-functions" "\
Choose from a concatenated list of buffers and recent files.

\(fn &optional THIS-MODE-ONLY)" t nil)

(autoload 'es-ido-like-helm "es-lib-core-functions" "\
Choose from a concatenated list of buffers and recent files.

\(fn &optional THIS-MODE-ONLY)" t nil)

(autoload 'es-manage-unsaved-buffers "es-lib-core-functions" "\
Similar to what happends when emacs is about to quit.

\(fn)" t nil)

(autoload 'es-query-replace-symbol-at-point "es-lib-core-functions" "\


\(fn)" t nil)

(autoload 'es-ack-replace-symbol "es-lib-core-functions" "\
Repalace symbol at point, or region contents in multiple
files.

\(fn FROM-SYMBOL-OR-STRING TO-SYMBOL-OR-STRING &key DIRECTORY AUTO-SAVE FINISH-FUNC SILENT)" t nil)

(autoload 'es-ack-pin-folder "es-lib-core-functions" "\
Set ack root directory for one buffer only.
Ack won't prompt for a directory name in that buffer.

\(fn FOLDER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-core-functions" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-core-macros" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-lexical" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-readme-generator" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-text-navigate" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-total-line" '("es-total-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elmacro-20180628.1411/elmacro-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elmacro-20180628.1411/elmacro-autoloads.el") (car load-path))))



(autoload 'elmacro-show-last-macro "elmacro" "\
Show the last macro as emacs lisp with NAME.

\(fn NAME)" t nil)

(autoload 'elmacro-show-last-commands "elmacro" "\
Take the latest COUNT commands and show them as emacs lisp.

This is basically a better version of `kmacro-edit-lossage'.

The default number of commands shown is modifiable in variable
`elmacro-show-last-commands-default'.

You can also modify this number by using a numeric prefix argument or
by using the universal argument, in which case it'll ask for how many
in the minibuffer.

\(fn &optional COUNT)" t nil)

(autoload 'elmacro-clear-command-history "elmacro" "\
Clear the list of recorded commands.

\(fn)" t nil)

(defvar elmacro-mode nil "\
Non-nil if elmacro mode is enabled.
See the `elmacro-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `elmacro-mode'.")

(custom-autoload 'elmacro-mode "elmacro" nil)

(autoload 'elmacro-mode "elmacro" "\
Toggle emacs activity recording (elmacro mode).
With a prefix argument ARG, enable elmacro mode if ARG is
positive, and disable it otherwise. If called from Lisp, enable
the mode if ARG is omitted or nil.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elmacro" '("elmacro-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elisp-sandbox-20131116.1842/elisp-sandbox-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elisp-sandbox-20131116.1842/elisp-sandbox-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elisp-sandbox" '("elisp-sandbox" "sandbox")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elisp-lint-20180224.2042/elisp-lint-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elisp-lint-20180224.2042/elisp-lint-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elisp-lint" '("elisp-lint-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elf-mode-20161009.748/elf-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elf-mode-20161009.748/elf-mode-autoloads.el") (car load-path))))



(autoload 'elf-mode "elf-mode" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elf-mode" '("elf-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elein-20120120.1116/elein-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elein-20120120.1116/elein-autoloads.el") (car load-path))))



(autoload 'elein-swank "elein" "\
Launch lein swank and connect slime to it.  Interactively, a
PREFIX means launch a standalone swank session without a
project.

\(fn &optional PREFIX)" t nil)

(autoload 'elein-kill-swank "elein" "\
Kill swank process started by lein swank.

\(fn)" t nil)

(autoload 'elein-reswank "elein" "\
Kill current lisp, restart lein swank and connect slime to it.

\(fn)" t nil)

(autoload 'elein-run-cmd "elein" "\
Run 'lein ARGS' using `compile' in the project root directory.

\(fn ARGS)" t nil)

(autoload 'elein-run-task "elein" "\
Run 'lein TASK' using `compile' in the project root directory.

\(fn TASK)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elein" '("elein-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eldoc-eval-20180607.1157/eldoc-eval-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eldoc-eval-20180607.1157/eldoc-eval-autoloads.el") (car load-path))))



(defvar eldoc-in-minibuffer-mode nil "\
Non-nil if Eldoc-In-Minibuffer mode is enabled.
See the `eldoc-in-minibuffer-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `eldoc-in-minibuffer-mode'.")

(custom-autoload 'eldoc-in-minibuffer-mode "eldoc-eval" nil)

(autoload 'eldoc-in-minibuffer-mode "eldoc-eval" "\
Show eldoc for current minibuffer input.

If called interactively, enable Eldoc-In-Minibuffer mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'eldoc-eval-expression "eldoc-eval" "\
Eval expression with eldoc support in mode-line.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eldoc-eval" '("eldoc-" "with-eldoc-in-minibuffer")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/el-sprunge-20140107.139/el-sprunge-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/el-sprunge-20140107.139/el-sprunge-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-sprunge" '("el-sprunge-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ctable-20171006.11/ctable-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ctable-20171006.11/ctable-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ctable" '("ctbl:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/anaphora-20180618.2200/anaphora-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/anaphora-20180618.2200/anaphora-autoloads.el") (car load-path))))



(let ((loads (get 'anaphora 'custom-loads))) (if (member '"anaphora" loads) nil (put 'anaphora 'custom-loads (cons '"anaphora" loads))))

(defvar anaphora-use-long-names-only nil "\
Use only long names such as `anaphoric-if' instead of traditional `aif'.")

(custom-autoload 'anaphora-use-long-names-only "anaphora" t)

(defun anaphora--install-traditional-aliases (&optional arg) "\
Install traditional short aliases for anaphoric macros.

With negative numeric ARG, remove traditional aliases." (let ((syms '((if . t) (prog1 . t) (prog2 . t) (when . when) (while . t) (and . t) (cond . cond) (lambda . lambda) (block . block) (case . case) (ecase . ecase) (typecase . typecase) (etypecase . etypecase) (let . let) (+ . t) (- . t) (* . t) (/ . t)))) (cond ((and (numberp arg) (< arg 0)) (dolist (cell syms) (when (ignore-errors (eq (symbol-function (intern-soft (format "a%s" (car cell)))) (intern-soft (format "anaphoric-%s" (car cell))))) (fmakunbound (intern (format "a%s" (car cell))))))) (t (dolist (cell syms) (let* ((builtin (car cell)) (traditional (intern (format "a%s" builtin))) (long (intern (format "anaphoric-%s" builtin)))) (defalias traditional long) (put traditional 'lisp-indent-function (get builtin 'lisp-indent-function)) (put traditional 'edebug-form-spec (cdr cell))))))))

(unless anaphora-use-long-names-only (anaphora--install-traditional-aliases))

(autoload 'anaphoric-if "anaphora" "\
Like `if', but the result of evaluating COND is bound to `it'.

The variable `it' is available within THEN and ELSE.

COND, THEN, and ELSE are otherwise as documented for `if'.

\(fn COND THEN &rest ELSE)" nil t)

(function-put 'anaphoric-if 'lisp-indent-function '2)

(autoload 'anaphoric-prog1 "anaphora" "\
Like `prog1', but the result of evaluating FIRST is bound to `it'.

The variable `it' is available within BODY.

FIRST and BODY are otherwise as documented for `prog1'.

\(fn FIRST &rest BODY)" nil t)

(function-put 'anaphoric-prog1 'lisp-indent-function '1)

(autoload 'anaphoric-prog2 "anaphora" "\
Like `prog2', but the result of evaluating FORM2 is bound to `it'.

The variable `it' is available within BODY.

FORM1, FORM2, and BODY are otherwise as documented for `prog2'.

\(fn FORM1 FORM2 &rest BODY)" nil t)

(function-put 'anaphoric-prog2 'lisp-indent-function '2)

(autoload 'anaphoric-when "anaphora" "\
Like `when', but the result of evaluating COND is bound to `it'.

The variable `it' is available within BODY.

COND and BODY are otherwise as documented for `when'.

\(fn COND &rest BODY)" nil t)

(function-put 'anaphoric-when 'lisp-indent-function '1)

(autoload 'anaphoric-while "anaphora" "\
Like `while', but the result of evaluating TEST is bound to `it'.

The variable `it' is available within BODY.

TEST and BODY are otherwise as documented for `while'.

\(fn TEST &rest BODY)" nil t)

(function-put 'anaphoric-while 'lisp-indent-function '1)

(autoload 'anaphoric-and "anaphora" "\
Like `and', but the result of the previous condition is bound to `it'.

The variable `it' is available within all CONDITIONS after the
initial one.

CONDITIONS are otherwise as documented for `and'.

Note that some implementations of this macro bind only the first
condition to `it', rather than each successive condition.

\(fn &rest CONDITIONS)" nil t)

(autoload 'anaphoric-cond "anaphora" "\
Like `cond', but the result of each condition is bound to `it'.

The variable `it' is available within the remainder of each of CLAUSES.

CLAUSES are otherwise as documented for `cond'.

\(fn &rest CLAUSES)" nil t)

(autoload 'anaphoric-lambda "anaphora" "\
Like `lambda', but the function may refer to itself as `self'.

ARGS and BODY are otherwise as documented for `lambda'.

\(fn ARGS &rest BODY)" nil t)

(function-put 'anaphoric-lambda 'lisp-indent-function 'defun)

(autoload 'anaphoric-block "anaphora" "\
Like `block', but the result of the previous expression is bound to `it'.

The variable `it' is available within all expressions of BODY
except the initial one.

NAME and BODY are otherwise as documented for `block'.

\(fn NAME &rest BODY)" nil t)

(function-put 'anaphoric-block 'lisp-indent-function '1)

(autoload 'anaphoric-case "anaphora" "\
Like `case', but the result of evaluating EXPR is bound to `it'.

The variable `it' is available within CLAUSES.

EXPR and CLAUSES are otherwise as documented for `case'.

\(fn EXPR &rest CLAUSES)" nil t)

(function-put 'anaphoric-case 'lisp-indent-function '1)

(autoload 'anaphoric-ecase "anaphora" "\
Like `ecase', but the result of evaluating EXPR is bound to `it'.

The variable `it' is available within CLAUSES.

EXPR and CLAUSES are otherwise as documented for `ecase'.

\(fn EXPR &rest CLAUSES)" nil t)

(function-put 'anaphoric-ecase 'lisp-indent-function '1)

(autoload 'anaphoric-typecase "anaphora" "\
Like `typecase', but the result of evaluating EXPR is bound to `it'.

The variable `it' is available within CLAUSES.

EXPR and CLAUSES are otherwise as documented for `typecase'.

\(fn EXPR &rest CLAUSES)" nil t)

(function-put 'anaphoric-typecase 'lisp-indent-function '1)

(autoload 'anaphoric-etypecase "anaphora" "\
Like `etypecase', but result of evaluating EXPR is bound to `it'.

The variable `it' is available within CLAUSES.

EXPR and CLAUSES are otherwise as documented for `etypecase'.

\(fn EXPR &rest CLAUSES)" nil t)

(function-put 'anaphoric-etypecase 'lisp-indent-function '1)

(autoload 'anaphoric-let "anaphora" "\
Like `let', but the result of evaluating FORM is bound to `it'.

FORM and BODY are otherwise as documented for `let'.

\(fn FORM &rest BODY)" nil t)

(function-put 'anaphoric-let 'lisp-indent-function '1)

(autoload 'anaphoric-+ "anaphora" "\
Like `+', but the result of evaluating the previous expression is bound to `it'.

The variable `it' is available within all expressions after the
initial one.

NUMBERS-OR-MARKERS are otherwise as documented for `+'.

\(fn &rest NUMBERS-OR-MARKERS)" nil t)

(autoload 'anaphoric-- "anaphora" "\
Like `-', but the result of evaluating the previous expression is bound to `it'.

The variable `it' is available within all expressions after the
initial one.

NUMBER-OR-MARKER and NUMBERS-OR-MARKERS are otherwise as
documented for `-'.

\(fn &optional NUMBER-OR-MARKER &rest NUMBERS-OR-MARKERS)" nil t)

(autoload 'anaphoric-* "anaphora" "\
Like `*', but the result of evaluating the previous expression is bound to `it'.

The variable `it' is available within all expressions after the
initial one.

NUMBERS-OR-MARKERS are otherwise as documented for `*'.

\(fn &rest NUMBERS-OR-MARKERS)" nil t)

(autoload 'anaphoric-/ "anaphora" "\
Like `/', but the result of evaluating the previous divisor is bound to `it'.

The variable `it' is available within all expressions after the
first divisor.

DIVIDEND, DIVISOR, and DIVISORS are otherwise as documented for `/'.

\(fn DIVIDEND DIVISOR &rest DIVISORS)" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "anaphora" '("anaphora-install-font-lock-keywords")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/el-init-20150728.920/el-init-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/el-init-20150728.920/el-init-autoloads.el") (car load-path))))



(autoload 'el-init-provide "el-init" "\
Call `provide' with the file name as a feature name.

\(fn)" nil nil)

(autoload 'el-init-load "el-init" "\
Load configuration files in DIRECTORY with `require'.

DIRECTORY is a path of a directory which is root of configuration files.
SUBDIRECTORIES is a list of subdirectories of DIRECTORY; its element is
a string or a list like (\"path\" t).
 means including all the directories in \"path\".
OVERRIDE-ONLY-INIT-FILES is a flag to use overridden `require' only for
configuration files.
OVERRIDE is a flag to use overridden `require' when `require' called in
configuration files.

The mechanism:
- Add SUBDIRECTORIES to `load-path'
- Call `require' for all the configure files in SUBDIRECTORIES

\(fn DIRECTORY &key (SUBDIRECTORIES el-init-subdirectories) (WRAPPERS el-init-wrappers) (OVERRIDE-ONLY-INIT-FILES el-init-override-only-init-files-p) (OVERRIDE el-init-overridep))" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-init" '("el-init-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/el-init-viewer-20150303.828/el-init-viewer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/el-init-viewer-20150303.828/el-init-viewer-autoloads.el") (car load-path))))



(autoload 'el-init-viewer "el-init-viewer" "\


\(fn)" t nil)

(autoload 'el-init-viewer-eval-after-load "el-init-viewer" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-init-viewer" '("el-init-viewer-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/el-get-20181006.225/el-get-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/el-get-20181006.225/el-get-autoloads.el") (car load-path))))



(autoload 'el-get-version "el-get" "\
Message the current el-get version

\(fn)" t nil)

(autoload 'el-get-install "el-get" "\
Cause the named PACKAGE to be installed after all of its
dependencies (if any).

PACKAGE may be either a string or the corresponding symbol.

\(fn PACKAGE)" t nil)

(autoload 'el-get-update "el-get" "\
Update PACKAGE.

\(fn PACKAGE)" t nil)

(autoload 'el-get-update-all "el-get" "\
Performs update of all installed packages.

\(fn &optional NO-PROMPT)" t nil)

(autoload 'el-get-update-packages-of-type "el-get" "\
Update all installed packages of type TYPE.

\(fn TYPE)" t nil)

(autoload 'el-get-self-update "el-get" "\
Update el-get itself.  The standard recipe takes care of reloading the code.

\(fn)" t nil)

(autoload 'el-get-remove "el-get" "\
Remove any PACKAGE that is know to be installed or required.

\(fn PACKAGE)" t nil)

(autoload 'el-get-reinstall "el-get" "\
Remove PACKAGE and then install it again.

\(fn PACKAGE)" t nil)

(autoload 'el-get-cd "el-get" "\
Open dired in the package directory.

\(fn PACKAGE)" t nil)

(autoload 'el-get-make-recipes "el-get" "\
Loop over `el-get-sources' and write a recipe file for each
entry which is not a symbol and is not already a known recipe.

\(fn &optional DIR)" t nil)

(autoload 'el-get-checksum "el-get" "\
Compute the checksum of the given package, and put it in the kill-ring

\(fn PACKAGE)" t nil)

(autoload 'el-get-self-checksum "el-get" "\
Compute the checksum of the running version of el-get itself.

Also put the checksum in the kill-ring.

\(fn)" t nil)

(autoload 'el-get "el-get" "\
Ensure that packages have been downloaded once and init them as needed.

This will not update the sources by using `apt-get install' or
`git pull', but it will ensure that:

* the packages have been installed
* load-path is set so their elisp files can be found
* Info-directory-list is set so their info files can be found
* Autoloads have been prepared and evaluated for each package
* Any post-installation setup (e.g. `(require 'feature)') happens

When SYNC is nil (the default), all installations run
concurrently, in the background.

When SYNC is 'sync, each package will be installed synchronously,
and any error will stop it all.

Please note that the `el-get-init' part of `el-get' is always
done synchronously. There's `byte-compile' support though, and
the packages you use are welcome to use `autoload' too.

PACKAGES is expected to be a list of packages you want to install
or init.  When PACKAGES is omited (the default), the list of
already installed packages is considered.

\(fn &optional SYNC &rest PACKAGES)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get" '("el-get-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-autoloading" '("el-get-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-build" '("el-get-")))



(autoload 'el-get-bundle-el-get "el-get-bundle" "\


\(fn SRC SYNC)" nil nil)

(autoload 'el-get-bundle "el-get-bundle" "\
Install PACKAGE and run initialization FORM.

PACKAGE can be either a simple package name or a package name
with a modifier before the name to specify local recipe source
information:

* `<owner>/' : specifies a Github owner name
* `gist:<id>' : specifies a Gist ID
* `<type>:' : specifies a type of the package source

If `FEATURE in PACKAGE' form is used instead of PACKAGE, then
that FEATURE is `require'd after installing PACKAGE.  You can
also use `el-get-bundle!' macro if FEATURE and PACKAGE are the
same.  If you wish to `require' more than one feature, then use
`:features' property in FORM.

The initialization FORM may start with a property list that
describes a local recipe.  The property list may include the keyword
`:bundle-sync' with a value of either `t' or `nil' to request that
`el-get-bundle' invoke `el-get' synchronously (respectively asynchronously).
The keyword `:bundle-async' is the inverse of `:bundle-sync'.
\(Note that the request to run el-get synchronously may not be respected in all
circumstances: see the definition of `el-get-bundle-el-get' for details.)
The FORM after the property list is treated as initialization code,
which is actually an `:after' property of the local recipe.

A copy of the initialization code is stored in a directory
specified by `el-get-bundle-init-directory' and its byte-compiled
version is used if `el-get-bundle-byte-compile' is non-nil.

\(fn PACKAGE &rest FORM)" nil t)

(function-put 'el-get-bundle 'lisp-indent-function 'defun)

(autoload 'el-get-bundle! "el-get-bundle" "\
Install PACKAGE and run initialization form.
It is the same as `el-get-bundle' except that PACKAGE is explicitly
required.

\(fn PACKAGE &rest ARGS)" nil t)

(function-put 'el-get-bundle! 'lisp-indent-function 'defun)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-bundle" '("el-get-bundle-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-byte-compile" '("el-get-")))



(autoload 'el-get-check-recipe "el-get-check" "\
Check the format of the recipe.
Please run this command before sending a pull request.
Usage: M-x el-get-check-recipe RET

You can run this function from checker script like this:
    test/check-recipe.el PATH/TO/RECIPE.rcp

When used as a lisp function, FILE-OR-BUFFER must be a buffer
object or a file path.

\(fn FILE-OR-BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-check" '("el-get-check-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-core" '("el-get-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-custom" '("el-get-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-dependencies" '("el-get-" "topological-sort")))



(autoload 'el-get-list-packages "el-get-list-packages" "\
Display a list of packages.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-list-packages" '("el-get-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-methods" '("el-get-insecure-check")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-notify" '("el-get-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-recipes" '("el-get-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-get-status" '("el-get-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/el-autoyas-20120918.1317/el-autoyas-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/el-autoyas-20120918.1317/el-autoyas-autoloads.el") (car load-path))))



(autoload 'el-autoyas-enable "el-autoyas" "\
Load and activate package.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-autoyas" '("el-autoyas-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clomacs-20181003.1735/clomacs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clomacs-20181003.1735/clomacs-autoloads.el") (car load-path))))



(autoload 'clomacs-def "clomacs" "\
Wrap CL-ENTITY-NAME, evaluated on clojure side by EL-ENTITY-NAME.
DOC - optional elisp function docstring (when nil it constructed from
underlying clojure entity docstring if possible).
TYPE possible values are listed in the CLOMACS-POSSIBLE-RETURN-TYPES,
or it may be a custom function (:string by default).

\(fn EL-ENTITY-NAME CL-ENTITY-NAME &key (DOC nil) (TYPE :string) LIB-NAME NAMESPACE)" nil t)

(autoload 'clomacs-defun "clomacs" "\
Wrap CL-FUNC-NAME, evaluated on clojure side by EL-FUNC-NAME.
CALL-TYPE - call Clojure side :sync or :async.
CALLBACK - callback function for :async CALL-TYPE case.
DOC - optional elisp function docstring (when nil it constructed from
underlying clojure entity docstring if possible).
INTERACTIVE - when defined and is a boolean `t` mark function (interactive),
if not boolean - insert interactive value into the function beginning as is.
RETURN-TYPE possible values are listed in the CLOMACS-POSSIBLE-RETURN-TYPES,
or it may be a custom function (:string by default).
RETURN-VALUE may be :value or :stdout (:value by default).
LIB-NAME - Elisp library name used in end-user .emacs config by `require'.
HTTPD-STARTER - in the case Clojure side code needs to call Elisp side code,
http-server should be started to pass http requests from Clojure REPL
to Emacs. This parameter is Elisp function to do it. Such function can
be created by `clomacs-create-httpd-start' macro.

\(fn EL-FUNC-NAME CL-FUNC-NAME &key (CALL-TYPE :sync) (CALLBACK nil) (DOC nil) (INTERACTIVE nil) (RETURN-TYPE :string) (RETURN-VALUE :value) LIB-NAME NAMESPACE (HTTPD-STARTER nil))" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clomacs" '("clo" "execute")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-20170125.245/auto-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-20170125.245/auto-complete-autoloads.el") (car load-path))))



(autoload 'auto-complete "auto-complete" "\
Start auto-completion at current point.

\(fn &optional SOURCES)" t nil)

(autoload 'auto-complete-mode "auto-complete" "\
AutoComplete mode

If called interactively, enable Auto-Complete mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-auto-complete-mode nil "\
Non-nil if Global Auto-Complete mode is enabled.
See the `global-auto-complete-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-auto-complete-mode'.")

(custom-autoload 'global-auto-complete-mode "auto-complete" nil)

(autoload 'global-auto-complete-mode "auto-complete" "\
Toggle Auto-Complete mode in all buffers.
With prefix ARG, enable Global Auto-Complete mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Complete mode is enabled in all buffers where
`auto-complete-mode-maybe' would do it.
See `auto-complete-mode' for more information on Auto-Complete mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete" '("ac-" "auto-complete-mode")))



(autoload 'ac-config-default "auto-complete-config" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-config" '("ac-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/direx-20170422.1327/direx-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/direx-20170422.1327/direx-autoloads.el") (car load-path))))



(autoload 'direx:jump-to-directory "direx" "\


\(fn)" t nil)

(autoload 'direx:jump-to-directory-other-window "direx" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "direx" '("direx:")))



(autoload 'direx-project:jump-to-project-root "direx-project" "\


\(fn)" t nil)

(autoload 'direx-project:jump-to-project-root-other-window "direx-project" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "direx-project" '("direx-project:")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ejc-sql-20180929.1148/ejc-sql-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ejc-sql-20180929.1148/ejc-sql-autoloads.el") (car load-path))))



(autoload 'ejc-owners-candidates "ejc-autocomplete" "\


\(fn)" nil nil)

(autoload 'ejc-tables-candidates "ejc-autocomplete" "\


\(fn)" nil nil)

(autoload 'ejc-colomns-candidates "ejc-autocomplete" "\


\(fn)" nil nil)

(autoload 'ejc-ac-setup "ejc-autocomplete" "\
Add the completion sources to the front of `ac-sources'.
This affects only the current buffer.

Check against following cases:
prefix-2.prefix-1.#
prefix-1.#
something#

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-autocomplete" '("ac-" "ejc-")))



(autoload 'ejc-direx:pop-to-buffer "ejc-direx" "\


\(fn)" t nil)

(autoload 'ejc-direx:switch-to-buffer "ejc-direx" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-direx" '("direx" "ejc-direx:")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-doc" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-format" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-interaction" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-lib" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-result-mode" '("ejc-result-")))



(autoload 'ejc-sql-mode "ejc-sql" "\
Toggle ejc-sql mode.

If called interactively, enable Ejc-Sql mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'ejc-create-menu "ejc-sql" "\


\(fn)" nil nil)

(autoload 'ejc-connect "ejc-sql" "\
Connect to selected db.

\(fn CONNECTION-NAME)" t nil)

(autoload 'ejc-connect-existing-repl "ejc-sql" "\
Connect to existing ejc-sql nREPL running process.
You can `cd` to your ejc-sql project folder (typically
'~/.emacs.d/elpa/ejc-sql-<version>') and launch nREPL via `lein repl`.
Then run in Emacs `ejc-connect-existing-repl', type HOST and PORT
from your `lein run` console output. Finally, use `ejc-connect' from
any SQL buffer to connect to exact database, as always. 

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-sql" '("ejc-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eide-20180626.1959/eide-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eide-20180626.1959/eide-autoloads.el") (car load-path))))



(autoload 'eide-start "eide" "\
Start Emacs-IDE.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide" '("eide-shell-open")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-browsing-theme" '("eide-browsing")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-compare" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-config" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-dark-theme" '("eide-dark")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-display" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-display-theme" '("eide-display")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-edit" '("eide-edit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-help" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-keys" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-light-theme" '("eide-light")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-menu" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-popup" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-project" '("eide-" "emacs-ide-config-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-search" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-settings-theme" '("eide-settings")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-vc" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-windows" '("eide-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eglot-20181003.1908/eglot-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eglot-20181003.1908/eglot-autoloads.el") (car load-path))))



(autoload 'eglot "eglot" "\
Manage a project with a Language Server Protocol (LSP) server.

The LSP server of CLASS started (or contacted) via CONTACT.  If
this operation is successful, current *and future* file buffers
of MANAGED-MAJOR-MODE inside PROJECT automatically become
\"managed\" by the LSP server, meaning information about their
contents is exchanged periodically to provide enhanced
code-analysis via `xref-find-definitions', `flymake-mode',
`eldoc-mode', `completion-at-point', among others.

Interactively, the command attempts to guess MANAGED-MAJOR-MODE
from current buffer, CLASS and CONTACT from
`eglot-server-programs' and PROJECT from `project-current'.  If
it can't guess, the user is prompted.  With a single
\\[universal-argument] prefix arg, it always prompt for COMMAND.
With two \\[universal-argument] prefix args, also prompts for
MANAGED-MAJOR-MODE.

PROJECT is a project instance as returned by `project-current'.

CLASS is a subclass of symbol `eglot-lsp-server'.

CONTACT specifies how to contact the server.  It is a
keyword-value plist used to initialize CLASS or a plain list as
described in `eglot-server-programs', which see.

INTERACTIVE is t if called interactively.

\(fn MANAGED-MAJOR-MODE PROJECT CLASS CONTACT &optional INTERACTIVE)" t nil)

(autoload 'eglot-ensure "eglot" "\
Start Eglot session for current buffer if there isn't one.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eglot" '("eglot-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/edebug-x-20130616.625/edebug-x-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/edebug-x-20130616.625/edebug-x-autoloads.el") (car load-path))))



(autoload 'edebug-x-modify-breakpoint-wrapper "edebug-x" "\
Set a breakpoint from an Elisp file.
The current function that pointer is in will be instrumented if
not already. When called with a prefix argument a conditional
breakpoint is set.

\(fn ARG)" t nil)

(autoload 'edebug-x-evaluate-function "edebug-x" "\
Evaluate function on line.
This removes all breakpoints in this function.

\(fn)" t nil)

(autoload 'edebug-x-show-data "edebug-x" "\
Display instrumented functions and edebug breakpoints.
Frame is split into two vertically showing the tabluated buffers
for each.

\(fn)" t nil)

(autoload 'edebug-x-show-breakpoints "edebug-x" "\
Display breakpoints in a tabulated list buffer.

\(fn)" t nil)

(autoload 'edebug-x-show-instrumented "edebug-x" "\
Display instrumented functions in a tabluated list buffer.

\(fn)" t nil)

(autoload 'edebug-x-mode "edebug-x" "\
A minor mode that makes it easier to use Edebug

If called interactively, enable Edebug-X mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(add-hook 'emacs-lisp-mode-hook 'edebug-x-mode)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "edebug-x" '("edebug-x-" "instrumented" "list-edebug-x-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ede-compdb-20150920.2033/ede-compdb-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ede-compdb-20150920.2033/ede-compdb-autoloads.el") (car load-path))))



(autoload 'ede-compdb-load-project "ede-compdb" "\
Create an instance of option `ede-compdb-project' for DIR.

\(fn DIR)" nil nil)

(autoload 'ede-ninja-load-project "ede-compdb" "\
Create an instance of option `ede-ninja-project' for DIR.

\(fn DIR)" nil nil)

(eval-after-load "ede/auto" '(ede-add-project-autoload (ede-project-autoload "compdb" :name "Compilation DB" :file 'ede-compdb :proj-file "compile_commands.json" :load-type 'ede-compdb-load-project :class-sym 'ede-compdb-project)))

(eval-after-load "ede/auto" '(ede-add-project-autoload (ede-project-autoload "ninja" :name "Ninja" :file 'ede-compdb :proj-file "build.ninja" :load-type 'ede-ninja-load-project :class-sym 'ede-ninja-project)))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ede-compdb" '("compdb-entry" "current-co" "ede-" "ff-other-file-list" "get-" "initialize-instance" "insert-compdb" "other-file-list" "parse-command-line" "project-" "set-configuration-directory")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ecb-20170728.1921/ecb-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ecb-20170728.1921/ecb-autoloads.el") (car load-path))))



(autoload 'ecb-activate "ecb" "\
Activates ECB and creates the special buffers for the choosen layout.
For the layout see `ecb-layout-name'. This function raises always the
ECB-frame if called from another frame. This is the same as calling
`ecb-minor-mode' with a positive argument.

\(fn)" t nil)

(autoload 'ecb-minor-mode "ecb" "\
Toggle ECB minor mode.
With prefix argument ARG, turn on if positive, otherwise off. Return non-nil
if the minor mode is enabled.

\\{ecb-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'ecb-byte-compile "ecb" "\
Byte-compiles the ECB package.
This is done for all lisp-files of ECB if FORCE-ALL is not nil or for each
lisp-file FILE.el which is either newer than FILE.elc or if FILE.elc doesn't
exist.

\(fn &optional FORCE-ALL)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-advice-test" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-analyse" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-autogen" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-cedet-wrapper" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-common-browser" '("defecb-" "ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-compatibility" '("Electric-pop-up-window" "bs-show" "ecb-" "electric-" "one-window-p" "scroll-all-function-all")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-compilation" '("ecb-compilation-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-create-layout" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-eshell" '("ecb-eshell-" "eshell")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-examples" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-face" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-file-browser" '("clearcase-sync-from-disk" "ecb-" "vc-checkin")))



(autoload 'ecb-show-help "ecb-help" "\
Shows the online help of ECB in Info or HTML-format.
The format depends on the setting in `ecb-show-help-format'. If called with
prefix argument, i.e. if FORMAT is not nil then the user is prompted to choose
the format of the help (Info or Html).

If an error about not finding the needed help-file occurs please take a look
at the options `ecb-help-info-start-file' and `ecb-help-html-start-file'!

Note: If you got ECB as a standard XEmacs-package maybe the
HTML-online-documentation is not included.

\(fn &optional FORMAT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-help" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-jde" '("ecb-jde-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-layout" '("balance-windows" "compilation-set-window-height" "current-window-configuration" "display-buffer" "ecb-" "other-window" "scroll-other-window" "set-window-configuration" "split-window" "switch-to-buffer" "walk-windows")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-layout-defs" '("ecb-buildin-layouts")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-method-browser" '("custom-save-all" "ecb-" "make-indirect-buffer")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-mode-line" '("ecb-mode-line-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-multiframe" '("ecb-multiframe-variables")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-navigate" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-semantic" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-semantic-wrapper" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-speedbar" '("dframe-" "ecb-" "speedbar-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-symboldef" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-tod" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-upgrade" '("ecb-")))



(defconst ecb-running-xemacs (featurep 'xemacs))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-util" '("defecb-multicache" "ecb-" "when-ecb-running-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-winman-support" '("ecb-winman-" "escreen-save-current-screen-configuration" "win")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "silentcomp" '("silentcomp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tree-buffer" '("tree-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eacl-20180607.1358/eacl-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eacl-20180607.1358/eacl-autoloads.el") (car load-path))))



(autoload 'eacl-get-project-root "eacl" "\
Get project root.

\(fn)" nil nil)

(autoload 'eacl-current-line-info "eacl" "\
Current line.

\(fn)" nil nil)

(autoload 'eacl-get-keyword "eacl" "\
Get trimmed keyword from CUR-LINE.

\(fn LINE)" nil nil)

(autoload 'eacl-complete-multi-lines-internal "eacl" "\
Complete multi-lines.  REGEX is used to match the lines.

\(fn REGEX)" nil nil)

(autoload 'eacl-complete-line "eacl" "\
Complete line by grepping project.

\(fn)" t nil)

(autoload 'eacl-complete-statement "eacl" "\
Complete statement which ends with \";\" by grepping project.

\(fn)" t nil)

(autoload 'eacl-complete-snippet "eacl" "\
Complete snippet which ends with \"}\" by grepping in project.

\(fn)" t nil)

(autoload 'eacl-complete-tag "eacl" "\
Complete snippet which ends with \">\" by grepping in project.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eacl" '("eacl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/dr-racket-like-unicode-20161021.1211/dr-racket-like-unicode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/dr-racket-like-unicode-20161021.1211/dr-racket-like-unicode-autoloads.el") (car load-path))))



(autoload 'dr-racket-like-unicode-char "dr-racket-like-unicode" "\
Transform the TeX-style code immediately prior to point into Unicode.

Customize `dr-racket-like-unicode-table' to change the collection of unicode symbols.

\(fn)" t nil)

(autoload 'dr-racket-like-unicode-mode "dr-racket-like-unicode" "\
A minor mode for writing Unicode as in DrDr-Racket.

If called interactively, enable Dr-Racket-Like-Unicode mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

This minor mode binds one command: `dr-racket-like-unicode-char'.

\\{dr-racket-like-unicode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dr-racket-like-unicode" '("dr-racket-like-unicode-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/discover-my-major-20180606.511/discover-my-major-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/discover-my-major-20180606.511/discover-my-major-autoloads.el") (car load-path))))



(autoload 'discover-my-major "discover-my-major" "\
Create a makey popup listing all major-mode keys with their description.
If ARG is non-nil recreate the makey popup function even if it is already defined.

\(fn ARG)" t nil)

(autoload 'discover-my-mode "discover-my-major" "\
Create a makey popup listing all MODE keys with their description.

\(fn MODE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "discover-my-major" '("dmm/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clj-refactor-20180826.2149/clj-refactor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clj-refactor-20180826.2149/clj-refactor-autoloads.el") (car load-path))))



(autoload 'cljr-add-keybindings-with-prefix "clj-refactor" "\
Bind keys in `cljr--all-helpers' under a PREFIX key.

\(fn PREFIX)" nil nil)

(autoload 'cljr-add-keybindings-with-modifier "clj-refactor" "\
Bind keys in `cljr--all-helpers' under a MODIFIER key.

\(fn MODIFIER)" nil nil)

(autoload 'cljr-rename-file-or-dir "clj-refactor" "\
Rename a file or directory of files.
Buffers visiting any affected file are killed and the
corresponding files are revisited.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-rename-file-or-dir

\(fn OLD-PATH NEW-PATH)" t nil)

(autoload 'cljr-rename-file "clj-refactor" "\


\(fn NEW-PATH)" t nil)

(autoload 'cljr-add-require-to-ns "clj-refactor" "\
Add a require statement to the ns form in current buffer.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-require-to-ns

\(fn CLJS\\=\\?)" t nil)

(autoload 'cljr-add-use-to-ns "clj-refactor" "\
Add a use statement to the buffer's ns form.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-use-to-ns

\(fn CLJS\\=\\?)" t nil)

(autoload 'cljr-add-import-to-ns "clj-refactor" "\
Add an import statement to the buffer's ns form.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-import-to-ns

\(fn &optional CLJS\\=\\?)" t nil)

(autoload 'cljr-require-macro "clj-refactor" "\
Add a require statement for a macro to the ns form in current buffer.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-require-macro

\(fn)" t nil)

(autoload 'cljr-stop-referring "clj-refactor" "\
Stop referring to vars in the namespace at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-stop-referring

\(fn)" t nil)

(autoload 'cljr-move-form "clj-refactor" "\
Move the form containing POINT to a new namespace.

If REGION is active, move all forms contained by region.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-move-form

\(fn)" t nil)

(autoload 'cljr-add-declaration "clj-refactor" "\
Add a declare for the current def near the top of the buffer.

With a prefix add a declaration for the symbol under the cursor instead.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-declaration

\(fn FOR-THING-AT-POINT-P)" t nil)

(autoload 'cljr-extract-constant "clj-refactor" "\
Extract form at (or above) point as a constant.
Create a def for it at the top level, and replace its current
occurrence with the defined name.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-constant

\(fn)" t nil)

(autoload 'cljr-extract-def "clj-refactor" "\
Extract form at (or above) point as a def.
Create a def for it at the top level, and replace its current
occurrence with the defined name.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-def

\(fn)" t nil)

(autoload 'cljr-cycle-thread "clj-refactor" "\
Cycle a threading macro between -> and ->>.
Also applies to other versions of the macros, like cond->.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-thread

\(fn)" t nil)

(autoload 'cljr-introduce-let "clj-refactor" "\
Create a let form, binding the form at point.
The resulting let form can then be expanded with `\\[cljr-expand-let]'.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-introduce-let

\(fn &optional N)" t nil)

(autoload 'cljr-expand-let "clj-refactor" "\
Expand the let form above point by one level.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-expand-let

\(fn)" t nil)

(autoload 'cljr-move-to-let "clj-refactor" "\
Move the form at point to a binding in the nearest let.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-move-to-let

\(fn)" t nil)

(autoload 'cljr-destructure-keys "clj-refactor" "\
Change a symbol binding at point to a destructuring bind.
Keys to use in the destructuring are inferred from the code, and
their usage is replaced with the new local variables.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-destructure-keys

\(fn)" t nil)

(autoload 'cljr-raise-sexp "clj-refactor" "\
Like paredit-raise-sexp, but removes # in front of function literals and sets.

\(fn &optional ARGUMENT)" t nil)

(autoload 'cljr-splice-sexp-killing-backward "clj-refactor" "\
Like paredit-splice-sexp-killing-backward, but removes # in
front of function literals and sets.

\(fn &optional ARGUMENT)" t nil)

(autoload 'cljr-splice-sexp-killing-forward "clj-refactor" "\
Like paredit-splice-sexp-killing-backward, but removes # in
front of function literals and sets.

\(fn &optional ARGUMENT)" t nil)

(autoload 'cljr-slash "clj-refactor" "\
Inserts / as normal, but also checks for common namespace shorthands to require.
If `cljr-magic-require-namespaces' is non-nil, typing one of the
short aliases listed in `cljr-magic-requires' followed by this
command will add the corresponding require statement to the ns
form.

\(fn)" t nil)

(autoload 'cljr-project-clean "clj-refactor" "\
Run `cljr-project-clean-functions' on every clojure file, then
sorts the project's dependency vectors.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-project-clean

\(fn)" t nil)

(autoload 'cljr-sort-project-dependencies "clj-refactor" "\
Sorts all dependency vectors in project.clj

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-sort-project-dependencies

\(fn)" t nil)

(autoload 'cljr-add-project-dependency "clj-refactor" "\
Add a dependency to the project.clj file.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-project-dependency

\(fn FORCE)" t nil)

(autoload 'cljr-update-project-dependency "clj-refactor" "\
Update the version of the dependency at point.

\(fn &optional VERSION)" t nil)

(autoload 'cljr-update-project-dependencies "clj-refactor" "\
Update all project dependencies.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-update-project-dependencies

\(fn)" t nil)

(autoload 'cljr-promote-function "clj-refactor" "\
Promote a function literal to an fn, or an fn to a defn.
With prefix PROMOTE-TO-DEFN, promote to a defn even if it is a
function literal.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-promote-function

\(fn PROMOTE-TO-DEFN)" t nil)

(autoload 'cljr-find-usages "clj-refactor" "\
Find all usages of the symbol at point in the project.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-find-usages

\(fn)" t nil)

(autoload 'cljr-rename-symbol "clj-refactor" "\
Rename the symbol at point and all of its occurrences.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-rename-symbol

\(fn &optional NEW-NAME)" t nil)

(autoload 'cljr-clean-ns "clj-refactor" "\
Clean the ns form for the current buffer.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-clean-ns

\(fn)" t nil)

(autoload 'cljr-add-missing-libspec "clj-refactor" "\
Requires or imports the symbol at point.

If the symbol at point is of the form str/join then the ns
containing join will be aliased to str.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-missing-libspec

\(fn)" t nil)

(autoload 'cljr-hotload-dependency "clj-refactor" "\
Download a dependency (if needed) and hotload it into the current repl session.

Defaults to the dependency vector at point, but prompts if none is found.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-hotload-dependency

\(fn)" t nil)

(autoload 'cljr-extract-function "clj-refactor" "\
Extract the form at (or above) point as a top-level defn.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-function

\(fn)" t nil)

(autoload 'cljr-add-stubs "clj-refactor" "\
Adds implementation stubs for the interface or protocol at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-stubs

\(fn)" t nil)

(autoload 'cljr-inline-symbol "clj-refactor" "\
Inline the symbol at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-inline-symbol

\(fn)" t nil)

(autoload 'cljr-version "clj-refactor" "\
Returns the version of the middleware as well as this package.

\(fn)" t nil)

(autoload 'cljr-toggle-debug-mode "clj-refactor" "\


\(fn)" t nil)

(autoload 'cljr-create-fn-from-example "clj-refactor" "\
Create a top-level defn for the symbol at point.
The context in which symbol is being used should be that of a
function, and the arglist of the defn is guessed from this
context.

For instance, if the symbol is the first argument of a `map'
call, the defn is created with one argument. If it is the first
argument of a `reduce', the defn will take two arguments.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-create-fn-from-example

\(fn)" t nil)

(autoload 'cljr-describe-refactoring "clj-refactor" "\
Show the wiki page, in emacs, for one of the available refactorings.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-describe-refactoring

\(fn CLJR-FN)" t nil)

(autoload 'cljr-change-function-signature "clj-refactor" "\
Change the function signature of the function at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-change-function-signature

\(fn)" t nil)

(autoload 'cljr--inject-middleware-p "clj-refactor" "\
Return non-nil if nREPL middleware should be injected.

\(fn &rest _)" nil nil)

(autoload 'cljr--inject-jack-in-dependencies "clj-refactor" "\
Inject the REPL dependencies of clj-refactor at `cider-jack-in'.
If injecting the dependencies is not preferred set `cljr-inject-dependencies-at-jack-in' to nil.

\(fn)" nil nil)

(eval-after-load 'cider '(cljr--inject-jack-in-dependencies))

(autoload 'clj-refactor-mode "clj-refactor" "\
A mode to keep the clj-refactor keybindings.

If called interactively, enable Clj-Refactor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{clj-refactor-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clj-refactor" '("*cljr--noninteractive*" "cjr--occurrence-count" "clj" "hydra-cljr-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/discover-20140103.2139/discover-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/discover-20140103.2139/discover-autoloads.el") (car load-path))))



(autoload 'discover-show-context-menu "discover" "\
Shows a context menu GROUP-NAME

\(fn GROUP-NAME)" nil nil)

(autoload 'discover-get-context-symbol "discover" "\
Macro that returns the context menu symbol for GROUP-NAME

\(fn GROUP-NAME)" nil t)

(autoload 'discover-add-context-menu "discover" "\
Save a context menu to Discover and bind it to the correct keys.


Example 1. Enable Discover in a mode:

    (discover-add-context-menu
       :context-menu (mygroup ... )
       :mode 'dired-mode
       :mode-hook 'dired-mode-hook
       :bind \"?\")

This will bind a function named `dired-mode-turn-on-mygroup' to
the hook `dired-mode-hook' specified in :mode-hook. The name for
the function is `<foo>-turn-on-discover' where `<foo>' is the
`car' symbol in :context-menu - better known as the name of the
context menu.

The function will call `local-set-key' with the binding given
in :bind.


Example 2. Globalized Discover Support:

    (discover-add-context-menu
       :context-menu (mygroup ...)
       :bind \"C-x r\")

As above, this will bind a function but this one is called
`discover--turn-on-mygroup' and is set when `discover-mode' is
set. This enables you to create \"global\" keybindings (that
nevertheless only take effect when `discover-mode' or
`global-discover-mode' is enabled) instead of local
ones. Omitting :mode and :mode-hook is all it takes.

PList Definitions:

:context-menu is a menu definition. See `discover-context-menus'.

:mode is a major mode symbol where the key in :bind take
effect. If major mode is `nil' then the key is defined against
`discover-mode' and is thus in effect when `discover-mode' is
enabled.

:mode-hook is the name of the mode hook where the context menu
key gets bound. Usually it's `<name>-mode-hook'. This property is
redundant if :mode is nil.

:bind is a string, to be passed to `kbd', that the context menu
will be bound to.

Notes:

You can only bind one menu per call to discover. The bound name
given to the key group is taken from the `car' in the list passed
to :context-menu. You can retrieve the command symbol for the
context menu by calling `discover-get-context-menu-command-name'
with the symbol name of the context menu..

\(fn &rest PROPERTIES)" nil nil)

(autoload 'discover-mode "discover" "\
Helps you discover Emacs with interactive context menus.

If called interactively, enable Discover mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Key bindings:
\\{discover-map}

\(fn &optional ARG)" t nil)

(defvar global-discover-mode nil "\
Non-nil if Global Discover mode is enabled.
See the `global-discover-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-discover-mode'.")

(custom-autoload 'global-discover-mode "discover" nil)

(autoload 'global-discover-mode "discover" "\
Toggle Discover mode in all buffers.
With prefix ARG, enable Global Discover mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Discover mode is enabled in all buffers where
`discover-mode-turn-on' would do it.
See `discover-mode' for more information on Discover mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "discover" '("discover-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/discover-clj-refactor-20150328.1459/discover-clj-refactor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/discover-clj-refactor-20150328.1459/discover-clj-refactor-autoloads.el") (car load-path))))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/disaster-20171016.2152/disaster-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/disaster-20171016.2152/disaster-autoloads.el") (car load-path))))



(defvar disaster-find-build-root-functions nil "\
Functions to call to get the build root directory from the project directory.
If nil is returned, the next function will be tried.  If all
functions return nil, the project root directory will be used as
the build directory.")

(autoload 'disaster "disaster" "\
Shows assembly code for current line of C/C++ file.

Here's the logic path it follows:

- Is there a Makefile in this directory? Run `make bufname.o`.
- Or is there a Makefile in a parent directory? Run `make -C .. bufname.o`.
- Or is this a C file? Run `cc -g -O3 -c -o bufname.o bufname.c`
- Or is this a C++ file? Run `c++ -g -O3 -c -o bufname.o bufname.c`
- If build failed, display errors in compile-mode.
- Run objdump inside a new window while maintaining focus.
- Jump to line matching current line.

If FILE and LINE are not specified, the current editing location
is used.

\(fn &optional FILE LINE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "disaster" '("disaster-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/diffview-20150929.511/diffview-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/diffview-20150929.511/diffview-autoloads.el") (car load-path))))



(autoload 'diffview-current "diffview" "\
Show current diff buffer in a side-by-side view.

\(fn)" t nil)

(autoload 'diffview-region "diffview" "\
Show current diff region in a side-by-side view.

\(fn)" t nil)

(autoload 'diffview-message "diffview" "\
Show `message-mode' buffer in a side-by-side view.

This is useful for reading patches from mailing lists.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "diffview" '("diffview-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/demangle-mode-20180516.245/demangle-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/demangle-mode-20180516.245/demangle-mode-autoloads.el") (car load-path))))



(autoload 'demangle-mode "demangle-mode" "\
Toggle demangle mode.

If called interactively, enable Demangle mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Interactively with no argument, this command toggles the mode.  A
positive prefix argument enables the mode; any other prefix
argument disables it.  From Lisp, argument omitted or nil enables
the mode, while `toggle' toggles the state.

When Demangle mode is enabled, mangled C++ symbols appearing
within the buffer are demangled, making their decoded C++ forms
visible.

Visit `https://github.com/liblit/demangle-mode/issues' or use
\\[demangle-mode-submit-bug-report] to report bugs in
`demangle-mode'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "demangle-mode" '("demangle-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/delim-kill-20100517.620/delim-kill-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/delim-kill-20100517.620/delim-kill-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "delim-kill" '("delim-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/datomic-snippets-20180817.1045/datomic-snippets-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/datomic-snippets-20180817.1045/datomic-snippets-autoloads.el") (car load-path))))



(autoload 'datomic-snippets-show-docs-at-point "datomic-snippets" "\


\(fn)" t nil)

(autoload 'datomic-snippets-initialize "datomic-snippets" "\


\(fn)" nil nil)

(eval-after-load "yasnippet" '(datomic-snippets-initialize))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "datomic-snippets" '("-aget" "datomic-snippets/")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ctags-update-20170728.758/ctags-update-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ctags-update-20170728.758/ctags-update-autoloads.el") (car load-path))))



(autoload 'ctags-update "ctags-update" "\
ctags-update in parent directory using `exuberant-ctags'.
1. you can call this function directly,
2. enable `ctags-auto-update-mode',
3. with prefix `C-u' then you can generate a new TAGS file in selected directory,
4. with prefix `C-uC-u' save the command to kill-ring instead of execute it.

\(fn &optional ARGS)" t nil)

(autoload 'ctags-auto-update-mode "ctags-update" "\
auto update TAGS using `exuberant-ctags' in parent directory.

If called interactively, enable Ctags-Auto-Update mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-ctags-auto-update-mode "ctags-update" "\
turn on `ctags-auto-update-mode'.

\(fn)" t nil)

(defvar ctags-global-auto-update-mode nil "\
Non-nil if Ctags-Global-Auto-Update mode is enabled.
See the `ctags-global-auto-update-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ctags-global-auto-update-mode'.")

(custom-autoload 'ctags-global-auto-update-mode "ctags-update" nil)

(autoload 'ctags-global-auto-update-mode "ctags-update" "\
Toggle Ctags-Auto-Update mode in all buffers.
With prefix ARG, enable Ctags-Global-Auto-Update mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Ctags-Auto-Update mode is enabled in all buffers where
`turn-on-ctags-auto-update-mode' would do it.
See `ctags-auto-update-mode' for more information on Ctags-Auto-Update mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ctags-update" '("ctags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cquery-20180811.2131/cquery-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cquery-20180811.2131/cquery-autoloads.el") (car load-path))))


 (autoload 'lsp-cquery-enable "cquery")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery" '("cquery-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery-call-hierarchy" '("cquery-call-hierarchy")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery-code-lens" '("cquery-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery-common" '("cquery--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery-inheritance-hierarchy" '("cquery-inheritance-hierarchy")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery-member-hierarchy" '("cquery-member-hierarchy")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery-semantic-highlighting" '("cquery-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cquery-tree" '("cquery-tree-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cpputils-cmake-20181006.328/cpputils-cmake-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cpputils-cmake-20181006.328/cpputils-cmake-autoloads.el") (car load-path))))



(autoload 'cppcm-get-exe-path-current-buffer "cpputils-cmake" "\


\(fn)" t nil)

(autoload 'cppcm-version "cpputils-cmake" "\


\(fn)" t nil)

(autoload 'cppcm-compile "cpputils-cmake" "\
Compile the executable/library in current directory,
default compile command or compile in the build directory.
You can specify the sequence which compile is default
by customize `cppcm-compile-list'.

\(fn &optional PREFIX)" t nil)

(autoload 'cppcm-recompile "cpputils-cmake" "\
Run 'make clean && compile'.

\(fn)" t nil)

(autoload 'cppcm-reload-all "cpputils-cmake" "\
Reload and reproduce everything.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cpputils-cmake" '("cppcm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/counsel-etags-20180807.555/counsel-etags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/counsel-etags-20180807.555/counsel-etags-autoloads.el") (car load-path))))



(autoload 'counsel-etags-get-hostname "counsel-etags" "\
Reliable way to get current hostname.
`(getenv \"HOSTNAME\")' won't work because $HOSTNAME is NOT an
 environment variable.
`system-name' won't work because /etc/hosts could be modified

\(fn)" nil nil)

(autoload 'counsel-etags-directory-p "counsel-etags" "\
Does directory of current file match REGEX?

\(fn REGEX)" nil nil)

(autoload 'counsel-etags-filename-p "counsel-etags" "\
Does current file match REGEX?

\(fn REGEX)" nil nil)

(autoload 'counsel-etags-update-tags-force "counsel-etags" "\
Update tags file now using default implementation.

\(fn)" t nil)

(autoload 'counsel-etags-scan-code "counsel-etags" "\
Use Ctags to scan code at DIR.

\(fn &optional DIR)" t nil)

(autoload 'counsel-etags-list-tag "counsel-etags" "\
List all tags.

\(fn)" t nil)

(autoload 'counsel-etags-find-tag "counsel-etags" "\
Find tag by two step matching.

First, user need input regex to fuzzy match tag.
Any tag whose sub-string matches regex will be listed.

Second, user could filter tags.

\(fn)" t nil)

(autoload 'counsel-etags-find-tag-at-point "counsel-etags" "\
Find tag using tagname at point.

\(fn)" t nil)

(autoload 'counsel-etags-recent-tag "counsel-etags" "\
Find tag using tagname from `counsel-etags-tag-history'.

\(fn)" t nil)

(autoload 'counsel-etags-virtual-update-tags "counsel-etags" "\
Scan the code and create tags file again.  Please note it's only interface
used by other hooks or commands.  The tags updating might now happen.

\(fn)" t nil)

(autoload 'counsel-etags-grep "counsel-etags" "\
Grep at project root directory or current directory.
Try to find best grep program (ripgrep, grep...) automatically.
Extended regex like (pattern1|pattern2) is used.
If DEFAULT-KEYWORD is not nil, it's used as grep keyword.
If HINT is not nil, it's used as grep hint.

\(fn &optional DEFAULT-KEYWORD HINT)" t nil)

(autoload 'counsel-etags-grep-symbol-at-point "counsel-etags" "\
Similar to `counsel-etags-grep' but grep symbol at point.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "counsel-etags" '("counsel-etags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/concurrent-20161229.330/concurrent-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/concurrent-20161229.330/concurrent-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "concurrent" '("cc:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-ycmd-20180520.1053/company-ycmd-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-ycmd-20180520.1053/company-ycmd-autoloads.el") (car load-path))))



(autoload 'company-ycmd-setup "company-ycmd" "\
Add company-ycmd to the front of company-backends.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-ycmd" '("company-ycmd")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-ycm-20140904.1817/company-ycm-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-ycm-20140904.1817/company-ycm-autoloads.el") (car load-path))))



(autoload 'company-ycm "company-ycm" "\


\(fn COMMAND &optional ARG &rest IGNORED)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-ycm" '("company-ycm--grab-symbol-or-word")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-statistics-20170210.1933/company-statistics-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-statistics-20170210.1933/company-statistics-autoloads.el") (car load-path))))



(defvar company-statistics-mode nil "\
Non-nil if Company-Statistics mode is enabled.
See the `company-statistics-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `company-statistics-mode'.")

(custom-autoload 'company-statistics-mode "company-statistics" nil)

(autoload 'company-statistics-mode "company-statistics" "\
Statistical sorting for company-mode.  Ranks completion candidates by
the frequency with which they have been chosen in recent (as given by
`company-statistics-size') history.

If called interactively, enable Company-Statistics mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Turning this mode on and off preserves the statistics.  They are also
preserved automatically between Emacs sessions in the default
configuration.  You can customize this behavior with
`company-statistics-auto-save', `company-statistics-auto-restore' and
`company-statistics-file'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-statistics" '("company-s")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-rtags-20180730.338/company-rtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-rtags-20180730.338/company-rtags-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-rtags" '("company-rtags")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-racer-20171205.310/company-racer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-racer-20171205.310/company-racer-autoloads.el") (car load-path))))



(autoload 'company-racer "company-racer" "\
`company-mode' completion back-end for racer.
Provide completion info according to COMMAND and ARG.  IGNORED, not used.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-racer" '("company-racer-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-posframe-20180610.1710/company-posframe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-posframe-20180610.1710/company-posframe-autoloads.el") (car load-path))))



(defvar company-posframe-mode nil "\
Non-nil if Company-Posframe mode is enabled.
See the `company-posframe-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `company-posframe-mode'.")

(custom-autoload 'company-posframe-mode "company-posframe" nil)

(autoload 'company-posframe-mode "company-posframe" "\
company-posframe minor mode.

If called interactively, enable Company-Posframe mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-posframe" '("company-posframe-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-math-20171016.1514/company-math-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-math-20171016.1514/company-math-autoloads.el") (car load-path))))



(autoload 'company-latex-commands "company-math" "\
Company backend for latex commands.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(autoload 'company-math-symbols-latex "company-math" "\
Company backend for LaTeX mathematical symbols.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(autoload 'company-math-symbols-unicode "company-math" "\
Company backend for insertion of Unicode mathematical symbols.
See the unicode-math page [1] for a list of fonts that have a
good support for mathematical symbols. Unicode provides only a
limited range of sub(super)scripts; see the wikipedia page [2]
for details.

 [1] http://ftp.snt.utwente.nl/pub/software/tex/help/Catalogue/entries/unicode-math.html
 [2] https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-math" '("company-math-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-lsp-20180917.2244/company-lsp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-lsp-20180917.2244/company-lsp-autoloads.el") (car load-path))))



(autoload 'company-lsp "company-lsp" "\
Define a company backend for lsp-mode.

See the documentation of `company-backends' for COMMAND and ARG.

\(fn COMMAND &optional ARG &rest _)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-lsp" '("company-lsp-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-irony-c-headers-20151018.909/company-irony-c-headers-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-irony-c-headers-20151018.909/company-irony-c-headers-autoloads.el") (car load-path))))



(autoload 'company-irony-c-headers "company-irony-c-headers" "\
Company backend for C/C++ header files.  Taking COMMAND ARG IGNORED.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-irony-c-headers" '("company-irony-c-headers-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-irony-20170905.2046/company-irony-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-irony-20170905.2046/company-irony-autoloads.el") (car load-path))))



(autoload 'company-irony "company-irony" "\


\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(autoload 'company-irony-setup-begin-commands "company-irony" "\
Include irony trigger commands to `company-begin-commands'.

This allow completion to be automatically triggered after member
accesses (obj.|, obj->|, ...).

This may be useful to company < `0.8.4', newer version of company
include these commands by default.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-irony" '("company-irony-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-flx-20180103.518/company-flx-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-flx-20180103.518/company-flx-autoloads.el") (car load-path))))



(defvar company-flx-mode nil "\
Non-nil if Company-Flx mode is enabled.
See the `company-flx-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `company-flx-mode'.")

(custom-autoload 'company-flx-mode "company-flx" nil)

(autoload 'company-flx-mode "company-flx" "\
company-flx minor mode

If called interactively, enable Company-Flx mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-flx" '("company-flx-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-c-headers-20180814.1730/company-c-headers-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-c-headers-20180814.1730/company-c-headers-autoloads.el") (car load-path))))



(autoload 'company-c-headers "company-c-headers" "\
Company backend for C/C++ header files.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-c-headers" '("call-if-function" "company-c-headers-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/common-lisp-snippets-20180226.1523/common-lisp-snippets-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/common-lisp-snippets-20180226.1523/common-lisp-snippets-autoloads.el") (car load-path))))



(autoload 'common-lisp-snippets-initialize "common-lisp-snippets" "\
Initialize Common Lisp snippets, so Yasnippet can see them.

\(fn)" nil nil)

(eval-after-load 'yasnippet '(common-lisp-snippets-initialize))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "common-lisp-snippets" '("common-lisp-snippets-root")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/commenter-20160219.1627/commenter-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/commenter-20160219.1627/commenter-autoloads.el") (car load-path))))



(autoload 'commenter-setup "commenter" "\
Add advises to ‘comment-normalize-vars’.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "commenter" '("commenter-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/comint-intercept-20170317.1228/comint-intercept-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/comint-intercept-20170317.1228/comint-intercept-autoloads.el") (car load-path))))



(autoload 'comint-intercept-mode "comint-intercept" "\
Intercept comint input and send it to other buffers or run some functions.

If called interactively, enable Comint-Intercept mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "comint-intercept" '("comint-intercept-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/codesearch-20181006.1431/codesearch-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/codesearch-20181006.1431/codesearch-autoloads.el") (car load-path))))



(autoload 'codesearch-build-index "codesearch" "\
Add the contents of `dir' to `index-file'.

\(fn DIR INDEX-FILE)" t nil)

(autoload 'codesearch-update-index "codesearch" "\
Rescan all of the directories currently in the index, updating
the index with the new contents.

\(fn)" t nil)

(autoload 'codesearch-reset "codesearch" "\
Reset (delete) the codesearch index.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "codesearch" '("codesearch-")))



(autoload 'listing-codesearch-search "listing-codesearch" "\
Search files matching `file-pattern'in the index for `pattern'.

\(fn PATTERN FILE-PATTERN)" t nil)

(autoload 'listing-codesearch-list-directories "listing-codesearch" "\
List the directories currently being indexed.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "listing-codesearch" '("listing-codesearch-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/codebug-20140929.2137/codebug-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/codebug-20140929.2137/codebug-autoloads.el") (car load-path))))



(autoload 'codebug "codebug" "\
Run CodeBug.

\(fn)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cmake-project-20171121.1115/cmake-project-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cmake-project-20171121.1115/cmake-project-autoloads.el") (car load-path))))



(autoload 'cmake-project-configure-project "cmake-project" "\
Configure or reconfigure a CMake build tree.
BUILD-DIRECTORY is the path to the build-tree directory.  If the
directory does not already exist, it will be created.  The source
directory is found automatically based on the current
buffer. With a prefix argument additional CMake flags can be
specified interactively.

\(fn BUILD-DIRECTORY GENERATOR &optional FLAGS)" t nil)

(autoload 'cmake-project-mode "cmake-project" "\
Minor mode that integrates a CMake-based project with Emacs
build tools such as the CompileCommand and Flymake.

If called interactively, enable Cmake-Project mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cmake-project" '("cmake-project-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cmake-mode-20180709.1426/cmake-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cmake-mode-20180709.1426/cmake-mode-autoloads.el") (car load-path))))



(autoload 'cmake-mode "cmake-mode" "\
Major mode for editing CMake source files.

\(fn)" t nil)

(autoload 'cmake-command-run "cmake-mode" "\
Runs the command cmake with the arguments specified.  The
optional argument topic will be appended to the argument list.

\(fn TYPE &optional TOPIC BUFFER)" t nil)

(autoload 'cmake-help-list-commands "cmake-mode" "\
Prints out a list of the cmake commands.

\(fn)" t nil)

(autoload 'cmake-help-command "cmake-mode" "\
Prints out the help message for the command the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help-module "cmake-mode" "\
Prints out the help message for the module the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help-variable "cmake-mode" "\
Prints out the help message for the variable the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help-property "cmake-mode" "\
Prints out the help message for the property the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help "cmake-mode" "\
Queries for any of the four available help topics and prints out the appropriate page.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("CMakeLists\\.txt\\'" . cmake-mode))

(add-to-list 'auto-mode-alist '("\\.cmake\\'" . cmake-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cmake-mode" '("cmake-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cmake-ide-20180713.1513/cmake-ide-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cmake-ide-20180713.1513/cmake-ide-autoloads.el") (car load-path))))



(autoload 'cmake-ide-setup "cmake-ide" "\
Set up the Emacs hooks for working with CMake projects.

\(fn)" nil nil)

(autoload 'cmake-ide-maybe-run-cmake "cmake-ide" "\
Run CMake if the compilation database JSON file is not found.

\(fn)" t nil)

(autoload 'cmake-ide-run-cmake "cmake-ide" "\
Run CMake and set compiler flags for auto-completion and flycheck.
This works by calling cmake in a temporary directory (or `cmake-ide-build-dir')
 and parsing the JSON file deposited there with the compiler
 flags.

\(fn)" t nil)

(autoload 'cmake-ide-load-db "cmake-ide" "\
Load compilation DB and set flags for current buffer.

\(fn)" t nil)

(autoload 'cmake-ide-compile "cmake-ide" "\
Compile the project.

\(fn)" t nil)

(autoload 'cmake-ide-maybe-start-rdm "cmake-ide" "\
Start the rdm (rtags) server.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cmake-ide" '("cide--" "cmake-ide-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cmake-font-lock-20170117.2025/cmake-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cmake-font-lock-20170117.2025/cmake-font-lock-autoloads.el") (car load-path))))



(autoload 'cmake-font-lock-activate "cmake-font-lock" "\
Activate advanced CMake colorization.

To activate this every time a CMake file is opened, use the following:

    (add-hook 'cmake-mode-hook 'cmake-font-lock-activate)

\(fn)" t nil)
(add-hook 'cmake-mode-hook 'cmake-font-lock-activate)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cmake-font-lock" '("cmake-font-lock-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/closure-lint-mode-20101118.2124/closure-lint-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/closure-lint-mode-20101118.2124/closure-lint-mode-autoloads.el") (car load-path))))



(autoload 'closure-lint-mode "closure-lint-mode" "\
Closure Lint mode.
     With no argument, this command toggles the mode.
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode.

If called interactively, enable Closure-Lint mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "closure-lint-mode" '("closure-lint-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-snippets-20180314.1308/clojure-snippets-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-snippets-20180314.1308/clojure-snippets-autoloads.el") (car load-path))))



(autoload 'clojure-snippets-initialize "clojure-snippets" "\


\(fn)" nil nil)

(eval-after-load 'yasnippet '(clojure-snippets-initialize))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-quick-repls-20150814.736/clojure-quick-repls-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-quick-repls-20150814.736/clojure-quick-repls-autoloads.el") (car load-path))))



(autoload 'clojure-quick-repls-connect "clojure-quick-repls" "\
Launch Clojure and ClojureScript repls for the current project

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-quick-repls" '("clojure-quick-repls-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-mode-extra-font-locking-20180114.1711/clojure-mode-extra-font-locking-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-mode-extra-font-locking-20180114.1711/clojure-mode-extra-font-locking-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-mode-extra-font-locking" '("clojure-built-in-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-cheatsheet-20180201.804/clojure-cheatsheet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-cheatsheet-20180201.804/clojure-cheatsheet-autoloads.el") (car load-path))))



(autoload 'clojure-cheatsheet "clojure-cheatsheet" "\
Use helm to show a Clojure cheatsheet.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-cheatsheet" '("clojure-cheatsheet" "helm-source-clojure-cheatsheet")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojars-20180825.1951/clojars-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojars-20180825.1951/clojars-autoloads.el") (car load-path))))



(autoload 'clojars "clojars" "\
Finds a Clojure library from clojars.org, and copies selected
   result to kill ring

\(fn QUERY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojars" '("clojars-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cljsbuild-mode-20160402.1700/cljsbuild-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cljsbuild-mode-20160402.1700/cljsbuild-mode-autoloads.el") (car load-path))))



(autoload 'cljsbuild-mode "cljsbuild-mode" "\
ClojureScript Build mode

If called interactively, enable Cljsbuild mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'cljsbuild-start "cljsbuild-mode" "\
Runs cljsbuild.

\(fn COMMAND)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cljsbuild-mode" '("cljsbuild-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cljr-helm-20160913.828/cljr-helm-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cljr-helm-20160913.828/cljr-helm-autoloads.el") (car load-path))))



(autoload 'cljr-helm "cljr-helm" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cljr-helm" '("cljr-helm-candidates" "helm-source-cljr")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clang-format-20180406.1514/clang-format-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clang-format-20180406.1514/clang-format-autoloads.el") (car load-path))))



(autoload 'clang-format-region "clang-format" "\
Use clang-format to format the code between START and END according to STYLE.
If called interactively uses the region or the current statement if there is no
no active region. If no STYLE is given uses `clang-format-style'. Use
ASSUME-FILE-NAME to locate a style config file, if no ASSUME-FILE-NAME is given
uses the function `buffer-file-name'.

\(fn START END &optional STYLE ASSUME-FILE-NAME)" t nil)

(autoload 'clang-format-buffer "clang-format" "\
Use clang-format to format the current buffer according to STYLE.
If no STYLE is given uses `clang-format-style'. Use ASSUME-FILE-NAME
to locate a style config file. If no ASSUME-FILE-NAME is given uses
the function `buffer-file-name'.

\(fn &optional STYLE ASSUME-FILE-NAME)" t nil)

(defalias 'clang-format 'clang-format-region)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clang-format" '("clang-format-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cl-lib-highlight-20140127.2112/cl-lib-highlight-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cl-lib-highlight-20140127.2112/cl-lib-highlight-autoloads.el") (car load-path))))



(autoload 'cl-lib-highlight-initialize "cl-lib-highlight" "\
Add all cl-lib font lock highlighting to `emacs-lisp-mode'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-lib-highlight" '("cl-lib-highlight-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cl-format-20160413.45/cl-format-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cl-format-20160413.45/cl-format-autoloads.el") (car load-path))))



(autoload 'cl-format "cl-format" "\
Format FMT using ARGS and print it to STREAM.

The full documentation not available until this function is
loaded.

\(fn STREAM FMT &rest ARGS)" nil nil)

(autoload 'cl-formatter "cl-format" "\
Compile FMT into a function.

This macro parses and compiles FMT into a function, which may be
passed as format argument to `cl-format'.

\(fn FMT)" nil t)

(autoload 'cl-error "cl-format" "\
Like `error', but use CL format strings.

\(fn FMT &rest ARGS)" nil nil)

(autoload 'cl-message "cl-format" "\
Like `error', but use CL format strings.

\(fn FMT &rest ARGS)" nil nil)

(autoload 'cl-format-font-lock-mode "cl-format" "\
Adds font-lock support for cl format strings.

If called interactively, enable Cl-Format-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-format" '("cl-format-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-format-builtins" '("?$" "?%" "?&" "?*" "?/" "?<" "??" "?\\[" "?^" "?_" "?a" "?b" "?c" "?d" "?e" "?f" "?g" "?i" "?o" "?p" "?r" "?s" "?t" "?w" "?x" "?{" "?~" "cl-format-" "single-key-description-forthcoming")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-format-def" '("cl-" "define-cl-format-directive")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clisp-format" '("char-" "clisp-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-spy-20160313.1440/cider-spy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-spy-20160313.1440/cider-spy-autoloads.el") (car load-path))))



(autoload 'cider-spy-nrepl-connected-hook "cider-spy" "\
This is called when an nREPL connection buffer is formed, and
   is executed with this buffer as the current buffer.

\(fn)" nil nil)

(autoload 'cider-spy-summary "cider-spy" "\
Create *cider-spy* buffer and attach listener.
   We assign a cider-spy-summary buffer to the nrepl-connection-buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-spy" '("cider-spy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-hydra-20161019.554/cider-hydra-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-hydra-20161019.554/cider-hydra-autoloads.el") (car load-path))))



(autoload 'cider-hydra-mode "cider-hydra" "\
Hydras for CIDER.

If called interactively, enable Cider-Hydra mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-hydra" '("cider-hydra-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-eval-sexp-fu-20160907.800/cider-eval-sexp-fu-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-eval-sexp-fu-20160907.800/cider-eval-sexp-fu-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-eval-sexp-fu" '("cider-esf--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-decompile-20151122.537/cider-decompile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-decompile-20151122.537/cider-decompile-autoloads.el") (car load-path))))



(autoload 'cider-decompile-func "cider-decompile" "\
Asks for the func name (FN-NAME) in the current namespace.and decompiles.

\(fn)" t nil)

(autoload 'cider-decompile-ns-func "cider-decompile" "\
Asks for the func name (FN-NAME) in a specific namespace and decompiles it.
The FN-NAME should be prefixed with the namespace.

\(fn FN-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-decompile" '("cider-decompile")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/choice-program-20180921.313/choice-program-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/choice-program-20180921.313/choice-program-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "choice-program" '("choice-prog")))



(autoload 'choice-program-default-prompt "choice-program-complete" "\
Format a prompt with optional default formatting.
PROMPT is the text used in the header minibuffer.
DEFAULT is the default input if given.
HISTORY is a quoted variable that has the history for this prompt history.

\(fn PROMPT &optional DEFAULT HISTORY)" nil nil)

(autoload 'choice-program-complete "choice-program-complete" "\
Read from the user a choice.

See `completing-read'.

PROMPT is a string to prompt with; normally it ends in a colon and a space.

CHOICES the list of things to auto-complete and allow the user to choose
  from.  Each element is analyzed independently If each element is not a
  string, it is written with `prin1-to-string'.

RETURN-AS-STRING is non-nil, return the symbol as a string
  (i.e. `symbol-name).

If REQUIRE-MATCH is non-nil, the user is not allowed to exit unless
  the input is (or completes to) an element of TABLE or is null.
  If it is also not t, Return does not exit if it does non-null completion.

If INITIAL-CONTENTS is non-nil, insert it in the minibuffer initially.
  If it is (STRING . POSITION), the initial input
  is STRING, but point is placed POSITION characters into the string.

HISTORY, if non-nil, specifies a history list
  and optionally the initial position in the list.
  It can be a symbol, which is the history list variable to use,
  or it can be a cons cell (HISTVAR . HISTPOS).
  In that case, HISTVAR is the history list variable to use,
  and HISTPOS is the initial position (the position in the list
  which INITIAL-CONTENTS corresponds to).
  If HISTORY is t, no history will be recorded.
  Positions are counted starting from 1 at the beginning of the list.

DEFAULT, if non-nil, will be returned when the user enters an empty
  string.

ALLOW-EMPTY-P, if non-nil, allow no data (empty string) to be returned.  In
  this case, nil is returned, otherwise, an error is raised.

NO-INITIAL-CONTENTS-ON-SINGLETON-P, if non-nil, don't populate with initialial
  contents when there is only one choice to pick from.

ADD-PROMPT-DEFAULT-P, if non-nil, munge the prompt using the default notation
  (ie `<Prompt> (default CHOICE)').

\(fn PROMPT CHOICES &optional RETURN-AS-STRING REQUIRE-MATCH INITIAL-CONTENTS HISTORY DEFAULT ALLOW-EMPTY-P NO-INITIAL-CONTENTS-ON-SINGLETON-P ADD-PROMPT-DEFAULT-P)" nil nil)




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/charmap-20160309.946/charmap-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/charmap-20160309.946/charmap-autoloads.el") (car load-path))))



(autoload 'charmap "charmap" "\
Display a specified unicode block.

\(fn)" t nil)

(autoload 'charmap-all "charmap" "\
Display entire unicode table.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "charmap" '("charmap-" "with-charmap-buffer")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/chapel-mode-20160504.808/chapel-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/chapel-mode-20160504.808/chapel-mode-autoloads.el") (car load-path))))



(defvar chapel-mode-syntax-table nil "\
Syntax table used in chapel-mode buffers.")
 (add-to-list 'auto-mode-alist '("\\.chpl\\'" . chapel-mode))

(defvar chapel-mode-hook nil "\
*Hook called by `chapel-mode'.")

(custom-autoload 'chapel-mode-hook "chapel-mode" t)

(autoload 'chapel-mode "chapel-mode" "\
Major mode for editing Chapel code.

To see what version of CC Mode you are running, enter `\\[c-version]'.

The hook `c-mode-common-hook' is run with no args at mode
initialization, then `chapel-mode-hook'.

Key bindings:
\\{chapel-mode-map}

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "chapel-mode" '("c-font-lock-chapel-new" "cc-imenu-chapel-generic-expression" "chapel-" "running-xemacs")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cff-20160118.2018/cff-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cff-20160118.2018/cff-autoloads.el") (car load-path))))



(autoload 'cff-find-other-file "cff" "\
Find the appropriate header, source or interface file for the current file.
If called with a PREFIX argument, force choice window
for multiple possible file variants; otherwise use the cached file name.

\(fn PREFIX)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cff" '("cff-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cedit-20141231.1614/cedit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cedit-20141231.1614/cedit-autoloads.el") (car load-path))))



(autoload 'cedit-forward-char "cedit" "\
balanced forward-char / returns point
foo|; {bar;} baz;  =>  foo;| {bar;} baz;
foo;| {bar;} baz;  =>  foo; {bar;}| baz;
foo; {bar;|} baz;  =>  ERROR
foo; {bar;} baz;|  =>  ERROR

\(fn &optional NEST)" t nil)

(autoload 'cedit-backward-char "cedit" "\
balanced backward-char / returns point
foo; {bar;}| baz;  =>  foo; |{bar;} baz;
foo;| {bar;} baz;  =>  foo|; {bar;} baz;
foo; {|bar;} baz;  =>  ERROR
|foo; {bar;} baz;  =>  ERROR

\(fn &optional NEST)" t nil)

(autoload 'cedit-end-of-statement "cedit" "\
goto end of statement
when THIS is non-nil, do not move to next statement
when fail, point is never moved
foo;| {bar;} baz;  =>  foo; {bar;}| baz;
foo; {bar;}| baz;  =>  foo; {bar;} baz;|
foo; {bar;} baz;|  =>  ERROR
foo; {bar;|} baz;  =>  ERROR

\(fn &optional THIS)" t nil)

(autoload 'cedit-beginning-of-statement "cedit" "\
goto beginning of statement
when THIS is non-nil, do not move to previous statement
when fail, point is never moved
foo; {bar;} |baz;  =>  foo; |{bar;} baz;
foo; |{bar;} baz;  =>  |foo; {bar;} baz;
|foo; {bar;} baz;  =>  ERROR
foo; {|bar;} baz;  =>  ERROR

\(fn &optional THIS)" t nil)

(autoload 'cedit-down-block "cedit" "\
go down into block
|else{foo; bar;}  =>  else{|foo; bar;}
|foo;  =>  ERROR

\(fn)" t nil)

(autoload 'cedit-up-block-backward "cedit" "\
go backward out of block.
if called at top-level, goto beginning of the first statement.
do{foo; bar; b|az;}  =>  |do{foo; bar; baz;}
 foo; bar; b|az;   =>   |foo; bar; baz;

\(fn)" t nil)

(autoload 'cedit-up-block-forward "cedit" "\
go forward out of block.
if called at top-level, goto end of the last statement.
do{foo; bar; b|az;}  =>  do{foo; bar; baz;}|
 foo; bar; b|az;   =>   foo; bar; baz;|

\(fn)" t nil)

(autoload 'cedit-slurp "cedit" "\
slurp statement
{fo|o; bar;} baz;  =>  {fo|o, bar;} baz;
                   =>  {fo|o, bar; baz;}
                   =>  {fo|o, bar, baz;}

\(fn)" t nil)

(autoload 'cedit-wrap-brace "cedit" "\
wrap statement with brace
to wrap two or more statements, mark them

\(fn)" t nil)

(autoload 'cedit-barf "cedit" "\
barf statement
{fo|o, bar; baz;}  =>  {fo|o; bar; baz;}
                   =>  {fo|o; bar;} baz;
                   =>  {fo|o;} bar; baz;

\(fn)" t nil)

(autoload 'cedit-splice-killing-backward "cedit" "\
splice statements killing preceding statements
{foo; bar, b|az, foobar;}  =>  {foo; |baz, foobar;}
                           =>  {|baz, foobar;}
                           =>  baz, foobar;

\(fn)" t nil)

(autoload 'cedit-raise "cedit" "\
raise statement
{foo; bar, b|az, foobar;}  =>  {foo; |baz;}
                           =>  baz;
to raise statement, in case comma-expr is also able to be raise, mark it.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cedit" '("cedit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cd-compile-20141108.1957/cd-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cd-compile-20141108.1957/cd-compile-autoloads.el") (car load-path))))



(defvar cd-compile-directory nil "\
Directory in which to run compile.")

(put 'cd-compile-directory 'safe-local-variable 'stringp)

(autoload 'cd-compile "cd-compile" "\
Run compile in a specific directory.
Runs \\[compile] in the directory DIR.

Interactively, uses `cd-compile-directory' for the directory if
non-nil; otherwise prompts the user to enter the directory.

\(fn DIR)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ccls-20181007.524/ccls-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ccls-20181007.524/ccls-autoloads.el") (car load-path))))


 (autoload 'lsp-ccls-enable "ccls")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls" '("ccls-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls-call-hierarchy" '("ccls-call-hierarchy")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls-code-lens" '("ccls-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls-common" '("ccls--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls-inheritance-hierarchy" '("ccls-inheritance-hierarchy")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls-member-hierarchy" '("ccls-member-hierarchy")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls-semantic-highlighting" '("ccls-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ccls-tree" '("ccls-tree-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cargo-20180812.1218/cargo-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cargo-20180812.1218/cargo-autoloads.el") (car load-path))))



(autoload 'cargo-minor-mode "cargo" "\
Cargo minor mode. Used to hold keybindings for cargo-mode.

If called interactively, enable cargo minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{cargo-minor-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cargo" '("cargo-minor-mode")))



(autoload 'cargo-process-bench "cargo-process" "\
Run the Cargo bench command.
With the prefix argument, modify the command's invocation.
Cargo: Run the benchmarks.

\(fn)" t nil)

(autoload 'cargo-process-build "cargo-process" "\
Run the Cargo build command.
With the prefix argument, modify the command's invocation.
Cargo: Compile the current project.

\(fn)" t nil)

(autoload 'cargo-process-clean "cargo-process" "\
Run the Cargo clean command.
With the prefix argument, modify the command's invocation.
Cargo: Remove the target directory.

\(fn)" t nil)

(autoload 'cargo-process-doc "cargo-process" "\
Run the Cargo doc command.
With the prefix argument, modify the command's invocation.
Cargo: Build this project's and its dependencies' documentation.

\(fn)" t nil)

(autoload 'cargo-process-doc-open "cargo-process" "\
Run the Cargo doc command with the --open switch.
With the prefix argument, modify the command's invocation.
Cargo: Open this project's documentation.

\(fn)" t nil)

(autoload 'cargo-process-new "cargo-process" "\
Run the Cargo new command.
With the prefix argument, modify the command's invocation.
NAME is the name of your application.
If BIN is t then create a binary application, otherwise a library.
Cargo: Create a new cargo project.

\(fn NAME &optional BIN)" t nil)

(autoload 'cargo-process-init "cargo-process" "\
Run the Cargo init command.
With the prefix argument, modify the command's invocation.
DIRECTORY is the directory you want to create a cargo project in.
If BIN is t then create a binary application, otherwise a library.
Cargo: Create a new cargo project in current directory.

\(fn DIRECTORY &optional BIN)" t nil)

(autoload 'cargo-process-run "cargo-process" "\
Run the Cargo run command.
With the prefix argument, modify the command's invocation.
Cargo: Build and execute src/main.rs.

\(fn)" t nil)

(autoload 'cargo-process-run-bin "cargo-process" "\
Run the Cargo run command --bin <name>.
With the prefix argument, modify the command's invocation.
Cargo: Build and execute a specific binary

\(fn COMMAND)" t nil)

(autoload 'cargo-process-run-example "cargo-process" "\
Run the Cargo run command --example <name>.
With the prefix argument, modify the command's invocation.
Cargo: Build and execute with --example <name>.

\(fn COMMAND)" t nil)

(autoload 'cargo-process-search "cargo-process" "\
Run the Cargo search command.
With the prefix argument, modify the command's invocation.
SEARCH-TERM is used as the search term for the Cargo registry.
Cargo: Search registry for crates.

\(fn SEARCH-TERM)" t nil)

(autoload 'cargo-process-test "cargo-process" "\
Run the Cargo test command.
With the prefix argument, modify the command's invocation.
Cargo: Run the tests.

\(fn)" t nil)

(autoload 'cargo-process-current-test "cargo-process" "\
Run the Cargo test command for the current test.
With the prefix argument, modify the command's invocation.
Cargo: Run the tests.

\(fn)" t nil)

(autoload 'cargo-process-current-file-tests "cargo-process" "\
Run the Cargo test command for the current file.
With the prefix argument, modify the command's invocation.
Cargo: Run the tests.

\(fn)" t nil)

(autoload 'cargo-process-update "cargo-process" "\
Run the Cargo update command.
With the prefix argument, modify the command's invocation.
Cargo: Update dependencies listed in Cargo.lock.

\(fn)" t nil)

(autoload 'cargo-process-fmt "cargo-process" "\
Run the Cargo fmt command.
With the prefix argument, modify the command's invocation.
Requires Cargo Fmt to be installed.

\(fn)" t nil)

(autoload 'cargo-process-check "cargo-process" "\
Run the Cargo check command.
With the prefix argument, modify the command's invocation.
Cargo: Check compile the current project.
Requires cargo-check to be installed.

\(fn)" t nil)

(autoload 'cargo-process-clippy "cargo-process" "\
Run the Cargo clippy command.
With the prefix argument, modify the command's invocation.
Cargo: Clippy compile the current project.
Requires Cargo clippy to be installed.

\(fn)" t nil)

(autoload 'cargo-process-add "cargo-process" "\
Run the Cargo add command.
With the prefix argument, modify the command's invocation.
CRATES is the name of the crate to add.
Cargo: This command allows you to add a dependency to a Cargo.toml manifest file.

\(fn CRATE)" t nil)

(autoload 'cargo-process-rm "cargo-process" "\
Run the Cargo rm command.
With the prefix argument, modify the command's invocation.
CRATE is the name of the crate to remove.
Cargo: Remove a dependency from a Cargo.toml manifest file.

\(fn CRATE)" t nil)

(autoload 'cargo-process-upgrade "cargo-process" "\
Run the Cargo update command.
With the prefix argument, modify the command's invocation.
If ALL is t then update all crates, otherwise specify CRATES.
Cargo: Upgrade dependencies as specified in the local manifest file

\(fn &optional ALL CRATES)" t nil)

(autoload 'cargo-process-repeat "cargo-process" "\
Run the last cargo-process command.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cargo-process" '("cargo-process-" "manifest-path-argument" "rustc-errno" "set-rust-backtrace")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/c-eldoc-20170917.2202/c-eldoc-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/c-eldoc-20170917.2202/c-eldoc-autoloads.el") (car load-path))))



(autoload 'c-turn-on-eldoc-mode "c-eldoc" "\
Enable c-eldoc-mode

\(fn)" t nil)

(autoload 'c-eldoc-print-current-symbol-info "c-eldoc" "\
Returns documentation string for the current symbol.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "c-eldoc" '("c-eldoc-" "call-c-eldoc-cleanup")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/build-status-20171111.1947/build-status-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/build-status-20171111.1947/build-status-autoloads.el") (car load-path))))


 (put 'build-status-mode-line-string 'risky-local-variable t)

(autoload 'build-status-mode "build-status" "\
Monitor the build status of the buffer's project.

If called interactively, enable Build-Status mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "build-status" '("build-status-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/build-helper-20161009.1755/build-helper-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/build-helper-20161009.1755/build-helper-autoloads.el") (car load-path))))



(autoload 'build-helper-setup "build-helper" "\
Setup build-helper.

\(fn)" nil nil)

(autoload 'build-helper-re-run "build-helper" "\
Run the last command or functions associated with a TARGET.

\(fn TARGET)" t nil)

(autoload 'build-helper-run "build-helper" "\
Run functions associated with TARGET, prompt if all fail.

This runs functions associated with the current `major-mode' and TARGET.

If all functions return nil, display a prompt with history of the last commands
executed in this project, `major-mode' and target.

This compile command will be executed from the function `projectile-project-root' directory.

\(fn TARGET)" t nil)

(autoload 'build-helper-re-run-test "build-helper" "\
Run `build-helper-re-run' with target test.

\(fn)" t nil)

(autoload 'build-helper-re-run-build "build-helper" "\
Run `build-helper-re-run' with target build.

\(fn)" t nil)

(autoload 'build-helper-re-run-run "build-helper" "\
Run `build-helper-re-run' with target run.

\(fn)" t nil)

(autoload 'build-helper-run-test "build-helper" "\
Run `build-helper-run' with target test.

\(fn)" t nil)

(autoload 'build-helper-run-build "build-helper" "\
Run `build-helper-run' with target build.

\(fn)" t nil)

(autoload 'build-helper-run-run "build-helper" "\
Run `build-helper-run' with target run.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "build-helper" '("build-helper-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/buffer-manage-20180528.1613/buffer-manage-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/buffer-manage-20180528.1613/buffer-manage-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "buffer-manage" '("buffer-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "config-manage" '("config-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/bshell-20170903.1837/bshell-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/bshell-20170903.1837/bshell-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bshell" '("bshell-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/better-shell-20180625.1316/better-shell-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/better-shell-20180625.1316/better-shell-autoloads.el") (car load-path))))



(autoload 'better-shell-remote-open "better-shell" "\
Prompt for a remote host to connect to, and open a shell
there.  With prefix argument, get a sudo shell.

\(fn &optional ARG)" t nil)

(autoload 'better-shell-sudo-here "better-shell" "\
Reopen the current file, directory, or shell as root.
For files and dired buffers, the non-sudo buffer is replaced with
a sudo buffer.  For shells, a sudo shell is opened but the
non-sudo shell is left in tact.

\(fn)" t nil)

(autoload 'better-shell-shell "better-shell" "\
Pop to an appropriate shell.
Cycle through all the shells, most recently used first.  When
called with a prefix ARG, finds or creates a shell in the current
directory.

\(fn &optional ARG)" t nil)

(autoload 'better-shell-for-projectile-root "better-shell" "\
Find or create a shell in the projectile root.
See `better-shell-for-dir' for details on how shells are found or created.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "better-shell" '("better-shell-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/beacon-20181008.1350/beacon-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/beacon-20181008.1350/beacon-autoloads.el") (car load-path))))



(autoload 'beacon-blink "beacon" "\
Blink the beacon at the position of the cursor.
Unlike `beacon-blink-automated', the beacon will blink
unconditionally (even if `beacon-mode' is disabled), and this can
be invoked as a user command or called from lisp code.

\(fn)" t nil)

(defvar beacon-mode nil "\
Non-nil if Beacon mode is enabled.
See the `beacon-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `beacon-mode'.")

(custom-autoload 'beacon-mode "beacon" nil)

(autoload 'beacon-mode "beacon" "\
Toggle Beacon mode on or off.

If called interactively, enable Beacon mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{beacon-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "beacon" '("beacon-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/basic-c-compile-20170302.1112/basic-c-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/basic-c-compile-20170302.1112/basic-c-compile-autoloads.el") (car load-path))))



(autoload 'basic-c-compile-makefile "basic-c-compile" "\
Create a Makefile of the form shown in README.org.
This function uses the variables `basic-c-compile-compiler',
`basic-c-compile-all-files' and `basic-c-compile-compiler-flags'.
It uses `basic-c-compile--files-to-compile' in conjunction with
`basic-c-compiler-all-files' to determine files to be the
Makefile's INFILE.

\(fn)" t nil)

(autoload 'basic-c-compile-file "basic-c-compile" "\
Compile file with or without a Makefile.
A y-or-n prompt is called to determine if you want to use the
Makefile of not.  If you say yes ('y') and there is no Makefile
in the directory then one is make using
`basic-c-compile--makefile'.  The presence of a outfile is
check for, if there is not one then 'rebuild' is called,
otherwise 'build' is called.

\(fn)" t nil)

(autoload 'basic-c-compile-run-c "basic-c-compile" "\
Run the program.
If the C source file is new than the outfile and
`basic-c-compile-auto-comp' is true, then the file will be
compiled before it is run.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "basic-c-compile" '("basic-c-compile-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/avy-flycheck-20160720.1500/avy-flycheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/avy-flycheck-20160720.1500/avy-flycheck-autoloads.el") (car load-path))))



(autoload 'avy-flycheck-goto-error "avy-flycheck" "\
Jump to a flycheck syntax error.
The window scope is determined by `avy-all-windows' (ARG negates it).

\(fn &optional ARG)" t nil)

(autoload 'avy-flycheck-setup "avy-flycheck" "\
Set up default keybindings.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "avy-flycheck" '("avy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/autodisass-llvm-bitcode-20150411.125/autodisass-llvm-bitcode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/autodisass-llvm-bitcode-20150411.125/autodisass-llvm-bitcode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "autodisass-llvm-bitcode" '("ad-llvm-bitcode-" "autodisass-llvm-bitcode-version")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-shell-command-20180817.1502/auto-shell-command-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-shell-command-20180817.1502/auto-shell-command-autoloads.el") (car load-path))))



(autoload 'ascmd:notify "auto-shell-command" "\


\(fn MSG)" nil nil)

(autoload 'ascmd:toggle "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:add "auto-shell-command" "\


\(fn &optional V)" t nil)

(autoload 'ascmd:remove "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:remove-all "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:popup "auto-shell-command" "\


\(fn N)" t nil)

(autoload 'ascmd:exec "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:process-count-clear "auto-shell-command" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-shell-command" '("ascmd:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-minor-mode-20180527.1123/auto-minor-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-minor-mode-20180527.1123/auto-minor-mode-autoloads.el") (car load-path))))



(defvar auto-minor-mode-alist nil "\
Alist of filename patterns vs corresponding minor mode functions.

This is an equivalent of ‘auto-mode-alist’, for minor modes.

Unlike ‘auto-mode-alist’, matching is always case-folded.")

(defvar auto-minor-mode-magic-alist nil "\
Alist of buffer beginnings vs corresponding minor mode functions.

This is an equivalent of ‘magic-mode-alist’, for minor modes.

Magic minor modes are applied after ‘set-auto-mode’ enables any
major mode, so it’s possible to check for expected major modes in
match functions.

Unlike ‘magic-mode-alist’, matching is always case-folded.")

(autoload 'auto-minor-mode-set "auto-minor-mode" "\
Enable all minor modes appropriate for the current buffer.

If the optional argument KEEP-MODE-IF-SAME is non-nil, then we
don’t re-activate minor modes already enabled in the buffer.

\(fn &optional KEEP-MODE-IF-SAME)" nil nil)

(advice-add #'set-auto-mode :after #'auto-minor-mode-set)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-minor-mode" '("auto-minor-mode-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-highlight-symbol-20130313.943/auto-highlight-symbol-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-highlight-symbol-20130313.943/auto-highlight-symbol-autoloads.el") (car load-path))))



(defvar global-auto-highlight-symbol-mode nil "\
Non-nil if Global Auto-Highlight-Symbol mode is enabled.
See the `global-auto-highlight-symbol-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-auto-highlight-symbol-mode'.")

(custom-autoload 'global-auto-highlight-symbol-mode "auto-highlight-symbol" nil)

(autoload 'global-auto-highlight-symbol-mode "auto-highlight-symbol" "\
Toggle Auto-Highlight-Symbol mode in all buffers.
With prefix ARG, enable Global Auto-Highlight-Symbol mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Highlight-Symbol mode is enabled in all buffers where
`ahs-mode-maybe' would do it.
See `auto-highlight-symbol-mode' for more information on Auto-Highlight-Symbol mode.

\(fn &optional ARG)" t nil)

(autoload 'auto-highlight-symbol-mode "auto-highlight-symbol" "\
Toggle Auto Highlight Symbol Mode

If called interactively, enable Auto-Highlight-Symbol mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-highlight-symbol" '("ahs-" "auto-highlight-symbol-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-exuberant-ctags-20140320.724/auto-complete-exuberant-ctags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-exuberant-ctags-20140320.724/auto-complete-exuberant-ctags-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-exuberant-ctags" '("ac-exuberant-ctags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-clang-async-20130526.1514/auto-complete-clang-async-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-clang-async-20130526.1514/auto-complete-clang-async-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-clang-async" '("ac-clang-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-clang-20140409.752/auto-complete-clang-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-clang-20140409.752/auto-complete-clang-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-clang" '("ac-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-chunk-20140225.946/auto-complete-chunk-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-chunk-20140225.946/auto-complete-chunk-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-chunk" '("ac-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-c-headers-20150912.323/auto-complete-c-headers-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-c-headers-20150912.323/auto-complete-c-headers-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-c-headers" '("achead:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-compile-20180321.1507/auto-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-compile-20180321.1507/auto-compile-autoloads.el") (car load-path))))



(autoload 'auto-compile-mode "auto-compile" "\
Compile Emacs Lisp source files after the visiting buffers are saved.

If called interactively, enable Auto-Compile mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

After a buffer containing Emacs Lisp code is saved to its source
file update the respective byte code file.  If the latter does
not exist do nothing.  Therefore to disable automatic compilation
remove the byte code file.  See command `toggle-auto-compile' for
a convenient way to do so.

This mode should be enabled globally, using it's globalized
variant `auto-compile-on-save-mode'.  Also see the related
`auto-compile-on-load-mode'.

\(fn &optional ARG)" t nil)

(defvar auto-compile-on-save-mode nil "\
Non-nil if Auto-Compile-On-Save mode is enabled.
See the `auto-compile-on-save-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `auto-compile-on-save-mode'.")

(custom-autoload 'auto-compile-on-save-mode "auto-compile" nil)

(autoload 'auto-compile-on-save-mode "auto-compile" "\
Toggle Auto-Compile mode in all buffers.
With prefix ARG, enable Auto-Compile-On-Save mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Compile mode is enabled in all buffers where
`turn-on-auto-compile-mode' would do it.
See `auto-compile-mode' for more information on Auto-Compile mode.

\(fn &optional ARG)" t nil)

(autoload 'toggle-auto-compile "auto-compile" "\
Toggle automatic compilation of an Emacs Lisp source file or files.

Read a file or directory name from the minibuffer defaulting to
the visited Emacs Lisp source file or `default-directory' if no
such file is being visited in the current buffer.

If the user selects a file then automatic compilation of only
that file is toggled.  Since both `auto-compile-on-save' and
`auto-compile-on-save' only ever _recompile_ byte code files,
toggling automatic compilation is done simply by creating or
removing the respective byte code file.

If the user selects a directory then automatic compilation for
multiple files is toggled as follows:

* With a positive prefix argument always compile source files;
  with a negative prefix argument always remove byte code files.

* Otherwise the existence or absence of the byte code file of
  the source file that was current when this command was invoked
  determines whether byte code files should be created or removed.

* If no Emacs Lisp source file is being visited in the buffer
  that was current when the command was invoked ask the user what
  to do.

* When _removing_ byte code files then all byte code files are
  removed.  If `auto-compile-deletes-stray-dest' is non-nil this
  even includes byte code files for which no source file exists.

* When _creating_ byte code files only do so for source files
  that are actual libraries.  Source files that provide the
  correct feature are considered to be libraries; see
  `packed-library-p'.

* Note that non-libraries can still be automatically compiled,
  you just cannot _recursively_ turn on automatic compilation
  using this command.

* When `auto-compile-toggle-recompiles' is non-nil recompile all
  affected source files even when the respective source files are
  up-to-date.  Do so even for non-library source files.

* Only enter subdirectories for which `packed-ignore-directory-p'
  returns nil; i.e. don't enter hidden directories or directories
  containing a file named \".nosearch\".

\(fn FILE ACTION)" t nil)

(defvar auto-compile-on-load-mode nil "\
Non-nil if Auto-Compile-On-Load mode is enabled.
See the `auto-compile-on-load-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `auto-compile-on-load-mode'.")

(custom-autoload 'auto-compile-on-load-mode "auto-compile" nil)

(autoload 'auto-compile-on-load-mode "auto-compile" "\
Before loading a library recompile it if it needs recompilation.

If called interactively, enable Auto-Compile-On-Load mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

A library needs to be recompiled if the source file is newer than
it's byte-compile destination.  Without this advice the outdated
byte code file would be loaded instead.

Also see the related `auto-compile-on-save-mode'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-compile" '("auto-compile-" "mode-line-" "turn-on-auto-compile-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/android-mode-20170323.815/android-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/android-mode-20170323.815/android-mode-autoloads.el") (car load-path))))



(autoload 'android-mode "android-mode" "\
Android application development minor mode.

If called interactively, enable Android mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "android-mode" '("android-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/align-cljlet-20160112.2101/align-cljlet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/align-cljlet-20160112.2101/align-cljlet-autoloads.el") (car load-path))))



(autoload 'align-cljlet "align-cljlet" "\
Align a let form so that the bindings neatly align into columns

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "align-cljlet" '("acl-" "defroute-columns")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-rtags-20170523.454/ac-rtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-rtags-20170523.454/ac-rtags-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-rtags" '("ac-rtags-" "rtags-location-regx")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-racer-20170114.809/ac-racer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-racer-20170114.809/ac-racer-autoloads.el") (car load-path))))



(autoload 'ac-racer-setup "ac-racer" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-racer" '("ac-racer--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-etags-20161001.1507/ac-etags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-etags-20161001.1507/ac-etags-autoloads.el") (car load-path))))



(autoload 'ac-etags-ac-setup "ac-etags" "\
Add `ac-source-etags' to `ac-sources' and enable `auto-complete' mode

\(fn)" t nil)

(autoload 'ac-etags-clear-cache "ac-etags" "\


\(fn)" t nil)

(autoload 'ac-etags-setup "ac-etags" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-etags" '("ac-etags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-clang-20180710.546/ac-clang-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-clang-20180710.546/ac-clang-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-clang" '("ac-clang-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clang-server" '("clang-server-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-cider-20161006.719/ac-cider-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-cider-20161006.719/ac-cider-autoloads.el") (car load-path))))



(defface ac-cider-candidate-face '((t (:inherit ac-candidate-face))) "\
Face for nrepl candidates." :group 'auto-complete)

(defface ac-cider-selection-face '((t (:inherit ac-selection-face))) "\
Face for the nrepl selected candidate." :group 'auto-complete)

(defconst ac-cider-source-defaults '((available . ac-cider-available-p) (candidate-face . ac-cider-candidate-face) (selection-face . ac-cider-selection-face) (prefix . cider-completion-symbol-start-pos) (match . ac-cider-match-fuzzy) (document . ac-cider-documentation) (cache)) "\
Defaults common to the various completion sources.")

(defvar ac-source-cider-everything (append '((candidates . ac-cider-candidates-everything) (symbol . "v")) ac-cider-source-defaults) "\
Auto-complete source for CIDER buffers.")

(autoload 'ac-cider-setup "ac-cider" "\
Add the CIDER completion source to the front of `ac-sources'.
This affects only the current buffer.

\(fn)" t nil)

(autoload 'ac-cider-popup-doc "ac-cider" "\
A popup alternative to `cider-doc'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-cider" '("ac-cider-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-capf-20151101.217/ac-capf-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-capf-20151101.217/ac-capf-autoloads.el") (car load-path))))



(autoload 'ac-capf-setup "ac-capf" "\
Add `ac-source-capf' to `ac-sources' and enable `auto-complete' mode

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-capf" '("ac-capf--candidates")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-c-headers-20151021.834/ac-c-headers-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-c-headers-20151021.834/ac-c-headers-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-c-headers" '("ac-")))


)
(setq package-activated-list
  (append
    '(dash s deferred request request-deferred epl pkg-info ycmd ycm yasnippet yasnippet-snippets yasnippet-classic-snippets yafolding xtest xterm-title xterm-keybinder xterm-frobs xterm-color xcscope x86-lookup x509-mode with-simulated-input async with-editor imenu-list window-purpose window-layout web-server web a parseclj treepy walkclj vkill visual-regexp visual-regexp-steroids unkillable-scratch undohist undo-tree shut-up undercover clojure-mode queue spinner sesman cider typed-clojure-mode tNFA heap trie tree-mode thingopt test-simple fringe-helper test-case-mode test-c term-run term-manager term+ tab-group term+mux tco tablist tab-jump-out syntactic-close symbol-overlay ivy swiper sudo-ext sudo-edit string-edit strie stream strace-mode ssh-tunnels ssh-config-mode ssh-agency ssh srefactor sotlisp sotclojure snippet smartscan smartparens f popup dumb-jump smart-jump expand-region smart-forward smart-cursor-color smart-compile smart-comment macrostep slime company slime-company simple-httpd signal shell-toggle shell-switcher shell-command sexp-move sequences sed-mode scheme-here scheme-complete sayid projectile markdown-mode graphql ghub git-commit magit-popup magit rustic rust-playground rust-mode rtags restart-emacs replace-symbol replace-pairs fullframe repl-toggle readline-complete faceup racket-mode pos-tip racer quack preproc-font-lock posframe popwin popup-complete pcache list-utils persistent-soft peg noflet kv creole fakir db elnode peek-mode pdf-tools pcmpl-git pcmpl-args parinfer paren-face paredit packed package-safe-delete opencl-mode ob-rust nrepl-sync highlight nrepl-eval-sexp-fu esxml nov nasm-mode multiple-cursors monroe modern-cpp-font-lock mmt minimap minimal-session-saver mic-paren mc-extras maxframe helm-core helm math-symbols math-symbol-lists mark-multiple manage-minor-mode malinka makey makefile-executor macro-math dash-functional flycheck lsp-mode lsp-ui lsp-rust lsp-clangd log4e ht list-packages-ext lisp-extra-font-lock levenshtein language-detection json-snatcher json-reformat json-mode jdecomp javap-mode javadoc-lookup java-imports hydra ivy-hydra counsel ivy-dired-history isearch-symbol-at-point irony irony-eldoc ipretty inflections inf-clojure iedit ido-at-point htmlize hippie-namespace hippie-exp-ext highlight-unique-symbol highlight-thing highlight-symbol highlight-stages highlight-refontification highlight-quoted highlight-parentheses highlight-operators highlight-function-calls highlight-escape-sequences highlight-defined helm-xref helm-rtags helm-proc helm-mode-manager helm-gtags helm-frame helm-flymake helm-flycheck helm-etags-plus helm-cscope helm-company helm-codesearch edn helm-clojuredocs helm-cider-history helm-cider helm-c-yasnippet google-c-style golden-ratio-scroll-screen gnome-c-style gited gitconfig-mode gitconfig git-wip-timemachine git-timemachine git-msg-prefix git-messenger git-link git-lens git-io git-dwim git-command git-auto-commit-mode git-attr git ggtags fuzzy function-args foreign-regexp font-lock-studio font-lock-profiler font-lock+ fn flyparens flymake-easy flymake-shell flymake-rust flymake-racket flymake-gradle flymake-google-cpplint flymake-cursor flymake-cppcheck flycheck-ycmd flycheck-tip flycheck-swiftlint flycheck-rust flycheck-rtags flycheck-posframe flycheck-pos-tip flycheck-popup-tip flycheck-pkg-config flycheck-joker flycheck-irony flycheck-inline flycheck-cstyle flycheck-color-mode-line flycheck-clojure flycheck-clangcheck flycheck-clang-tidy flycheck-clang-analyzer flycheck-checkbashisms flx flx-isearch flx-ido evalator evalator-clojure eval-sexp-fu avy ace-window eval-in-repl eval-expr eterm-256color es-lib elmacro elisp-sandbox elisp-lint elf-mode elein eldoc-eval el-sprunge ctable anaphora el-init el-init-viewer el-get el-autoyas clomacs auto-complete direx ejc-sql eide eglot edebug-x ede-compdb ecb eacl dr-racket-like-unicode discover-my-major clj-refactor discover discover-clj-refactor disaster diffview demangle-mode delim-kill datomic-snippets ctags-update cquery cpputils-cmake counsel-etags concurrent company-ycmd company-ycm company-statistics company-rtags company-racer company-posframe company-math company-lsp company-irony-c-headers company-irony company-flx company-c-headers common-lisp-snippets commenter comint-intercept codesearch codebug cmake-project cmake-mode cmake-ide cmake-font-lock closure-lint-mode clojure-snippets clojure-quick-repls clojure-mode-extra-font-locking clojure-cheatsheet clojars cljsbuild-mode cljr-helm clang-format cl-lib-highlight cl-format cider-spy cider-hydra cider-eval-sexp-fu cider-decompile choice-program charmap chapel-mode cff cedit cd-compile ccls cargo c-eldoc build-status build-helper buffer-manage bshell better-shell beacon basic-c-compile avy-flycheck autodisass-llvm-bitcode auto-shell-command auto-minor-mode auto-highlight-symbol auto-complete-exuberant-ctags auto-complete-clang-async auto-complete-clang auto-complete-chunk auto-complete-c-headers auto-compile android-mode align-cljlet ac-rtags ac-racer ac-etags ac-clang ac-cider ac-capf ac-c-headers)
    package-activated-list))
(progn
  (require 'info)
  (info-initialize)
  (setq Info-directory-list
    (append
      '("/home/lk/.emacs.d/elpa/magit-20181009.8" "/home/lk/.emacs.d/elpa/magit-popup-20181003.921" "/home/lk/.emacs.d/elpa/ghub-20181003.1456" "/home/lk/.emacs.d/elpa/slime-20180923.1848" "/home/lk/.emacs.d/elpa/ivy-20180926.1249" "/home/lk/.emacs.d/elpa/with-editor-20181008.2142")
      Info-directory-list)))

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; End:
