;;; Quickstart file to activate all packages at startup  -*- lexical-binding:t -*-
;; ¡¡ This file is autogenerated by `package-quickstart-refresh', DO NOT EDIT !!

(let ((load-file-name "/home/lk/.emacs.d/elpa/yasnippet-20180621.50/yasnippet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/yasnippet-20180621.50/yasnippet-autoloads.el") (car load-path))))



(autoload 'yas-minor-mode "yasnippet" "\
Toggle YASnippet mode.

If called interactively, enable Yas minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When YASnippet mode is enabled, `yas-expand', normally bound to
the TAB key, expands snippets of code depending on the major
mode.

With no argument, this command toggles the mode.
positive prefix argument turns on the mode.
Negative prefix argument turns off the mode.

Key bindings:
\\{yas-minor-mode-map}

\(fn &optional ARG)" t nil)

(defvar yas-global-mode nil "\
Non-nil if Yas-Global mode is enabled.
See the `yas-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `yas-global-mode'.")

(custom-autoload 'yas-global-mode "yasnippet" nil)

(autoload 'yas-global-mode "yasnippet" "\
Toggle Yas minor mode in all buffers.
With prefix ARG, enable Yas-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Yas minor mode is enabled in all buffers where
`yas-minor-mode-on' would do it.
See `yas-minor-mode' for more information on Yas minor mode.

\(fn &optional ARG)" t nil)
(autoload 'snippet-mode "yasnippet" "A mode for editing yasnippets" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yasnippet" '("help-snippet-def" "snippet-mode-map" "yas")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/yafolding-20170305.317/yafolding-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/yafolding-20170305.317/yafolding-autoloads.el") (car load-path))))



(defvar yafolding-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "<C-S-return>") #'yafolding-hide-parent-element) (define-key map (kbd "<C-M-return>") #'yafolding-toggle-all) (define-key map (kbd "<C-return>") #'yafolding-toggle-element) map))

(autoload 'yafolding-mode "yafolding" "\
Toggle yafolding mode.

If called interactively, enable Yafolding mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yafolding" '("yafolding-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xtest-20141214.1706/xtest-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xtest-20141214.1706/xtest-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xtest" '("xt-" "xtd-" "xtest-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-title-20091203.1023/xterm-title-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-title-20091203.1023/xterm-title-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-title" '("xterm-title-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-keybinder-20160523.56/xterm-keybinder-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-keybinder-20160523.56/xterm-keybinder-autoloads.el") (car load-path))))



(autoload 'xterm-keybinder-setup "xterm-keybinder" "\
Enable Emacs keybinds even in the xterm terminal Emacs.

\(fn)" t nil)

(autoload 'urxvt-keybinder-insert "xterm-keybinder" "\
Insert urxvt setting.

\(fn)" t nil)

(autoload 'urxvt-change-font-size "xterm-keybinder" "\
Change font size in URxvt.

OFFSET is a variable to increase/decrease the font size from
current font size.

Optional variable FONT is the font name and as the default value,
this functions uses the value that you will set in
‘urxvt-keybinder-setup’.

If you set optional ABSOLUTE-SIZE variable, this function priors
the size than OFFSET and sets the ABSOLUTE-SIZE.

\(fn OFFSET &optional FONT ABSOLUTE-SIZE)" nil nil)

(autoload 'urxvt-keybinder-setup "xterm-keybinder" "\
Setup function for URxvt.
You can also set FONT name and the SIZE.

If you set BOTH FONT and SIZE, you can use ‘text-scale-increase’
and ‘text-scale-decrease’ functions to adjust font size inside
URxvt frame.

\(fn &optional FONT SIZE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-keybinder" '("urxvt-font-" "xterm-keybinder-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-frobs-20161207.1609/xterm-frobs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-frobs-20161207.1609/xterm-frobs-autoloads.el") (car load-path))))



(autoload 'xterm-iconify "xterm-frobs" "\
Minimize (iconify) xterm window.

\(fn)" t nil)

(autoload 'xterm-deiconify "xterm-frobs" "\
Restore (deiconify) xterm window.

\(fn)" t nil)

(autoload 'xterm-set-font "xterm-frobs" "\
Set the font of the xterm window to FONT.
When called interactively, prompt for the name of the font to use.

This function is used to change the font of the xterm window in which a
tty-mode emacs is running.  It should also work if emacs is running under
`screen' in an xterm window.

Use \\[set-default-font] if this emacs is using the window system directly.

\(fn FONT-NAME)" t nil)

(autoload 'xterm-set-icon-title "xterm-frobs" "\
Set the title in the icon for this xterm window to TITLE.
This does not change the title of the corresponding window.

\(fn TITLE)" t nil)

(autoload 'xterm-set-window-title "xterm-frobs" "\
Set the title for xterm window to TITLE.
This does not change the title in the corresponding icon.

\(fn TITLE)" t nil)

(autoload 'xterm-set-all-titles "xterm-frobs" "\
Set the title for xterm window and corresponding icon to TITLE.

\(fn TITLE)" t nil)

(autoload 'xterm-set-background-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-foreground-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-cursor-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-mouse-foreground-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-mouse-background-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-set-highlight-color "xterm-frobs" "\


\(fn COLOR)" t nil)

(autoload 'xterm-reverse-video "xterm-frobs" "\
Set xterm to reverse video mode.
For monochrome xterms, this is white foreground on black background.
For xterms which support color, this has the effect of swapping the
foreground and background colors, whatever they may be.

The effect of this command and \\[xterm-normal-video] may be exchanged
if the XTerm*reverseVideo resource property is set to True.

\(fn)" t nil)

(autoload 'xterm-normal-video "xterm-frobs" "\
Set xterm to normal (i.e. non-reverse) video mode.
For monochrome xterms, this is black foreground on white background.
For xterms which support color, this has the effect of restoring the
original foreground and background colors, whatever they may be.

The effect of this command and \\[xterm-reverse-video] may be exchanged
if the XTerm*reverseVideo resource property is set to True.

\(fn)" t nil)

(autoload 'xterm-sync-emacs-colors "xterm-frobs" "\
Query xterm for color palette and define color list for Emacs.

\(fn)" t nil)

(autoload 'xterm-print-formatted-color-alist "xterm-frobs" "\
Create a pretty-printed table of the current xterm color map.
This table is inserted into a new buffer which can be saved to a file and
reloaded later.

\(fn &optional COLOR-ALIST)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-frobs" '("xterm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/xterm-color-20180202.2318/xterm-color-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/xterm-color-20180202.2318/xterm-color-autoloads.el") (car load-path))))



(autoload 'xterm-color-filter "xterm-color" "\
Translate ANSI color sequences in STRING into text properties.
Returns new STRING with text properties applied.

This function will check if `xterm-color-preserve-properties' is
set to T and only call `xterm-color-filter-real' on substrings
that do not have text properties applied (passing through the rest
unmodified).  Preserving properties in this fashion is really a hack
and not very robust as there may be situations where text properties
are applied on ANSI data, which will mess up the state machine.
It works fine with and is really meant for eshell though.

This can be inserted into `comint-preoutput-filter-functions'.

\(fn STRING)" nil nil)

(autoload 'xterm-color-colorize-buffer "xterm-color" "\
Apply `xterm-color-filter' to current buffer, and replace its contents.

\(fn)" t nil)

(autoload 'xterm-color-test "xterm-color" "\
Create and display a new buffer that contains ANSI control sequences.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-color" '("+xterm-color--" "xterm-color-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/s-20180406.808/s-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/s-20180406.808/s-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "s" '("s-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/with-simulated-input-20170821.617/with-simulated-input-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/with-simulated-input-20170821.617/with-simulated-input-autoloads.el") (car load-path))))



(autoload 'with-simulated-input "with-simulated-input" "\
Eval BODY forms with KEYS as simulated input.

This macro is intended for automated testing of normally
interactive functions by simulating input. If BODY tries to read
user input (e.g. via `completing-read'), it will read input
events from KEYS instead, as if the user had manually typed those
keys after initiating evaluation of BODY.

KEYS should be a string representing a sequence of key presses,
in the format understood by `kbd'. In the most common case of
typing in some text and pressing RET, KEYS would be something
like `\"hello RET\"'. Note that spaced must be indicated
explicitly using `SPC', e.g. `\"hello SPC world RET\"'.

KEYS can also be a list. In this case, each element should either
be a key sequence as described above or an arbitrary lisp form
that will be evaluated at that point in the input sequence. For
example, `\"hello RET\"' could also be written as:

    `((insert \"hello\") \"RET\")'

If BODY tries to read more input events than KEYS provides, an
error is signalled. This is to ensure that BODY will never block
waiting for input, since this macro is intended for
non-interactive use. If BODY does not consume all the input
events in KEYS, the remaining input events in KEYS are discarded,
and any remaining lisp forms in KEYS are never evaluated.

Any errors generated by any means during the evaluation of BODY
are propagated normally.

The return value is the last form in BODY, as if it was wrapped
in `progn'.

\(fn KEYS &rest BODY)" nil t)

(function-put 'with-simulated-input 'lisp-indent-function '1)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "with-simulated-input" '("current-idle-time@simulate-idle-time" "wsi-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/async-20180527.1730/async-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/async-20180527.1730/async-autoloads.el") (car load-path))))



(autoload 'async-start-process "async" "\
Start the executable PROGRAM asynchronously.  See `async-start'.
PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the
process object when done.  If FINISH-FUNC is nil, the future
object will return the process object when the program is
finished.  Set DEFAULT-DIRECTORY to change PROGRAM's current
working directory.

\(fn NAME PROGRAM FINISH-FUNC &rest PROGRAM-ARGS)" nil nil)

(autoload 'async-start "async" "\
Execute START-FUNC (often a lambda) in a subordinate Emacs process.
When done, the return value is passed to FINISH-FUNC.  Example:

    (async-start
       ;; What to do in the child process
       (lambda ()
         (message \"This is a test\")
         (sleep-for 3)
         222)

       ;; What to do when it finishes
       (lambda (result)
         (message \"Async process done, result should be 222: %s\"
                  result)))

If FINISH-FUNC is nil or missing, a future is returned that can
be inspected using `async-get', blocking until the value is
ready.  Example:

    (let ((proc (async-start
                   ;; What to do in the child process
                   (lambda ()
                     (message \"This is a test\")
                     (sleep-for 3)
                     222))))

        (message \"I'm going to do some work here\") ;; ....

        (message \"Waiting on async process, result should be 222: %s\"
                 (async-get proc)))

If you don't want to use a callback, and you don't care about any
return value from the child process, pass the `ignore' symbol as
the second argument (if you don't, and never call `async-get', it
will leave *emacs* process buffers hanging around):

    (async-start
     (lambda ()
       (delete-file \"a remote file on a slow link\" nil))
     'ignore)

Note: Even when FINISH-FUNC is present, a future is still
returned except that it yields no value (since the value is
passed to FINISH-FUNC).  Call `async-get' on such a future always
returns nil.  It can still be useful, however, as an argument to
`async-ready' or `async-wait'.

\(fn START-FUNC &optional FINISH-FUNC)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "async" '("async-")))



(autoload 'async-byte-recompile-directory "async-bytecomp" "\
Compile all *.el files in DIRECTORY asynchronously.
All *.elc files are systematically deleted before proceeding.

\(fn DIRECTORY &optional QUIET)" nil nil)

(defvar async-bytecomp-package-mode nil "\
Non-nil if Async-Bytecomp-Package mode is enabled.
See the `async-bytecomp-package-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `async-bytecomp-package-mode'.")

(custom-autoload 'async-bytecomp-package-mode "async-bytecomp" nil)

(autoload 'async-bytecomp-package-mode "async-bytecomp" "\
Byte compile asynchronously packages installed with package.el.
Async compilation of packages can be controlled by
`async-bytecomp-allowed-packages'.

If called interactively, enable Async-Bytecomp-Package mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'async-byte-compile-file "async-bytecomp" "\
Byte compile Lisp code FILE asynchronously.

Same as `byte-compile-file' but asynchronous.

\(fn FILE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "async-bytecomp" '("async-byte")))



(defvar dired-async-mode nil "\
Non-nil if Dired-Async mode is enabled.
See the `dired-async-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `dired-async-mode'.")

(custom-autoload 'dired-async-mode "dired-async" nil)

(autoload 'dired-async-mode "dired-async" "\
Do dired actions asynchronously.

If called interactively, enable Dired-Async mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-copy "dired-async" "\
Run ‘dired-do-copy’ asynchronously.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-symlink "dired-async" "\
Run ‘dired-do-symlink’ asynchronously.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-hardlink "dired-async" "\
Run ‘dired-do-hardlink’ asynchronously.

\(fn &optional ARG)" t nil)

(autoload 'dired-async-do-rename "dired-async" "\
Run ‘dired-do-rename’ asynchronously.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dired-async" '("dired-async-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smtpmail-async" '("async-smtpmail-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/with-editor-20180726.2044/with-editor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/with-editor-20180726.2044/with-editor-autoloads.el") (car load-path))))



(autoload 'with-editor-export-editor "with-editor" "\
Teach subsequent commands to use current Emacs instance as editor.

Set and export the environment variable ENVVAR, by default
\"EDITOR\".  The value is automatically generated to teach
commands to use the current Emacs instance as \"the editor\".

This works in `shell-mode', `term-mode' and `eshell-mode'.

\(fn &optional (ENVVAR \"EDITOR\"))" t nil)

(autoload 'with-editor-export-git-editor "with-editor" "\
Like `with-editor-export-editor' but always set `$GIT_EDITOR'.

\(fn)" t nil)

(autoload 'with-editor-export-hg-editor "with-editor" "\
Like `with-editor-export-editor' but always set `$HG_EDITOR'.

\(fn)" t nil)

(defvar shell-command-with-editor-mode nil "\
Non-nil if Shell-Command-With-Editor mode is enabled.
See the `shell-command-with-editor-mode' command
for a description of this minor mode.")

(custom-autoload 'shell-command-with-editor-mode "with-editor" nil)

(autoload 'shell-command-with-editor-mode "with-editor" "\
Teach `shell-command' to use current Emacs instance as editor.

If called interactively, enable Shell-Command-With-Editor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Teach `shell-command', and all commands that ultimately call that
command, to use the current Emacs instance as editor by executing
\"EDITOR=CLIENT COMMAND&\" instead of just \"COMMAND&\".

CLIENT is automatically generated; EDITOR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming no other variable overrides the effect of \"$EDITOR\".
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Alternatively you can use the `with-editor-async-shell-command',
which also allows the use of another variable instead of
\"EDITOR\".

\(fn &optional ARG)" t nil)

(autoload 'with-editor-async-shell-command "with-editor" "\
Like `async-shell-command' but with `$EDITOR' set.

Execute string \"ENVVAR=CLIENT COMMAND\" in an inferior shell;
display output, if any.  With a prefix argument prompt for an
environment variable, otherwise the default \"EDITOR\" variable
is used.  With a negative prefix argument additionally insert
the COMMAND's output at point.

CLIENT is automatically generated; ENVVAR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming it respects ENVVAR as an \"EDITOR\"-like variable.
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Also see `async-shell-command' and `shell-command'.

\(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil)

(autoload 'with-editor-shell-command "with-editor" "\
Like `shell-command' or `with-editor-async-shell-command'.
If COMMAND ends with \"&\" behave like the latter,
else like the former.

\(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "with-editor" '("server-" "shell-command--shell-command-with-editor-mode" "start-file-process--with-editor-process-filter" "with-editor")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/imenu-list-20180601.1402/imenu-list-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/imenu-list-20180601.1402/imenu-list-autoloads.el") (car load-path))))



(autoload 'imenu-list-noselect "imenu-list" "\
Update and show the imenu-list buffer, but don't select it.
If the imenu-list buffer doesn't exist, create it.

\(fn)" t nil)

(autoload 'imenu-list "imenu-list" "\
Update and show the imenu-list buffer.
If the imenu-list buffer doesn't exist, create it.

\(fn)" t nil)

(defvar imenu-list-minor-mode nil "\
Non-nil if Imenu-List minor mode is enabled.
See the `imenu-list-minor-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `imenu-list-minor-mode'.")

(custom-autoload 'imenu-list-minor-mode "imenu-list" nil)

(autoload 'imenu-list-minor-mode "imenu-list" "\
Toggle Imenu-List minor mode on or off.

If called interactively, enable Imenu-List minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{imenu-list-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'imenu-list-smart-toggle "imenu-list" "\
Enable or disable `imenu-list-minor-mode' according to buffer's visibility.
If the imenu-list buffer is displayed in any window, disable
`imenu-list-minor-mode', otherwise enable it.
Note that all the windows in every frame searched, even invisible ones, not
only those in the selected frame.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "imenu-list" '("imenu-list-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/window-purpose-20180809.1156/window-purpose-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/window-purpose-20180809.1156/window-purpose-autoloads.el") (car load-path))))



(defvar purpose-mode nil "\
Non-nil if Purpose mode is enabled.
See the `purpose-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `purpose-mode'.")

(custom-autoload 'purpose-mode "window-purpose" nil)

(autoload 'purpose-mode "window-purpose" "\
Toggle Purpose mode on or off.

If called interactively, enable Purpose mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{purpose-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose" '("find-file-" "purpose-" "switch-buffer-")))



(eieio-defclass-autoload 'purpose-conf 'nil "window-purpose-configuration" nil)

(autoload 'purpose-set-extension-configuration "window-purpose-configuration" "\
Set an extension's entry in `purpose-extended-configuration'.
EXT-KEYWORD should be a keyword used to identify the extension.
CONFIG is a `purpose-conf' object containing the extension's purpose
configuration.
Example:
 (purpose-set-extension-configuration
     :python
     (purpose-conf \"py\"
                   :mode-purposes
                   '((python-mode . python)
                     (inferior-python-mode . interpreter))))

This function calls `purpose-compile-extended-configuration' when its
done.

\(fn EXT-KEYWORD CONFIG)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-configuration" '("define-purpose-list-checker" "purpose-")))



(autoload 'purpose-toggle-window-buffer-dedicated "window-purpose-core" "\
Toggle window WINDOW's dedication to its current buffer on or off.
WINDOW defaults to the selected window.

\(fn &optional WINDOW)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-core" '("default-" "purpose-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-fixes" '("purpose-")))



(autoload 'purpose-save-window-layout-file "window-purpose-layout" "\
Save window layout of current frame to file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-load-window-layout-file "window-purpose-layout" "\
Load window layout from file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-save-window-layout "window-purpose-layout" "\
Save a window layout.
NAME is the name to give the window layout.
DIRECTORY is the directory in which to save the layout.

\(fn NAME DIRECTORY)" t nil)

(autoload 'purpose-load-window-layout "window-purpose-layout" "\
Load a window layout.
NAME is the name of a window layout.  If NAME is not given, prompt the
user for a name.
LAYOUT-DIRS is a list of directories to search for the layout file, and
defaults to `purpose-layout-dirs'.  If `purpose-use-built-in-layouts',
then `purpose--built-in-layouts-dir' is also searched.  See
`purpose-find-window-layout' for more details.

To load a window layout from a specific file, use
`purpose-load-window-layout-file'.

\(fn &optional NAME LAYOUT-DIRS)" t nil)

(autoload 'purpose-save-frame-layout-file "window-purpose-layout" "\
Save frame layout of Emacs to file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-load-frame-layout-file "window-purpose-layout" "\
Load frame layout from file FILENAME.
If FILENAME is nil, use `purpose-default-layout-file' instead.

\(fn &optional FILENAME)" t nil)

(autoload 'purpose-save-frame-layout "window-purpose-layout" "\
Save a frame layout.
NAME is the name to give the frame layout.
DIRECTORY is the directory in which to save the layout.

\(fn NAME DIRECTORY)" t nil)

(autoload 'purpose-load-frame-layout "window-purpose-layout" "\
Load a frame layout.
NAME is the name of a frame layout.  If NAME is not given, prompt the
user for a name.
LAYOUT-DIRS is a list of directories to search for the layout file, and
defaults to `purpose-layout-dirs'.  If `purpose-use-built-in-layouts',
then `purpose--built-in-layouts-dir' is also searched.  See
`purpose-find-frame-layout' for more details.

To load a frame layout from a specific file, use
`purpose-load-frame-layout-file'.

\(fn &optional NAME LAYOUT-DIRS)" t nil)

(autoload 'purpose-delete-non-dedicated-windows "window-purpose-layout" "\
Delete all windows that aren't dedicated to their purpose or buffer.

\(fn)" t nil)

(autoload 'purpose-set-window-purpose "window-purpose-layout" "\
Set window's purpose to PURPOSE, and dedicate it.
With prefix argument (DONT-DEDICATE is non-nil), don't dedicate the
window.  If DONT-DEDICATE is non-nil, and the current window is
dedicated, un-dedicate the window.
Changing the window's purpose is done by displaying a buffer of
the right purpose in it, or creating a dummy buffer.

\(fn PURPOSE &optional DONT-DEDICATE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-layout" '("purpose-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-prefix-overload" '("define-purpose-prefix-overload" "purpose--")))



(autoload 'purpose-switch-buffer "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in the selected window.
If FORCE-SAME-WINDOW is non-nil, don't select a different window if the
currently selected window is not available.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD FORCE-SAME-WINDOW)" t nil)

(autoload 'purpose-switch-buffer-other-window "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME in another window.
Never selects the currently selected window.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-switch-buffer-other-frame "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in another frame.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-pop-buffer "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in another window.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-pop-buffer-same-window "window-purpose-switch" "\
Select buffer BUFFER-OR-NAME, preferably in the selected window.
If BUFFER-OR-NAME is nil, select the buffer returned by `other-buffer'.

\(fn BUFFER-OR-NAME &optional NORECORD)" t nil)

(autoload 'purpose-switch-buffer-with-purpose "window-purpose-switch" "\
Prompt the user and switch to a buffer with purpose PURPOSE.
If called interactively, or with PURPOSE nil, PURPOSE defaults to the
current buffer's purpose.

\(fn &optional PURPOSE)" t nil)

(autoload 'purpose-switch-buffer-with-some-purpose "window-purpose-switch" "\
Like `purpose-switch-buffer-with-purpose', but first choose a PURPOSE.

\(fn PURPOSE)" t nil)

(autoload 'purpose-switch-buffer-with-purpose-other-window "window-purpose-switch" "\
Prompt the user and switch to a buffer with purpose PURPOSE.
The buffer is display in another window.
If called interactively, or with PURPOSE nil, PURPOSE defaults to the
current buffer's purpose.

\(fn &optional PURPOSE)" t nil)

(autoload 'purpose-switch-buffer-with-purpose-other-frame "window-purpose-switch" "\
Prompt the user and switch to a buffer with purpose PURPOSE.
The buffer is display in another frame.
If called interactively, or with PURPOSE nil, PURPOSE defaults to the
current buffer's purpose.

\(fn &optional PURPOSE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-switch" '("purpose-" "without-purpose")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-utils" '("purpose-")))



(autoload 'purpose-x-code1-setup "window-purpose-x" "\
Setup purpose-x-code1.
This setup includes 4 windows:
1. dedicated 'edit window
2. dedicated 'dired window.  This window shows the current buffer's
directory in a special window, using `dired' and
`dired-hide-details-mode' (if available).
3. dedicated 'buffers window.  This window shows the currently open
files, using `ibuffer'.
4. dedicated 'ilist window.  This window shows the current buffer's
imenu.

\(fn)" t nil)

(autoload 'purpose-x-magit-single-on "window-purpose-x" "\
Turn on magit-single purpose configuration.

\(fn)" t nil)

(autoload 'purpose-x-magit-multi-on "window-purpose-x" "\
Turn on magit-multi purpose configuration.

\(fn)" t nil)

(autoload 'purpose-x-golden-ratio-setup "window-purpose-x" "\
Make `golden-ratio-mode' aware of `purpose-mode'.

\(fn)" t nil)

(autoload 'purpose-x-popwin-setup "window-purpose-x" "\
Activate `popwin' emulation.
This extension treats certain buffers as \"popup\" buffers and displays
them in a special popup window.
The window is closed automatically when selecting another buffer (via
`switch-to-buffer' and the like), or by pressing \\[keyboard-quit].
You can control which buffers are treated as popup buffers by changing
the variables `purpose-x-popwin-major-modes',
`purpose-x-popwin-buffer-names' and
`purpose-x-popwin-buffer-name-regexps'.
Look at `purpose-x-popwin-*' variables and functions to learn more.

\(fn)" t nil)

(autoload 'purpose-x-persp-setup "window-purpose-x" "\
Activate purpose-x-persp extension.
This extension automatically activates a purpose configuration for the
current perspective.  The configuration changes automatically when
switching perspectives or when toggling `persp-mode'.
The variable `purpose-x-persp-confs' matches between perspectives and
purpose configurations.

\(fn)" t nil)

(autoload 'purpose-x-persp-switch-buffer "window-purpose-x" "\
Switch to BUFFER, limited by purpose and perspective.
BUFFER is chosen from buffers with the same purpose as the current
buffer that are also part of the current perspective.
NORECORD and FORCE-SAME-WINDOW have the same meaning as in
`switch-to-buffer'.

\(fn BUFFER &optional NORECORD FORCE-SAME-WINDOW)" t nil)

(autoload 'purpose-x-persp-switch-buffer-other-window "window-purpose-x" "\
Switch to BUFFER in other window, limited by purpose and perspective.
NORECORD has the same meaning as in `switch-to-buffer-other-window'.
The relation between `purpose-x-persp-switch-buffer-other-window' and
`switch-to-buffer-other-window' is the same as the relation between
`purpose-x-persp-switch-buffer' and `switch-to-buffer'.

\(fn BUFFER &optional NORECORD)" t nil)

(autoload 'purpose-x-persp-switch-buffer-other-frame "window-purpose-x" "\
Switch to BUFFER in other frame, limited by purpose and perspective.
NORECORD has the same meaning as in `switch-to-buffer-other-frame'.
The relation between `purpose-x-persp-switch-buffer-other-frame' and
`switch-to-buffer-other-frame' is the same as the relation between
`purpose-x-persp-switch-buffer' and `switch-to-buffer'.

\(fn BUFFER &optional NORECORD)" t nil)

(autoload 'purpose-x-kill-setup "window-purpose-x" "\
Activate purpose-x-kill extension.
This extension makes `kill-buffer' aware of the purpose-dedicated window
parameter, when killing a visible buffer.  If a buffer that is being
killed is displayed in a window,and that window is purpose-dedicated,
then try to replace the buffer with another buffer with the same purpose.
If that isn't possible, treat the window as if it was buffer-dedicated.

This is implemented by overriding `replace-buffer-in-windows' with
`purpose-x-replace-buffer-in-windows-1'.  See
`purpose-x-replace-buffer-in-windows-1' for more details.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-purpose-x" '("purpose-x-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/window-layout-20170215.33/window-layout-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/window-layout-20170215.33/window-layout-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "window-layout" '("wlf:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/web-server-20140906.6/web-server-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/web-server-20140906.6/web-server-autoloads.el") (car load-path))))



(autoload 'ws-start "web-server" "\
Start a server using HANDLERS and return the server object.

HANDLERS may be a single function (which is then called on every
request) or a list of conses of the form (MATCHER . FUNCTION),
where the FUNCTION associated with the first successful MATCHER
is called.  Handler functions are called with two arguments, the
process and the request object.

A MATCHER may be either a function (in which case it is called on
the request object) or a cons cell of the form (KEYWORD . STRING)
in which case STRING is matched against the value of the header
specified by KEYWORD.

Any supplied NETWORK-ARGS are assumed to be keyword arguments for
`make-network-process' to which they are passed directly.

For example, the following starts a simple hello-world server on
port 8080.

  (ws-start
   (lambda (request)
     (with-slots (process headers) request
       (process-send-string process
        \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nhello world\")))
   8080)

Equivalently, the following starts an identical server using a
function MATCH and the `ws-response-header' convenience
function.

  (ws-start
   '(((lambda (_) t) .
      (lambda (proc request)
        (ws-response-header proc 200 '(\"Content-type\" . \"text/plain\"))
        (process-send-string proc \"hello world\")
        t)))
   8080)

\(fn HANDLERS PORT &optional LOG-BUFFER &rest NETWORK-ARGS)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-server" '("ws-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-server-status-codes" '("ws-status-codes")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/vkill-20091203.1022/vkill-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/vkill-20091203.1022/vkill-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vkill" '("process-list-" "vkill" "list-unix-processes")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/visual-regexp-20170301.116/visual-regexp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/visual-regexp-20170301.116/visual-regexp-autoloads.el") (car load-path))))



(autoload 'vr/mc-mark "visual-regexp" "\
Convert regexp selection to multiple cursors.

\(fn REGEXP START END)" nil nil)

(autoload 'vr/replace "visual-regexp" "\
Regexp-replace with live visual feedback.

\(fn REGEXP REPLACE START END)" t nil)

(autoload 'vr/query-replace "visual-regexp" "\
Use vr/query-replace like you would use query-replace-regexp.

\(fn REGEXP REPLACE START END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "visual-regexp" '("vr--" "vr/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/visual-regexp-steroids-20170222.253/visual-regexp-steroids-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/visual-regexp-steroids-20170222.253/visual-regexp-steroids-autoloads.el") (car load-path))))



(autoload 'vr/select-replace "visual-regexp-steroids" "\


\(fn)" t nil)

(autoload 'vr/select-query-replace "visual-regexp-steroids" "\


\(fn)" t nil)

(autoload 'vr/select-mc-mark "visual-regexp-steroids" "\


\(fn)" t nil)

(autoload 'vr/isearch-forward "visual-regexp-steroids" "\
Like isearch-forward, but using Python (or custom) regular expressions.

\(fn)" t nil)

(autoload 'vr/isearch-backward "visual-regexp-steroids" "\
Like isearch-backward, but using Python (or custom) regular expressions.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "visual-regexp-steroids" '("vr--" "vr/")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/unkillable-scratch-20160505.203/unkillable-scratch-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/unkillable-scratch-20160505.203/unkillable-scratch-autoloads.el") (car load-path))))



(defvar unkillable-scratch nil "\
Non-nil if Unkillable-Scratch mode is enabled.
See the `unkillable-scratch' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `unkillable-scratch'.")

(custom-autoload 'unkillable-scratch "unkillable-scratch" nil)

(autoload 'unkillable-scratch "unkillable-scratch" "\
A minor mode to disallow the *scratch* buffer from being killed.

If called interactively, enable Unkillable-Scratch mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "unkillable-scratch" '("unkillable-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/undohist-20150315.1242/undohist-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/undohist-20150315.1242/undohist-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "undohist" '("make-undohist-file-name" "undohist-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/dash-20180726.1213/dash-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/dash-20180726.1213/dash-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dash" '("!cdr" "!cons" "--" "->" "-a" "-butlast" "-c" "-d" "-e" "-f" "-gr" "-i" "-keep" "-l" "-m" "-non" "-only-some" "-p" "-r" "-s" "-t" "-u" "-value-to-list" "-when-let" "-zip" "dash-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shut-up-20180628.1830/shut-up-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shut-up-20180628.1830/shut-up-autoloads.el") (car load-path))))



(autoload 'shut-up "shut-up" "\
Evaluate BODY with silenced output.

While BODY is evaluated, all output is redirected to a buffer,
unless `shut-up-ignore' is non-nil.  This affects:

- `message'
- All functions using `standard-output' (e.g. `print', `princ', etc.)

Inside BODY, the buffer is bound to the lexical variable
`shut-up-sink'.  Additionally provide a lexical function
`shut-up-current-output', which returns the current contents of
`shut-up-sink' when called with no arguments.

Changes to the variable `shut-up-ignore' inside BODY does not
have any affect.

\(fn &rest BODY)" nil t)

(function-put 'shut-up 'lisp-indent-function '0)

(autoload 'shut-up-silence-emacs "shut-up" "\
Silence Emacs.

Change Emacs settings to reduce the output.

WARNING: This function has GLOBAL SIDE-EFFECTS.  You should only
call this function in `noninteractive' sessions.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shut-up" '("inhibit-message" "shut-up-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/undercover-20180403.1452/undercover-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/undercover-20180403.1452/undercover-autoloads.el") (car load-path))))



(autoload 'undercover "undercover" "\
Enable test coverage for files matched by CONFIGURATION.
Example of CONFIGURATION: (\"*.el\" \"subdir/*.el\" (:exclude \"exclude-*.el\")).

If running under Travic CI automatically generate report
on `kill-emacs' and send it to coveralls.io.

\(fn &rest CONFIGURATION)" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "undercover" '("undercover-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-mode-20180816.2105/clojure-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-mode-20180816.2105/clojure-mode-autoloads.el") (car load-path))))



(autoload 'clojure-mode "clojure-mode" "\
Major mode for editing Clojure code.

\\{clojure-mode-map}

\(fn)" t nil)

(autoload 'clojure-unwind "clojure-mode" "\
Unwind thread at point or above point by one level.
Return nil if there are no more levels to unwind.

\(fn)" t nil)

(autoload 'clojure-unwind-all "clojure-mode" "\
Fully unwind thread at point or above point.

\(fn)" t nil)

(autoload 'clojure-thread "clojure-mode" "\
Thread by one more level an existing threading macro.

\(fn)" t nil)

(autoload 'clojure-thread-first-all "clojure-mode" "\
Fully thread the form at point using ->.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'.

\(fn BUT-LAST)" t nil)

(autoload 'clojure-thread-last-all "clojure-mode" "\
Fully thread the form at point using ->>.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'.

\(fn BUT-LAST)" t nil)

(autoload 'clojure-cycle-privacy "clojure-mode" "\
Make public the current private def, or vice-versa.
See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-privacy

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-list "clojure-mode" "\
Convert collection at (point) to list.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-quoted-list "clojure-mode" "\
Convert collection at (point) to quoted list.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-map "clojure-mode" "\
Convert collection at (point) to map.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-vector "clojure-mode" "\
Convert collection at (point) to vector.

\(fn)" t nil)

(autoload 'clojure-convert-collection-to-set "clojure-mode" "\
Convert collection at (point) to set.

\(fn)" t nil)

(autoload 'clojure-cycle-if "clojure-mode" "\
Change a surrounding if to if-not, or vice-versa.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-if

\(fn)" t nil)

(autoload 'clojure-cycle-when "clojure-mode" "\
Change a surrounding when to when-not, or vice-versa.

\(fn)" t nil)

(autoload 'clojure-let-backward-slurp-sexp "clojure-mode" "\
Slurp the s-expression before the let form into the let form.
With a numberic prefix argument slurp the previous N s-expression into the let form.

\(fn &optional N)" t nil)

(autoload 'clojure-let-forward-slurp-sexp "clojure-mode" "\
Slurp the next s-expression after the let form into the let form.
With a numeric prefix argument slurp the next N s-expressions into the let form.

\(fn &optional N)" t nil)

(autoload 'clojure-introduce-let "clojure-mode" "\
Create a let form, binding the form at point.
With a numeric prefix argument the let is introduced N lists up.

\(fn &optional N)" t nil)

(autoload 'clojure-move-to-let "clojure-mode" "\
Move the form at point to a binding in the nearest let.

\(fn)" t nil)

(autoload 'clojurescript-mode "clojure-mode" "\
Major mode for editing ClojureScript code.

\\{clojurescript-mode-map}

\(fn)" t nil)

(autoload 'clojurec-mode "clojure-mode" "\
Major mode for editing ClojureC code.

\\{clojurec-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(clj\\|dtm\\|edn\\)\\'" . clojure-mode))

(add-to-list 'auto-mode-alist '("\\.cljc\\'" . clojurec-mode))

(add-to-list 'auto-mode-alist '("\\.cljs\\'" . clojurescript-mode))

(add-to-list 'auto-mode-alist '("\\(?:build\\|profile\\)\\.boot\\'" . clojure-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-mode" '("add-custom-clojure-indents" "clojure" "define-clojure-indent" "put-clojure-indent")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/epl-20180205.2049/epl-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/epl-20180205.2049/epl-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "epl" '("epl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pkg-info-20150517.1143/pkg-info-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pkg-info-20150517.1143/pkg-info-autoloads.el") (car load-path))))



(autoload 'pkg-info-library-original-version "pkg-info" "\
Get the original version in the header of LIBRARY.

The original version is stored in the X-Original-Version header.
This header is added by the MELPA package archive to preserve
upstream version numbers.

LIBRARY is either a symbol denoting a named feature, or a library
name as string.

If SHOW is non-nil, show the version in the minibuffer.

Return the version from the header of LIBRARY as list.  Signal an
error if the LIBRARY was not found or had no X-Original-Version
header.

See Info node `(elisp)Library Headers' for more information
about library headers.

\(fn LIBRARY &optional SHOW)" t nil)

(autoload 'pkg-info-library-version "pkg-info" "\
Get the version in the header of LIBRARY.

LIBRARY is either a symbol denoting a named feature, or a library
name as string.

If SHOW is non-nil, show the version in the minibuffer.

Return the version from the header of LIBRARY as list.  Signal an
error if the LIBRARY was not found or had no proper header.

See Info node `(elisp)Library Headers' for more information
about library headers.

\(fn LIBRARY &optional SHOW)" t nil)

(autoload 'pkg-info-defining-library-original-version "pkg-info" "\
Get the original version of the library defining FUNCTION.

The original version is stored in the X-Original-Version header.
This header is added by the MELPA package archive to preserve
upstream version numbers.

If SHOW is non-nil, show the version in mini-buffer.

This function is mainly intended to find the version of a major
or minor mode, i.e.

   (pkg-info-defining-library-version 'flycheck-mode)

Return the version of the library defining FUNCTION.  Signal an
error if FUNCTION is not a valid function, if its defining
library was not found, or if the library had no proper version
header.

\(fn FUNCTION &optional SHOW)" t nil)

(autoload 'pkg-info-defining-library-version "pkg-info" "\
Get the version of the library defining FUNCTION.

If SHOW is non-nil, show the version in mini-buffer.

This function is mainly intended to find the version of a major
or minor mode, i.e.

   (pkg-info-defining-library-version 'flycheck-mode)

Return the version of the library defining FUNCTION.  Signal an
error if FUNCTION is not a valid function, if its defining
library was not found, or if the library had no proper version
header.

\(fn FUNCTION &optional SHOW)" t nil)

(autoload 'pkg-info-package-version "pkg-info" "\
Get the version of an installed PACKAGE.

If SHOW is non-nil, show the version in the minibuffer.

Return the version as list, or nil if PACKAGE is not installed.

\(fn PACKAGE &optional SHOW)" t nil)

(autoload 'pkg-info-version-info "pkg-info" "\
Obtain complete version info for LIBRARY and PACKAGE.

LIBRARY is a symbol denoting a named feature, or a library name
as string.  PACKAGE is a symbol denoting an ELPA package.  If
omitted or nil, default to LIBRARY.

If SHOW is non-nil, show the version in the minibuffer.

When called interactively, prompt for LIBRARY.  When called
interactively with prefix argument, prompt for PACKAGE as well.

Return a string with complete version information for LIBRARY.
This version information contains the version from the headers of
LIBRARY, and the version of the installed PACKAGE, the LIBRARY is
part of.  If PACKAGE is not installed, or if the PACKAGE version
is the same as the LIBRARY version, do not include a package
version.

\(fn LIBRARY &optional PACKAGE SHOW)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pkg-info" '("pkg-info-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/queue-0.2/queue-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/queue-0.2/queue-autoloads.el") (car load-path))))



(defalias 'make-queue 'queue-create "\
Create an empty queue data structure.")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "queue" '("queue")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/spinner-1.7.3/spinner-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/spinner-1.7.3/spinner-autoloads.el") (car load-path))))



(autoload 'spinner-create "spinner" "\
Create a spinner of the given TYPE.
The possible TYPEs are described in `spinner--type-to-frames'.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

If BUFFER-LOCAL is non-nil, the spinner will be automatically
deactivated if the buffer is killed.  If BUFFER-LOCAL is a
buffer, use that instead of current buffer.

When started, in order to function properly, the spinner runs a
timer which periodically calls `force-mode-line-update' in the
curent buffer.  If BUFFER-LOCAL was set at creation time, then
`force-mode-line-update' is called in that buffer instead.  When
the spinner is stopped, the timer is deactivated.

DELAY, if given, is the number of seconds to wait after starting
the spinner before actually displaying it. It is safe to cancel
the spinner before this time, in which case it won't display at
all.

\(fn &optional TYPE BUFFER-LOCAL FPS DELAY)" nil nil)

(autoload 'spinner-start "spinner" "\
Start a mode-line spinner of given TYPE-OR-OBJECT.
If TYPE-OR-OBJECT is an object created with `make-spinner',
simply activate it.  This method is designed for minor modes, so
they can use the spinner as part of their lighter by doing:
    \\='(:eval (spinner-print THE-SPINNER))
To stop this spinner, call `spinner-stop' on it.

If TYPE-OR-OBJECT is anything else, a buffer-local spinner is
created with this type, and it is displayed in the
`mode-line-process' of the buffer it was created it.  Both
TYPE-OR-OBJECT and FPS are passed to `make-spinner' (which see).
To stop this spinner, call `spinner-stop' in the same buffer.

Either way, the return value is a function which can be called
anywhere to stop this spinner.  You can also call `spinner-stop'
in the same buffer where the spinner was created.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

DELAY, if given, is the number of seconds to wait until actually
displaying the spinner. It is safe to cancel the spinner before
this time, in which case it won't display at all.

\(fn &optional TYPE-OR-OBJECT FPS DELAY)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "spinner" '("spinner")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sesman-20180809.1043/sesman-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sesman-20180809.1043/sesman-autoloads.el") (car load-path))))



(autoload 'sesman-start "sesman" "\
Start a Sesman session.

\(fn)" t nil)

(autoload 'sesman-restart "sesman" "\
Restart sesman session.
When WHICH is nil, restart the current session; when a single universal
argument or 'linked, restart all linked sessions; when a double universal
argument, t or 'all, restart all sessions. For programmatic use, WHICH can also
be a session or a name of the session, in which case that session is restarted.

\(fn &optional WHICH)" t nil)

(autoload 'sesman-quit "sesman" "\
Terminate a Sesman session.
When WHICH is nil, kill only the current session; when a single universal
argument or 'linked, kill all linked sessions; when a double universal argument,
t or 'all, kill all sessions. For programmatic use, WHICH can also be a session
or a name of the session, in which case that session is killed.

\(fn &optional WHICH)" t nil)

(autoload 'sesman-info "sesman" "\
Display linked sessions info.
When ALL is non-nil, show info for all sessions.

\(fn &optional ALL)" t nil)

(autoload 'sesman-link-with-buffer "sesman" "\
Associate SESSION with BUFFER.
BUFFER defaults to current buffer. On universal argument, or if BUFFER is 'ask,
ask for buffer.

\(fn &optional BUFFER SESSION)" t nil)

(autoload 'sesman-link-with-directory "sesman" "\
Associate a SESSION with DIR.
DIR defaults to `default-directory'. On universal argument, or if DIR is 'ask,
ask for directory.

\(fn &optional DIR SESSION)" t nil)

(autoload 'sesman-link-with-project "sesman" "\
Link the SESSION with PROJECT.
PROJECT defaults to current project. On universal argument, or if PROJECT is
'ask, ask for the project.

\(fn &optional PROJECT SESSION)" t nil)

(autoload 'sesman-unlink "sesman" "\
Break any of the previously created links.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sesman" '("sesman-")))



(autoload 'sesman-browser "sesman-browser" "\
Display an interactive session browser.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sesman-browser" '("sesman-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-20180817.1140/cider-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-20180817.1140/cider-autoloads.el") (car load-path))))



(autoload 'cider-version "cider" "\
Display CIDER's version.

\(fn)" t nil)

(autoload 'cider-jack-in-clj "cider" "\
Start an nREPL server for the current project and connect to it.
PARAMS is a plist optionally containing :project-dir and :jack-in-cmd.
With the prefix argument, prompt for all these parameters.

\(fn PARAMS)" t nil)

(autoload 'cider-jack-in-cljs "cider" "\
Start an nREPL server for the current project and connect to it.
PARAMS is a plist optionally containing :project-dir, :jack-in-cmd and
:cljs-repl-type (e.g. Node, Figwheel, etc).  With the prefix argument,
prompt for all these parameters.

\(fn PARAMS)" t nil)

(autoload 'cider-jack-in-clj&cljs "cider" "\
Start an nREPL server and connect with clj and cljs REPLs.
PARAMS is a plist optionally containing :project-dir, :jack-in-cmd and
:cljs-repl-type (e.g. Node, Figwheel, etc).  With the prefix argument,
prompt for all these parameters.  When SOFT-CLJS-START is non-nil, start
cljs REPL only when the ClojureScript dependencies are met.

\(fn &optional PARAMS SOFT-CLJS-START)" t nil)

(autoload 'cider-connect-sibling-clj "cider" "\
Create a Clojure REPL with the same server as OTHER-REPL.
PARAMS is for consistency with other connection commands and is currently
ignored.  OTHER-REPL defaults to `cider-current-repl' and in programs can
also be a server buffer, in which case a new session with a REPL for that
server is created.

\(fn PARAMS &optional OTHER-REPL)" t nil)

(autoload 'cider-connect-sibling-cljs "cider" "\
Create a ClojureScript REPL with the same server as OTHER-REPL.
PARAMS is a plist optionally containing :cljs-repl-type (e.g. Node,
Figwheel, etc).  All other parameters are inferred from the OTHER-REPL.
OTHER-REPL defaults to `cider-current-repl' but in programs can also be a
server buffer, in which case a new session for that server is created.

\(fn PARAMS &optional OTHER-REPL)" t nil)

(autoload 'cider-connect-clj "cider" "\
Initialize a CLJ connection to an nREPL server.
PARAMS is a plist optionally containing :host, :port and :project-dir.  On
prefix argument, prompt for all the parameters.

\(fn &optional PARAMS)" t nil)

(autoload 'cider-connect-cljs "cider" "\
Initialize a CLJS connection to an nREPL server.
PARAMS is a plist optionally containing :host, :port, :project-dir and
:cljs-repl-type (e.g. Node, Figwheel, etc).  On prefix, prompt for all the
parameters regardless of their supplied or default values.

\(fn &optional PARAMS)" t nil)

(autoload 'cider-connect-clj&cljs "cider" "\
Initialize a CLJ and CLJS connection to an nREPL server..
PARAMS is a plist optionally containing :host, :port, :project-dir and
:cljs-repl-type (e.g. Node, Figwheel, etc).  When SOFT-CLJS-START is
non-nil, don't start if ClojureScript requirements are not met.

\(fn PARAMS &optional SOFT-CLJS-START)" t nil)

(autoload 'cider "cider" "\
Start a connection of any type interactively.

\(fn)" t nil)

(defalias 'cider-jack-in #'cider-jack-in-clj)

(defalias 'cider-jack-in-clojure #'cider-jack-in-clj)

(defalias 'cider-jack-in-clojurescript #'cider-jack-in-cljs)

(defalias 'cider-connect #'cider-connect-clj)

(defalias 'cider-connect-clojure #'cider-connect-clj)

(defalias 'cider-connect-clojurescript #'cider-connect-cljs)

(defalias 'cider-connect-sibling-clojure #'cider-connect-sibling-clj)

(defalias 'cider-connect-sibling-clojurescript #'cider-connect-sibling-cljs)

(eval-after-load 'clojure-mode '(progn (define-key clojure-mode-map (kbd "C-c M-x") #'cider) (define-key clojure-mode-map (kbd "C-c M-j") #'cider-jack-in-clj) (define-key clojure-mode-map (kbd "C-c M-J") #'cider-jack-in-cljs) (define-key clojure-mode-map (kbd "C-c M-c") #'cider-connect-clj) (define-key clojure-mode-map (kbd "C-c M-C") #'cider-connect-cljs) (define-key clojure-mode-map (kbd "C-c C-x") 'cider-start-map) (define-key clojure-mode-map (kbd "C-c C-s") 'sesman-map) (require 'sesman) (sesman-install-menu clojure-mode-map) (add-hook 'clojure-mode-hook (lambda nil (setq-local sesman-system 'CIDER)))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider" '("cider-")))



(autoload 'cider-apropos "cider-apropos" "\
Show all symbols whose names match QUERY, a regular expression.
QUERY can also be a list of space-separated words (e.g. take while) which
will be converted to a regular expression (like take.+while) automatically
behind the scenes.  The search may be limited to the namespace NS, and may
optionally search doc strings (based on DOCS-P), include private vars
\(based on PRIVATES-P), and be case-sensitive (based on CASE-SENSITIVE-P).

\(fn QUERY &optional NS DOCS-P PRIVATES-P CASE-SENSITIVE-P)" t nil)

(autoload 'cider-apropos-documentation "cider-apropos" "\
Shortcut for (cider-apropos <query> nil t).

\(fn)" t nil)

(autoload 'cider-apropos-select "cider-apropos" "\
Similar to `cider-apropos', but presents the results in a completing read.
Show all symbols whose names match QUERY, a regular expression.
QUERY can also be a list of space-separated words (e.g. take while) which
will be converted to a regular expression (like take.+while) automatically
behind the scenes.  The search may be limited to the namespace NS, and may
optionally search doc strings (based on DOCS-P), include private vars
\(based on PRIVATES-P), and be case-sensitive (based on CASE-SENSITIVE-P).

\(fn QUERY &optional NS DOCS-P PRIVATES-P CASE-SENSITIVE-P)" t nil)

(autoload 'cider-apropos-documentation-select "cider-apropos" "\
Shortcut for (cider-apropos-select <query> nil t).

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-apropos" '("apropos-special-form" "cider-")))



(autoload 'cider-browse-ns "cider-browse-ns" "\
List all NAMESPACE's vars in BUFFER.

\(fn NAMESPACE)" t nil)

(autoload 'cider-browse-ns-all "cider-browse-ns" "\
List all loaded namespaces in BUFFER.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-browse-ns" '("cider-browse-ns-")))



(autoload 'cider-browse-spec "cider-browse-spec" "\
Browse SPEC definition.

\(fn SPEC)" t nil)

(autoload 'cider-browse-spec-all "cider-browse-spec" "\
Open list of specs in a popup buffer.

With a prefix argument ARG, prompts for a regexp to filter specs.
No filter applied if the regexp is the empty string.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-browse-spec" '("cider-")))



(autoload 'cider-cheatsheet "cider-cheatsheet" "\
Navigate `cider-cheatsheet-hierarchy' with `completing-read'.

When you make it to a Clojure var its doc buffer gets displayed.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-cheatsheet" '("cider-cheatsheet-")))



(autoload 'cider-classpath "cider-classpath" "\
List all classpath entries.

\(fn)" t nil)

(autoload 'cider-open-classpath-entry "cider-classpath" "\
Open a classpath entry.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-classpath" '("cider-classpath-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-client" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-common" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-completion" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-connection" '("cider-")))



(autoload 'cider-debug-defun-at-point "cider-debug" "\
Instrument the \"top-level\" expression at point.
If it is a defn, dispatch the instrumented definition.  Otherwise,
immediately evaluate the instrumented expression.

While debugged code is being evaluated, the user is taken through the
source code and displayed the value of various expressions.  At each step,
a number of keys will be prompted to the user.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-debug" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-doc" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-eldoc" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-eval" '("cider-")))



(autoload 'cider-find-var "cider-find" "\
Find definition for VAR at LINE.
Prompt according to prefix ARG and `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix of `-` or a double prefix argument causes
the results to be displayed in a different window.  The default value is
thing at point.

\(fn &optional ARG VAR LINE)" t nil)

(autoload 'cider-find-dwim-at-mouse "cider-find" "\
Find and display variable or resource at mouse EVENT.

\(fn EVENT)" t nil)

(autoload 'cider-find-dwim "cider-find" "\
Find and display the SYMBOL-FILE at point.
SYMBOL-FILE could be a var or a resource.  If thing at point is empty then
show dired on project.  If var is not found, try to jump to resource of the
same name.  When called interactively, a prompt is given according to the
variable `cider-prompt-for-symbol'.  A single or double prefix argument
inverts the meaning.  A prefix of `-' or a double prefix argument causes
the results to be displayed in a different window.  A default value of thing
at point is given when prompted.

\(fn SYMBOL-FILE)" t nil)

(autoload 'cider-find-resource "cider-find" "\
Find the resource at PATH.
Prompt for input as indicated by the variable `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix argument of `-` or a double prefix
argument causes the results to be displayed in other window.  The default
value is thing at point.

\(fn PATH)" t nil)

(autoload 'cider-find-ns "cider-find" "\
Find the file containing NS.
A prefix ARG of `-` or a double prefix argument causes
the results to be displayed in a different window.

\(fn &optional ARG NS)" t nil)

(autoload 'cider-find-keyword "cider-find" "\
Find the namespace of the keyword at point and its first occurrence there.

For instance - if the keyword at point is \":cider.demo/keyword\", this command
would find the namespace \"cider.demo\" and afterwards find the first mention
of \"::keyword\" there.

Prompt according to prefix ARG and `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix of `-` or a double prefix argument causes
the results to be displayed in a different window.  The default value is
thing at point.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-find" '("cider-")))



(autoload 'cider-format-region "cider-format" "\
Format the Clojure code in the current region.
START and END represent the region's boundaries.

\(fn START END)" t nil)

(autoload 'cider-format-defun "cider-format" "\
Format the code in the current defun.

\(fn)" t nil)

(autoload 'cider-format-buffer "cider-format" "\
Format the Clojure code in the current buffer.

\(fn)" t nil)

(autoload 'cider-format-edn-buffer "cider-format" "\
Format the EDN data in the current buffer.

\(fn)" t nil)

(autoload 'cider-format-edn-region "cider-format" "\
Format the EDN data in the current region.
START and END represent the region's boundaries.

\(fn START END)" t nil)

(autoload 'cider-format-edn-last-sexp "cider-format" "\
Format the EDN data of the last sexp.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-format" '("cider--format-")))



(autoload 'cider-grimoire-web "cider-grimoire" "\
Open grimoire documentation in the default web browser.

Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn &optional ARG)" t nil)

(autoload 'cider-grimoire "cider-grimoire" "\
Open grimoire documentation in a popup buffer.

Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-grimoire" '("cider-")))



(autoload 'cider-inspect-last-sexp "cider-inspector" "\
Inspect the result of the the expression preceding point.

\(fn)" t nil)

(autoload 'cider-inspect-defun-at-point "cider-inspector" "\
Inspect the result of the \"top-level\" expression at point.

\(fn)" t nil)

(autoload 'cider-inspect-last-result "cider-inspector" "\
Inspect the most recent eval result.

\(fn)" t nil)

(autoload 'cider-inspect "cider-inspector" "\
Inspect the result of the preceding sexp.

With a prefix argument ARG it inspects the result of the \"top-level\" form.
With a second prefix argument it prompts for an expression to eval and inspect.

\(fn &optional ARG)" t nil)

(autoload 'cider-inspect-expr "cider-inspector" "\
Evaluate EXPR in NS and inspect its value.
Interactively, EXPR is read from the minibuffer, and NS the
current buffer's namespace.

\(fn EXPR NS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-inspector" '("cider-")))



(autoload 'cider-macroexpand-1 "cider-macroexpansion" "\
Invoke \\=`macroexpand-1\\=` on the expression preceding point.
If invoked with a PREFIX argument, use \\=`macroexpand\\=` instead of
\\=`macroexpand-1\\=`.

\(fn &optional PREFIX)" t nil)

(autoload 'cider-macroexpand-all "cider-macroexpansion" "\
Invoke \\=`macroexpand-all\\=` on the expression preceding point.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-macroexpansion" '("cider-")))



(defvar cider-mode-line '(:eval (format " cider[%s]" (cider--modeline-info))) "\
Mode line lighter for cider mode.

The value of this variable is a mode line template as in
`mode-line-format'.  See Info Node `(elisp)Mode Line Format' for details
about mode line templates.

Customize this variable to change how cider mode displays its status in the
mode line.  The default value displays the current connection.  Set this
variable to nil to disable the mode line entirely.")

(custom-autoload 'cider-mode-line "cider-mode" t)

(eval-after-load 'clojure-mode '(easy-menu-define cider-clojure-mode-menu-open clojure-mode-map "Menu for Clojure mode.\n  This is displayed in `clojure-mode' buffers, if `cider-mode' is not active." `("CIDER" :visible (not cider-mode) ["Start a Clojure REPL" cider-jack-in :help "Starts an nREPL server (with Leiningen, Boot, or Gradle) and connects a REPL to it."] ["Connect to a Clojure REPL" cider-connect :help "Connects to a REPL that's already running."] ["Connect to a ClojureScript REPL" cider-connect-clojurescript :help "Connects to a ClojureScript REPL that's already running."] ["Start a Clojure REPL, and a ClojureScript REPL" cider-jack-in-cljs :help "Starts an nREPL server, connects a Clojure REPL to it, and then a ClojureScript REPL."] "--" ["View manual online" cider-view-manual])))

(autoload 'cider-mode "cider-mode" "\
Minor mode for REPL interaction from a Clojure buffer.

If called interactively, enable Cider mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{cider-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-mode" '("cider-")))



(autoload 'cider-ns-reload "cider-ns" "\
Send a (require 'ns :reload) to the REPL.

With an argument PROMPT, it prompts for a namespace name.  This is the
Clojure out of the box reloading experience and does not rely on
org.clojure/tools.namespace.  See Commentary of this file for a longer list
of differences.  From the Clojure doc: \":reload forces loading of all the
identified libs even if they are already loaded\".

\(fn &optional PROMPT)" t nil)

(autoload 'cider-ns-reload-all "cider-ns" "\
Send a (require 'ns :reload-all) to the REPL.

With an argument PROMPT, it prompts for a namespace name.  This is the
Clojure out of the box reloading experience and does not rely on
org.clojure/tools.namespace.  See Commentary of this file for a longer list
of differences.  From the Clojure doc: \":reload-all implies :reload and
also forces loading of all libs that the identified libs directly or
indirectly load via require\".

\(fn &optional PROMPT)" t nil)

(autoload 'cider-ns-refresh "cider-ns" "\
Reload modified and unloaded namespaces on the classpath.

With a single prefix argument, or if MODE is `refresh-all', reload all
namespaces on the classpath unconditionally.

With a double prefix argument, or if MODE is `clear', clear the state of
the namespace tracker before reloading.  This is useful for recovering from
some classes of error (for example, those caused by circular dependencies)
that a normal reload would not otherwise recover from.  The trade-off of
clearing is that stale code from any deleted files may not be completely
unloaded.

With a negative prefix argument, or if MODE is `inhibit-fns', prevent any
refresh functions (defined in `cider-ns-refresh-before-fn' and
`cider-ns-refresh-after-fn') from being invoked.

\(fn &optional MODE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-ns" '("cider-ns-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-overlays" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-popup" '("cider-")))



(autoload 'cider-profile-samples "cider-profile" "\
Displays current max-sample-count.
If optional QUERY is specified, set max-sample-count and display new value.

\(fn &optional QUERY)" t nil)

(autoload 'cider-profile-var-profiled-p "cider-profile" "\
Displays the profiling status of var under point.
Prompts for var if none under point or QUERY is present.

\(fn QUERY)" t nil)

(autoload 'cider-profile-ns-toggle "cider-profile" "\
Toggle profiling for the ns associated with optional QUERY.

If optional argument QUERY is non-nil, prompt for ns.  Otherwise use
current ns.

\(fn &optional QUERY)" t nil)

(autoload 'cider-profile-toggle "cider-profile" "\
Toggle profiling for the given QUERY.
Defaults to the symbol at point.
With prefix arg or no symbol at point, prompts for a var.

\(fn QUERY)" t nil)

(autoload 'cider-profile-summary "cider-profile" "\
Display a summary of currently collected profile data.

\(fn)" t nil)

(autoload 'cider-profile-var-summary "cider-profile" "\
Display profile data for var under point QUERY.
Defaults to the symbol at point.  With prefix arg or no symbol at point,
prompts for a var.

\(fn QUERY)" t nil)

(autoload 'cider-profile-clear "cider-profile" "\
Clear any collected profile data.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-profile" '("cider-profile-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-repl" '("cider-")))



(autoload 'cider-repl-history "cider-repl-history" "\
Display items in the CIDER command history in another buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-repl-history" '("cider-repl-history-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-resolve" '("cider-resolve-")))



(autoload 'cider-scratch "cider-scratch" "\
Go to the scratch buffer named `cider-scratch-buffer-name'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-scratch" '("cider-")))



(autoload 'cider-selector "cider-selector" "\
Select a new buffer by type, indicated by a single character.
The user is prompted for a single character indicating the method by
which to choose a new buffer.  The `?' character describes then
available methods.  OTHER-WINDOW provides an optional target.
See `def-cider-selector-method' for defining new methods.

\(fn &optional OTHER-WINDOW)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-selector" '("??" "?c" "?d" "?e" "?m" "?p" "?q" "?r" "?s" "?x" "cider-selector-" "def-cider-selector-method")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-stacktrace" '("cider-")))



(defvar cider-auto-test-mode nil "\
Non-nil if Cider-Auto-Test mode is enabled.
See the `cider-auto-test-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `cider-auto-test-mode'.")

(custom-autoload 'cider-auto-test-mode "cider-test" nil)

(autoload 'cider-auto-test-mode "cider-test" "\
Toggle automatic testing of Clojure files.

If called interactively, enable Cider-Auto-Test mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When enabled this reruns tests every time a Clojure file is loaded.
Only runs tests corresponding to the loaded file's namespace and does
nothing if no tests are defined or if the file failed to load.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-test" '("cider-")))



(autoload 'cider-toggle-trace-var "cider-tracing" "\
Toggle var tracing.
Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn ARG)" t nil)

(autoload 'cider-toggle-trace-ns "cider-tracing" "\
Toggle ns tracing.
Defaults to the current ns.  With prefix arg QUERY, prompts for a ns.

\(fn QUERY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-tracing" '("cider-")))



(autoload 'cider-view-manual "cider-util" "\
View the manual in your default browser.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-util" '("cider-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-client" '("cider-enlighten-mode" "nrepl-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-dict" '("nrepl-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/typed-clojure-mode-20151003.1822/typed-clojure-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/typed-clojure-mode-20151003.1822/typed-clojure-mode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "typed-clojure-error-mode" '("typed-clojure-error-mode")))



(autoload 'typed-clojure-mode "typed-clojure-mode" "\
The official minor mode for editing Typed Clojure. Provides
namespace typechecking, error navigation, display of type data,
and annotation snippets.

If called interactively, enable Typed-Clojure mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{typed-clojure-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "typed-clojure-mode" '("typed-clojure-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tNFA-0.1.1/tNFA-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tNFA-0.1.1/tNFA-autoloads.el") (car load-path))))



(autoload 'tNFA-from-regexp "tNFA" "\
Create a tagged NFA that recognizes the regular expression REGEXP.
The return value is the initial state of the tagged NFA.

REGEXP can be any sequence type (vector, list, or string); it
need not be an actual string. Special characters in REGEXP are
still just that: elements of the sequence that are characters
which have a special meaning in regexps.

The :test keyword argument specifies how to test whether two
individual elements of STRING are identical. The default is `eq'.

Only a subset of the full Emacs regular expression syntax is
supported. There is no support for regexp constructs that are
only meaningful for strings (character ranges and character
classes inside character alternatives, and syntax-related
backslash constructs). Back-references and non-greedy postfix
operators are not supported, so `?' after a postfix operator
loses its special meaning. Also, matches are always anchored, so
`$' and `^' lose their special meanings (use `.*' at the
beginning and end of the regexp to get an unanchored match).

\(fn REGEXP &key (test \\='eq))" nil nil)

(autoload 'tNFA-regexp-match "tNFA" "\
Return non-nil if STRING matches REGEXP, nil otherwise.
Sets the match data if there was a match; see `match-beginning',
`match-end' and `match-string'.

REGEXP and STRING can be any sequence type (vector, list, or
string); they need not be actual strings. Special characters in
REGEXP are still just that: elements of the sequence that are
characters which have a special meaning in regexps.

The :test keyword argument specifies how to test whether two
individual elements of STRING are identical. The default is `eq'.

Only a subset of the full Emacs regular expression syntax is
supported. There is no support for regexp constructs that are
only meaningful for strings (character ranges and character
classes inside character alternatives, and syntax-related
backslash constructs). Back-references and non-greedy postfix
operators are not supported, so `?' after a postfix operator
loses its special meaning. Also, matches are always anchored, so
`$' and `^' lose their special meanings (use `.*' at the
beginning and end of the regexp to get an unanchored match).

\(fn REGEXP STRING &key (test \\='eq))" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tNFA" '("tNFA-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/heap-0.5/heap-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/heap-0.5/heap-autoloads.el") (car load-path))))



(autoload 'make-heap "heap" "\
Create an empty heap with comparison function COMPARE-FUNCTION.

COMPARE-FUNCTION takes two arguments, A and B, and returns
non-nil or nil. To implement a max-heap, it should return non-nil
if A is greater than B. To implemenet a min-heap, it should
return non-nil if A is less than B.

Optional argument INITIAL-SIZE sets the initial size of the heap,
defaulting to 10. Optional argument RESIZE-FACTOR sets the factor
by which the heap's size is increased if it runs out of space,
defaulting to 2.

\(fn COMPARE-FUNCTION &optional INITIAL-SIZE RESIZE-FACTOR)" nil nil)

(defalias 'heap-create 'make-heap)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "heap" '("heap-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/trie-0.4/trie-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/trie-0.4/trie-autoloads.el") (car load-path))))



(defalias 'make-trie 'trie--create "\
Return a new trie that uses comparison function COMPARISON-FUNCTION.

A trie stores sequences (strings, vectors or lists) along with
associated data. COMPARISON-FUNCTEION should accept two
arguments, each being an element of such a sequence, and return t
if the first is strictly smaller than the second.

The optional argument TYPE specifies the type of trie to
create. However, the only one that is currently implemented is
the default, so this argument is useless for now.

\(See also `make-trie-custom'.)")

(defalias 'trie-create 'make-trie)

(defalias 'make-trie-custom 'trie--create-custom "\
Return a new trie that uses comparison function COMPARISON-FUNCTION.

A trie stores sequences (strings, vectors or lists) along with
associated data. COMPARISON-FUNCTION should accept two arguments,
each being an element of such a sequence, and return t if the
first is strictly smaller than the second.

The remaining keyword arguments: :CREATEFUN, :INSERTFUN, :DELETEFUN,
:LOOKUPFUN, :MAPFUN, :EMPTYFUN, :STACK-CREATEFUN, :STACK-POPFUN,
:STACK-EMPTYFUN, :TRANSFORM-FOR-PRINT and :TRANSFORM-FROM-READ
determine the type of trie that is created.

CREATEFUN is called as follows:

  (CREATEFUN COMPARISON-FUNCTION SEQ)

and should return a data structure (\"ARRAY\") that can be used
as an associative array, where two elements A and B are equal if
the following is non-nil:

  (and (COMPARISON-FUNCTION b a)
       (COMPARISON-FUNCTION b a))

The SEQ argument is a vector containing the sequence that will
correspond to the newly created array in the trie. For most types
of trie, this value is ignored. It is passed to CREATEFUN only in
order to allow the creation of \"hybrid\" trie structures, in
which different types of associative array are used in different
parts of the trie. For example, the type of associative array
could be chosen based on the depth in the trie, given by (length
SEQ). (Note that all the other functions described below must be
able to correctly handle *any* of the types of associate array
that might be created by CREATEFUN.)

INSERTFUN, DELETEFUN, LOOKUPFUN, MAPFUN and EMPTYFUN should
insert, delete, lookup, map over, and check-if-there-exist-any
elements in an associative array. They are called as follows:

  (INSERTFUN array element &optional updatefun)
  (DELETEFUN array element &optional predicate nilflag)
  (LOOKUPFUN array element &optional nilflag)
  (MAPFUN function array &optional reverse)
  (EMPTYFUN array)

INSERTFUN should insert ELEMENT into ARRAY and return the new
element, which will be ELEMENT itself unless UPDATEFUN is
specified. In that case, if and only if an element matching
ELEMENT already exists in the associative array, INSERTFUN should
instead pass ELEMENT and the matching element as arguments to
UPDATEFUN, replace the matching element with the return value,
and return that return value.

DELETEFUN should delete the element in the associative array that
matches ELEMENT, and return the deleted element. However, if
PREDICATE is specified and a matching element exists in ARRAY,
DELETEFUN should first pass the matching element as an argument
to PREDICATE before deleting, and should only delete the element
if PREDICATE returns non-nil. DELETEFUN should return NILFLAG if
no element was deleted (either becuase no matching element was
found, or because TESTFUN returned nil).

LOOKUPFUN should return the element from the associative array
that matches ELEMENT, or NILFLAG if no matching element exists.

MAPFUN should map FUNCTION over all elements in the order defined by
COMPARISON-FUNCTION, or in reverse order if REVERSE is non-nil.


STACK-CREATEFUN, STACK-POPFUN and STACK-EMPTYFUN should allow the
associative array to be used as a stack. STACK-CREATEFUN is
called as follows:

  (STACK-CREATEFUN array)

and should return a data structure (\"STACK\") that behaves like
a sorted stack of all elements in the associative array. I.e.
successive calls to

  (STACK-POPFUN stack)

should return elements from the associative array in the order
defined by COMPARISON-FUNCTION, and

  (STACK-EMPTYFUN stack)

should return non-nil if the stack is empty, nil otherwise.

The stack functions are optional, in that all trie operations
other than the stack-related ones will work correctly. However,
any code that makes use of trie-stacks will complain if supplied
with this type of trie.


The :TRANSFORM-FOR-PRINT and :TRANSFORM-FROM-READ arguments are
optional. If supplied, they can be used to transform the trie
into a format suitable for passing to Elisp's `print'
functions (typically used to persistently store the trie by
writing it to file), and transform from that format back to the
original usable form.


Warning: to avoid nasty dynamic scoping bugs, the supplied
functions must *never* bind any variables with names commencing
\"--\".")

(defalias 'trie-create-custom 'make-trie-custom)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "trie" '("Lewenstein-" "edit-distance" "trie-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tree-mode-20151104.1331/tree-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tree-mode-20151104.1331/tree-mode-autoloads.el") (car load-path))))



(autoload 'tree-minor-mode "tree-mode" "\
More keybindings for tree-widget.

If called interactively, enable Tree minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{tree-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tree-mode" '("tree-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/test-simple-20170527.1532/test-simple-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/test-simple-20170527.1532/test-simple-autoloads.el") (car load-path))))



(autoload 'test-simple-start "test-simple" "\


\(fn &optional TEST-START-MSG)" nil t)

(autoload 'test-simple-clear "test-simple" "\
Initialize and reset everything to run tests.
You should run this before running any assertions.  Running more than once
clears out information from the previous run.

\(fn &optional TEST-INFO TEST-START-MSG)" t nil)

(autoload 'test-simple-run "test-simple" "\
Register command line to run tests non-interactively and bind key to run test.
After calling this function, you can run test by key specified by `test-simple-runner-key'.

It is preferable to write at the first line of test files as a comment, e.g,
;;;; (test-simple-run \"emacs -batch -L %s -l %s\" (file-name-directory (locate-library \"test-simple.elc\")) buffer-file-name)

Calling this function interactively, COMMAND-LINE-FORMATS is set above.

\(fn &rest COMMAND-LINE-FORMATS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "test-simple" '("assert-" "end-tests" "note" "test-simple-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/fringe-helper-20140620.2109/fringe-helper-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/fringe-helper-20140620.2109/fringe-helper-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fringe-helper" '("fringe-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/test-case-mode-20130525.1434/test-case-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/test-case-mode-20130525.1434/test-case-mode-autoloads.el") (car load-path))))



(autoload 'test-case-mode "test-case-mode" "\
A minor mode for test buffers.
Tests can be started with the commands `test-case-run' or
`test-case-run-all'.  If you want to run tests automatically after a
compilation, use `test-case-compilation-finish-run-all'.

If called interactively, enable Test-Case mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When a run has finished, the results appear in a buffer named \"*Test
Result*\".  Clicking on the files will take you to the failure location,
as will `next-error' and `previous-error'.

Failures are also highlighted in the buffer.  Hovering the mouse above
them, or enabling `test-case-echo-failure-mode' shows the associated
failure message.

The testing states are indicated visually.  The buffer name is colored
according to the result and a dot in the mode-line represents the global
state.  This behavior is customizable through `test-case-color-buffer-id'
and `test-case-mode-line-info-position'.

\(fn &optional ARG)" t nil)

(autoload 'enable-test-case-mode-if-test "test-case-mode" "\
Turns on ``test-case-mode'' if this buffer is a recognized test.

\(fn)" nil nil)
(add-hook 'find-file-hook 'enable-test-case-mode-if-test)

(autoload 'test-case-find-all-tests "test-case-mode" "\
Find all test cases in DIRECTORY.

\(fn DIRECTORY)" t nil)

(autoload 'test-case-compilation-finish-run-all "test-case-mode" "\
Post-compilation hook for running all tests after successful compilation.
Install this the following way:

\(add-hook 'compilation-finish-functions
          'test-case-compilation-finish-run-all)

\(fn BUFFER RESULT)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "test-case-mode" '("disable-test-case-mode" "tast-case-menu-format-buffer" "test-case-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/test-c-20180423.1720/test-c-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/test-c-20180423.1720/test-c-autoloads.el") (car load-path))))



(autoload 'test-c "test-c" "\
Compile and run a new test-c buffer (or reuse existing one).

\(fn NEW-BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "test-c" '("test-c-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term-run-20151228.905/term-run-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term-run-20151228.905/term-run-autoloads.el") (car load-path))))



(autoload 'term-run "term-run" "\
Run PROGRAM in BUFFER-OR-NAME with ARGS in terminal buffer.

If BUFFER-OR-NAME is given, use this buffer.  In this case, old process in the
buffer will be destroyed.  Otherwise, new buffer will be generated automatically
from PROGRAM.

This function returns the buffer where the process starts running.

\(fn PROGRAM &optional BUFFER-OR-NAME &rest ARGS)" nil nil)

(autoload 'term-run-shell-command "term-run" "\
Run COMMAND in terminal buffer.

If NEW-BUFFER-P is given or called with prefix argument, generate new terminal
buffer for running COMMAND.  Otherwise, use the same buffer.  In this case, old
process in the buffer will be destroyed.

This function returns the buffer where the process starts running.

\(fn COMMAND &optional NEW-BUFFER-P)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term-run" '("term-run-shell-command-history")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term-manager-20171020.841/term-manager-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term-manager-20171020.841/term-manager-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term-manager" '("term-manager")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term-manager-indexed-mapping" '("term-manager-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term+-20170509.17/term+-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term+-20170509.17/term+-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+edit" '("term+edit")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+file-transfer" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+input" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+logging" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+shell-history" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+vars" '("term+")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xterm-256color" '("term-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tab-group-20140306.1450/tab-group-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tab-group-20140306.1450/tab-group-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tab-group" '("tab-group:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/term+mux-20140211.749/term+mux-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/term+mux-20140211.749/term+mux-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "term+mux" '("term+mux-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/tco-20160811.12/tco-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/tco-20160811.12/tco-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tco" '("defun-tco" "tco-add-trampoline")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ivy-20180809.1712/ivy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ivy-20180809.1712/ivy-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "colir" '("colir-")))



(autoload 'ivy-resume "ivy" "\
Resume the last completion session.

\(fn)" t nil)

(autoload 'ivy-read "ivy" "\
Read a string in the minibuffer, with completion.

PROMPT is a format string, normally ending in a colon and a
space; %d anywhere in the string is replaced by the current
number of matching candidates.  For the literal % character,
escape it with %%. See also `ivy-count-format'.

COLLECTION is either a list of strings, a function, an alist, or
a hash table.

PREDICATE is applied to filter out the COLLECTION immediately.
This argument is for `completing-read' compat.

When REQUIRE-MATCH is non-nil, only members of COLLECTION can be
selected, i.e. custom text.

If INITIAL-INPUT is not nil, then insert that input in the
minibuffer initially.

HISTORY is a name of a variable to hold the completion session
history.

KEYMAP is composed with `ivy-minibuffer-map'.

If PRESELECT is not nil, then select the corresponding candidate
out of the ones that match the INITIAL-INPUT.

DEF is for compatibility with `completing-read'.

UPDATE-FN is called each time the current candidate(s) is changed.

When SORT is t, use `ivy-sort-functions-alist' for sorting.

ACTION is a lambda function to call after selecting a result.  It
takes a single string argument.

UNWIND is a lambda function to call before exiting.

RE-BUILDER is a lambda function to call to transform text into a
regex pattern.

MATCHER is to override matching.

DYNAMIC-COLLECTION is a boolean to specify if the list of
candidates is updated after each input by calling COLLECTION.

CALLER is a symbol to uniquely identify the caller to `ivy-read'.
It is used, along with COLLECTION, to determine which
customizations apply to the current completion session.

\(fn PROMPT COLLECTION &key PREDICATE REQUIRE-MATCH INITIAL-INPUT HISTORY PRESELECT DEF KEYMAP UPDATE-FN SORT ACTION UNWIND RE-BUILDER MATCHER DYNAMIC-COLLECTION CALLER)" nil nil)

(autoload 'ivy-completing-read "ivy" "\
Read a string in the minibuffer, with completion.

This interface conforms to `completing-read' and can be used for
`completing-read-function'.

PROMPT is a string that normally ends in a colon and a space.
COLLECTION is either a list of strings, an alist, an obarray, or a hash table.
PREDICATE limits completion to a subset of COLLECTION.
REQUIRE-MATCH is a boolean value.  See `completing-read'.
INITIAL-INPUT is a string inserted into the minibuffer initially.
HISTORY is a list of previously selected inputs.
DEF is the default value.
INHERIT-INPUT-METHOD is currently ignored.

\(fn PROMPT COLLECTION &optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HISTORY DEF INHERIT-INPUT-METHOD)" nil nil)

(defvar ivy-mode nil "\
Non-nil if Ivy mode is enabled.
See the `ivy-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ivy-mode'.")

(custom-autoload 'ivy-mode "ivy" nil)

(autoload 'ivy-mode "ivy" "\
Toggle Ivy mode on or off.
Turn Ivy mode on if ARG is positive, off otherwise.
Turning on Ivy mode sets `completing-read-function' to
`ivy-completing-read'.

Global bindings:
\\{ivy-mode-map}

Minibuffer bindings:
\\{ivy-minibuffer-map}

\(fn &optional ARG)" t nil)

(autoload 'ivy-switch-buffer "ivy" "\
Switch to another buffer.

\(fn)" t nil)

(autoload 'ivy-switch-view "ivy" "\
Switch to one of the window views stored by `ivy-push-view'.

\(fn)" t nil)

(autoload 'ivy-switch-buffer-other-window "ivy" "\
Switch to another buffer in another window.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy" '("ivy-" "with-ivy-window")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy-overlay" '("ivy-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/swiper-20180813.1625/swiper-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/swiper-20180813.1625/swiper-autoloads.el") (car load-path))))



(autoload 'swiper-avy "swiper" "\
Jump to one of the current swiper candidates.

\(fn)" t nil)

(autoload 'swiper "swiper" "\
`isearch' with an overview.
When non-nil, INITIAL-INPUT is the initial search pattern.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'swiper-all "swiper" "\
Run `swiper' for all open buffers.

\(fn &optional INITIAL-INPUT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "swiper" '("swiper-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sudo-ext-20170126.1214/sudo-ext-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sudo-ext-20170126.1214/sudo-ext-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sudo-ext" '("sudo")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sudo-edit-20180731.1908/sudo-edit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sudo-edit-20180731.1908/sudo-edit-autoloads.el") (car load-path))))



(autoload 'sudo-edit-set-header "sudo-edit" "\
*Display a warning in header line of the current buffer.
This function is suitable to add to `find-file-hook' and `dired-file-hook'.

\(fn)" nil nil)

(defvar sudo-edit-indicator-mode nil "\
Non-nil if Sudo-Edit-Indicator mode is enabled.
See the `sudo-edit-indicator-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `sudo-edit-indicator-mode'.")

(custom-autoload 'sudo-edit-indicator-mode "sudo-edit" nil)

(autoload 'sudo-edit-indicator-mode "sudo-edit" "\
Indicates editing as root by displaying a message in the header line.

If called interactively, enable Sudo-Edit-Indicator mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'sudo-edit "sudo-edit" "\
Edit currently visited file as another user, by default `sudo-edit-user'.

With a prefix ARG prompt for a file to visit.  Will also prompt
for a file to visit if current buffer is not visiting a file.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sudo-edit" '("sudo-edit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/string-edit-20160411.656/string-edit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/string-edit-20160411.656/string-edit-autoloads.el") (car load-path))))



(autoload 'string-edit-at-point "string-edit" "\
Pop up a buffer to edit the string at point.
This saves you from needing to manually escape characters.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "string-edit" '("se/" "string-edit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/stream-2.2.4/stream-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/stream-2.2.4/stream-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "stream" '("stream")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "stream-x" '("stream-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/strace-mode-20171116.2039/strace-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/strace-mode-20171116.2039/strace-mode-autoloads.el") (car load-path))))



(autoload 'strace-mode "strace-mode" "\
Major mode for strace output.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.strace\\'" . strace-mode))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-tunnels-20180703.2027/ssh-tunnels-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-tunnels-20180703.2027/ssh-tunnels-autoloads.el") (car load-path))))



(autoload 'ssh-tunnels "ssh-tunnels" "\
View and manipulate SSH tunnels.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh-tunnels" '("ssh-tunnels-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-config-mode-20180609.951/ssh-config-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-config-mode-20180609.951/ssh-config-mode-autoloads.el") (car load-path))))



(autoload 'ssh-config-mode "ssh-config-mode" "\
Major mode for fontifiying ssh config files.

\\{ssh-config-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("/\\.ssh/config\\'" . ssh-config-mode))

(add-to-list 'auto-mode-alist '("/sshd?_config\\'" . ssh-config-mode))

(add-to-list 'auto-mode-alist '("/known_hosts\\'" . ssh-known-hosts-mode))

(add-to-list 'auto-mode-alist '("/authorized_keys\\'" . ssh-authorized-keys-mode))

(autoload 'ssh-known-hosts-mode "ssh-config-mode" "\
Major mode for fontifiying ssh known_hosts files.
\\{ssh-known-hosts-mode}

\(fn)" t nil)
 (autoload 'ssh-authorized-keys-mode "ssh-config-mode" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh-config-mode" '("ssh-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-agency-20180508.26/ssh-agency-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-agency-20180508.26/ssh-agency-autoloads.el") (car load-path))))



(autoload 'ssh-agency-ensure "ssh-agency" "\
Start ssh-agent and add keys, as needed.

Intended to be added to `magit-credential-hook'.

\(fn)" nil nil)

(add-hook 'magit-credential-hook 'ssh-agency-ensure)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh-agency" '("ssh-agency-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ssh-20120904.2042/ssh-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ssh-20120904.2042/ssh-autoloads.el") (car load-path))))


 (add-hook 'same-window-regexps "^\\*ssh-.*\\*\\(\\|<[0-9]+>\\)")

(autoload 'ssh "ssh" "\
Open a network login connection via `ssh' with args INPUT-ARGS.
INPUT-ARGS should start with a host name; it may also contain
other arguments for `ssh'.

Input is sent line-at-a-time to the remote connection.

Communication with the remote host is recorded in a buffer `*ssh-HOST*'
\(or `*ssh-USER@HOST*' if the remote username differs).
If a prefix argument is given and the buffer `*ssh-HOST*' already exists,
a new buffer with a different connection will be made.

When called from a program, if the optional second argument BUFFER is
a string or buffer, it specifies the buffer to use.

The variable `ssh-program' contains the name of the actual program to
run.  It can be a relative or absolute path.

The variable `ssh-explicit-args' is a list of arguments to give to
the ssh when starting.  They are prepended to any arguments given in
INPUT-ARGS.

If the default value of `ssh-directory-tracking-mode' is t, then the
default directory in that buffer is set to a remote (FTP) file name to
access your home directory on the remote machine.  Occasionally this causes
an error, if you cannot access the home directory on that machine.  This
error is harmless as long as you don't try to use that default directory.

If `ssh-directory-tracking-mode' is neither t nor nil, then the default
directory is initially set up to your (local) home directory.
This is useful if the remote machine and your local machine
share the same files via NFS.  This is the default.

If you wish to change directory tracking styles during a session, use the
function `ssh-directory-tracking-mode' rather than simply setting the
variable.

The variable `ssh-x-display-follow-current-frame' can be used to specify
how ssh X display tunelling interacts with frames on remote displays.

\(fn INPUT-ARGS &optional BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ssh" '("ssh-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/srefactor-20180703.1810/srefactor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/srefactor-20180703.1810/srefactor-autoloads.el") (car load-path))))



(autoload 'srefactor-refactor-at-point "srefactor" "\
Offer contextual menu with actions based on current tag in scope.

Each menu item added returns a token for what type of refactoring
to perform.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "srefactor" '("srefactor-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "srefactor-lisp" '("comment-" "cur-buf" "first-token" "format-type" "ignore-num" "lexemes" "next-token" "orig-format-type" "recursive-p" "second-token" "srefactor-" "tok")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "srefactor-ui" '("srefactor-ui-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/sotlisp-20180706.1749/sotlisp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/sotlisp-20180706.1749/sotlisp-autoloads.el") (car load-path))))



(defvar speed-of-thought-mode nil "\
Non-nil if Speed-Of-Thought mode is enabled.
See the `speed-of-thought-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `speed-of-thought-mode'.")

(custom-autoload 'speed-of-thought-mode "sotlisp" nil)

(autoload 'speed-of-thought-mode "sotlisp" "\
Toggle Speed-Of-Thought mode on or off.

If called interactively, enable Speed-Of-Thought mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{speed-of-thought-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'speed-of-thought-hook-in "sotlisp" "\
Add functions ON and OFF to `speed-of-thought-mode' hooks.
If `speed-of-thought-mode' is already on, call ON.

\(fn ON OFF)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sotlisp" '("sotlisp-" "speed-of-thought-turn-o")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/snippet-20130210.2315/snippet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/snippet-20130210.2315/snippet-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "snippet" '("snippet")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smartparens-20180808.1758/smartparens-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smartparens-20180808.1758/smartparens-autoloads.el") (car load-path))))



(autoload 'sp-cheat-sheet "smartparens" "\
Generate a cheat sheet of all the smartparens interactive functions.

Without a prefix argument, print only the short documentation and examples.

With non-nil prefix argument ARG, show the full documentation for each function.

You can follow the links to the function or variable help page.
To get back to the full list, use \\[help-go-back].

You can use `beginning-of-defun' and `end-of-defun' to jump to
the previous/next entry.

Examples are fontified using the `font-lock-string-face' for
better orientation.

\(fn &optional ARG)" t nil)

(defvar smartparens-mode-map (make-sparse-keymap) "\
Keymap used for `smartparens-mode'.")

(autoload 'sp-use-paredit-bindings "smartparens" "\
Initiate `smartparens-mode-map' with `sp-paredit-bindings'.

\(fn)" t nil)

(autoload 'sp-use-smartparens-bindings "smartparens" "\
Initiate `smartparens-mode-map' with `sp-smartparens-bindings'.

\(fn)" t nil)

(autoload 'smartparens-mode "smartparens" "\
Toggle smartparens mode.

If called interactively, enable Smartparens mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

You can enable pre-set bindings by customizing
`sp-base-key-bindings' variable.  The current content of
`smartparens-mode-map' is:

 \\{smartparens-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'smartparens-strict-mode "smartparens" "\
Toggle the strict smartparens mode.

If called interactively, enable Smartparens-Strict mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When strict mode is active, `delete-char', `kill-word' and their
backward variants will skip over the pair delimiters in order to
keep the structure always valid (the same way as `paredit-mode'
does).  This is accomplished by remapping them to
`sp-delete-char' and `sp-kill-word'.  There is also function
`sp-kill-symbol' that deletes symbols instead of words, otherwise
working exactly the same (it is not bound to any key by default).

When strict mode is active, this is indicated with \"/s\"
after the smartparens indicator in the mode list.

\(fn &optional ARG)" t nil)

(defvar smartparens-global-strict-mode nil "\
Non-nil if Smartparens-Global-Strict mode is enabled.
See the `smartparens-global-strict-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `smartparens-global-strict-mode'.")

(custom-autoload 'smartparens-global-strict-mode "smartparens" nil)

(autoload 'smartparens-global-strict-mode "smartparens" "\
Toggle Smartparens-Strict mode in all buffers.
With prefix ARG, enable Smartparens-Global-Strict mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Smartparens-Strict mode is enabled in all buffers where
`turn-on-smartparens-strict-mode' would do it.
See `smartparens-strict-mode' for more information on Smartparens-Strict mode.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-smartparens-strict-mode "smartparens" "\
Turn on `smartparens-strict-mode'.

\(fn)" t nil)

(autoload 'turn-off-smartparens-strict-mode "smartparens" "\
Turn off `smartparens-strict-mode'.

\(fn)" t nil)

(defvar smartparens-global-mode nil "\
Non-nil if Smartparens-Global mode is enabled.
See the `smartparens-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `smartparens-global-mode'.")

(custom-autoload 'smartparens-global-mode "smartparens" nil)

(autoload 'smartparens-global-mode "smartparens" "\
Toggle Smartparens mode in all buffers.
With prefix ARG, enable Smartparens-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Smartparens mode is enabled in all buffers where
`turn-on-smartparens-mode' would do it.
See `smartparens-mode' for more information on Smartparens mode.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-smartparens-mode "smartparens" "\
Turn on `smartparens-mode'.

This function is used to turn on `smartparens-global-mode'.

By default `smartparens-global-mode' ignores buffers with
`mode-class' set to special, but only if they are also not comint
buffers.

Additionally, buffers on `sp-ignore-modes-list' are ignored.

You can still turn on smartparens in these mode manually (or
in mode's startup-hook etc.) by calling `smartparens-mode'.

\(fn)" t nil)

(autoload 'turn-off-smartparens-mode "smartparens" "\
Turn off `smartparens-mode'.

\(fn)" t nil)

(autoload 'show-smartparens-mode "smartparens" "\
Toggle visualization of matching pairs.  When enabled, any
matching pair is highlighted after `sp-show-pair-delay' seconds
of Emacs idle time if the point is immediately in front or after
a pair.  This mode works similarly to `show-paren-mode', but
support custom pairs.

If called interactively, enable Show-Smartparens mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar show-smartparens-global-mode nil "\
Non-nil if Show-Smartparens-Global mode is enabled.
See the `show-smartparens-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `show-smartparens-global-mode'.")

(custom-autoload 'show-smartparens-global-mode "smartparens" nil)

(autoload 'show-smartparens-global-mode "smartparens" "\
Toggle Show-Smartparens mode in all buffers.
With prefix ARG, enable Show-Smartparens-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Show-Smartparens mode is enabled in all buffers where
`turn-on-show-smartparens-mode' would do it.
See `show-smartparens-mode' for more information on Show-Smartparens mode.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-show-smartparens-mode "smartparens" "\
Turn on `show-smartparens-mode'.

\(fn)" t nil)

(autoload 'turn-off-show-smartparens-mode "smartparens" "\
Turn off `show-smartparens-mode'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens" '("smartparens-" "sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-clojure" '("sp-clojure-prefix")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-config" '("sp-lisp-invalid-hyperlink-p")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-crystal" '("sp-crystal-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-elixir" '("sp-elixir-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-ess" '("sp-ess-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-haskell" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-html" '("sp-html-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-latex" '("sp-latex-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-lua" '("sp-lua-post-keyword-insert")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-markdown" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-org" '("sp--org-skip-asterisk")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-python" '("sp-python-fix-tripple-quotes")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-ruby" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-rust" '("sp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-scala" '("sp-scala-wrap-with-indented-newlines")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smartparens-text" '("sp-text-mode-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/expand-region-20180817.1134/expand-region-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/expand-region-20180817.1134/expand-region-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cc-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cperl-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "css-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "enh-ruby-mode-expansions" '("er/add-enh-ruby-mode-expansions")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "er-basic-expansions" '("er--" "er/mark-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-mode-expansions" '("er/add-erlang-mode-expansions")))



(autoload 'er/expand-region "expand-region" "\
Increase selected region by semantic units.

With prefix argument expands the region that many times.
If prefix argument is negative calls `er/contract-region'.
If prefix argument is 0 it resets point and mark to their state
before calling `er/expand-region' for the first time.

\(fn ARG)" t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "expand-region-core" '("er--" "er/")))



(let ((loads (get 'expand-region 'custom-loads))) (if (member '"expand-region-custom" loads) nil (put 'expand-region 'custom-loads (cons '"expand-region-custom" loads))))

(defvar expand-region-preferred-python-mode 'python "\
The name of your preferred python mode")

(custom-autoload 'expand-region-preferred-python-mode "expand-region-custom" t)

(defvar expand-region-guess-python-mode t "\
If expand-region should attempt to guess your preferred python mode")

(custom-autoload 'expand-region-guess-python-mode "expand-region-custom" t)

(defvar expand-region-autocopy-register "" "\
If set to a string of a single character (try \"e\"), then the
contents of the most recent expand or contract command will
always be copied to the register named after that character.")

(custom-autoload 'expand-region-autocopy-register "expand-region-custom" t)

(defvar expand-region-skip-whitespace t "\
If expand-region should skip past whitespace on initial expansion")

(custom-autoload 'expand-region-skip-whitespace "expand-region-custom" t)

(defvar expand-region-fast-keys-enabled t "\
If expand-region should bind fast keys after initial expand/contract")

(custom-autoload 'expand-region-fast-keys-enabled "expand-region-custom" t)

(defvar expand-region-contract-fast-key "-" "\
Key to use after an initial expand/contract to contract once more.")

(custom-autoload 'expand-region-contract-fast-key "expand-region-custom" t)

(defvar expand-region-reset-fast-key "0" "\
Key to use after an initial expand/contract to undo.")

(custom-autoload 'expand-region-reset-fast-key "expand-region-custom" t)

(defvar expand-region-exclude-text-mode-expansions '(html-mode nxml-mode) "\
List of modes which derive from `text-mode' for which text mode expansions are not appropriate.")

(custom-autoload 'expand-region-exclude-text-mode-expansions "expand-region-custom" t)

(defvar expand-region-smart-cursor nil "\
Defines whether the cursor should be placed intelligently after expansion.

If set to t, and the cursor is already at the beginning of the new region,
keep it there; otherwise, put it at the end of the region.

If set to nil, always place the cursor at the beginning of the region.")

(custom-autoload 'expand-region-smart-cursor "expand-region-custom" t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "expand-region-custom" '("expand-region-guess-python-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "feature-mode-expansions" '("er--block-between-keywords" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "html-mode-expansions" '("er--" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "js-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "js2-mode-expansions" '("er/add-js2-mode-expansions" "js2-mark-parent-statement")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "jsp-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "latex-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nxml-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "octave-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-el-expansions" '("er--python-string-delimiter" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-el-fgallina-expansions" '("er--python-" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-mode-expansions" '("er--" "er/" "py-goto-beyond-clause")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ruby-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sml-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "subword-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "text-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "the-org-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-mode-expansions" '("er/add-web-mode-expansions")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-forward-20140430.713/smart-forward-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-forward-20140430.713/smart-forward-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-forward" '("smart-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-cursor-color-20141124.1719/smart-cursor-color-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-cursor-color-20141124.1719/smart-cursor-color-autoloads.el") (car load-path))))



(defvar smart-cursor-color-mode nil "\
Non-nil if Smart-Cursor-Color mode is enabled.
See the `smart-cursor-color-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `smart-cursor-color-mode'.")

(custom-autoload 'smart-cursor-color-mode "smart-cursor-color" nil)

(autoload 'smart-cursor-color-mode "smart-cursor-color" "\
Dynamically changed cursor color at point's color.

If called interactively, enable Smart-Cursor-Color mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-smart-cursor-color "smart-cursor-color" "\
Unconditionally turn on `smart-cursor-color-mode'.

\(fn)" t nil)

(autoload 'turn-off-smart-cursor-color "smart-cursor-color" "\
Unconditionally turn off `smart-cursor-color-mode'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-cursor-color" '("scc--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-compile-20180316.330/smart-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-compile-20180316.330/smart-compile-autoloads.el") (car load-path))))



(autoload 'smart-compile "smart-compile" "\
An interface to `compile'.
It calls `compile' or other compile function,
which is defined in `smart-compile-alist'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-compile" '("smart-compile-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/smart-comment-20160322.1839/smart-comment-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/smart-comment-20160322.1839/smart-comment-autoloads.el") (car load-path))))



(autoload 'smart-comment-cleanup "smart-comment" "\
Remove lines marked for deletion.

\(fn)" t nil)

(autoload 'smart-comment-mark-line "smart-comment" "\
Mark a line for deletion. ARG is ignored.

\(fn ARG)" t nil)

(autoload 'smart-comment-mark-region "smart-comment" "\
Mark a region from BEG to END for deletion. ARG is ignored.

\(fn BEG END ARG)" t nil)

(autoload 'smart-comment-region "smart-comment" "\
Comment or uncomment a region from BEG to END. ARG is ignored.

\(fn BEG END ARG)" t nil)

(autoload 'smart-comment-line "smart-comment" "\
Comment or uncomment a line. ARG is ignored.

\(fn ARG)" t nil)

(autoload 'smart-comment "smart-comment" "\
Smart commenting based on the location of point on line.
A single ARG is passed along to the function being invoked. Two
universal arguments invoke `smart-comment-cleanup' which deletes
all lines marked for deletion.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-comment" '("smart-comment-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/simple-httpd-20180528.1603/simple-httpd-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/simple-httpd-20180528.1603/simple-httpd-autoloads.el") (car load-path))))



(autoload 'httpd-start "simple-httpd" "\
Start the web server process. If the server is already
running, this will restart the server. There is only one server
instance per Emacs instance.

\(fn)" t nil)

(autoload 'httpd-stop "simple-httpd" "\
Stop the web server if it is currently running, otherwise do nothing.

\(fn)" t nil)

(autoload 'httpd-running-p "simple-httpd" "\
Return non-nil if the simple-httpd server is running.

\(fn)" nil nil)

(autoload 'httpd-serve-directory "simple-httpd" "\
Start the web server with given `directory' as `httpd-root'.

\(fn DIRECTORY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "simple-httpd" '("defservlet" "httpd" "with-httpd-buffer")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/signal-20160816.1438/signal-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/signal-20160816.1438/signal-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "signal" '("defsignal" "undefsignal")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shell-toggle-20150226.1411/shell-toggle-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shell-toggle-20150226.1411/shell-toggle-autoloads.el") (car load-path))))



(autoload 'shell-toggle-cd "shell-toggle" "\
Call `shell-toggle' with a prefix argument.
See command `shell-toggle'.

\(fn)" t nil)

(autoload 'shell-toggle "shell-toggle" "\
Toggle between the shell buffer and whatever buffer you are editing.
With a prefix argument MAKE-CD also insert a \"cd DIR\" command
into the shell, where DIR is the directory of the current buffer.

Call twice in a row to get a full screen window for the shell buffer.

When called in the shell buffer returns you to the buffer you were editing
before calling this the first time.

Options: `shell-toggle-goto-eob'

\(fn MAKE-CD)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shell-toggle" '("shell-toggle-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shell-switcher-20161029.552/shell-switcher-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shell-switcher-20161029.552/shell-switcher-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rswitcher" '("rswitcher-")))



(defvar shell-switcher-new-shell-function 'shell-switcher-make-eshell "\
This variable references a function used to create new shells.
The function must take 0 arguments and return a newly created
shell buffer.
`shell-switcher-make-shell',`shell-switcher-make-eshell' and
`shell-switcher-make-ansi-term' are possible functions.")

(custom-autoload 'shell-switcher-new-shell-function "shell-switcher" t)

(defvar shell-switcher-ask-before-creating-new nil "\
If non-nil ask the user before creating a new shell buffer.
A new shell buffer is automatically created if there are no
buffers to switch to and this variable is set to nil.")

(custom-autoload 'shell-switcher-ask-before-creating-new "shell-switcher" t)

(defvar shell-switcher-ansi-term-shell "" "\
If non-empty use this shell with `ansi-term'.
Otherwise the shell will be chosen based on the environment with
a fallback to /bin/sh")

(custom-autoload 'shell-switcher-ansi-term-shell "shell-switcher" t)

(defvar shell-switcher-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "C-'") 'shell-switcher-switch-buffer) (define-key map (kbd "C-x 4 '") 'shell-switcher-switch-buffer-other-window) (define-key map (kbd "C-M-'") 'shell-switcher-new-shell) map) "\
Keymap to use in shell-switcher mode.")

(defvar shell-switcher-mode nil "\
Non-nil if Shell-Switcher mode is enabled.
See the `shell-switcher-mode' command
for a description of this minor mode.")

(custom-autoload 'shell-switcher-mode "shell-switcher" nil)

(autoload 'shell-switcher-mode "shell-switcher" "\
Toggle shell-switcher mode.
Interactively with no argument, this command toggles the mode. A
positive prefix argument enables the mode, any other prefix
argument disables it. From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

If called interactively, enable Shell-Switcher mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When shell-switcher mode is enabled, switching and creating shell
buffers is just a matter of calling
\\[shell-switcher-switch-buffer]. Then, you can type the last key
of this key binding again to continue switching. Additionally,
see commands \\[shell-switcher-switch-buffer-other-window] and
\\[shell-switcher-new-shell].

\(fn &optional ARG)" t nil)

(autoload 'shell-switcher-switch-buffer "shell-switcher" "\
Switch to the most recently accessed buffer.
Switch to the most recently accessed shell buffer that is not the
current one.  Pressing the last key of the key sequence that call
this command will result in switching to the next shell buffer :
for example, if `C-'' is bound to this command, repeatedly
pressing `'' (quote) will let the user visit all shell
buffers (this is actually done by `sswitcher--switch-partially'.

If there is no shell buffer or if the only shell buffer is the
current buffer, propose the creation of a new shell buffer.

\(fn)" t nil)

(autoload 'shell-switcher-switch-buffer-other-window "shell-switcher" "\
Switch to the most recently accessed buffer in another window.
Same as `shell-switcher-switch-buffer' but change another
window.

\(fn)" t nil)

(autoload 'shell-switcher-new-shell "shell-switcher" "\
Unconditionally create and display a new shell buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shell-switcher" '("shell-switcher-" "sswitcher--")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/shell-command-20090830.1040/shell-command-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/shell-command-20090830.1040/shell-command-autoloads.el") (car load-path))))



(autoload 'shell-command-completion-mode "shell-command" "\
Enable or disable tab-completion for some commands.
The commands are `shell-command', `shell-command-on-region', `grep',
`grep-find' and `compile'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shell-command" '("compile-prompt" "grep-" "shell-command")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/scheme-here-20141028.718/scheme-here-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/scheme-here-20141028.718/scheme-here-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "scheme-here" '("run-scheme-here" "scheme-here-" "switch-to-scheme-here")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/scheme-complete-20170824.1413/scheme-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/scheme-complete-20170824.1413/scheme-complete-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "scheme-complete" '("*scheme-" "in-mod-p" "scheme-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/f-20180106.922/f-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/f-20180106.922/f-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "f" '("f-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/projectile-20180815.2057/projectile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/projectile-20180815.2057/projectile-autoloads.el") (car load-path))))



(autoload 'projectile-version "projectile" "\
Get the Projectile version as string.

If called interactively or if SHOW-VERSION is non-nil, show the
version in the echo area and the messages buffer.

The returned string includes both, the version from package.el
and the library version, if both a present and different.

If the version number could not be determined, signal an error,
if called interactively, or if SHOW-VERSION is non-nil, otherwise
just return nil.

\(fn &optional SHOW-VERSION)" t nil)

(autoload 'projectile-invalidate-cache "projectile" "\
Remove the current project's files from `projectile-projects-cache'.

With a prefix argument ARG prompts for the name of the project whose cache
to invalidate.

\(fn ARG)" t nil)

(autoload 'projectile-purge-file-from-cache "projectile" "\
Purge FILE from the cache of the current project.

\(fn FILE)" t nil)

(autoload 'projectile-purge-dir-from-cache "projectile" "\
Purge DIR from the cache of the current project.

\(fn DIR)" t nil)

(autoload 'projectile-cache-current-file "projectile" "\
Add the currently visited file to the cache.

\(fn)" t nil)

(autoload 'projectile-discover-projects-in-directory "projectile" "\
Discover any projects in DIRECTORY and add them to the projectile cache.
This function is not recursive and only adds projects with roots
at the top level of DIRECTORY.

\(fn DIRECTORY)" t nil)

(autoload 'projectile-switch-to-buffer "projectile" "\
Switch to a project buffer.

\(fn)" t nil)

(autoload 'projectile-switch-to-buffer-other-window "projectile" "\
Switch to a project buffer and show it in another window.

\(fn)" t nil)

(autoload 'projectile-switch-to-buffer-other-frame "projectile" "\
Switch to a project buffer and show it in another window.

\(fn)" t nil)

(autoload 'projectile-display-buffer "projectile" "\
Display a project buffer in another window without selecting it.

\(fn)" t nil)

(autoload 'projectile-project-buffers-other-buffer "projectile" "\
Switch to the most recently selected buffer project buffer.
Only buffers not visible in windows are returned.

\(fn)" t nil)

(autoload 'projectile-multi-occur "projectile" "\
Do a `multi-occur' in the project's buffers.
With a prefix argument, show NLINES of context.

\(fn &optional NLINES)" t nil)

(autoload 'projectile-find-other-file "projectile" "\
Switch between files with the same name but different extensions.
With FLEX-MATCHING, match any file that contains the base name of current file.
Other file extensions can be customized with the variable `projectile-other-file-alist'.

\(fn &optional FLEX-MATCHING)" t nil)

(autoload 'projectile-find-other-file-other-window "projectile" "\
Switch between files with the same name but different extensions in other window.
With FLEX-MATCHING, match any file that contains the base name of current file.
Other file extensions can be customized with the variable `projectile-other-file-alist'.

\(fn &optional FLEX-MATCHING)" t nil)

(autoload 'projectile-find-other-file-other-frame "projectile" "\
Switch between files with the same name but different extensions in other window.
With FLEX-MATCHING, match any file that contains the base name of current file.
Other file extensions can be customized with the variable `projectile-other-file-alist'.

\(fn &optional FLEX-MATCHING)" t nil)

(autoload 'projectile-find-file-dwim "projectile" "\
Jump to a project's files using completion based on context.

With a prefix ARG invalidates the cache first.

If point is on a filename, Projectile first tries to search for that
file in project:

- If it finds just a file, it switches to that file instantly.  This works even
if the filename is incomplete, but there's only a single file in the current project
that matches the filename at point.  For example, if there's only a single file named
\"projectile/projectile.el\" but the current filename is \"projectile/proj\" (incomplete),
`projectile-find-file-dwim' still switches to \"projectile/projectile.el\" immediately
 because this is the only filename that matches.

- If it finds a list of files, the list is displayed for selecting.  A list of
files is displayed when a filename appears more than one in the project or the
filename at point is a prefix of more than two files in a project.  For example,
if `projectile-find-file-dwim' is executed on a filepath like \"projectile/\", it lists
the content of that directory.  If it is executed on a partial filename like
 \"projectile/a\", a list of files with character 'a' in that directory is presented.

- If it finds nothing, display a list of all files in project for selecting.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-file-dwim-other-window "projectile" "\
Jump to a project's files using completion based on context in other window.

With a prefix ARG invalidates the cache first.

If point is on a filename, Projectile first tries to search for that
file in project:

- If it finds just a file, it switches to that file instantly.  This works even
if the filename is incomplete, but there's only a single file in the current project
that matches the filename at point.  For example, if there's only a single file named
\"projectile/projectile.el\" but the current filename is \"projectile/proj\" (incomplete),
`projectile-find-file-dwim-other-window' still switches to \"projectile/projectile.el\"
immediately because this is the only filename that matches.

- If it finds a list of files, the list is displayed for selecting.  A list of
files is displayed when a filename appears more than one in the project or the
filename at point is a prefix of more than two files in a project.  For example,
if `projectile-find-file-dwim-other-window' is executed on a filepath like \"projectile/\", it lists
the content of that directory.  If it is executed on a partial filename
like \"projectile/a\", a list of files with character 'a' in that directory
is presented.

- If it finds nothing, display a list of all files in project for selecting.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-file-dwim-other-frame "projectile" "\
Jump to a project's files using completion based on context in other frame.

With a prefix ARG invalidates the cache first.

If point is on a filename, Projectile first tries to search for that
file in project:

- If it finds just a file, it switches to that file instantly.  This works even
if the filename is incomplete, but there's only a single file in the current project
that matches the filename at point.  For example, if there's only a single file named
\"projectile/projectile.el\" but the current filename is \"projectile/proj\" (incomplete),
`projectile-find-file-dwim-other-frame' still switches to \"projectile/projectile.el\"
immediately because this is the only filename that matches.

- If it finds a list of files, the list is displayed for selecting.  A list of
files is displayed when a filename appears more than one in the project or the
filename at point is a prefix of more than two files in a project.  For example,
if `projectile-find-file-dwim-other-frame' is executed on a filepath like \"projectile/\", it lists
the content of that directory.  If it is executed on a partial filename
like \"projectile/a\", a list of files with character 'a' in that directory
is presented.

- If it finds nothing, display a list of all files in project for selecting.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-file "projectile" "\
Jump to a project's file using completion.
With a prefix ARG invalidates the cache first.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-file-other-window "projectile" "\
Jump to a project's file using completion and show it in another window.

With a prefix ARG invalidates the cache first.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-file-other-frame "projectile" "\
Jump to a project's file using completion and show it in another frame.

With a prefix ARG invalidates the cache first.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-dir "projectile" "\
Jump to a project's directory using completion.

With a prefix ARG invalidates the cache first.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-dir-other-window "projectile" "\
Jump to a project's directory in other window using completion.

With a prefix ARG invalidates the cache first.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-dir-other-frame "projectile" "\
Jump to a project's directory in other window using completion.

With a prefix ARG invalidates the cache first.

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-test-file "projectile" "\
Jump to a project's test file using completion.

With a prefix ARG invalidates the cache first.

\(fn &optional ARG)" t nil)

(autoload 'projectile-project-info "projectile" "\
Display info for current project.

\(fn)" t nil)

(autoload 'projectile-find-implementation-or-test-other-window "projectile" "\
Open matching implementation or test file in other window.

\(fn)" t nil)

(autoload 'projectile-find-implementation-or-test-other-frame "projectile" "\
Open matching implementation or test file in other frame.

\(fn)" t nil)

(autoload 'projectile-toggle-between-implementation-and-test "projectile" "\
Toggle between an implementation file and its test file.

\(fn)" t nil)

(autoload 'projectile-grep "projectile" "\
Perform rgrep in the project.

With a prefix ARG asks for files (globbing-aware) which to grep in.
With prefix ARG of `-' (such as `M--'), default the files (without prompt),
to `projectile-grep-default-files'.

With REGEXP given, don't query the user for a regexp.

\(fn &optional REGEXP ARG)" t nil)

(autoload 'projectile-ag "projectile" "\
Run an ag search with SEARCH-TERM in the project.

With an optional prefix argument ARG SEARCH-TERM is interpreted as a
regular expression.

\(fn SEARCH-TERM &optional ARG)" t nil)

(autoload 'projectile-ripgrep "projectile" "\
Run a Ripgrep search with `SEARCH-TERM' at current project root.

SEARCH-TERM is a regexp.

\(fn SEARCH-TERM)" t nil)

(autoload 'projectile-regenerate-tags "projectile" "\
Regenerate the project's [e|g]tags.

\(fn)" t nil)

(autoload 'projectile-find-tag "projectile" "\
Find tag in project.

\(fn)" t nil)

(autoload 'projectile-run-command-in-root "projectile" "\
Invoke `execute-extended-command' in the project's root.

\(fn)" t nil)

(autoload 'projectile-run-shell-command-in-root "projectile" "\
Invoke `shell-command' in the project's root.

\(fn)" t nil)

(autoload 'projectile-run-async-shell-command-in-root "projectile" "\
Invoke `async-shell-command' in the project's root.

\(fn)" t nil)

(autoload 'projectile-run-shell "projectile" "\
Invoke `shell' in the project's root.

Switch to the project specific shell buffer if it already exists.

\(fn)" t nil)

(autoload 'projectile-run-eshell "projectile" "\
Invoke `eshell' in the project's root.

Switch to the project specific eshell buffer if it already exists.

\(fn)" t nil)

(autoload 'projectile-run-ielm "projectile" "\
Invoke `ielm' in the project's root.

Switch to the project specific ielm buffer if it already exists.

\(fn)" t nil)

(autoload 'projectile-run-term "projectile" "\
Invoke `term' in the project's root.

Switch to the project specific term buffer if it already exists.

\(fn PROGRAM)" t nil)

(autoload 'projectile-replace "projectile" "\
Replace literal string in project using non-regexp `tags-query-replace'.

With a prefix argument ARG prompts you for a directory on which
to run the replacement.

\(fn &optional ARG)" t nil)

(autoload 'projectile-replace-regexp "projectile" "\
Replace a regexp in the project using `tags-query-replace'.

With a prefix argument ARG prompts you for a directory on which
to run the replacement.

\(fn &optional ARG)" t nil)

(autoload 'projectile-kill-buffers "projectile" "\
Kill all project buffers.

\(fn)" t nil)

(autoload 'projectile-save-project-buffers "projectile" "\
Save all project buffers.

\(fn)" t nil)

(autoload 'projectile-dired "projectile" "\
Open `dired' at the root of the project.

\(fn)" t nil)

(autoload 'projectile-dired-other-window "projectile" "\
Open `dired'  at the root of the project in another window.

\(fn)" t nil)

(autoload 'projectile-dired-other-frame "projectile" "\
Open `dired' at the root of the project in another frame.

\(fn)" t nil)

(autoload 'projectile-vc "projectile" "\
Open `vc-dir' at the root of the project.

For git projects `magit-status-internal' is used if available.
For hg projects `monky-status' is used if available.

If PROJECT-ROOT is given, it is opened instead of the project
root directory of the current buffer file.  If interactively
called with a prefix argument, the user is prompted for a project
directory to open.

\(fn &optional PROJECT-ROOT)" t nil)

(autoload 'projectile-recentf "projectile" "\
Show a list of recently visited files in a project.

\(fn)" t nil)

(autoload 'projectile-configure-project "projectile" "\
Run project configure command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-compile-project "projectile" "\
Run project compilation command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-test-project "projectile" "\
Run project test command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-run-project "projectile" "\
Run project run command.

Normally you'll be prompted for a compilation command, unless
variable `compilation-read-command'.  You can force the prompt
with a prefix ARG.

\(fn ARG)" t nil)

(autoload 'projectile-switch-project "projectile" "\
Switch to a project we have visited before.
Invokes the command referenced by `projectile-switch-project-action' on switch.
With a prefix ARG invokes `projectile-commander' instead of
`projectile-switch-project-action.'

\(fn &optional ARG)" t nil)

(autoload 'projectile-switch-open-project "projectile" "\
Switch to a project we have currently opened.
Invokes the command referenced by `projectile-switch-project-action' on switch.
With a prefix ARG invokes `projectile-commander' instead of
`projectile-switch-project-action.'

\(fn &optional ARG)" t nil)

(autoload 'projectile-find-file-in-directory "projectile" "\
Jump to a file in a (maybe regular) DIRECTORY.

This command will first prompt for the directory the file is in.

\(fn &optional DIRECTORY)" t nil)

(autoload 'projectile-find-file-in-known-projects "projectile" "\
Jump to a file in any of the known projects.

\(fn)" t nil)

(autoload 'projectile-cleanup-known-projects "projectile" "\
Remove known projects that don't exist anymore.

\(fn)" t nil)

(autoload 'projectile-clear-known-projects "projectile" "\
Clear both `projectile-known-projects' and `projectile-known-projects-file'.

\(fn)" t nil)

(autoload 'projectile-remove-known-project "projectile" "\
Remove PROJECT from the list of known projects.

\(fn &optional PROJECT)" t nil)

(autoload 'projectile-remove-current-project-from-known-projects "projectile" "\
Remove the current project from the list of known projects.

\(fn)" t nil)

(autoload 'projectile-ibuffer "projectile" "\
Open an IBuffer window showing all buffers in the current project.

Let user choose another project when PREFIX is supplied.

\(fn PREFIX)" t nil)

(autoload 'projectile-commander "projectile" "\
Execute a Projectile command with a single letter.
The user is prompted for a single character indicating the action to invoke.
The `?' character describes then
available actions.

See `def-projectile-commander-method' for defining new methods.

\(fn)" t nil)

(autoload 'projectile-edit-dir-locals "projectile" "\
Edit or create a .dir-locals.el file of the project.

\(fn)" t nil)

(defvar projectile-mode nil "\
Non-nil if Projectile mode is enabled.
See the `projectile-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `projectile-mode'.")

(custom-autoload 'projectile-mode "projectile" nil)

(autoload 'projectile-mode "projectile" "\
Minor mode to assist project management and navigation.

When called interactively, toggle `projectile-mode'.  With prefix
ARG, enable `projectile-mode' if ARG is positive, otherwise disable
it.

When called from Lisp, enable `projectile-mode' if ARG is omitted,
nil or positive.  If ARG is `toggle', toggle `projectile-mode'.
Otherwise behave as if called interactively.

\\{projectile-mode-map}

\(fn &optional ARG)" t nil)

(define-obsolete-function-alias 'projectile-global-mode 'projectile-mode "1.0")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "projectile" '("??" "def-projectile-commander-method" "projectile-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/markdown-mode-20180731.1830/markdown-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/markdown-mode-20180731.1830/markdown-mode-autoloads.el") (car load-path))))



(autoload 'markdown-mode "markdown-mode" "\
Major mode for editing Markdown files.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))

(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

(autoload 'gfm-mode "markdown-mode" "\
Major mode for editing GitHub Flavored Markdown files.

\(fn)" t nil)

(autoload 'markdown-view-mode "markdown-mode" "\
Major mode for viewing Markdown content.

\(fn)" t nil)

(autoload 'gfm-view-mode "markdown-mode" "\
Major mode for viewing GitHub Flavored Markdown content.

\(fn)" t nil)

(autoload 'markdown-live-preview-mode "markdown-mode" "\
Toggle native previewing on save for a specific markdown file.

If called interactively, enable Markdown-Live-Preview mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "markdown-mode" '("defun-markdown-" "gfm-" "markdown")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rustic-20180816.1007/rustic-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rustic-20180816.1007/rustic-autoloads.el") (car load-path))))



(add-to-list 'auto-mode-alist '("\\.rs\\'" . rustic-mode))

(autoload 'rustic-mode "rustic" "\
Major mode for Rust code.

\\{rustic-map}

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic" '("rustic")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-babel" '("org-babel-execute:rustic" "rustic-babel-")))



(autoload 'rustic-cargo-clippy "rustic-cargo" "\
Run `cargo clippy'.

\(fn)" t nil)

(autoload 'rustic-cargo-test "rustic-cargo" "\
Run `cargo test'.

\(fn)" t nil)

(autoload 'rustic-cargo-build "rustic-cargo" "\


\(fn)" t nil)

(autoload 'rustic-cargo-run "rustic-cargo" "\


\(fn)" t nil)

(autoload 'rustic-cargo-clean "rustic-cargo" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-cargo" '("rustic-")))



(autoload 'rustic-compile "rustic-compile" "\
Compile rust project.
If called without arguments use `rustic-compile-command'.

Otherwise use provided argument ARG and store it in
`compilation-arguments'.

\(fn &optional ARG)" t nil)

(autoload 'rustic-recompile "rustic-compile" "\
Re-compile the program using `compilation-arguments'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-compile" '("rust")))



(autoload 'rustic-flycheck-setup "rustic-flycheck" "\
Setup Rust in Flycheck.
If the current file is part of a Cargo project, configure
Flycheck according to the Cargo project layout.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-flycheck" '("rustic-flycheck-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-interaction" '("rustic-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-lsp" '("lsp-rust-" "rust")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-racer" '("racer-src-button" "rustic-racer-")))



(autoload 'rustic-format--enable-format-on-save "rustic-util" "\
Enable formatting using rustfmt when saving buffer.

\(fn)" t nil)

(autoload 'rustic-format--disable-format-on-save "rustic-util" "\
Disable formatting using rustfmt when saving buffer.

\(fn)" t nil)

(autoload 'rustic-cargo-fmt "rustic-util" "\
Use rustfmt via cargo.

\(fn)" t nil)

(autoload 'rustic-playpen "rustic-util" "\
Create a shareable URL for the contents of the current region, 
src-block or buffer on the Rust playpen.

\(fn BEGIN END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rustic-util" '("rustic-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rust-playground-20180807.1158/rust-playground-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rust-playground-20180807.1158/rust-playground-autoloads.el") (car load-path))))



(autoload 'rust-playground "rust-playground" "\
Run playground for Rust language in a new buffer.

\(fn)" t nil)

(autoload 'rust-playground-rm "rust-playground" "\
Remove files of the current snippet together with directory of this snippet.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rust-playground" '("in-rust-playground" "rust-playground-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rust-mode-20180626.2212/rust-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rust-mode-20180626.2212/rust-mode-autoloads.el") (car load-path))))



(autoload 'rust-mode "rust-mode" "\
Major mode for Rust code.

\\{rust-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rust-mode" '("cargo-compilation-regexps" "rust")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/rtags-20180814.1713/rtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/rtags-20180814.1713/rtags-autoloads.el") (car load-path))))



(autoload 'rtags-set-periodic-reparse-timeout "rtags" "\
Set `rtags-periodic-reparse-timeout' to TIME.

\(fn TIME)" t nil)

(autoload 'rtags-call-bury-or-delete "rtags" "\
Call `rtags-bury-buffer-function' function.

\(fn)" t nil)

(autoload 'rtags-next-match "rtags" "\


\(fn)" t nil)

(autoload 'rtags-previous-match "rtags" "\


\(fn)" t nil)

(autoload 'rtags-next-diag "rtags" "\


\(fn)" t nil)

(autoload 'rtags-previous-diag "rtags" "\


\(fn)" t nil)

(autoload 'rtags-preprocess-file "rtags" "\
Preprocess selected region or buffer.
If optional BUFFER is given, use BUFFER instead of `current-buffer'.
It uses the stored compile command from the RTags database for preprocessing.

\(fn &optional BUFFER)" t nil)

(autoload 'rtags-set-current-project "rtags" "\
Set active project.
Uses `completing-read' to ask for the project.

\(fn)" t nil)

(autoload 'rtags-print-symbol-info "rtags" "\
Print information about the symbol under cursor.

\(fn &optional VERBOSE)" t nil)

(autoload 'rtags-symbol-type "rtags" "\
Print symbol type under cursor.

\(fn)" t nil)

(autoload 'rtags-print-dependencies "rtags" "\
Print dependency information of the file in buffer.

If optional PREFIX is given, a selection of what type of dependency
information should be shown will be offered. Currently only one can
be chosen.
\"includes\"        - Print includes the file in buffer includes.
\"included-by\"     - Print files which include the file in buffer.
\"depends-on\"      - Print files the file in buffer depends on.
\"depended-on\"     - ...
\"tree-depends-on\" - ...

If optional BUFFER is given print dependencies for file in BUFFER
instead of file from `current-buffer'.

\(fn &optional PREFIX BUFFER)" t nil)

(defvar rtags-dependency-tree-data nil)

(autoload 'rtags-references-tree "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-functions-called-by-this-function "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-all-functions-called-this-function "rtags" "\


\(fn)" nil nil)

(autoload 'rtags-list-results "rtags" "\
Show the RTags results buffer.

\(fn)" t nil)

(autoload 'rtags-print-source-arguments "rtags" "\


\(fn &optional BUFFER)" t nil)

(autoload 'rtags-print-class-hierarchy "rtags" "\


\(fn)" t nil)

(autoload 'rtags-print-enum-value-at-point "rtags" "\


\(fn &optional LOCATION)" t nil)

(autoload 'rtags-goto-offset "rtags" "\


\(fn POS)" t nil)

(autoload 'rtags-location-stack-filter "rtags" "\


\(fn PATH/LAMBDA/RX)" t nil)

(autoload 'rtags-location-stack-jump "rtags" "\


\(fn BY)" t nil)

(autoload 'rtags-location-stack-visualize-update "rtags" "\


\(fn)" nil nil)

(autoload 'rtags-enable-standard-keybindings "rtags" "\
Setup standard keybindings for the RTags commands.

If optional MAP is non-nil, add the keys to MAP instead of `c-mode-base-map'.
If optional PREFIX is non-nil, use PREFIX as prefix key for the commands,
default is \"C-c r \". It doesn't matter whether you add a space at the end
of PREFIX or not, if doesn't contain one, one will be added.

\(fn &optional MAP PREFIX)" t nil)

(autoload 'rtags-print-current-location "rtags" "\


\(fn)" t nil)

(autoload 'rtags-location-stack-forward "rtags" "\


\(fn)" t nil)

(autoload 'rtags-location-stack-back "rtags" "\


\(fn)" t nil)

(autoload 'rtags-location-stack-reset "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-symbol-at-point "rtags" "\
Find the natural target for the symbol under the cursor and moves to that location.
For references this means to jump to the definition/declaration of the referenced symbol (it jumps to the definition if it is indexed).
For definitions it jumps to the declaration (if there is only one) For declarations it jumps to the definition.
If called with prefix, open first match in other window

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-references-at-point "rtags" "\
Find all references to the symbol under the cursor.

If there's exactly one result jump directly to it, and if optional
PREFIX is given jump to it in other window. If there's more show a
buffer with the different alternatives and jump to the first one, if
`rtags-jump-to-first-match' is true. References to references will be
treated as references to the referenced symbol.

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-virtuals-at-point "rtags" "\
List all reimplementations of function under cursor.
This includes both declarations and definitions.

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-all-references-at-point "rtags" "\


\(fn &optional PREFIX)" t nil)

(autoload 'rtags-guess-function-at-point "rtags" "\


\(fn)" t nil)

(autoload 'rtags-rename-symbol "rtags" "\
Rename symbol (identifier) at point.

Normally this function will ask the user (via minibuffer) for the
replacement and then ask for confirmation.  However, when the scope
of the symbol at point is just one file (the file that's being
visited by current buffer), the variable `rtags-use-multiple-cursors'
is non-nil and the `multiple-cursors' package is available, then this
function will create fake cursors at all occurrences of the symbol.

The optional argument NO-CONFIRM means agree to all replacements and
can be specified with a prefix argument.

\(fn &optional NO-CONFIRM)" t nil)

(autoload 'rtags-find-symbol "rtags" "\


\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-references "rtags" "\


\(fn &optional PREFIX)" t nil)

(autoload 'rtags-find-symbol-current-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-references-current-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-symbol-current-dir "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-references-current-dir "rtags" "\


\(fn)" t nil)

(autoload 'rtags-clear-diagnostics-overlays "rtags" "\


\(fn &optional BUF)" t nil)

(autoload 'rtags-is-running "rtags" "\


\(fn)" t nil)

(autoload 'rtags-cycle-through-diagnostics "rtags" "\


\(fn)" t nil)

(autoload 'rtags-fix-fixit-at-point "rtags" "\
Apply compiler fix-it at point.

\(fn)" t nil)

(autoload 'rtags-restart-tracking-timer "rtags" "\


\(fn)" t nil)

(autoload 'rtags-post-command-hook "rtags" "\


\(fn)" t nil)

(autoload 'rtags-toggle-diagnostics-suspended "rtags" "\


\(fn &optional QUIET)" t nil)

(autoload 'rtags-set-diagnostics-suspended "rtags" "\


\(fn &optional QUIET)" t nil)

(autoload 'rtags-stop-diagnostics "rtags" "\


\(fn)" t nil)

(autoload 'rtags-clear-diagnostics "rtags" "\


\(fn)" t nil)

(autoload 'rtags-diagnostics "rtags" "\


\(fn &optional RESTART NODIRTY)" t nil)

(autoload 'rtags-compilation-flags "rtags" "\


\(fn)" t nil)

(autoload 'rtags-close-taglist "rtags" "\


\(fn)" t nil)

(autoload 'rtags-taglist "rtags" "\


\(fn &optional DEST-WINDOW)" t nil)

(autoload 'rtags-select "rtags" "\


\(fn &optional OTHER-WINDOW REMOVE SHOW)" t nil)

(autoload 'rtags-select-other-window "rtags" "\


\(fn &optional NOT-OTHER-WINDOW)" t nil)

(autoload 'rtags-select-caller "rtags" "\


\(fn &optional NOT-OTHER-WINDOW)" t nil)

(autoload 'rtags-select-caller-other-window "rtags" "\


\(fn)" t nil)

(autoload 'rtags-show-in-other-window "rtags" "\


\(fn)" t nil)

(autoload 'rtags-select-and-remove-rtags-buffer "rtags" "\


\(fn)" t nil)

(autoload 'rtags-imenu "rtags" "\


\(fn)" t nil)

(autoload 'rtags-copy-and-print-current-location "rtags" "\


\(fn)" t nil)

(autoload 'rtags-find-file "rtags" "\
Find files matching a file pattern in the RTags database.

With PREFIX and when `rtags-use-filename-completion' is nil,
negate `rtags-find-file-prefer-exact-match' when matching files.

Initial file pattern to match is obtained from `rtags-current-symbol'
which can be overridden by specifying DEFAULT-FILE

\(fn &optional PREFIX DEFAULT-FILE)" t nil)

(autoload 'rtags-show-rtags-buffer "rtags" "\


\(fn)" t nil)

(autoload 'rtags-fixit "rtags" "\


\(fn &optional EDIFF BUFFER)" t nil)

(autoload 'rtags-remove-other-window "rtags" "\


\(fn)" t nil)

(autoload 'rtags-update-current-project "rtags" "\


\(fn)" t nil)

(autoload 'rtags-show-target-in-other-window "rtags" "\
DEST-WINDOW : destination window. Can be nil; in this case the current window is split
according to `rtags-other-window-window-size-percentage'.
CENTER-WINDOW : if true the target window is centered.
TRY-DECLARATION-FIRST : first try to find the declaration of the item, then the
definition.

\(fn &optional DEST-WINDOW CENTER-WINDOW TRY-DECLARATION-FIRST)" t nil)

(autoload 'rtags-suspend-file "rtags" "\


\(fn &optional ARG)" t nil)

(autoload 'rtags-unsuspend-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-toggle-file-suspended "rtags" "\


\(fn)" t nil)

(autoload 'rtags-clear-suspended-files "rtags" "\


\(fn &optional A B)" t nil)

(autoload 'rtags-suspend-all-files "rtags" "\


\(fn &optional A)" t nil)

(autoload 'rtags-list-suspended-files "rtags" "\


\(fn)" t nil)

(autoload 'rtags-compile-file "rtags" "\


\(fn &optional BUFFER)" t nil)

(autoload 'rtags-recompile-file "rtags" "\


\(fn)" t nil)

(autoload 'rtags-quit-rdm "rtags" "\
Quit the RTags process (rdm).

\(fn)" t nil)

(autoload 'rtags-restart-process "rtags" "\
Restart the RTags process (rdm).

\(fn)" t nil)

(autoload 'rtags-start-process-unless-running "rtags" "\
Launch the RTags process (rdm) if it's not already started.

\(fn)" t nil)

(autoload 'rtags-reparse-file "rtags" "\
WAIT-REPARSING : t to wait for reparsing to finish, nil for async (no waiting).

\(fn &optional BUFFER PERIODIC)" t nil)

(autoload 'rtags-maybe-reparse-file "rtags" "\


\(fn &optional BUFFER)" t nil)

(autoload 'rtags-display-summary "rtags" "\
Display a short text describing the item at point.
See `rtags-get-summary-text' for details.
If `rtags-display-summary-as-tooltip' is t, a tooltip is displayed.

\(fn &optional HIDE-EMPTY POS)" t nil)

(autoload 'rtags-display-summary-as-message "rtags" "\
Display a short text in message area describing the item at point.
See `rtags-get-summary-text' for details.

\(fn)" t nil)

(autoload 'rtags-get-include-file-for-symbol "rtags" "\
Insert #include declaration to buffer corresponding to the input symbol.
With optional PREFIX insert include at point.

\(fn &optional PREFIX)" t nil)

(autoload 'rtags-make-member "rtags" "\
Create a stub member functions. Type a declaration and then
`rtags-make-member' can be used to create the stub definition in
the class.

\(fn)" t nil)

(autoload 'rtags-check-includes "rtags" "\


\(fn)" t nil)

(autoload 'rtags-tokens "rtags" "\


\(fn &optional FROM TO CALLBACK)" t nil)

(autoload 'rtags-create-doxygen-comment "rtags" "\
Creates doxygen comment for function at point.

Comment will be inserted before current line. It uses yasnippet to let
the user enter missing field manually.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rtags" '("rtags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/deferred-20170901.1330/deferred-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/deferred-20170901.1330/deferred-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "deferred" '("deferred:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/request-20170201.147/request-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/request-20170201.147/request-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "request" '("request-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/request-deferred-20160419.2305/request-deferred-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/request-deferred-20160419.2305/request-deferred-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "request-deferred" '("request-deferred")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/fullframe-20170816.1003/fullframe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/fullframe-20170816.1003/fullframe-autoloads.el") (car load-path))))



(autoload 'fullframe/current-buffer-window-config "fullframe" "\
Return the window-configuration stored for the current buffer.

\(fn)" nil nil)

(autoload 'fullframe/erase-current-buffer-window-config "fullframe" "\
Forget the window config associated with the current buffer.

\(fn)" nil nil)

(autoload 'fullframe/set-current-buffer-window-config "fullframe" "\
Associate the current buffer with the window-configuration WCONF.

\(fn WCONF)" nil nil)

(autoload 'fullframe/split-screen "fullframe" "\
After COMMAND-ON is executed and only one window present in
  the current frame, split the frame in two windows ('below or
  'right, depending on DIRECTION being `horizontal' or
  `vertical') and switch the new window to the buffer
  SECOND-BUFFER (name or symbol). If SWITCH-TO-SECOND-BUFFER is
  not `nil', the window holding SECOND-BUFFER will be activated.

\(fn COMMAND-ON COMMAND-OFF SECOND-BUFFER &optional DIRECTION SWITCH-TO-SECOND-BUFFER SIZE)" nil t)

(autoload 'fullframe "fullframe" "\
Save window/frame state when executing COMMAND-ON.

Advises COMMAND-ON so that the buffer it displays will appear in
a full-frame window.  The previous window configuration will be
restored when COMMAND-OFF is executed in that buffer.  If
KILL-ON-COFF is non-nil, then the buffer will also be killed
after COMMAND-OFF has completed.

This function uses `defadvice' on versions of emacs < 24.4,
`advice-add' otherwise.

AFTER-COMMAND-ON-FUNC is called after COMMAND-ON was called and
the window it generated is the only one in in the frame.

\(fn COMMAND-ON COMMAND-OFF &optional KILL-ON-COFF AFTER-COMMAND-ON-FUNC)" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fullframe" '("fullframe/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/repl-toggle-20180501.1028/repl-toggle-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/repl-toggle-20180501.1028/repl-toggle-autoloads.el") (car load-path))))



(autoload 'repl-toggle-mode "repl-toggle" "\
A minor mode to allow uniform repl buffer switching.

If called interactively, enable Repl-Mode mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'rtog/switch-to-shell-buffer "repl-toggle" "\
Make sure that `BUFFER-NAME' exists and is displayed.

Executes `SHELL-COMMAND', passing `SHELL-ARGS', if buffer
`BUFFER-NAME' doesn't exist.

\(fn BUFFER-NAME SHELL-COMMAND &optional SHELL-ARGS)" nil t)

(autoload 'rtog/add-repl "repl-toggle" "\
Associate MODE with REPL-CMD at runtime..

If in a buffer with `major-mode' MODE, execute REPL-CMD when
`rtog/toggle-repl' is called.

\(fn MODE REPL-CMD)" t nil)

(autoload 'rtog/toggle-repl "repl-toggle" "\
Switch to the repl asscociated with the current major mode.

If in a repl already switch back to the buffer we
came from.

If you provide PASSALONG? as a universal prefix with
\\[universal-argument], the current line or region is passed to
the repl buffer, using \\[universal-argument]
\\[universal-argument] the current function or definition is
passed, and finaly using
\\[universal-argument]\\[universal-argument]\\[universal-argument]
you can pass the whole current buffer.

Additional paramters passed will be IGNORED.

\(fn &optional PASSALONG\\=\\? &rest IGNORED)" t nil)

(autoload 'rtog/activate "repl-toggle" "\
Activate the repl-toggle minor mode.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "repl-toggle" '("repl-toggle-mode-map" "rtog/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/readline-complete-20150708.1437/readline-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/readline-complete-20150708.1437/readline-complete-autoloads.el") (car load-path))))



(autoload 'ac-rlc-setup-sources "readline-complete" "\
Add me to shell-mode-hook!

\(fn)" nil nil)

(autoload 'ac-rlc-prefix-shell-dispatcher "readline-complete" "\


\(fn)" nil nil)

(eval-after-load 'auto-complete '(eval '(ac-define-source shell '((candidates . rlc-candidates) (prefix . ac-rlc-prefix-shell-dispatcher) (requires . 0)))))

(autoload 'company-readline "readline-complete" "\
`company-mode' back-end using `readline-complete'.

\(fn COMMAND &optional ARG &rest IGNORE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "readline-complete" '("ac-" "rlc-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/faceup-20170925.1946/faceup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/faceup-20170925.1946/faceup-autoloads.el") (car load-path))))



(autoload 'faceup-view-buffer "faceup" "\
Display the faceup representation of the current buffer.

\(fn)" t nil)

(autoload 'faceup-write-file "faceup" "\
Save the faceup representation of the current buffer to the file FILE-NAME.

Unless a name is given, the file will be named xxx.faceup, where
xxx is the file name associated with the buffer.

If optional second arg CONFIRM is non-nil, this function
asks for confirmation before overwriting an existing file.
Interactively, confirmation is required unless you supply a prefix argument.

\(fn &optional FILE-NAME CONFIRM)" t nil)

(autoload 'faceup-render-view-buffer "faceup" "\
Convert BUFFER containing Faceup markup to a new buffer and display it.

\(fn &optional BUFFER)" t nil)

(autoload 'faceup-clean-buffer "faceup" "\
Remove faceup markup from buffer.

\(fn)" t nil)

(autoload 'faceup-defexplainer "faceup" "\
Defines an Ert explainer function for FUNCTION.

FUNCTION must return an explanation when the test fails and
`faceup-test-explain' is set.

\(fn FUNCTION)" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "faceup" '("faceup-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/racket-mode-20180814.221/racket-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/racket-mode-20180814.221/racket-mode-autoloads.el") (car load-path))))



(autoload 'racket-bug-report "racket-bug-report" "\
Fill a buffer with data to make a racket-mode bug report.

\(fn)" t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-collection" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-common" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-complete" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-custom" '("defface-racket" "racket-")))



(add-to-list 'hs-special-modes-alist '(racket-mode "(" ")" ";" nil nil))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-edit" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-font-lock" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-imenu" '("racket--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-indent" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-keywords-and-builtins" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-logger" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-make-doc" '("racket-make-doc/")))



(autoload 'racket-mode "racket-mode" "\
Major mode for editing Racket.
\\{racket-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.rkt[dl]?\\'" . racket-mode))

(modify-coding-system-alist 'file "\\.rkt[dl]?\\'" 'utf-8)

(add-to-list 'interpreter-mode-alist '("racket" . racket-mode))

(autoload 'racket-mode-start-faster "racket-mode" "\
Compile racket-mode's .rkt files for faster startup.

racket-mode is implemented as an Emacs Lisp \"front end\" that
talks to a Racket process \"back end\". Because racket-mode is
delivered as an Emacs package instead of a Racket package,
installing it does _not_ do the `raco setup` that is normally
done for Racket packages.

This command will do a `raco make` of racket-mode's .rkt files,
creating bytecode files in a `compiled/` subdirectory. As a
result, when a `racket-run' or `racket-repl' command must start
the Racket process, it will start faster.

If you run this command, _ever_, you should run it _again_ after:

- Installing an updated version of racket-mode. Otherwise, you
  might lose some of the speed-up.

- Installing a new version of Racket and/or changing the value of
  the variable `racket-program'. Otherwise, you might get an
  error message due to the bytecode being different versions.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-mode" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-ppss" '("racket--ppss-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-profile" '("racket-")))



(autoload 'racket-repl "racket-repl" "\
Run the Racket REPL and display its buffer in some window.

If the Racket process is not already running, it is started.

If NOSELECT is not nil, does not select the REPL
window (preserves the originally selected window).

Commands that don't want the REPL to be displayed can instead use
`racket--repl-ensure-buffer-and-process'.

\(fn &optional NOSELECT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-repl" '("racket-" "with-racket-repl-buffer")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-stepper" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-tests" '("racket-tests/")))



(autoload 'racket-unicode-input-method-enable "racket-unicode-input-method" "\
Set input method to `racket-unicode`.

The `racket-unicode` input method lets you easily type various
Unicode symbols that might be useful when writing Racket
code.

To automatically enable the `racket-unicode` input method in
`racket-mode` buffers use `M-x customize-variable <RET>
racket-mode-hook` or put the following code in your Emacs init
file:

    (add-hook 'racket-mode-hook #'racket-unicode-input-method-enable)

Likewise for `racket-repl-mode` buffers:

    (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

To temporarily enable this input method for a single buffer you
can use `M-x racket-unicode-input-method-enable`.

Use `C-\\` to toggle the input method.

When the `racket-unicode` input method is active, you can for
example type `All` and it is immediately replaced with `∀`. A few
other examples:

    omega     ω
    x_1       x₁
    x^1       x¹
    |A|       𝔸
    test-->>E test-->>∃ (racket/redex)

To see a table of all key sequences use `M-x
describe-input-method <RET> racket-unicode`.

If you don’t like the highlighting of partially matching tokens you
can turn it off by setting `input-method-highlight-flag' to nil via
`M-x customize-variable`.

\(fn)" t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-util" '("racket--")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pos-tip-20150318.1513/pos-tip-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pos-tip-20150318.1513/pos-tip-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pos-tip" '("pos-tip-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/racer-20180709.625/racer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/racer-20180709.625/racer-autoloads.el") (car load-path))))



(autoload 'racer-find-definition "racer" "\
Run the racer find-definition command and process the results.

\(fn)" t nil)

(autoload 'racer-find-definition-other-window "racer" "\
Run the racer find-definition command and process the results.

\(fn)" t nil)

(autoload 'racer-find-definition-other-frame "racer" "\
Run the racer find-definition command and process the results.

\(fn)" t nil)

(autoload 'racer-mode "racer" "\
Minor mode for racer.

If called interactively, enable Racer mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racer" '("racer-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/quick-peek-20180525.1411/quick-peek-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/quick-peek-20180525.1411/quick-peek-autoloads.el") (car load-path))))



(autoload 'quick-peek-overlay-at "quick-peek" "\
Find overlay for line at POS.

\(fn POS)" nil nil)

(autoload 'quick-peek-show "quick-peek" "\
Show STR in an inline window at POS.
MIN-H (default: 4) and MAX-H (default: 16) are bounds on the
height of the window.  Setting MAX-H to `none' allows the inline
window to expand past the bottom of the current Emacs window.

\(fn STR &optional POS MIN-H MAX-H)" nil nil)

(autoload 'quick-peek-hide "quick-peek" "\
Hide inline windows.
With non-nil POS, clear only overlays on line of POS.
Return the number of overlays hidden.

\(fn &optional POS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "quick-peek" '("quick-peek-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/quack-20160410.207/quack-autoloads.el"))
(add-to-list 'load-path (directory-file-name (or (file-name-directory "/home/lk/.emacs.d/elpa/quack-20160410.207/quack-autoloads.el") (car load-path))))



)
(let ((load-file-name "/home/lk/.emacs.d/elpa/preproc-font-lock-20151107.2018/preproc-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/preproc-font-lock-20151107.2018/preproc-font-lock-autoloads.el") (car load-path))))



(defvar preproc-font-lock-modes '(c-mode c++-mode objc-mode) "\
List of major modes where Preproc Font Lock Global mode should be enabled.")

(custom-autoload 'preproc-font-lock-modes "preproc-font-lock" t)

(autoload 'preproc-font-lock-mode "preproc-font-lock" "\
Minor mode that highlights preprocessor directives.

If called interactively, enable Preproc-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar preproc-font-lock-global-mode nil "\
Non-nil if Preproc-Font-Lock-Global mode is enabled.
See the `preproc-font-lock-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `preproc-font-lock-global-mode'.")

(custom-autoload 'preproc-font-lock-global-mode "preproc-font-lock" nil)

(autoload 'preproc-font-lock-global-mode "preproc-font-lock" "\
Toggle Preproc-Font-Lock mode in all buffers.
With prefix ARG, enable Preproc-Font-Lock-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Preproc-Font-Lock mode is enabled in all buffers where
`(lambda nil (when (apply 'derived-mode-p preproc-font-lock-modes) (preproc-font-lock-mode 1)))' would do it.
See `preproc-font-lock-mode' for more information on Preproc-Font-Lock mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "preproc-font-lock" '("preproc-font-lock-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/popwin-20150315.1300/popwin-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/popwin-20150315.1300/popwin-autoloads.el") (car load-path))))



(autoload 'popwin:popup-buffer "popwin" "\
Show BUFFER in a popup window and return the popup window. If
NOSELECT is non-nil, the popup window will not be selected. If
STICK is non-nil, the popup window will be stuck. If TAIL is
non-nil, the popup window will show the last contents. Calling
`popwin:popup-buffer' during `popwin:popup-buffer' is allowed. In
that case, the buffer of the popup window will be replaced with
BUFFER.

\(fn BUFFER &key (width popwin:popup-window-width) (height popwin:popup-window-height) (position popwin:popup-window-position) NOSELECT DEDICATED STICK TAIL)" t nil)

(autoload 'popwin:display-buffer "popwin" "\
Display BUFFER-OR-NAME, if possible, in a popup window, or as
usual. This function can be used as a value of
`display-buffer-function'.

\(fn BUFFER-OR-NAME &optional NOT-THIS-WINDOW)" t nil)

(autoload 'popwin:pop-to-buffer "popwin" "\
Same as `pop-to-buffer' except that this function will use
`popwin:display-buffer-1' instead of `display-buffer'.

\(fn BUFFER &optional OTHER-WINDOW NORECORD)" t nil)

(autoload 'popwin:universal-display "popwin" "\
Call the following command interactively with letting
`popwin:special-display-config' be
`popwin:universal-display-config'. This will be useful when
displaying buffers in popup windows temporarily.

\(fn)" t nil)

(autoload 'popwin:one-window "popwin" "\
Delete other window than the popup window. C-g restores the
original window configuration.

\(fn)" t nil)

(autoload 'popwin:popup-buffer-tail "popwin" "\
Same as `popwin:popup-buffer' except that the buffer will be
`recenter'ed at the bottom.

\(fn &rest SAME-AS-POPWIN:POPUP-BUFFER)" t nil)

(autoload 'popwin:find-file "popwin" "\
Edit file FILENAME with popup window by `popwin:popup-buffer'.

\(fn FILENAME &optional WILDCARDS)" t nil)

(autoload 'popwin:find-file-tail "popwin" "\
Edit file FILENAME with popup window by
`popwin:popup-buffer-tail'.

\(fn FILE &optional WILDCARD)" t nil)

(autoload 'popwin:messages "popwin" "\
Display *Messages* buffer in a popup window.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "popwin" '("popwin")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/popup-20160709.1429/popup-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/popup-20160709.1429/popup-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "popup" '("popup-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/popup-complete-20141109.308/popup-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/popup-complete-20141109.308/popup-complete-autoloads.el") (car load-path))))



(autoload 'popup-complete--in-region "popup-complete" "\


\(fn NEXT-FUNC START END COLLECTION &optional PREDICATE)" nil nil)

(add-hook 'completion-in-region-functions 'popup-complete--in-region)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "popup-complete" '("popup-complete-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/picolisp-mode-20150516.855/picolisp-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/picolisp-mode-20150516.855/picolisp-mode-autoloads.el") (car load-path))))



(autoload 'picolisp-mode "picolisp-mode" "\
Major mode for PicoLisp programming. Derived from lisp-mode.

\\{picolisp-mode-map}

\(fn)" t nil)

(autoload 'picolisp-repl-mode "picolisp-mode" "\
Major mode for `pil' REPL sessions. Derived from comint-mode.

\\{picolisp-repl-mode-map}

\(fn)" t nil)

(autoload 'picolisp-repl "picolisp-mode" "\
Start a `pil' session in a new `picolisp-repl-mode' buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "picolisp-mode" '("picolisp-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pcache-20170105.2214/pcache-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pcache-20170105.2214/pcache-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcache" '("*pcache-repositor" "constructor" "pcache-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/list-utils-20160414.1402/list-utils-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/list-utils-20160414.1402/list-utils-autoloads.el") (car load-path))))



(let ((loads (get 'list-utils 'custom-loads))) (if (member '"list-utils" loads) nil (put 'list-utils 'custom-loads (cons '"list-utils" loads))))

(require 'cl)

(defstruct tconc head tail)

(autoload 'tconc-list "list-utils" "\
Efficiently append LIST to TC.

TC is a data structure created by `make-tconc'.

\(fn TC LIST)" nil nil)

(autoload 'tconc "list-utils" "\
Efficiently append ARGS to TC.

TC is a data structure created by `make-tconc'

Without ARGS, return the list held by TC.

\(fn TC &rest ARGS)" nil nil)

(autoload 'list-utils-cons-cell-p "list-utils" "\
Return non-nil if CELL holds a cons cell rather than a proper list.

A proper list is defined as a series of cons cells in which the
cdr slot of each cons holds a pointer to the next element of the
list, and the cdr slot in the final cons holds nil.

A plain cons cell, for the purpose of this function, is a single
cons in which the cdr holds data rather than a pointer to the
next cons cell, eg

    '(1 . 2)

In addition, a list which is not nil-terminated is not a proper
list and will be recognized by this function as a cons cell.
Such a list is printed using dot notation for the last two
elements, eg

    '(1 2 3 4 . 5)

Such improper lists are produced by `list*'.

\(fn CELL)" nil nil)

(autoload 'list-utils-make-proper-copy "list-utils" "\
Copy a cons cell or improper LIST into a proper list.

If optional TREE is non-nil, traverse LIST, making proper
copies of any improper lists contained within.

Optional RECUR-INTERNAL is for internal use only.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-make-proper-inplace "list-utils" "\
Make a cons cell or improper LIST into a proper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making any
improper lists contained within into proper lists.

Optional RECUR-INTERNAL is for internal use only.

Modifies LIST and returns the modified value.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-make-improper-copy "list-utils" "\
Copy a proper LIST into an improper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making proper
copies of any improper lists contained within.

Optional RECUR-INTERNAL is for internal use only.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-make-improper-inplace "list-utils" "\
Make proper LIST into an improper list.

Improper lists consist of proper lists consed to a final
element, and are produced by `list*'.

If optional TREE is non-nil, traverse LIST, making any
proper lists contained within into improper lists.

Optional RECUR-INTERNAL is for internal use only.

Modifies LIST and returns the modified value.

\(fn LIST &optional TREE RECUR-INTERNAL)" nil nil)

(autoload 'list-utils-linear-subseq "list-utils" "\
Return the linear elements from a partially cyclic LIST.

If there is no cycle in LIST, return LIST.  If all elements of
LIST are included in a cycle, return nil.

As an optimization, CYCLE-LENGTH may be specified if the length
of the cyclic portion is already known.  Otherwise it will be
calculated from LIST.

\(fn LIST &optional CYCLE-LENGTH)" nil nil)

(autoload 'list-utils-cyclic-subseq "list-utils" "\
Return any cyclic elements from LIST as a circular list.

The first element of the cyclic structure is not guaranteed to be
first element of the return value unless FROM-START is non-nil.

To linearize the return value, use `list-utils-make-linear-inplace'.

If there is no cycle in LIST, return nil.

\(fn LIST &optional FROM-START)" nil nil)

(autoload 'list-utils-cyclic-length "list-utils" "\
Return the number of cyclic elements in LIST.

If some portion of LIST is linear, only the cyclic
elements will be counted.

If LIST is completely linear, return 0.

\(fn LIST)" nil nil)

(autoload 'list-utils-cyclic-p "list-utils" "\
Return non-nil if LIST contains any cyclic structures.

If optional PERFECT is set, only return non-nil if LIST is a
perfect non-branching cycle in which the last element points
to the first.

\(fn LIST &optional PERFECT)" nil nil)

(autoload 'list-utils-linear-p "list-utils" "\
Return non-nil if LIST is linear (no cyclic structure).

\(fn LIST)" nil nil)

(defalias 'list-utils-improper-p 'list-utils-cons-cell-p)

(autoload 'list-utils-safe-length "list-utils" "\
Return the number of elements in LIST.

LIST may be linear or cyclic.

If LIST is not really a list, returns 0.

If LIST is an improper list, return the number of proper list
elements, like `safe-length'.

\(fn LIST)" nil nil)

(autoload 'list-utils-flat-length "list-utils" "\
Count simple elements from the beginning of LIST.

Stop counting when a cons is reached.  nil is not a cons,
and is considered to be a \"simple\" element.

If the car of LIST is a cons, return 0.

\(fn LIST)" nil nil)

(autoload 'list-utils-make-linear-copy "list-utils" "\
Return a linearized copy of LIST, which may be cyclic.

If optional TREE is non-nil, traverse LIST, substituting
linearized copies of any cyclic lists contained within.

\(fn LIST &optional TREE)" nil nil)

(autoload 'list-utils-make-linear-inplace "list-utils" "\
Linearize LIST, which may be cyclic.

Modifies LIST and returns the modified value.

If optional TREE is non-nil, traverse LIST, linearizing any
cyclic lists contained within.

\(fn LIST &optional TREE)" nil nil)

(autoload 'list-utils-safe-equal "list-utils" "\
Compare LIST-1 and LIST-2, which may be cyclic lists.

LIST-1 and LIST-2 may also contain cyclic lists, which are
each traversed and compared.  This function will not infloop
when cyclic lists are encountered.

Non-nil is returned only if the leaves of LIST-1 and LIST-2 are
`equal' and the structure is identical.

Optional TEST specifies a test, defaulting to `equal'.

If LIST-1 and LIST-2 are not actually lists, they are still
compared according to TEST.

\(fn LIST-1 LIST-2 &optional TEST)" nil nil)

(autoload 'list-utils-depth "list-utils" "\
Find the depth of LIST, which may contain other lists.

If LIST is not a list or is an empty list, returns a depth
of 0.

If LIST is a cons cell or a list which does not contain other
lists, returns a depth of 1.

\(fn LIST)" nil nil)

(autoload 'list-utils-flatten "list-utils" "\
Return a flattened copy of LIST, which may contain other lists.

This function flattens cons cells as lists, and
flattens circular list structures.

\(fn LIST)" nil nil)

(autoload 'list-utils-insert-before "list-utils" "\
Look in LIST for ELEMENT and insert NEW-ELEMENT before it.

Optional TEST sets the test used for a matching element, and
defaults to `equal'.

LIST is modified and the new value is returned.

\(fn LIST ELEMENT NEW-ELEMENT &optional TEST)" nil nil)

(autoload 'list-utils-insert-after "list-utils" "\
Look in LIST for ELEMENT and insert NEW-ELEMENT after it.

Optional TEST sets the test used for a matching element, and
defaults to `equal'.

LIST is modified and the new value is returned.

\(fn LIST ELEMENT NEW-ELEMENT &optional TEST)" nil nil)

(autoload 'list-utils-insert-before-pos "list-utils" "\
Look in LIST for position POS, and insert NEW-ELEMENT before.

POS is zero-indexed.

LIST is modified and the new value is returned.

\(fn LIST POS NEW-ELEMENT)" nil nil)

(autoload 'list-utils-insert-after-pos "list-utils" "\
Look in LIST for position POS, and insert NEW-ELEMENT after.

LIST is modified and the new value is returned.

\(fn LIST POS NEW-ELEMENT)" nil nil)

(autoload 'list-utils-and "list-utils" "\
Return the elements of LIST1 which are present in LIST2.

This is similar to `cl-intersection' (or `intersection') from
the cl library, except that `list-utils-and' preserves order,
does not uniquify the results, and exhibits more predictable
performance for large lists.

Order will follow LIST1.  Duplicates may be present in the result
as in LIST1.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed.  When FLIP is set, LIST2 will be the guide for the
order of the result, and will determine whether duplicates may
be returned.  Since this function preserves duplicates, setting
FLIP can change the number of elements in the result.

Performance: `list-utils-and' and friends use a general-purpose
hashing approach.  `intersection' and friends use pure iteration.
Iteration can be much faster in a few special cases, especially
when the number of elements is small.  In other scenarios,
iteration can be much slower.  Hashing has no worst-case
performance scenario, although it uses much more memory.  For
heavy-duty list operations, performance may be improved by
`let'ing `gc-cons-threshold' to a high value around sections that
make frequent use of this function.

\(fn LIST1 LIST2 &optional TEST HINT FLIP)" nil nil)

(autoload 'list-utils-not "list-utils" "\
Return the elements of LIST1 which are not present in LIST2.

This is similar to `cl-set-difference' (or `set-difference') from
the cl library, except that `list-utils-not' preserves order and
exhibits more predictable performance for large lists.  Order will
follow LIST1.  Duplicates may be present as in LIST1.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed, returning elements of LIST2 which are not present in
LIST1.  When FLIP is set, LIST2 will be the guide for the order
of the result, and will determine whether duplicates may be
returned.

Performance: see notes under `list-utils-and'.

\(fn LIST1 LIST2 &optional TEST HINT FLIP)" nil nil)

(autoload 'list-utils-xor "list-utils" "\
Return elements which are only present in either LIST1 or LIST2.

This is similar to `cl-set-exclusive-or' (or `set-exclusive-or')
from the cl library, except that `list-utils-xor' preserves order,
and exhibits more predictable performance for large lists.  Order
will follow LIST1, then LIST2.  Duplicates may be present as in
LIST1 or LIST2.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
the list to be hashed (LIST2 unless FLIP is set).

When optional FLIP is set, the sense of the comparison is
reversed, causing order and duplicates to follow LIST2, then
LIST1.

Performance: see notes under `list-utils-and'.

\(fn LIST1 LIST2 &optional TEST HINT FLIP)" nil nil)

(autoload 'list-utils-uniq "list-utils" "\
Return a uniquified copy of LIST, preserving order.

This is similar to `cl-remove-duplicates' (or `remove-duplicates')
from the cl library, except that `list-utils-uniq' preserves order,
and exhibits more predictable performance for large lists.  Order
will follow LIST.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-dupes "list-utils" "\
Return only duplicated elements from LIST, preserving order.

Duplicated elements may still exist in the result: this function
removes singlets.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-singlets "list-utils" "\
Return only singlet elements from LIST, preserving order.

Duplicated elements may not exist in the result.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-partition-dupes "list-utils" "\
Partition LIST into duplicates and singlets, preserving order.

The return value is an alist with two keys: 'dupes and 'singlets.
The two values of the alist are lists which, if combined, comprise
a complete copy of the elements of LIST.

Duplicated elements may still exist in the 'dupes partition.

TEST is an optional comparison function in the form of a
hash-table-test.  The default is `equal'.  Other valid values
include `eq' (built-in), `eql' (built-in), `list-utils-htt-='
\(numeric), `list-utils-htt-case-fold-equal' (case-insensitive).
See `define-hash-table-test' to define your own tests.

HINT is an optional micro-optimization, predicting the size of
LIST.

Performance: see notes under `list-utils-and'.

\(fn LIST &optional TEST HINT)" nil nil)

(autoload 'list-utils-alist-or-flat-length "list-utils" "\
Count simple or cons-cell elements from the beginning of LIST.

Stop counting when a proper list of non-zero length is reached.

If the car of LIST is a list, return 0.

\(fn LIST)" nil nil)

(autoload 'list-utils-alist-flatten "list-utils" "\
Flatten LIST, which may contain other lists.  Do not flatten cons cells.

It is not guaranteed that the result contains *only* cons cells.
The result could contain other data types present in LIST.

This function simply avoids flattening single conses or improper
lists where the last two elements would be expressed as a dotted
pair.

\(fn LIST)" nil nil)

(autoload 'list-utils-plist-reverse "list-utils" "\
Return reversed copy of property-list PLIST, maintaining pair associations.

\(fn PLIST)" nil nil)

(autoload 'list-utils-plist-del "list-utils" "\
Delete from PLIST the property PROP and its associated value.

When PROP is not present in PLIST, there is no effect.

The new plist is returned; use `(setq x (list-utils-plist-del x prop))'
to be sure to use the new value.

This functionality overlaps with the undocumented `cl-do-remf'.

\(fn PLIST PROP)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "list-utils" '("list-utils-htt-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/persistent-soft-20150223.1853/persistent-soft-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/persistent-soft-20150223.1853/persistent-soft-autoloads.el") (car load-path))))



(let ((loads (get 'persistent-soft 'custom-loads))) (if (member '"persistent-soft" loads) nil (put 'persistent-soft 'custom-loads (cons '"persistent-soft" loads))))

(autoload 'persistent-soft-location-readable "persistent-soft" "\
Return non-nil if LOCATION is a readable persistent-soft data store.

\(fn LOCATION)" nil nil)

(autoload 'persistent-soft-location-destroy "persistent-soft" "\
Destroy LOCATION (a persistent-soft data store).

Returns non-nil on confirmed success.

\(fn LOCATION)" nil nil)

(autoload 'persistent-soft-exists-p "persistent-soft" "\
Return t if SYMBOL exists in the LOCATION persistent data store.

This is a noop unless LOCATION is a string and pcache is loaded.

Returns nil on failure, without throwing an error.

\(fn SYMBOL LOCATION)" nil nil)

(autoload 'persistent-soft-fetch "persistent-soft" "\
Return the value for SYMBOL in the LOCATION persistent data store.

This is a noop unless LOCATION is a string and pcache is loaded.

Returns nil on failure, without throwing an error.

\(fn SYMBOL LOCATION)" nil nil)

(autoload 'persistent-soft-flush "persistent-soft" "\
Flush data for the LOCATION data store to disk.

\(fn LOCATION)" nil nil)

(autoload 'persistent-soft-store "persistent-soft" "\
Under SYMBOL, store VALUE in the LOCATION persistent data store.

This is a noop unless LOCATION is a string and pcache is loaded.

Optional EXPIRATION sets an expiry time in seconds.

Returns a true value if storage was successful.  Returns nil
on failure, without throwing an error.

\(fn SYMBOL VALUE LOCATION &optional EXPIRATION)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "persistent-soft" '("persistent-soft-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/peg-20150708.641/peg-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/peg-20150708.641/peg-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "peg" '("peg-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pcmpl-git-20170121.59/pcmpl-git-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pcmpl-git-20170121.59/pcmpl-git-autoloads.el") (car load-path))))



(autoload 'pcomplete/git "pcmpl-git" "\
Completion rules for the `git' command.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcmpl-git" '("pcmpl-git-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcmpl-git-parse" '("git-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/pcmpl-args-20120912.524/pcmpl-args-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/pcmpl-args-20120912.524/pcmpl-args-autoloads.el") (car load-path))))


 (dolist (func '(pcomplete/chgrp pcomplete/chmod pcomplete/chown pcomplete/chroot pcomplete/cp pcomplete/date pcomplete/dd pcomplete/dir pcomplete/echo pcomplete/env pcomplete/false pcomplete/groups pcomplete/id pcomplete/ln pcomplete/ls pcomplete/mv pcomplete/nice pcomplete/nohup pcomplete/printenv pcomplete/printf pcomplete/rm pcomplete/rmdir pcomplete/sort pcomplete/stat pcomplete/test pcomplete/true pcomplete/vdir pcomplete/basename pcomplete/cat pcomplete/cksum pcomplete/comm pcomplete/csplit pcomplete/cut pcomplete/df pcomplete/dircolors pcomplete/dirname pcomplete/du pcomplete/expand pcomplete/expr pcomplete/factor pcomplete/fmt pcomplete/fold pcomplete/head pcomplete/hostid pcomplete/install pcomplete/join pcomplete/link pcomplete/logname pcomplete/md5sum pcomplete/mkdir pcomplete/mkfifo pcomplete/mknod pcomplete/mktemp pcomplete/nl pcomplete/od pcomplete/paste pcomplete/pathchk pcomplete/pinky pcomplete/pr pcomplete/ptx pcomplete/pwd pcomplete/readlink pcomplete/seq pcomplete/sha1sum pcomplete/shred pcomplete/sleep pcomplete/split pcomplete/stty pcomplete/sum pcomplete/sync pcomplete/tac pcomplete/tail pcomplete/tee pcomplete/touch pcomplete/tr pcomplete/tsort pcomplete/tty pcomplete/uname pcomplete/unexpand pcomplete/uniq pcomplete/unlink pcomplete/users pcomplete/wc pcomplete/whoami pcomplete/who pcomplete/yes pcomplete/man pcomplete/info pcomplete/find pcomplete/command pcomplete/time pcomplete/which pcomplete/coproc pcomplete/do pcomplete/elif pcomplete/else pcomplete/exec pcomplete/if pcomplete/then pcomplete/until pcomplete/whatis pcomplete/whence pcomplete/where pcomplete/whereis pcomplete/while pcomplete/gzip pcomplete/bzip2 pcomplete/xz pcomplete/tar pcomplete/perl pcomplete/python pcomplete/bzr pcomplete/hg pcomplete/git pcomplete/etags pcomplete/ctags pcomplete/ctags-exuberant pcomplete/cmp pcomplete/curl pcomplete/dict pcomplete/enscript pcomplete/gcc pcomplete/gdb pcomplete/gprof pcomplete/grep pcomplete/egrep pcomplete/fgrep pcomplete/rgrep pcomplete/make pcomplete/rsync pcomplete/sudo pcomplete/vlc pcomplete/xargs pcomplete/configure pcomplete/nosetests pcomplete/a2ps pcomplete/ack-grep pcomplete/agrep pcomplete/automake pcomplete/awk pcomplete/bash pcomplete/bc pcomplete/bison pcomplete/cal pcomplete/dc pcomplete/diff pcomplete/emacs pcomplete/gawk pcomplete/gperf pcomplete/indent pcomplete/locate pcomplete/ld pcomplete/ldd pcomplete/m4 pcomplete/ncal pcomplete/netstat pcomplete/nm pcomplete/objcopy pcomplete/objdump pcomplete/patch pcomplete/pgrep pcomplete/ps pcomplete/readelf pcomplete/sed pcomplete/shar pcomplete/strip pcomplete/texindex pcomplete/traceroute pcomplete/wget)) (autoload func "pcmpl-args"))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pcmpl-args" '("pcmpl-args-" "pcomplete/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/a-20180806.851/a-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/a-20180806.851/a-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "a" '("a-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/parseclj-20180602.2006/parseclj-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/parseclj-20180602.2006/parseclj-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj" '("parseclj-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj-ast" '("parseclj-ast-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj-lex" '("parseclj-lex-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parseclj-parser" '("parseclj-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/parinfer-20180801.351/parinfer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/parinfer-20180801.351/parinfer-autoloads.el") (car load-path))))



(autoload 'parinfer-mode "parinfer" "\
Parinfer mode.

If called interactively, enable Parinfer mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'parinfer-region-mode "parinfer" "\
Available when region is active.

If called interactively, enable Parinfer-Region mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parinfer" '("parinfer-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parinfer-ext" '("parinfer-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "parinferlib" '("parinferlib-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/paren-face-20180318.2025/paren-face-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/paren-face-20180318.2025/paren-face-autoloads.el") (car load-path))))



(autoload 'paren-face-mode "paren-face" "\
Use a dedicated face just for parentheses.

If called interactively, enable Paren-Face mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-paren-face-mode nil "\
Non-nil if Global Paren-Face mode is enabled.
See the `global-paren-face-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-paren-face-mode'.")

(custom-autoload 'global-paren-face-mode "paren-face" nil)

(autoload 'global-paren-face-mode "paren-face" "\
Toggle Paren-Face mode in all buffers.
With prefix ARG, enable Global Paren-Face mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Paren-Face mode is enabled in all buffers where
`turn-on-paren-face-mode-if-desired' would do it.
See `paren-face-mode' for more information on Paren-Face mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "paren-face" '("paren-face-" "turn-on-paren-face-mode-if-desired")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/paredit-20171127.205/paredit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/paredit-20171127.205/paredit-autoloads.el") (car load-path))))



(autoload 'paredit-mode "paredit" "\
Minor mode for pseudo-structurally editing Lisp code.
With a prefix argument, enable Paredit Mode even if there are
  unbalanced parentheses in the buffer.
Paredit behaves badly if parentheses are unbalanced, so exercise
  caution when forcing Paredit Mode to be enabled, and consider
  fixing unbalanced parentheses instead.
\\<paredit-mode-map>

If called interactively, enable Paredit mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'enable-paredit-mode "paredit" "\
Turn on pseudo-structural editing of Lisp code.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "paredit" '("?\\" "disable-paredit-mode" "paredit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/packed-20180318.1729/packed-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/packed-20180318.1729/packed-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "packed" '("packed-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/package-safe-delete-20150116.1607/package-safe-delete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/package-safe-delete-20150116.1607/package-safe-delete-autoloads.el") (car load-path))))



(autoload 'package-safe-delete-packages "package-safe-delete" "\
Delete PACKAGES.

PACKAGES is a list of package name symbols.
None of the PACKAGES are deleted when there's a package depending on one of
them, or if one of the PACKAGES is not installed.
With FORCE non-nil, the user is not prompted for confirmation before the
packages are deleted.

\(fn PACKAGES &optional FORCE)" nil nil)

(autoload 'package-safe-delete "package-safe-delete" "\
Delete a PACKAGE.

PACKAGE is a package name symbol.
PACKAGE is not deleted when there are other packages requiring it.
Interactively, prompt for its name.

\(fn PACKAGE)" t nil)

(autoload 'package-safe-delete-packages-recursively "package-safe-delete" "\
Delete PACKAGES.
Each of the PACKAGES and all packages required only by the PACKAGES are deleted.

PACKAGES is a list of package name symbols.
None of the PACKAGES are deleted when there's a package depending on one of
them, or if one of the PACKAGES is not installed.
With FORCE non-nil, the user is not prompted for confirmation before the
packages are deleted.

\(fn PACKAGES &optional FORCE)" nil nil)

(autoload 'package-safe-delete-recursively "package-safe-delete" "\
Recursively delete a PACKAGE.
PACKAGE and all packages required only by it are deleted.

PACKAGE is a package name symbol.
PACKAGE is not deleted when there are other packages requiring it.
Interactively, prompt for its name.

\(fn PACKAGE)" t nil)

(autoload 'package-safe-delete-all "package-safe-delete" "\
Delete all packages not explicitly required.

With FORCE non-nil, the user is not prompted for confirmation before the
packages are deleted.

\(fn &optional FORCE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "package-safe-delete" '("package-safe-delete-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/opencl-mode-20170816.1249/opencl-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/opencl-mode-20170816.1249/opencl-mode-autoloads.el") (car load-path))))



(autoload 'opencl-mode "opencl-mode" "\
Major mode for opencl kernel editing

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "opencl-mode" '("opencl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/nrepl-sync-20140807.1554/nrepl-sync-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/nrepl-sync-20140807.1554/nrepl-sync-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-sync" '("nrepl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-20180605.635/highlight-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-20180605.635/highlight-autoloads.el") (car load-path))))



(defvar hlt-auto-face-foreground nil "\
*Foreground color for pseudo faces created from a chosen background.
The value is either a color (name or #RGB hex triplet) or nil.  A nil
value means that highlighting does not change the existing foreground
color.")

(custom-autoload 'hlt-auto-face-foreground "highlight" t)

(defvar hlt-auto-faces-flag nil "\
*Non-nil means highlighting can automatically choose faces.
Highlighting action can use the next background color or face in
`hlt-auto-face-backgrounds'.  When a given item in the list is a color
name, not a face, `hlt-auto-face-foreground' is used as the
corresponding foreground.

This option has no effect on unhighlighting.")

(custom-autoload 'hlt-auto-faces-flag "highlight" t)

(defvar hlt-default-copy/yank-props '(face) "\
*Properties that `hlt-copy-props' and `hlt-yank-props' use by default.
You can use a prefix argument with those commands to override the
default behavior.
Either a list of properties (symbols) or `t', meaning all properties.")

(custom-autoload 'hlt-default-copy/yank-props "highlight" t)

(defvar hlt-face-prop (if (< emacs-major-version 22) 'face 'font-lock-face) "\
*Face property used for highlighting: `face' or `font-lock-face'.
If the value is `font-lock-face' then highlighting by library
`highlight.el' disappears when `font-lock-mode' is turned off.

If the value is `face', and if library`font-lock+.el' has been loaded,
then highlighting persists - it is independent of font-locking.

For Emacs 20 or 21, font-locking does not recognize property
`font-lock-face', so just use `face' (the default value for these
versions), not `font-lock-face' - do not change the value.")

(custom-autoload 'hlt-face-prop "highlight" t)

(defvar hlt-line-dups-ignore-regexp "[ \11]*" "\
Regexp to ignore leading and trailing text for duplicate lines.
Or nil if no such text is to be ignored.
Used by `hlt-highlight-line-dups-region' to determine whether two
lines are duplicates.")

(custom-autoload 'hlt-line-dups-ignore-regexp "highlight" t)

(defvar hlt-max-region-no-warning 100000 "\
*Maximum size (chars) of region to highlight without confirmation.
This is used only for highlighting of a regexp, which can be slow.")

(custom-autoload 'hlt-max-region-no-warning "highlight" t)

(defvar hlt-overlays-priority 0 "\
*Priority of the overlays created by `hlt-*' functions.")

(custom-autoload 'hlt-overlays-priority "highlight" t)

(defvar hlt-use-overlays-flag 'only "\
*Non-nil means use overlays to highlight; nil means use text properties.
This value also affects some actions, such as unhighlighting, for text
that is highlighted.  If the value is `only' (the default value), then
those actions only affect overlay highlighting.  Otherwise, they
affect both kinds of highlighting.")

(custom-autoload 'hlt-use-overlays-flag "highlight" t)

(autoload 'hlt-choose-default-face "highlight" "\
Choose a face for highlighting.
Set `hlt-last-face' to the face, and return it.

You can choose a face name or a color name.  If a color is chosen, it
is used for the face background.  The face foreground is determined by
the value of `hlt-auto-face-foreground'.

\(fn FACE)" t nil)

(autoload 'hlt-next-face "highlight" "\
Choose the next face for highlighting and unhighlighting.
Use `hlt-auto-face-backgrounds' and `hlt-auto-face-foreground'.

A non-negative numeric prefix arg N means use the Nth entry of
`hlt-auto-face-backgrounds'.  Counting is 0-based.

A negative numeric prefix arg N means count from the end, not the
beginning, of `hlt-auto-face-backgrounds': -1 means the last entry, -2
means the next-to-last, etc. (counting from the end is 1-based, not
0-based).

From LISP, if the first argument is `previous' then choose the
previous face, not the next one.

\(fn &optional FACE-NB MSGP)" t nil)

(autoload 'hlt-previous-face "highlight" "\
Like `hlt-next-face', but previous, not next.
Use of a numeric prefix arg is the same as for `hlt-next-face'.

\(fn &optional FACE-NB MSGP)" t nil)

(autoload 'hlt-highlighter "highlight" "\
Highlight the text you drag the mouse over.
The face used is the last face that was used for highlighting.
You can use command `hlt-choose-default-face' to choose the default
face to use.

If `hlt-auto-faces-flag' is non-nil then this command cycles to the
next color/face.  This is the case even if you do not drag the
mouse (empty highlight).  A message tells you what the face is.

A numeric prefix arg N means use the face represented by the Nth entry
of `hlt-auto-face-backgrounds' (uses `hlt-next-face').

\(fn START-EVENT &optional FACE-NB)" t nil)

(autoload 'hlt-eraser "highlight" "\
Erase highlights that you click or drag the mouse over.
If `hlt-use-overlays-flag' is non-nil, then remove overlay
highlighting for the last face that was used for highlighting.  (You
can use command `hlt-choose-default-face' first to choose a different
face.)

If `hlt-use-overlays-flag' is not `only', then remove text-property
highlighting for *ALL* faces (not just highlighting faces).  This
means, in particular, that a value of nil erases both overlays for the
last face and text properties for all faces.

With a numeric prefix arg N, if `hlt-use-overlays-flag' is `only',
erase the face represented by the Nth entry of
`hlt-auto-face-backgrounds' (uses `hlt-next-face').

\(fn START-EVENT &optional FACE-NB)" t nil)

(autoload 'hlt-highlighter-mouse "highlight" "\
Same as `hlt-highlighter', but for binding to a menu item.

\(fn)" t nil)

(autoload 'hlt-eraser-mouse "highlight" "\
Same as `hlt-eraser', but for binding to a menu item.

\(fn)" t nil)

(autoload 'hlt-highlight "highlight" "\
Highlight or unhighlight.
If the region is not active or it is empty, then use the whole buffer.
The face used is the last face that was used for highlighting.
You can use command `hlt-choose-default-face' to choose a different face.

This is several commands rolled into one, depending on the prefix arg:

* No prefix arg: highlight all text in region/buffer
* Plain prefix arg (`C-u') or zero prefix arg (`C-0'): UNhighlight all
* Positive prefix arg (`C-1'): highlight regexp matches
* Negative prefix arg (`C--'): UNhighlight regexp matches

You can also use the individual commands:

* `hlt-highlight-region'          - same as no prefix arg
* `hlt-unhighlight-region'        - same as `C-u' or `C-0'
* `hlt-highlight-regexp-region'   - same as `C-1'
* `hlt-unhighlight-regexp-region' - same as `C--'

\(fn &optional PREFIX)" t nil)

(autoload 'hlt-highlight-region-in-buffers "highlight" "\
Use `hlt-highlight-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means highlight with `mouse-face', not `face'.
A prefix arg <= 0 means highlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to highlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is highlighted.

Non-nil optional arg MSGP means show status messages.

\(fn BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-highlight-region "highlight" "\
Highlight either the region/buffer or new input that you type.
Use the region if active, or the buffer otherwise.

If *ALL* of the following are true then apply the last-used face as a
text property to the next and subsequent characters that you type, and
add that face to a Facemenu menu (`Text Properties' or one of its
submenus):

 * You call this command interactively.
 * You use no prefix arg.
 * Option `hlt-use-overlays-flag' is nil
 * The last property used for highlighting was `face'.

Otherwise, the behavior respects `hlt-use-overlays-flag' and depends
on the optional arguments, as follows:

Optional args START and END are the limits of the area to act on.
  They default to the region limits.  If the region is not active or
  it is empty, then use the whole buffer.  (But see BUFFERS, below.)

Optional 3rd arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different face.)

Optional 4th arg MSGP non-nil means to display a progress message.
  Interactively, MSGP is t.

Optional 5th arg MOUSEP non-nil means use `mouse-face', not `face'.
  Interactively, MOUSEP is provided by the prefix arg.

Optional 6th arg BUFFERS is the list of buffers to highlight.
  If non-nil and this command is called interactively then explicit
  START and END values are ignored, and the actual values are
  determined automatically for each buffer, based on whether the
  region is active there.

\(fn &optional START END FACE MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-unhighlight-region-in-buffers "highlight" "\
Use `hlt-unhighlight-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means unhighlight `mouse-face', not `face'.
A prefix arg <= 0 means unhighlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to unhighlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is unhighlighted.

Non-nil optional arg MSGP means show status messages.

\(fn BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-unhighlight-region "highlight" "\
Remove all highlighting in region or buffer.
Use the region if active, or the buffer otherwise.
The arguments are the same as for `hlt-highlight-region'.

If `hlt-use-overlays-flag' is non-nil, then remove overlay highlighting.
If `hlt-use-overlays-flag' is not `only', then remove text-property
highlighting.  This means, in particular, that a value of nil removes
both overlays and text properties.

\(fn &optional START END FACE MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-highlight-regexp-region-in-buffers "highlight" "\
Use `hlt-highlight-regexp-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means highlight with `mouse-face', not `face'.
A prefix arg <= 0 means highlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to highlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is highlighted.

See `hlt-highlight-regexp-region' for other arguments.

\(fn REGEXP BUFFERS &optional FACE MSGP MOUSEP NTH)" t nil)

(autoload 'hlt-highlight-regexp-region "highlight" "\
Highlight regular expression REGEXP in region/buffer.
Use the region if active, or the buffer otherwise.

Optional args START and END are the limits of the area to act on.
  They default to the region limits.  (But see BUFFERS, below.)
Optional 4th arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different face.)
Optional 5th arg MSGP:
  t means to treat this as an interactive call when deciding to
    display all messages.
  non-nil & non-t means to display only error and warning messages.
Optional 6th arg MOUSEP non-nil means to use `mouse-face' property,
  not `face'.  Interactively, this is provided by the prefix arg.
Optional 7th arg NTH determines which regexp subgroup is highlighted.
  If nil or 0, the entire regexp is highlighted.  Otherwise, the NTH
  regexp subgroup (\"\\\\(...\\\\)\" expression) is highlighted.
  (NTH is not available interactively.)
Optional 6th arg BUFFERS is the list of buffers to highlight.
  If non-nil then explicit START and END values are ignored, and the
  actual values are determined automatically for each buffer, based on
  whether the region is active there.

\(fn &optional START END REGEXP FACE MSGP MOUSEP NTH BUFFERS)" t nil)

(autoload 'hlt-unhighlight-regexp-region-in-buffers "highlight" "\
Use `hlt-unhighlight-regexp-region' in each buffer of list BUFFERS.
A prefix arg >= 0 means unhighlight `mouse-face', not `face'.
A prefix arg <= 0 means unhighlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to unhighlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is unhighlighted.

See `hlt-highlight-regexp-region' for other arguments.

\(fn REGEXP BUFFERS &optional NTH MSGP)" t nil)

(autoload 'hlt-unhighlight-regexp-region "highlight" "\
Unhighlight text matching regular expression REGEXP in region/buffer.
This is like `hlt-highlight-regexp-region' (which see), but opposite.
Where `hlt-highlight-regexp-region' highlights REGEXP matches, this
unhighlights the matches.

\(fn &optional START END REGEXP FACE MSGP MOUSEP NTH BUFFERS)" t nil)

(autoload 'hlt-highlight-regexp-to-end "highlight" "\
Highlight text after cursor that matches REGEXP.
The behavior respects `hlt-use-overlays-flag' and depends on the
optional arguments, as follows:

 Optional 2nd arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different
  face.)

 Optional 3rd arg MSGP non-nil means to display a progress message.
  Interactively, MSGP is t.

 Optional 4th arg MOUSEP non-nil means use property `mouse-face', not
 `face'.  Interactively, MOUSEP is provided by the prefix arg.

 Optional 5th arg NTH determines which regexp subgroup is highlighted.
  If nil or 0, the entire regexp is highlighted.  Otherwise, the NTH
  regexp subgroup (\"\\\\(...\\\\)\" expression) is highlighted.
  (NTH is not available interactively.)

\(fn REGEXP &optional FACE MSGP MOUSEP NTH)" t nil)

(autoload 'hlt-unhighlight-regexp-to-end "highlight" "\
UNhighlight text after cursor that matches REGEXP.
This is like `hlt-highlight-regexp-to-end' (which see), but opposite.
Where `hlt-highlight-regexp-to-end' highlights REGEXP matches, this
unhighlights the matches.

\(fn REGEXP &optional FACE MSGP MOUSEP NTH)" t nil)

(autoload 'hlt-highlight-regexp-groups-region "highlight" "\
Like `hlt-highlight-regexp-region', but highlight regexp groups.
Highlight regular expression REGEXP in region/buffer.
Use the region if active, or the buffer otherwise.

Up to 8 group levels are highlighted, using faces `hlt-regexp-level-1'
through `hlt-regexp-level-8'.  The current default highlighting face
is used to highlight the non-group matches. You can change the default
face using command `hlt-choose-default-face'.

Optional args START and END are the limits of the area to act on.
  They default to the region limits.
Optional 4th arg MSGP:
  t means to treat this as an interactive call when deciding to
    display all messages.
  non-nil & non-t means to display only error and warning messages.
Optional 5th arg MOUSEP non-nil means to use `mouse-face' property,
  not `face'.  Interactively, this is provided by the prefix arg.

\(fn &optional START END REGEXP MSGP MOUSEP)" t nil)

(autoload 'hlt-unhighlight-regexp-groups-region "highlight" "\
Like `hlt-highlight-regexp-groups-region', but opposite.
Where `hlt-highlight-regexp-groups-region' highlights REGEXP matches,
this unhighlights the matches.

\(fn &optional START END REGEXP MSGP MOUSEP)" t nil)

(autoload 'hlt-unhighlight-region-for-face-in-buffers "highlight" "\
Use `hlt-unhighlight-region-for-face' in each buffer of list BUFFERS.
A prefix arg >= 0 means unhighlight `mouse-face', not `face'.
A prefix arg <= 0 means unhighlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to unhighlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is unhighlighted.

See `hlt-unhighlight-region-for-face' for other arguments.

\(fn FACE BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-unhighlight-region-for-face "highlight" "\
Remove any highlighting in the region that uses FACE.
Same as `hlt-unhighlight-region', but removes only highlighting
that uses FACE.  Interactively, you are prompted for the face.

This works only for overlay highlighting, not text-property
highlighting.

Note: When text in the region has been highlighted using more than one
face, unhighlighting for one of those faces can mean that adjacent
highlighting outside the region appears to change.  That outside text
still has the same multiple-overlay face highlighting, but the overlay
stacking order is not the same as it was.

Optional arg FACE is the face to use.
  Interactively, this is the last face that was used for highlighting.
  (You can use command `hlt-choose-default-face' to choose a different face.)
Optional args START and END are the limits of the area to act on.
  They default to the region limits.  (But see BUFFERS, below.)
Optional arg MSGP non-nil means show status messages.
Optional arg MOUSEP non-nil means use `mouse-face' property, not
  `face'.  Interactively, MOUSEP is provided by the prefix arg.
Optional arg BUFFERS is the list of buffers to unhighlight for FACE.
  If non-nil then explicit START and END values are ignored, and the
  actual values are determined automatically for each buffer, based on
  whether the region is active there.

\(fn &optional FACE START END MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-replace-highlight-face-in-buffers "highlight" "\
Use `hlt-replace-highlight-face' in each buffer of list BUFFERS.
A prefix arg >= 0 means highlight with `mouse-face', not `face'.
A prefix arg <= 0 means highlight all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to highlight, one at a
 time.  Use `C-g' to end prompting.
If you specify no BUFFERS then the current buffer is highlighted.

See `hlt-replace-highlight-face' for other arguments.

\(fn OLD-FACE NEW-FACE BUFFERS &optional MSGP)" t nil)

(autoload 'hlt-replace-highlight-face "highlight" "\
Replace OLD-FACE by NEW-FACE in overlay highlighting in the region.
This command applies only to overlay highlighting created by library
`highlight.el'.

Update the last-used highlighting face.

With a prefix argument, replace OLD-FACE as the `mouse-face' property,
 not the `face' property.

Other arguments:
 Optional args START and END are the limits of the area to act on.
  They default to the region limits.  If the region is not active or
  it is empty, then use the whole buffer.
 Optional arg MSGP non-nil means display a progress message.
 Optional arg MOUSEP non-nil means use `mouse-face' property, not
  `face'.  Interactively, MOUSEP is provided by the prefix arg.

\(fn OLD-FACE NEW-FACE &optional START END MSGP MOUSEP BUFFERS)" t nil)

(autoload 'hlt-highlight-symbol "highlight" "\
Highlight occurrences of SYMBOL.
The symbol at point is used by default, or the symbol under the mouse
pointer if the command is invoked using the mouse.

Highlight over the region if active, or the buffer otherwise.
With a prefix arg, use all buffers that are visible or iconified.
\(This first unhighlights occurrences, to prevent stacking up multiple
highlighting on the same occurrences.)

When called from Lisp:
* ALL-BUFFERS-P corresponds to the prefix-argument behavior.
* FACE is the face to use.

\(fn SYMBOL &optional ALL-BUFFERS-P FACE)" t nil)

(autoload 'hlt-unhighlight-symbol "highlight" "\
Unhighlight occurrences of SYMBOL.
The symbol at point is used by default, or the symbol under the mouse
pointer if the command is invoked using the mouse.

Unhighlight over the region if active, or the buffer otherwise.
With a prefix arg, use all buffers that are visible or iconified.

When called from Lisp:
* ALL-BUFFERS-P corresponds to the prefix-argument behavior.
* FACE is the face to unhighlight.

\(fn SYMBOL &optional ALL-BUFFERS-P FACE)" t nil)

(autoload 'hlt-highlight-enclosing-list "highlight" "\
Highlight the ARGth level sexp enclosing point.
ARG is the numeric prefix value.

A negative prefix arg prompts you for the face to use.  This face is
used by default from then on.  You can also choose the default face
using command `hlt-choose-default-face'.  The same face is used as the
default for all `hlt-*' functions.

When used in Lisp code:
 MOUSEP non-nil means use property `mouse-face', not `face'.

\(fn ARG &optional FACE MOUSEP)" t nil)

(autoload 'hlt-highlight-single-quotations "highlight" "\
Highlight single-quoted text in the region.
This means, for example, commands and keys between `'s: `foobar'.
If the region is not active or it is empty, then use the whole buffer.
With a prefix argument, prompt for the highlighting face to use.
Otherwise, use the last face used for highlighting.
 You can also use command `hlt-choose-default-face' to choose a
 different face.

\(fn &optional FACE)" t nil)

(autoload 'hlt-highlight-line-dups-region "highlight" "\
Highlight sets of duplicate lines in the region.
Each set is given a different background, according to user option
`hlt-auto-face-backgrounds'.

Whether leading and trailing whitespace is ignored is controlled by
option `hlt-line-dups-ignore-regexp'.  But a prefix argument reverses
this: if the option value is \"\" then whitespace defined by
\"[ 	]*\" is ignored, and otherwise whitespace is not ignored.

\(fn &optional START END MSGP FLIP)" t nil)

(autoload 'hlt-highlight-lines "highlight" "\
Highlight full lines in region, window-wide.

\(fn START END FACE MSGP)" t nil)

(autoload 'hlt-mouse-face-each-line "highlight" "\
Put `mouse-face' on each line of buffer in region.
If the region is active and not empty, then limit mouse-face
highlighting to the region.  Otherwise, use the whole buffer.
With a prefix argument, prompt for the highlighting face to use.
Otherwise, use the last face used for highlighting.
 You can also use command `hlt-choose-default-face' to choose a
 different face.
Optional args START and END are the limits of the area to act on.
  They default to the region limits.
Optional arg MSGP non-nil means display a progress message.

\(fn &optional START END FACE MSGP)" t nil)

(autoload 'hlt-toggle-use-overlays-flag "highlight" "\
Toggle `hlt-use-overlays-flag'.
If the current value is non-nil, it is set to nil.
If the current value is nil, it is set to the last non-nil value.

\(fn)" t nil)

(defalias 'hlt-paste-props 'hlt-yank-props)

(autoload 'hlt-yank-props "highlight" "\
Yank (paste) copied text properties over the active region.
Interactively, do nothing if there is no nonempty active region.
By default, yank only the copied properties defined by
 `hlt-default-copy/yank-props'.
With a plain or non-negative prefix arg, yank all copied properties.
With a negative prefix arg, you are prompted for the copied properties
 to yank.  To finish entering properties, hit `RET RET' (i.e., twice).

NOTE: If the list of copied text properties is empty, then yanking
      REMOVES ALL PROPERTIES from the text in the region.  This
      provides an easy way to UNpropertize text.

\(fn START END &optional ARG MSGP)" t nil)

(autoload 'hlt-mouse-copy-props "highlight" "\
Same as `hlt-copy-props', but copy at mouse pointer, not at point.

\(fn &optional EVENT ARG MSGP)" t nil)

(autoload 'hlt-copy-props "highlight" "\
Copy text properties at point for use by `hlt-yank-props'.
Properties are copied to `hlt-copied-props'.
By default, copy the properties defined by
 `hlt-default-copy/yank-props'.
With a plain or non-negative prefix arg, copy all properties.
With a negative prefix arg, you are prompted for the properties to
 copy.  To finish entering properties, hit `RET RET' (i.e., twice).

\(fn &optional POSITION ARG MSGP)" t nil)

(autoload 'hlt-highlight-isearch-matches "highlight" "\
Highlight matches of the current Isearch search pattern using FACE.
If the region is active then it limits highlighting.  If inactive then
highlight matches throughout the buffer, or the list of BUFFERS.  If
this is accessed from a `multi-search' command then the BUFFERS are
the buffers being searched.

With no prefix arg:
 * If `hlt-auto-faces-flag' is nil then use the last highlighting face
   used or chosen with command `hlt-choose-default-face'.
 * If non-nil then use the next highlighting face.

With a non-negative prefix arg, prompt for the face to use.
With a non-positive prefix arg, use `mouse-face' instead of `face'.

To use a prefix argument you must set either `isearch-allow-scroll' or
`isearch-allow-prefix' (if available) to non-nil.  Otherwise, a prefix
arg during Isearch exits Isearch.

\(fn &optional FACE MSGP MOUSEP BUFFERS STRING)" t nil)

(autoload 'hlt-unhighlight-isearch-matches "highlight" "\
Unhighlight matches of the current Isearch search pattern.
With no prefix arg, unhighlight all faces.
With a non-negative prefix arg, prompt for the face to unhighlight.
With a non-positive prefix arg, use `mouse-face' instead of `face'.
With any other prefix arg, unhighlight the last highlighting face used
 or chosen with command `hlt-choose-default-face'.
 (`hlt-auto-faces-flag' has no effect.)

To use a prefix argument you must set either `isearch-allow-scroll' or
`isearch-allow-prefix' (if available) to non-nil.  Otherwise, a prefix
arg during Isearch exits Isearch.

Non-interactively, FACE = nil means unhighlight all faces.

\(fn &optional FACE MSGP MOUSEP BUFFERS STRING)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight" '("hlt-" "menu-bar-edit-menu")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/nrepl-eval-sexp-fu-20140311.1041/nrepl-eval-sexp-fu-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/nrepl-eval-sexp-fu-20140311.1041/nrepl-eval-sexp-fu-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nrepl-eval-sexp-fu" '("define-n" "nesf-" "nrepl-eval-sexp-fu-" "turn-on-nrepl-eval-sexp-fu-flash-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/noflet-20141102.1454/noflet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/noflet-20141102.1454/noflet-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "noflet" '("letn" "ntake-all")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/multiple-cursors-20180615.1218/multiple-cursors-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/multiple-cursors-20180615.1218/multiple-cursors-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-cycle-cursors" '("mc/")))



(autoload 'mc/edit-lines "mc-edit-lines" "\
Add one cursor to each line of the active region.
Starts from mark and moves in straight down or up towards the
line point is on.

What is done with lines which are not long enough is governed by
`mc/edit-lines-empty-lines'.  The prefix argument ARG can be used
to override this.  If ARG is a symbol (when called from Lisp),
that symbol is used instead of `mc/edit-lines-empty-lines'.
Otherwise, if ARG negative, short lines will be ignored.  Any
other non-nil value will cause short lines to be padded.

\(fn &optional ARG)" t nil)

(autoload 'mc/edit-ends-of-lines "mc-edit-lines" "\
Add one cursor to the end of each line in the active region.

\(fn)" t nil)

(autoload 'mc/edit-beginnings-of-lines "mc-edit-lines" "\
Add one cursor to the beginning of each line in the active region.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-edit-lines" '("mc/edit-lines-empty-lines")))



(autoload 'mc-hide-unmatched-lines-mode "mc-hide-unmatched-lines-mode" "\
Minor mode when enabled hides all lines where no cursors (and
also hum/lines-to-expand below and above) To make use of this
mode press \"C-'\" while multiple-cursor-mode is active. You can
still edit lines while you are in mc-hide-unmatched-lines
mode. To leave this mode press <return> or \"C-g\"

If called interactively, enable Mc-Hide-Unmatched-Lines mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-hide-unmatched-lines-mode" '("hum/")))



(autoload 'mc/mark-next-like-this "mc-mark-more" "\
Find and mark the next part of the buffer matching the currently active region
If no region is active add a cursor on the next line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-like-this-word "mc-mark-more" "\
Find and mark the next part of the buffer matching the currently active region
If no region is active, mark the word at the point and find the next match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-word-like-this "mc-mark-more" "\
Find and mark the next word of the buffer matching the currently active region
The matching region must be a whole word to be a match
If no region is active, mark the symbol at the point and find the next match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-symbol-like-this "mc-mark-more" "\
Find and mark the next symbol of the buffer matching the currently active region
The matching region must be a whole symbol to be a match
If no region is active, mark the symbol at the point and find the next match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
If no region is active add a cursor on the previous line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-like-this-word "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
If no region is active, mark the word at the point and find the previous match
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark previous.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-word-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
The matching region must be a whole word to be a match
If no region is active add a cursor on the previous line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-symbol-like-this "mc-mark-more" "\
Find and mark the previous part of the buffer matching the currently active region
The matching region must be a whole symbol to be a match
If no region is active add a cursor on the previous line
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mc/mark-next-lines "mc-mark-more" "\


\(fn ARG)" t nil)

(autoload 'mc/mark-previous-lines "mc-mark-more" "\


\(fn ARG)" t nil)

(autoload 'mc/unmark-next-like-this "mc-mark-more" "\
Deselect next part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/unmark-previous-like-this "mc-mark-more" "\
Deselect prev part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/skip-to-next-like-this "mc-mark-more" "\
Skip the current one and select the next part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/skip-to-previous-like-this "mc-mark-more" "\
Skip the current one and select the prev part of the buffer matching the currently active region.

\(fn)" t nil)

(autoload 'mc/mark-all-like-this "mc-mark-more" "\
Find and mark all the parts of the buffer matching the currently active region

\(fn)" t nil)

(autoload 'mc/mark-all-words-like-this "mc-mark-more" "\


\(fn)" t nil)

(autoload 'mc/mark-all-symbols-like-this "mc-mark-more" "\


\(fn)" t nil)

(autoload 'mc/mark-all-in-region "mc-mark-more" "\
Find and mark all the parts in the region matching the given search

\(fn BEG END &optional SEARCH)" t nil)

(autoload 'mc/mark-all-in-region-regexp "mc-mark-more" "\
Find and mark all the parts in the region matching the given regexp.

\(fn BEG END)" t nil)

(autoload 'mc/mark-more-like-this-extended "mc-mark-more" "\
Like mark-more-like-this, but then lets you adjust with arrows key.
The adjustments work like this:

   <up>    Mark previous like this and set direction to 'up
   <down>  Mark next like this and set direction to 'down

If direction is 'up:

   <left>  Skip past the cursor furthest up
   <right> Remove the cursor furthest up

If direction is 'down:

   <left>  Remove the cursor furthest down
   <right> Skip past the cursor furthest down

The bindings for these commands can be changed. See `mc/mark-more-like-this-extended-keymap'.

\(fn)" t nil)

(autoload 'mc/mark-all-like-this-dwim "mc-mark-more" "\
Tries to guess what you want to mark all of.
Can be pressed multiple times to increase selection.

With prefix, it behaves the same as original `mc/mark-all-like-this'

\(fn ARG)" t nil)

(autoload 'mc/mark-all-dwim "mc-mark-more" "\
Tries even harder to guess what you want to mark all of.

If the region is active and spans multiple lines, it will behave
as if `mc/mark-all-in-region'. With the prefix ARG, it will call
`mc/edit-lines' instead.

If the region is inactive or on a single line, it will behave like
`mc/mark-all-like-this-dwim'.

\(fn ARG)" t nil)

(autoload 'mc/mark-all-like-this-in-defun "mc-mark-more" "\
Mark all like this in defun.

\(fn)" t nil)

(autoload 'mc/mark-all-words-like-this-in-defun "mc-mark-more" "\
Mark all words like this in defun.

\(fn)" t nil)

(autoload 'mc/mark-all-symbols-like-this-in-defun "mc-mark-more" "\
Mark all symbols like this in defun.

\(fn)" t nil)

(autoload 'mc/toggle-cursor-on-click "mc-mark-more" "\
Add a cursor where you click, or remove a fake cursor that is
already there.

\(fn EVENT)" t nil)

(defalias 'mc/add-cursor-on-click 'mc/toggle-cursor-on-click)

(autoload 'mc/mark-sgml-tag-pair "mc-mark-more" "\
Mark the tag we're in and its pair for renaming.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-mark-more" '("mc--" "mc/")))



(autoload 'mc/mark-pop "mc-mark-pop" "\
Add a cursor at the current point, pop off mark ring and jump
to the popped mark.

\(fn)" t nil)



(autoload 'mc/insert-numbers "mc-separate-operations" "\
Insert increasing numbers for each cursor, starting at
`mc/insert-numbers-default' or ARG.

\(fn ARG)" t nil)

(autoload 'mc/insert-letters "mc-separate-operations" "\
Insert increasing letters for each cursor, starting at 0 or ARG.
     Where letter[0]=a letter[2]=c letter[26]=aa

\(fn ARG)" t nil)

(autoload 'mc/reverse-regions "mc-separate-operations" "\


\(fn)" t nil)

(autoload 'mc/sort-regions "mc-separate-operations" "\


\(fn)" t nil)

(autoload 'mc/vertical-align "mc-separate-operations" "\
Aligns all cursors vertically with a given CHARACTER to the one with the
highest colum number (the rightest).
Might not behave as intended if more than one cursors are on the same line.

\(fn CHARACTER)" t nil)

(autoload 'mc/vertical-align-with-space "mc-separate-operations" "\
Aligns all cursors with whitespace like `mc/vertical-align' does

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-separate-operations" '("mc--" "mc/insert-numbers-default")))



(autoload 'multiple-cursors-mode "multiple-cursors-core" "\
Mode while multiple cursors are active.

If called interactively, enable Multiple-Cursors mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "multiple-cursors-core" '("activate-cursor-for-undo" "deactivate-cursor-after-undo" "multiple-cursors-mode" "unsupported-cmd")))



(autoload 'set-rectangular-region-anchor "rectangular-region-mode" "\
Anchors the rectangular region at point.

Think of this one as `set-mark' except you're marking a rectangular region. It is
an exceedingly quick way of adding multiple cursors to multiple lines.

\(fn)" t nil)

(autoload 'rectangular-region-mode "rectangular-region-mode" "\
A mode for creating a rectangular region to edit

If called interactively, enable Rectangular-Region mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rectangular-region-mode" '("rectangular-region-mode" "rrm/")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/monroe-20180703.1746/monroe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/monroe-20180703.1746/monroe-autoloads.el") (car load-path))))



(autoload 'monroe-interaction-mode "monroe" "\
Minor mode for Monroe interaction from a Clojure buffer.

If called interactively, enable Monroe-Interaction mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

The following keys are available in `monroe-interaction-mode`:

  \\{monroe-interaction-mode}

\(fn &optional ARG)" t nil)

(autoload 'monroe "monroe" "\
Load monroe by setting up appropriate mode, asking user for
connection endpoint.

\(fn HOST-AND-PORT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "monroe" '("clojure-enable-monroe" "monroe-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/modern-cpp-font-lock-20180110.2031/modern-cpp-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/modern-cpp-font-lock-20180110.2031/modern-cpp-font-lock-autoloads.el") (car load-path))))



(autoload 'modern-c++-font-lock-mode "modern-cpp-font-lock" "\
Provides font-locking as a Minor Mode for Modern C++

If called interactively, enable Modern-C++-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar modern-c++-font-lock-global-mode nil "\
Non-nil if Modern-C++-Font-Lock-Global mode is enabled.
See the `modern-c++-font-lock-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `modern-c++-font-lock-global-mode'.")

(custom-autoload 'modern-c++-font-lock-global-mode "modern-cpp-font-lock" nil)

(autoload 'modern-c++-font-lock-global-mode "modern-cpp-font-lock" "\
Toggle Modern-C++-Font-Lock mode in all buffers.
With prefix ARG, enable Modern-C++-Font-Lock-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Modern-C++-Font-Lock mode is enabled in all buffers where
`(lambda nil (when (apply 'derived-mode-p '(c++-mode)) (modern-c++-font-lock-mode 1)))' would do it.
See `modern-c++-font-lock-mode' for more information on Modern-C++-Font-Lock mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "modern-cpp-font-lock" '("modern-c++-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mmt-20180101.619/mmt-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mmt-20180101.619/mmt-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mmt" '("mmt-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/minimal-session-saver-20140508.2041/minimal-session-saver-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/minimal-session-saver-20140508.2041/minimal-session-saver-autoloads.el") (car load-path))))



(autoload 'minimal-session-saver-customize-set-hooks "minimal-session-saver" "\
Set function which adds or removes hooks.

SYMBOL and VALUE are passed to `custom-set-default'.

\(fn SYMBOL VALUE)" nil nil)

(let ((loads (get 'minimal-session-saver 'custom-loads))) (if (member '"minimal-session-saver" loads) nil (put 'minimal-session-saver 'custom-loads (cons '"minimal-session-saver" loads))))

(defvar minimal-session-saver-store-on-exit nil "\
Automatically store the session data every time you quit Emacs.

This value may also be a string representing a separate data file
to be used for store-on-exit session data.")

(custom-autoload 'minimal-session-saver-store-on-exit "minimal-session-saver" nil)

(defvar minimal-session-saver-install-short-aliases nil "\
Install short aliases such as `mss-load' for `minimal-session-saver-load'.")

(custom-autoload 'minimal-session-saver-install-short-aliases "minimal-session-saver" t)

(autoload 'minimal-session-saver-install-aliases "minimal-session-saver" "\
Install aliases outside the \"minimal-session-saver-\" namespace.

With optional negative ARG, uninstall aliases.

The following aliases will be installed

   mss-store                for   minimal-session-saver-store
   mss-load                 for   minimal-session-saver-load
   mss-store-frame          for   minimal-session-saver-store-frame
   mss-load-frame           for   minimal-session-saver-load-frame
   mss-add-buffer           for   minimal-session-saver-add-buffer
   mss-remove-buffer        for   minimal-session-saver-remove-buffer
   mss-mark-stored-buffers  for   minimal-session-saver-mark-stored-buffers

\(fn &optional ARG)" nil nil)

(when minimal-session-saver-install-short-aliases (minimal-session-saver-install-aliases))

(autoload 'minimal-session-saver-store "minimal-session-saver" "\
Save the list of currently visited files to PATH.

Optional FILE-LIST overrides the list of currently visited
files.

With universal prefix argument, enter PATH interactively.

\(fn &optional PATH FILE-LIST)" t nil)

(autoload 'minimal-session-saver-store-frame "minimal-session-saver" "\
Save currently visited files associated with the current frame to PATH.

Requires frame-bufs.el.

When PATH is not supplied, prompts to enter value interactively.

\(fn &optional PATH)" t nil)

(autoload 'minimal-session-saver-load "minimal-session-saver" "\
Load the saved set of visited files from PATH.

With universal prefix argument, enter PATH interactively.

\(fn &optional PATH)" t nil)

(autoload 'minimal-session-saver-load-frame "minimal-session-saver" "\
Load the saved set of visited files from PATH into a new frame.

Requires frame-bufs.el.

When PATH is not supplied, prompts to enter value interactively.

\(fn &optional PATH)" t nil)

(autoload 'minimal-session-saver-add-buffer "minimal-session-saver" "\
Add the current buffer to the saved set of visited files in PATH.

With universal prefix argument, enter PATH interactively.

BUFFER is optional, and defaults to the currently visited buffer.
When BUFFER is not visiting a file, there is no effect.

\(fn &optional PATH BUFFER)" t nil)

(autoload 'minimal-session-saver-remove-buffer "minimal-session-saver" "\
Remove the current buffer from the saved set of visited files in PATH.

With universal prefix argument, enter PATH interactively.

BUFFER is optional, and defaults to the currently visited buffer.
When the BUFFER is not visiting a file, or is visiting a file
which was not in the list, there is no effect.

\(fn &optional PATH BUFFER)" t nil)

(autoload 'minimal-session-saver-mark-stored-buffers "minimal-session-saver" "\
Mark buff-menu entries matching the saved set of visited files in PATH.

With universal prefix argument, enter PATH interactively.

Optional CHAR defaults to `buff-menu-marker-char' or ?> if that
variable is not defined.

Optional COL is a 0-indexed position in the line at which to draw
the requested marker character.  Default is 0.

This command can only be called from within a `buff-menu' buffer.

\(fn &optional PATH CHAR COL)" t nil)

(autoload 'minimal-session-saver-kill-emacs-hook "minimal-session-saver" "\
Optionally save session data at shutdown time.

This function has not effect unless the variable
`minimal-session-saver-store-on-exit' is non-nil.

\(fn)" nil nil)

(when minimal-session-saver-store-on-exit (add-hook 'kill-emacs-hook 'minimal-session-saver-kill-emacs-hook))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "minimal-session-saver" '("minimal-session-saver-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mic-paren-20170731.1907/mic-paren-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mic-paren-20170731.1907/mic-paren-autoloads.el") (car load-path))))



(autoload 'paren-activate "mic-paren" "\
Activate mic-paren parenthesis highlighting.
Note: This also deactivates the paren.el
and stig-paren.el packages if they are active!

The following options are available via the customize-feature:
  `paren-priority'
  `paren-overlay-priority'
  `paren-sexp-mode'
  `paren-highlight-at-point'
  `paren-highlight-offscreen'
  `paren-display-message'
  `paren-message-linefeed-display'
  `paren-message-no-match'
  `paren-message-show-linenumber'
  `paren-message-truncate-lines'
  `paren-ding-unmatched'
  `paren-delay'
  `paren-dont-touch-blink'
  `paren-match-face'
  `paren-mismatch-face'
  `paren-no-match-face'
  `paren-bind-modified-sexp-functions'

The following options are settable via toggling functions (look at the
documentation of these options for the names of these functions):
  `paren-match-quoted-paren'
  `paren-match-paired-delimiter'
  `paren-open-paren-context-backward'

\(fn)" t nil)

(autoload 'paren-deactivate "mic-paren" "\
Deactivate mic-paren parenthesis highlighting.

\(fn)" t nil)

(autoload 'paren-toggle-matching-paired-delimiter "mic-paren" "\
Toggle matching paired delimiter.
Force on with positive ARG.  Use this in mode hooks to activate or
deactivate paired delimiter matching.  If optional second argument
NO-MESSAGE is non-nil then don't display a message about the
current activation state of the paired-delimiter-matching feature.

\(fn ARG &optional NO-MESSAGE)" t nil)

(autoload 'paren-toggle-matching-quoted-paren "mic-paren" "\
Toggle matching quoted parens.
Force on with positive ARG.  Use this in mode hooks to activate or
deactivate quoted paren matching.  If optional second argument
NO-MESSAGE is non-nil then don't display a message about the
current activation state of the quoted-paren-matching feature.

\(fn ARG &optional NO-MESSAGE)" t nil)

(autoload 'paren-toggle-open-paren-context "mic-paren" "\
Toggle whether or not to determine context of the matching open-paren.
Force backward context with positive ARG.  Use this in mode-hooks.
See `paren-open-paren-context-backward'.

\(fn ARG)" t nil)

(autoload 'paren-forward-sexp "mic-paren" "\
Act like `forward-sexp' but also handle quoted parens.
See `paren-match-quoted-paren'.

\(fn &optional ARG)" t nil)

(autoload 'paren-backward-sexp "mic-paren" "\
Act like `backward-sexp' but also match quoted parens.
See `paren-match-quoted-paren'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mic-paren" '("mic-paren-" "paren-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mc-extras-20180520.439/mc-extras-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mc-extras-20180520.439/mc-extras-autoloads.el") (car load-path))))



(autoload 'mc/cua-rectangle-to-multiple-cursors "mc-cua" "\
Turn CUA rectangle mode into multiple-cursors mode, keeping insert positions and selections.

\(fn)" t nil)

(autoload 'mc/cua-rectangle-setup "mc-cua" "\
Enable interaction between multiple cursors and CUA rectangle copy & paste.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-cua" '("mc/cua-saved-kill-ring")))



(autoload 'mc/freeze-fake-cursors "mc-freeze" "\
Freeze fake cursors for later reactivation.

With ARG or when there is no fake cursor, create a fake cursor at
point before freezing fake cursors.

\(fn &optional ARG)" t nil)

(autoload 'mc/unfreeze-fake-cursors "mc-freeze" "\
Unfreeze frozen fake cursors.

\(fn)" t nil)

(autoload 'mc/freeze-fake-cursors-dwim "mc-freeze" "\
Freeze or unfreeze fake cursors depending on the current state.

With ARG, always create a fake cursor at point then freeze fake
cursors.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-freeze" '("mc-freeze--")))



(autoload 'mc/mark-next-sexps "mc-mark-extras" "\
Mark next ARG sexps.

\(fn ARG)" t nil)

(autoload 'mc/mark-previous-sexps "mc-mark-extras" "\
Mark previous ARG sexps.

\(fn ARG)" t nil)

(autoload 'mc/mark-all-below "mc-mark-extras" "\
Mark lines below until the cursor hits a line shorter than the current column position.

\(fn)" t nil)

(autoload 'mc/mark-all-above "mc-mark-extras" "\
Mark lines above until the cursor hits a line shorter than the current column position.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mc-mark-extras" '("mc/mark-sexps")))



(autoload 'mc/move-to-column "mc-move" "\
Move every cursor to column COLUMN.
If COLUMN is omitted, move every fake cursor to the same column as the real cursor.

\(fn COLUMN)" t nil)

(autoload 'mc/compare-chars "mc-move" "\
Compare the character at point with that at each fake cursor, and move forward as far as they all match.
With an optional argument, move backwards by calling `mc/compare-chars-backward'.
This command pushes the mark before moving cursors.

\(fn &optional ARG)" t nil)

(autoload 'mc/compare-chars-forward "mc-move" "\
Compare the character at point with that at each fake cursor, and move forward as far as they all match.
This command pushes the mark before moving cursors.

\(fn)" t nil)

(autoload 'mc/compare-chars-backward "mc-move" "\
Backwards version of `mc/compare-chars-forward'.

\(fn)" t nil)



(autoload 'mc/rect-rectangle-to-multiple-cursors "mc-rect" "\
Turn rectangle-mark-mode into multiple-cursors mode, keeping selections.

\(fn START END)" t nil)



(autoload 'mc/remove-current-cursor "mc-remove" "\
Remove the current cursor by replacing the next fake cursor with the real cursor.

\(fn)" t nil)

(autoload 'mc/remove-duplicated-cursors "mc-remove" "\
Remove duplicated fake cursors, including ones that overlap the real cursor.

\(fn)" t nil)

(autoload 'mc/remove-cursors-at-eol "mc-remove" "\
Remove cursors at EOL, either fake or real.

\(fn)" t nil)

(autoload 'mc/remove-cursors-on-blank-lines "mc-remove" "\
Remove cursors on blank lines, either fake or real.

\(fn)" t nil)




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/maxframe-20170120.1705/maxframe-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/maxframe-20170120.1705/maxframe-autoloads.el") (car load-path))))



(autoload 'w32-maximize-frame "maxframe" "\
Maximize the current frame (windows only)

\(fn)" t nil)

(autoload 'w32-restore-frame "maxframe" "\
Restore a minimized/maximized frame (windows only)

\(fn)" t nil)

(autoload 'x-maximize-frame "maxframe" "\
Maximize the current frame (x or mac only)

\(fn &optional THE-FRAME)" t nil)

(autoload 'x-restore-frame "maxframe" "\
Restore the current frame (x or mac only)

\(fn &optional THE-FRAME)" t nil)

(autoload 'maximize-frame "maxframe" "\
Maximizes the frame to fit the display if under a windowing
system.

\(fn &optional THE-FRAME)" t nil)

(autoload 'restore-frame "maxframe" "\
Restores a maximized frame.  See `maximize-frame'.

\(fn &optional THE-FRAME)" t nil)

(defalias 'mf 'maximize-frame)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "maxframe" '("mf-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/matlab-mode-20180125.1810/matlab-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/matlab-mode-20180125.1810/matlab-mode-autoloads.el") (car load-path))))



(autoload 'matlab-cedet-setup "cedet-matlab" "\
Update various paths to get SRecode to identify our macros.

\(fn)" t nil)



(autoload 'company-matlab-shell "company-matlab-shell" "\
A `company-mode' completion backend for `matlab-shell'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-matlab-shell" '("company-matlab-shell-")))



(autoload 'enable-visual-studio-bookmarks "linemark" "\
Bind the viss bookmark functions to F2 related keys.
\\<global-map>
\\[viss-bookmark-toggle]     - To=ggle a bookmark on this line.
\\[viss-bookmark-next-buffer]   - Move to the next bookmark.
\\[viss-bookmark-prev-buffer]   - Move to the previous bookmark.
\\[viss-bookmark-clear-all-buffer] - Clear all bookmarks.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "linemark" '("linemark-" "viss-bookmark-")))



(add-to-list 'auto-mode-alist '("\\.m$" . matlab-mode))

(autoload 'matlab-mode "matlab" "\
MATLAB(R) mode is a major mode for editing MATLAB dot-m files.
\\<matlab-mode-map>
Convenient editing commands are:
 \\[matlab-comment-region]   - Comment/Uncomment out a region of code.
 \\[matlab-fill-comment-line] - Fill the current comment line.
 \\[matlab-fill-region] - Fill code and comments in region.
 \\[matlab-fill-paragraph]     - Refill the current command or comment.
 \\[matlab-complete-symbol]   - Symbol completion of matlab symbolsbased on the local syntax.
 \\[matlab-indent-sexp] - Indent syntactic block of code.

Convenient navigation commands are:
 \\[matlab-beginning-of-command]   - Move to the beginning of a command.
 \\[matlab-end-of-command]   - Move to the end of a command.
 \\[matlab-beginning-of-defun] - Move to the beginning of a function.
 \\[matlab-end-of-defun] - Move do the end of a function.
 \\[matlab-forward-sexp] - Move forward over a syntactic block of code.
 \\[matlab-backward-sexp] - Move backwards over a syntactic block of code.

Convenient template insertion commands:
 \\[tempo-template-matlab-function] - Insert a function definition.
 \\[tempo-template-matlab-if] - Insert an IF END block.
 \\[tempo-template-matlab-for] - Insert a FOR END block.
 \\[tempo-template-matlab-switch] - Insert a SWITCH END statement.
 \\[matlab-insert-next-case] - Insert the next CASE condition in a SWITCH.
 \\[matlab-insert-end-block] - Insert a matched END statement.  With optional ARG, reindent.
 \\[matlab-stringify-region] - Convert plain text in region to a string with correctly quoted chars.

Variables:
  `matlab-indent-level'		Level to indent blocks.
  `matlab-cont-level'		Level to indent continuation lines.
  `matlab-cont-requires-ellipsis' Does your MATLAB support implied elipsis.
  `matlab-case-level'		Level to unindent case statements.
  `matlab-indent-past-arg1-functions'
                                Regexp of functions to indent past the first
                                  argument on continuation lines.
  `matlab-maximum-indents'      List of maximum indents during lineups.
  `matlab-comment-column'       Goal column for on-line comments.
  `fill-column'			Column used in auto-fill.
  `matlab-indent-function-body' If non-nil, indents body of MATLAB functions.
  `matlab-functions-have-end'	If non-nil, MATLAB functions terminate with end.
  `matlab-return-function'	Customize RET handling with this function.
  `matlab-auto-fill'            Non-nil, do auto-fill at startup.
  `matlab-fill-code'            Non-nil, auto-fill code.
  `matlab-fill-strings'         Non-nil, auto-fill strings.
  `matlab-verify-on-save-flag'  Non-nil, enable code checks on save.
  `matlab-highlight-block-match-flag'
                                Enable matching block begin/end keywords.
  `matlab-vers-on-startup'	If t, show version on start-up.
  `matlab-handle-simulink'      If t, enable simulink keyword highlighting.

All Key Bindings:
\\{matlab-mode-map}

\(fn)" t nil)

(autoload 'matlab-shell "matlab" "\
Create a buffer with MATLAB running as a subprocess.

MATLAB shell cannot work on the MS Windows platform because MATLAB is not
a console application.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "matlab" '("gud-matlab-" "matlab-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "matlab-publish" '("matlab-")))



(autoload 'mlint-minor-mode "mlint" "\
Toggle mlint minor mode, a mode for showing mlint errors.
With prefix ARG, turn mlint minor mode on iff ARG is positive.
\\{mlint-minor-mode-map\\}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mlint" '("initialize-instance" "linemark-" "mlint-")))



(autoload 'semantic-default-matlab-setup "semantic-matlab" "\
Set up a buffer for parsing of MATLAB files.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "semantic-matlab" '("matlab-mode" "semantic-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "semanticdb-matlab" '("matlab-mode" "semantic")))



(autoload 'srecode-semantic-handle-:matlab "srecode-matlab" "\
Add macros into the dictionary DICT based on the current MATLAB buffer.
Adds the following:
FILE_SYMBOL - The file name as a symbol.
FILE_DOC_SYMBOL - The file name as a symbol for doc strings.
PACKAGE - The package this file is in, or empty if none.
FILE_CLASS - Show section if filename should be a class.
FILE_FUNCTION - Show setion if filename is a function.

On class prediction - when filling in an empty file, if the filename and directory it is in
match, for example @foo/foo.m then foo should be a classdef.

\(fn DICT)" nil nil)



(autoload 'tlc-mode "tlc" "\
Major mode for editing Tlc files, or files found in tlc directories.

\(fn)" t nil)
(add-to-list 'auto-mode-alist '("\\.tlc$" . tlc-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tlc" '("tlc-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-core-20180712.837/helm-core-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-core-20180712.837/helm-core-autoloads.el") (car load-path))))



(autoload 'helm-define-multi-key "helm" "\
In KEYMAP, define key sequence KEY for function list FUNCTIONS.
Each function runs sequentially for each KEY press.
If DELAY is specified, switch back to initial function of FUNCTIONS list
after DELAY seconds.
The functions in FUNCTIONS list take no args.
e.g
    (defun foo ()
      (interactive)
      (message \"Run foo\"))
    (defun bar ()
      (interactive)
      (message \"Run bar\"))
    (defun baz ()
      (interactive)
      (message \"Run baz\"))

\(helm-define-multi-key global-map (kbd \"<f5> q\") '(foo bar baz) 2)

Each time \"<f5> q\" is pressed, the next function is executed. Waiting
more than 2 seconds between key presses switches back to executing the first
function on the next hit.

\(fn KEYMAP KEY FUNCTIONS &optional DELAY)" nil nil)

(autoload 'helm-multi-key-defun "helm" "\
Define NAME as a multi-key command running FUNS.
After DELAY seconds, the FUNS list is reinitialized.
See `helm-define-multi-key'.

\(fn NAME DOCSTRING FUNS &optional DELAY)" nil t)

(function-put 'helm-multi-key-defun 'lisp-indent-function '2)

(autoload 'helm-define-key-with-subkeys "helm" "\
Defines in MAP a KEY and SUBKEY to COMMAND.

This allows typing KEY to call COMMAND the first time and
type only SUBKEY on subsequent calls.

Arg MAP is the keymap to use, SUBKEY is the initial short key-binding to
call COMMAND.

Arg OTHER-SUBKEYS is an alist specifying other short key-bindings
to use once started e.g:

    (helm-define-key-with-subkeys global-map
       (kbd \"C-x v n\") ?n 'git-gutter:next-hunk '((?p . git-gutter:previous-hunk)))


In this example, `C-x v n' will run `git-gutter:next-hunk'
subsequent \"n\"'s run this command again
and subsequent \"p\"'s run `git-gutter:previous-hunk'.

If specified PROMPT can be displayed in minibuffer to
describe SUBKEY and OTHER-SUBKEYS.
Arg EXIT-FN specifies a function to run on exit.

For any other keys pressed, run their assigned command as defined
in MAP and then exit the loop running EXIT-FN, if specified.

NOTE: SUBKEY and OTHER-SUBKEYS bindings support only char syntax and
vectors, so don't use strings to define them.

\(fn MAP KEY SUBKEY COMMAND &optional OTHER-SUBKEYS PROMPT EXIT-FN)" nil nil)

(function-put 'helm-define-key-with-subkeys 'lisp-indent-function '1)

(autoload 'helm-debug-open-last-log "helm" "\
Open helm log file or buffer of last helm session.

\(fn)" t nil)

(autoload 'helm "helm" "\
Main function to execute helm sources.

PLIST is a list like

\(:key1 val1 :key2 val2 ...)

 or

\(&optional sources input prompt resume preselect
            buffer keymap default history allow-nest).

** Keywords

Keywords supported:

- :sources
- :input
- :prompt
- :resume
- :preselect
- :buffer
- :keymap
- :default
- :history
- :allow-nest

Extra LOCAL-VARS keywords are supported, see the \"** Other
keywords\" section below.

Basic keywords are the following:

*** :sources

One of the following:

- List of sources
- Symbol whose value is a list of sources
- Alist representing a Helm source.
  - In this case the source has no name and is referenced in
    `helm-sources' as a whole alist.

*** :input

Initial input of minibuffer (temporary value of `helm-pattern')

*** :prompt

Minibuffer prompt. Default value is `helm--prompt'.

*** :resume

If t, allow resumption of the previous session of this Helm
command, skipping initialization.

If 'noresume, this instance of `helm' cannot be resumed.

*** :preselect

Initially selected candidate (string or regexp).

*** :buffer

Buffer name for this Helm session. `helm-buffer' will take this value.

*** :keymap

\[Obsolete]

Keymap used at the start of this Helm session.

It is overridden by keymaps specified in sources, and is kept
only for backward compatibility.

Keymaps should be specified in sources using the :keymap slot
instead. See `helm-source'.

This keymap is not restored by `helm-resume'.

*** :default

Default value inserted into the minibuffer with
\\<minibuffer-local-map>\\[next-history-element].

It can be a string or a list of strings, in this case
\\<minibuffer-local-map>\\[next-history-element] cycles through
the list items, starting with the first.

If nil, `thing-at-point' is used.

If `helm--maybe-use-default-as-input' is non-`nil', display is
updated using this value, unless :input is specified, in which
case that value is used instead.

*** :history

Minibuffer input, by default, is pushed to `minibuffer-history'.

When an argument HISTORY is provided, input is pushed to
HISTORY. HISTORY should be a valid symbol.

*** :allow-nest

Allow running this Helm command in a running Helm session.

** Other keywords

Other keywords are interpreted as local variables of this Helm
session. The `helm-' prefix can be omitted. For example,

\(helm :sources 'helm-source-buffers-list
       :buffer \"*helm buffers*\"
       :candidate-number-limit 10)

starts a Helm session with the variable
`helm-candidate-number-limit' set to 10.

** Backward compatibility

For backward compatibility, positional parameters are
supported:

\(helm sources input prompt resume preselect
       buffer keymap default history allow-nest)

However, the use of non-keyword args is deprecated.

\(fn &key SOURCES INPUT PROMPT RESUME PRESELECT BUFFER KEYMAP DEFAULT HISTORY ALLOW-NEST OTHER-LOCAL-VARS)" nil nil)

(autoload 'helm-cycle-resume "helm" "\
Cycle in `helm-buffers' list and resume when waiting more than 1.2s.

\(fn)" t nil)

(autoload 'helm-other-buffer "helm" "\
Simplified `helm' interface with other `helm-buffer'.
Call `helm' only with ANY-SOURCES and ANY-BUFFER as args.

\(fn ANY-SOURCES ANY-BUFFER)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm" '("copy-region-as-kill--advice" "cua-delete-region--advice" "helm-" "with-helm-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-lib" '("helm-" "with-helm-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-multi-match" '("helm-m")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-source" '("helm-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-20180810.507/helm-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-20180810.507/helm-autoloads.el") (car load-path))))



(defvar helm-adaptive-mode nil "\
Non-nil if Helm-Adaptive mode is enabled.
See the `helm-adaptive-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-adaptive-mode'.")

(custom-autoload 'helm-adaptive-mode "helm-adaptive" nil)

(autoload 'helm-adaptive-mode "helm-adaptive" "\
Toggle adaptive sorting in all sources.

If called interactively, enable Helm-Adaptive mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'helm-reset-adaptive-history "helm-adaptive" "\
Delete all `helm-adaptive-history' and his file.
Useful when you have a old or corrupted `helm-adaptive-history-file'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-adaptive" '("helm-adapt")))



(autoload 'helm-bookmarks "helm-bookmark" "\
Preconfigured `helm' for bookmarks.

\(fn)" t nil)

(autoload 'helm-filtered-bookmarks "helm-bookmark" "\
Preconfigured helm for bookmarks (filtered by category).
Optional source `helm-source-bookmark-addressbook' is loaded
only if external addressbook-bookmark package is installed.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-bookmark" '("bmkext-jump-" "bookmark" "helm-")))



(autoload 'helm-buffers-list "helm-buffers" "\
Preconfigured `helm' to list buffers.

\(fn)" t nil)

(autoload 'helm-mini "helm-buffers" "\
Preconfigured `helm' lightweight version (buffer -> recentf).

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-buffers" '("helm-")))



(autoload 'helm-colors "helm-color" "\
Preconfigured `helm' for color.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-color" '("helm-")))



(autoload 'helm-M-x "helm-command" "\
Preconfigured `helm' for Emacs commands.
It is `helm' replacement of regular `M-x' `execute-extended-command'.

Unlike regular `M-x' emacs vanilla `execute-extended-command' command,
the prefix args if needed, can be passed AFTER starting `helm-M-x'.
When a prefix arg is passed BEFORE starting `helm-M-x', the first `C-u'
while in `helm-M-x' session will disable it.

You can get help on each command by persistent action.

\(fn ARG &optional COMMAND-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-command" '("helm-")))



(autoload 'helm-configuration "helm-config" "\
Customize `helm'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-config" '("helm-")))



(autoload 'helm-dabbrev "helm-dabbrev" "\
Preconfigured helm for dynamic abbreviations.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-dabbrev" '("helm-dabbrev-")))



(autoload 'helm-lisp-completion-at-point "helm-elisp" "\
Preconfigured helm for lisp symbol completion at point.

\(fn)" t nil)

(autoload 'helm-complete-file-name-at-point "helm-elisp" "\
Preconfigured helm to complete file name at point.

\(fn &optional FORCE)" t nil)

(autoload 'helm-lisp-indent "helm-elisp" "\


\(fn)" t nil)

(autoload 'helm-lisp-completion-or-file-name-at-point "helm-elisp" "\
Preconfigured helm to complete lisp symbol or filename at point.
Filename completion happen if string start after or between a double quote.

\(fn)" t nil)

(autoload 'helm-apropos "helm-elisp" "\
Preconfigured helm to describe commands, functions, variables and faces.
In non interactives calls DEFAULT argument should be provided as a string,
i.e the `symbol-name' of any existing symbol.

\(fn DEFAULT)" t nil)

(autoload 'helm-manage-advice "helm-elisp" "\
Preconfigured `helm' to disable/enable function advices.

\(fn)" t nil)

(autoload 'helm-locate-library "helm-elisp" "\
Preconfigured helm to locate elisp libraries.

\(fn)" t nil)

(autoload 'helm-timers "helm-elisp" "\
Preconfigured `helm' for timers.

\(fn)" t nil)

(autoload 'helm-complex-command-history "helm-elisp" "\
Preconfigured helm for complex command history.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-elisp" '("helm-" "with-helm-show-completion")))



(autoload 'helm-list-elisp-packages "helm-elisp-package" "\
Preconfigured helm for listing and handling emacs packages.

\(fn ARG)" t nil)

(autoload 'helm-list-elisp-packages-no-fetch "helm-elisp-package" "\
Preconfigured helm for emacs packages.

Same as `helm-list-elisp-packages' but don't fetch packages on remote.
Called with a prefix ARG always fetch packages on remote.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-elisp-package" '("helm-")))



(autoload 'helm-esh-pcomplete "helm-eshell" "\
Preconfigured helm to provide helm completion in eshell.

\(fn)" t nil)

(autoload 'helm-eshell-history "helm-eshell" "\
Preconfigured helm for eshell history.

\(fn)" t nil)

(autoload 'helm-eshell-prompts "helm-eshell" "\
Pre-configured `helm' to browse the prompts of the current Eshell.

\(fn)" t nil)

(autoload 'helm-eshell-prompts-all "helm-eshell" "\
Pre-configured `helm' to browse the prompts of all Eshell sessions.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-eshell" '("helm-e")))



(autoload 'helm-eval-expression "helm-eval" "\
Preconfigured helm for `helm-source-evaluation-result'.

\(fn ARG)" t nil)

(autoload 'helm-eval-expression-with-eldoc "helm-eval" "\
Preconfigured helm for `helm-source-evaluation-result' with `eldoc' support. 

\(fn)" t nil)

(autoload 'helm-calcul-expression "helm-eval" "\
Preconfigured helm for `helm-source-calculation-result'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-eval" '("helm-")))



(autoload 'helm-run-external-command "helm-external" "\
Preconfigured `helm' to run External PROGRAM asyncronously from Emacs.
If program is already running exit with error.
You can set your own list of commands with
`helm-external-commands-list'.

\(fn PROGRAM)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-external" '("helm-")))



(autoload 'helm-projects-history "helm-files" "\


\(fn)" t nil)

(autoload 'helm-browse-project "helm-files" "\
Preconfigured helm to browse projects.
Browse files and see status of project with its vcs.
Only HG and GIT are supported for now.
Fall back to `helm-browse-project-find-files'
if current directory is not under control of one of those vcs.
With a prefix ARG browse files recursively, with two prefix ARG
rebuild the cache.
If the current directory is found in the cache, start
`helm-browse-project-find-files' even with no prefix ARG.
NOTE: The prefix ARG have no effect on the VCS controlled directories.

Needed dependencies for VCS:
<https://github.com/emacs-helm/helm-ls-git>
and
<https://github.com/emacs-helm/helm-ls-hg>.

\(fn ARG)" t nil)

(autoload 'helm-find-files "helm-files" "\
Preconfigured `helm' for helm implementation of `find-file'.
Called with a prefix arg show history if some.
Don't call it from programs, use `helm-find-files-1' instead.
This is the starting point for nearly all actions you can do on files.

\(fn ARG)" t nil)

(autoload 'helm-delete-tramp-connection "helm-files" "\
Allow deleting tramp connection or marked tramp connections at once.

This replace `tramp-cleanup-connection' which is partially broken in
emacs < to 25.1.50.1 (See Emacs Bug#24432).

It allows additionally to delete more than one connection at once.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-files" '("eshell-command-aliases-list" "helm-")))



(autoload 'helm-find "helm-find" "\
Preconfigured `helm' for the find shell command.

Recursively find files whose names are matched by all specified
globbing PATTERNs under the current directory using the external
program specified in `find-program' (usually \"find\").  Every
input PATTERN is silently wrapped into two stars: *PATTERN*.

With prefix argument, prompt for a directory to search.

When user option `helm-findutils-search-full-path' is non-nil,
match against complete paths, otherwise, against file names
without directory part.

The (possibly empty) list of globbing PATTERNs can be followed by
the separator \"*\" plus any number of additional arguments that
are passed to \"find\" literally.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-find" '("helm-")))



(autoload 'helm-select-xfont "helm-font" "\
Preconfigured `helm' to select Xfont.

\(fn)" t nil)

(autoload 'helm-ucs "helm-font" "\
Preconfigured helm for `ucs-names'.

Called with a prefix arg force reloading cache.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-font" '("helm-")))



(autoload 'helm-for-files "helm-for-files" "\
Preconfigured `helm' for opening files.
Run all sources defined in `helm-for-files-preferred-list'.

\(fn)" t nil)

(autoload 'helm-multi-files "helm-for-files" "\
Preconfigured helm like `helm-for-files' but running locate only on demand.

Allow toggling back and forth from locate to others sources with
`helm-multi-files-toggle-locate-binding' key.
This avoid launching needlessly locate when what you search is already
found.

\(fn)" t nil)

(autoload 'helm-recentf "helm-for-files" "\
Preconfigured `helm' for `recentf'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-for-files" '("helm-")))



(autoload 'helm-goto-precedent-file "helm-grep" "\
Go to precedent file in helm grep/etags buffers.

\(fn)" t nil)

(autoload 'helm-goto-next-file "helm-grep" "\
Go to precedent file in helm grep/etags buffers.

\(fn)" t nil)

(autoload 'helm-do-grep-ag "helm-grep" "\
Preconfigured helm for grepping with AG in `default-directory'.
With prefix-arg prompt for type if available with your AG version.

\(fn ARG)" t nil)

(autoload 'helm-grep-do-git-grep "helm-grep" "\
Preconfigured helm for git-grepping `default-directory'.
With a prefix arg ARG git-grep the whole repository.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-grep" '("helm-")))



(autoload 'helm-documentation "helm-help" "\
Preconfigured Helm for Helm documentation.
With a prefix arg refresh the documentation.

Find here the documentation of all documented sources.

\(fn)" t nil)

(defvar helm-comp-read-mode-line "\\<helm-comp-read-map>C/\\[helm-cr-empty-string]:Empty \\<helm-map>\\[helm-help]:Help \\[helm-select-action]:Act \\[helm-maybe-exit-minibuffer]/f1/f2/f-n:NthAct \\[helm-toggle-suspend-update]:Tog.suspend")

(defvar helm-read-file-name-mode-line-string "\\<helm-read-file-map>\\[helm-help]:Help C/\\[helm-cr-empty-string]:Empty \\<helm-map>\\[helm-select-action]:Act \\[helm-maybe-exit-minibuffer]/f1/f2/f-n:NthAct \\[helm-toggle-suspend-update]:Tog.suspend" "\
String displayed in mode-line in `helm-source-find-files'.")

(defvar helm-top-mode-line "\\<helm-top-map>\\[helm-help]:Help \\<helm-map>\\[helm-select-action]:Act \\[helm-maybe-exit-minibuffer]/f1/f2/f-n:NthAct \\[helm-toggle-suspend-update]:Tog.suspend")

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-help" '("helm-")))



(autoload 'helm-gid "helm-id-utils" "\
Preconfigured helm for `gid' command line of `ID-Utils'.
Need A database created with the command `mkid'
above `default-directory'.
Need id-utils as dependency which provide `mkid', `gid' etc...
See <https://www.gnu.org/software/idutils/>.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-id-utils" '("helm-gid-")))



(autoload 'helm-imenu "helm-imenu" "\
Preconfigured `helm' for `imenu'.

\(fn)" t nil)

(autoload 'helm-imenu-in-all-buffers "helm-imenu" "\
Preconfigured helm for fetching imenu entries in all buffers with similar mode as current.
A mode is similar as current if it is the same, it is derived i.e `derived-mode-p'
or it have an association in `helm-imenu-all-buffer-assoc'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-imenu" '("helm-")))



(autoload 'helm-info "helm-info" "\
Preconfigured `helm' for searching Info files' indices.

With a prefix argument \\[universal-argument], set REFRESH to non-nil.

Optional parameter REFRESH, when non-nil, reevaluates
`helm-default-info-index-list'.  If the variable has been
customized, set it to its saved value.  If not, set it to its
standard value.  See `custom-reevaluate-setting' for more.

REFRESH is useful when new Info files are installed.  If
`helm-default-info-index-list' has not been customized, the new
Info files are made available.

\(fn &optional REFRESH)" t nil)

(autoload 'helm-info-at-point "helm-info" "\
Preconfigured `helm' for searching info at point.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-info" '("helm-")))



(autoload 'helm-projects-find-files "helm-locate" "\
Find files with locate in `helm-locate-project-list'.
With a prefix arg refresh the database in each project.

\(fn UPDATE)" t nil)

(autoload 'helm-locate "helm-locate" "\
Preconfigured `helm' for Locate.
Note: you can add locate options after entering pattern.
See 'man locate' for valid options and also `helm-locate-command'.

You can specify a local database with prefix argument ARG.
With two prefix arg, refresh the current local db or create it
if it doesn't exists.

To create a user specific db, use
\"updatedb -l 0 -o db_path -U directory\".
Where db_path is a filename matched by
`helm-locate-db-file-regexp'.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-locate" '("helm-")))



(autoload 'helm-man-woman "helm-man" "\
Preconfigured `helm' for Man and Woman pages.
With a prefix arg reinitialize the cache.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-man" '("helm-")))



(autoload 'helm-world-time "helm-misc" "\
Preconfigured `helm' to show world time.
Default action change TZ environment variable locally to emacs.

\(fn)" t nil)

(autoload 'helm-insert-latex-math "helm-misc" "\
Preconfigured helm for latex math symbols completion.

\(fn)" t nil)

(autoload 'helm-ratpoison-commands "helm-misc" "\
Preconfigured `helm' to execute ratpoison commands.

\(fn)" t nil)

(autoload 'helm-stumpwm-commands "helm-misc" "\
Preconfigured helm for stumpwm commands.

\(fn)" t nil)

(autoload 'helm-minibuffer-history "helm-misc" "\
Preconfigured `helm' for `minibuffer-history'.

\(fn)" t nil)

(autoload 'helm-comint-input-ring "helm-misc" "\
Preconfigured `helm' that provide completion of `comint' history.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-misc" '("helm-")))



(autoload 'helm-comp-read "helm-mode" "\
Read a string in the minibuffer, with helm completion.

It is helm `completing-read' equivalent.

- PROMPT is the prompt name to use.

- COLLECTION can be a list, vector, obarray or hash-table.
  It can be also a function that receives three arguments:
  the values string, predicate and t. See `all-completions' for more details.

Keys description:

- TEST: A predicate called with one arg i.e candidate.

- INITIAL-INPUT: Same as input arg in `helm'.

- PRESELECT: See preselect arg of `helm'.

- DEFAULT: This option is used only for compatibility with regular
  Emacs `completing-read' (Same as DEFAULT arg of `completing-read').

- BUFFER: Name of helm-buffer.

- MUST-MATCH: Candidate selected must be one of COLLECTION.

- FUZZY: Enable fuzzy matching.

- REVERSE-HISTORY: When non--nil display history source after current
  source completion.

- REQUIRES-PATTERN: Same as helm attribute, default is 0.

- HISTORY: A list containing specific history, default is nil.
  When it is non--nil, all elements of HISTORY are displayed in
  a special source before COLLECTION.

- INPUT-HISTORY: A symbol. the minibuffer input history will be
  stored there, if nil or not provided, `minibuffer-history'
  will be used instead.

- CASE-FOLD: Same as `helm-case-fold-search'.

- DEL-INPUT: Boolean, when non--nil (default) remove the partial
  minibuffer input from HISTORY is present.

- PERSISTENT-ACTION: A function called with one arg i.e candidate.

- PERSISTENT-HELP: A string to document PERSISTENT-ACTION.

- MODE-LINE: A string or list to display in mode line.
  Default is `helm-comp-read-mode-line'.

- KEYMAP: A keymap to use in this `helm-comp-read'.
  (the keymap will be shared with history source)

- NAME: The name related to this local source.

- HEADER-NAME: A function to alter NAME, see `helm'.

- EXEC-WHEN-ONLY-ONE: Bound `helm-execute-action-at-once-if-one'
  to non--nil. (possibles values are t or nil).

- VOLATILE: Use volatile attribute.

- SORT: A predicate to give to `sort' e.g `string-lessp'
  Use this only on small data as it is ineficient.
  If you want to sort faster add a sort function to
  FC-TRANSFORMER.
  Note that FUZZY when enabled is already providing a sort function.

- FC-TRANSFORMER: A `filtered-candidate-transformer' function
  or a list of functions.

- HIST-FC-TRANSFORMER: A `filtered-candidate-transformer'
  function for the history source.

- MARKED-CANDIDATES: If non--nil return candidate or marked candidates as a list.

- NOMARK: When non--nil don't allow marking candidates.

- ALISTP: (default is non--nil) See `helm-comp-read-get-candidates'.

- CANDIDATES-IN-BUFFER: when non--nil use a source build with
  `helm-source-in-buffer' which is much faster.
  Argument VOLATILE have no effect when CANDIDATES-IN-BUFFER is non--nil.

- MATCH-PART: Allow matching only one part of candidate.
  See match-part documentation in `helm-source'.

- ALLOW-NEST: Allow nesting this `helm-comp-read' in a helm session.
  See `helm'.

- MULTILINE: See multiline in `helm-source'.

Any prefix args passed during `helm-comp-read' invocation will be recorded
in `helm-current-prefix-arg', otherwise if prefix args were given before
`helm-comp-read' invocation, the value of `current-prefix-arg' will be used.
That's mean you can pass prefix args before or after calling a command
that use `helm-comp-read' See `helm-M-x' for example.

\(fn PROMPT COLLECTION &key TEST INITIAL-INPUT DEFAULT PRESELECT (BUFFER \"*Helm Completions*\") MUST-MATCH FUZZY REVERSE-HISTORY (REQUIRES-PATTERN 0) HISTORY INPUT-HISTORY (CASE-FOLD helm-comp-read-case-fold-search) (DEL-INPUT t) (PERSISTENT-ACTION nil) (PERSISTENT-HELP \"DoNothing\") (MODE-LINE helm-comp-read-mode-line) HELP-MESSAGE (KEYMAP helm-comp-read-map) (NAME \"Helm Completions\") HEADER-NAME CANDIDATES-IN-BUFFER MATCH-PART EXEC-WHEN-ONLY-ONE QUIT-WHEN-NO-CAND (VOLATILE t) SORT FC-TRANSFORMER HIST-FC-TRANSFORMER MARKED-CANDIDATES NOMARK (ALISTP t) (CANDIDATE-NUMBER-LIMIT helm-candidate-number-limit) MULTILINE ALLOW-NEST)" nil nil)

(autoload 'helm-read-file-name "helm-mode" "\
Read a file name with helm completion.
It is helm `read-file-name' emulation.

Argument PROMPT is the default prompt to use.

Keys description:

- NAME: Source name, default to \"Read File Name\".

- INITIAL-INPUT: Where to start read file name, default to `default-directory'.

- BUFFER: `helm-buffer' name default to \"*Helm Completions*\".

- TEST: A predicate called with one arg 'candidate'.

- CASE-FOLD: Same as `helm-case-fold-search'.

- PRESELECT: helm preselection.

- HISTORY: Display HISTORY in a special source.

- MUST-MATCH: Can be 'confirm, nil, or t.

- FUZZY: Enable fuzzy matching when non-nil (Enabled by default).

- MARKED-CANDIDATES: When non--nil return a list of marked candidates.

- NOMARK: When non--nil don't allow marking candidates.

- ALISTP: Don't use `all-completions' in history (take effect only on history).

- PERSISTENT-ACTION-IF: a persistent if action function.

- PERSISTENT-HELP: persistent help message.

- MODE-LINE: A mode line message, default is `helm-read-file-name-mode-line-string'.

\(fn PROMPT &key (NAME \"Read File Name\") (INITIAL-INPUT default-directory) (BUFFER \"*Helm file completions*\") TEST (CASE-FOLD helm-file-name-case-fold-search) PRESELECT HISTORY MUST-MATCH (FUZZY t) DEFAULT MARKED-CANDIDATES (CANDIDATE-NUMBER-LIMIT helm-ff-candidate-number-limit) NOMARK (ALISTP t) (PERSISTENT-ACTION-IF \\='helm-find-files-persistent-action-if) (PERSISTENT-HELP \"Hit1 Expand Candidate, Hit2 or (C-u) Find file\") (MODE-LINE helm-read-file-name-mode-line-string))" nil nil)

(defvar helm-mode nil "\
Non-nil if Helm mode is enabled.
See the `helm-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-mode'.")

(custom-autoload 'helm-mode "helm-mode" nil)

(autoload 'helm-mode "helm-mode" "\
Toggle generic helm completion.

All functions in Emacs that use `completing-read'
or `read-file-name' and friends will use helm interface
when this mode is turned on.

However you can modify this behavior for functions of your choice
with `helm-completing-read-handlers-alist'.

Also commands using `completion-in-region' will be helmized when
`helm-mode-handle-completion-in-region' is non nil, you can modify
this behavior with `helm-mode-no-completion-in-region-in-modes'.

Called with a positive arg, turn on unconditionally, with a
negative arg turn off.
You can turn it on with `helm-mode'.

Some crap emacs functions may not be supported,
e.g `ffap-alternate-file' and maybe others
You can add such functions to `helm-completing-read-handlers-alist'
with a nil value.

About `ido-mode':
When you are using `helm-mode', DO NOT use `ido-mode', instead if you
want some commands use `ido', add these commands to
`helm-completing-read-handlers-alist' with `ido' as value.

Note: This mode is incompatible with Emacs23.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-mode" '("helm-")))



(autoload 'helm-browse-url-firefox "helm-net" "\
Same as `browse-url-firefox' but detach from emacs.

So when you quit emacs you can keep your firefox session open
and not be prompted to kill firefox process.

NOTE: Probably not supported on some systems (e.g Windows).

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-opera "helm-net" "\
Browse URL with opera browser and detach from emacs.

So when you quit emacs you can keep your opera session open
and not be prompted to kill opera process.

NOTE: Probably not supported on some systems (e.g Windows).

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-chromium "helm-net" "\
Browse URL with google chrome browser.

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-uzbl "helm-net" "\
Browse URL with uzbl browser.

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-browse-url-conkeror "helm-net" "\
Browse URL with conkeror browser.

\(fn URL &optional IGNORE)" t nil)

(autoload 'helm-surfraw "helm-net" "\
Preconfigured `helm' to search PATTERN with search ENGINE.

\(fn PATTERN ENGINE)" t nil)

(autoload 'helm-google-suggest "helm-net" "\
Preconfigured `helm' for google search with google suggest.

\(fn)" t nil)

(autoload 'helm-wikipedia-suggest "helm-net" "\
Preconfigured `helm' for Wikipedia lookup with Wikipedia suggest.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-net" '("helm-")))



(autoload 'helm-org-agenda-files-headings "helm-org" "\
Preconfigured helm for org files headings.

\(fn)" t nil)

(autoload 'helm-org-in-buffer-headings "helm-org" "\
Preconfigured helm for org buffer headings.

\(fn)" t nil)

(autoload 'helm-org-parent-headings "helm-org" "\
Preconfigured helm for org headings that are parents of the
current heading.

\(fn)" t nil)

(autoload 'helm-org-capture-templates "helm-org" "\
Preconfigured helm for org templates.

\(fn)" t nil)

(autoload 'helm-org-completing-read-tags "helm-org" "\
Completing read function for Org tags.

This function is used as a `completing-read' function in
`helm-completing-read-handlers-alist' by `org-set-tags' and
`org-capture'.

NOTE: Org tag completion will work only if you disable org fast tag
selection, see (info \"(org) setting tags\").

\(fn PROMPT COLLECTION PRED REQ INITIAL HIST DEF INHERIT-INPUT-METHOD NAME BUFFER)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-org" '("helm-")))



(autoload 'helm-moccur-mode "helm-regexp" "\
Major mode to provide actions in helm moccur saved buffer.

Special commands:
\\{helm-moccur-mode-map}

\(fn)" t nil)

(autoload 'helm-regexp "helm-regexp" "\
Preconfigured helm to build regexps.
`query-replace-regexp' can be run from there against found regexp.

\(fn)" t nil)

(autoload 'helm-occur "helm-regexp" "\
Preconfigured helm for searching lines matching pattern in `current-buffer'.

When `helm-source-occur' is member of
`helm-sources-using-default-as-input' which is the default,
symbol at point is searched at startup.

When a region is marked search only in this region by narrowing.

To search in multiples buffers start from one of the commands listing
buffers (i.e. a helm command using `helm-source-buffers-list' like
`helm-mini') and use the multi occur buffers action.

This is the helm implementation that collect lines matching pattern
like vanilla emacs `occur' but have nothing to do with it, the search
engine beeing completely different.

\(fn)" t nil)

(autoload 'helm-occur-from-isearch "helm-regexp" "\
Invoke `helm-occur' from isearch.

\(fn)" t nil)

(autoload 'helm-multi-occur-from-isearch "helm-regexp" "\
Invoke `helm-multi-occur' from isearch.

With a prefix arg, reverse the behavior of
`helm-moccur-always-search-in-current'.
The prefix arg can be set before calling
`helm-multi-occur-from-isearch' or during the buffer selection.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-regexp" '("helm-")))



(autoload 'helm-mark-ring "helm-ring" "\
Preconfigured `helm' for `helm-source-mark-ring'.

\(fn)" t nil)

(autoload 'helm-global-mark-ring "helm-ring" "\
Preconfigured `helm' for `helm-source-global-mark-ring'.

\(fn)" t nil)

(autoload 'helm-all-mark-rings "helm-ring" "\
Preconfigured `helm' for `helm-source-global-mark-ring' and `helm-source-mark-ring'.

\(fn)" t nil)

(autoload 'helm-register "helm-ring" "\
Preconfigured `helm' for Emacs registers.

\(fn)" t nil)

(autoload 'helm-show-kill-ring "helm-ring" "\
Preconfigured `helm' for `kill-ring'.
It is drop-in replacement of `yank-pop'.

First call open the kill-ring browser, next calls move to next line.

\(fn)" t nil)

(autoload 'helm-execute-kmacro "helm-ring" "\
Preconfigured helm for keyboard macros.
Define your macros with `f3' and `f4'.
See (info \"(emacs) Keyboard Macros\") for detailed infos.
This command is useful when used with persistent action.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-ring" '("helm-")))



(autoload 'helm-semantic "helm-semantic" "\
Preconfigured `helm' for `semantic'.
If ARG is supplied, pre-select symbol at point instead of current

\(fn ARG)" t nil)

(autoload 'helm-semantic-or-imenu "helm-semantic" "\
Preconfigured helm for `semantic' or `imenu'.
If ARG is supplied, pre-select symbol at point instead of current
semantic tag in scope.

If `semantic-mode' is active in the current buffer, then use
semantic for generating tags, otherwise fall back to `imenu'.
Fill in the symbol at point by default.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-semantic" '("helm-s")))



(defvar helm-top-poll-mode nil "\
Non-nil if Helm-Top-Poll mode is enabled.
See the `helm-top-poll-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-top-poll-mode'.")

(custom-autoload 'helm-top-poll-mode "helm-sys" nil)

(autoload 'helm-top-poll-mode "helm-sys" "\
Refresh automatically helm top buffer once enabled.

If called interactively, enable Helm-Top-Poll mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'helm-top "helm-sys" "\
Preconfigured `helm' for top command.

\(fn)" t nil)

(autoload 'helm-list-emacs-process "helm-sys" "\
Preconfigured `helm' for emacs process.

\(fn)" t nil)

(autoload 'helm-xrandr-set "helm-sys" "\
Preconfigured helm for xrandr.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-sys" '("helm-")))



(autoload 'helm-etags-select "helm-tags" "\
Preconfigured helm for etags.
If called with a prefix argument REINIT
or if any of the tag files have been modified, reinitialize cache.

This function aggregates three sources of tag files:

  1) An automatically located file in the parent directories,
     by `helm-etags-get-tag-file'.
  2) `tags-file-name', which is commonly set by `find-tag' command.
  3) `tags-table-list' which is commonly set by `visit-tags-table' command.

\(fn REINIT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-tags" '("helm-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-types" '("helm-")))



(defvar helm-popup-tip-mode nil "\
Non-nil if Helm-Popup-Tip mode is enabled.
See the `helm-popup-tip-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `helm-popup-tip-mode'.")

(custom-autoload 'helm-popup-tip-mode "helm-utils" nil)

(autoload 'helm-popup-tip-mode "helm-utils" "\
Show help-echo informations in a popup tip at end of line.

If called interactively, enable Helm-Popup-Tip mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-utils" '("helm-" "with-helm-display-marked-candidates")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-x-files" '("helm-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/math-symbols-20170818.1459/math-symbols-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/math-symbols-20170818.1459/math-symbols-autoloads.el") (car load-path))))



(autoload 'math-symbols-input-activate "math-symbols" "\
Activating Math Input method.

\(fn NAME)" nil nil)

(register-input-method "math-symbols-bold" "math" 'math-symbols-input-activate "mBo")

(autoload 'math-symbols-bold-region "math-symbols" "\
Convert REGION to bold style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-string "math-symbols" "\
Convert STRING to bold style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-italic" "math" 'math-symbols-input-activate "mIt")

(autoload 'math-symbols-italic-region "math-symbols" "\
Convert REGION to italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-italic-string "math-symbols" "\
Convert STRING to italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-bold-italic" "math" 'math-symbols-input-activate "mBoIt")

(autoload 'math-symbols-bold-italic-region "math-symbols" "\
Convert REGION to bold-italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-italic-string "math-symbols" "\
Convert STRING to bold-italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-script" "math" 'math-symbols-input-activate "mSc")

(autoload 'math-symbols-script-region "math-symbols" "\
Convert REGION to script style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-script-string "math-symbols" "\
Convert STRING to script style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-bold-script" "math" 'math-symbols-input-activate "mBoSc")

(autoload 'math-symbols-bold-script-region "math-symbols" "\
Convert REGION to bold-script style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-script-string "math-symbols" "\
Convert STRING to bold-script style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-fraktur" "math" 'math-symbols-input-activate "mFr")

(autoload 'math-symbols-fraktur-region "math-symbols" "\
Convert REGION to fraktur style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-fraktur-string "math-symbols" "\
Convert STRING to fraktur style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-bold-fraktur" "math" 'math-symbols-input-activate "mBoFr")

(autoload 'math-symbols-bold-fraktur-region "math-symbols" "\
Convert REGION to bold-fraktur style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-bold-fraktur-string "math-symbols" "\
Convert STRING to bold-fraktur style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-double-struck" "math" 'math-symbols-input-activate "mDoSt")

(autoload 'math-symbols-double-struck-region "math-symbols" "\
Convert REGION to double-struck style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-double-struck-string "math-symbols" "\
Convert STRING to double-struck style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif" "math" 'math-symbols-input-activate "mSaSe")

(autoload 'math-symbols-sans-serif-region "math-symbols" "\
Convert REGION to sans-serif style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-string "math-symbols" "\
Convert STRING to sans-serif style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif-bold" "math" 'math-symbols-input-activate "mSaSeBo")

(autoload 'math-symbols-sans-serif-bold-region "math-symbols" "\
Convert REGION to sans-serif-bold style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-bold-string "math-symbols" "\
Convert STRING to sans-serif-bold style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif-italic" "math" 'math-symbols-input-activate "mSaSeIt")

(autoload 'math-symbols-sans-serif-italic-region "math-symbols" "\
Convert REGION to sans-serif-italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-italic-string "math-symbols" "\
Convert STRING to sans-serif-italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-sans-serif-bold-italic" "math" 'math-symbols-input-activate "mSaSeBoIt")

(autoload 'math-symbols-sans-serif-bold-italic-region "math-symbols" "\
Convert REGION to sans-serif-bold-italic style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-sans-serif-bold-italic-string "math-symbols" "\
Convert STRING to sans-serif-bold-italic style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-monospace" "math" 'math-symbols-input-activate "mMo")

(autoload 'math-symbols-monospace-region "math-symbols" "\
Convert REGION to monospace style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-monospace-string "math-symbols" "\
Convert STRING to monospace style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-superscript" "math" 'math-symbols-input-activate "mSu")

(autoload 'math-symbols-superscript-region "math-symbols" "\
Convert REGION to superscript style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-superscript-string "math-symbols" "\
Convert STRING to superscript style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-subscript" "math" 'math-symbols-input-activate "mSu")

(autoload 'math-symbols-subscript-region "math-symbols" "\
Convert REGION to subscript style.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-subscript-string "math-symbols" "\
Convert STRING to subscript style.

\(fn STRING)" nil nil)

(register-input-method "math-symbols-tex" "math" 'math-symbols-input-activate "mt")

(autoload 'math-symbols-from-tex-region "math-symbols" "\
Convert TeX commands in REGION to math symbols.
For example, 'Phi' will be converted to '𝛷'.

\(fn FROM TO)" t nil)

(autoload 'math-symbols-to-tex-region "math-symbols" "\
Convert math symbols to TeX command in REGION.
For example, `𝒫' will be converted to `mathcal{P}'.
Optional argument UNICODE specifies to use unicode-math package.

\(fn FROM TO &optional UNICODE)" t nil)

(autoload 'math-symbols-to-tex-unicode-region "math-symbols" "\


\(fn FROM TO)" t nil)

(autoload 'math-symbols-insert "math-symbols" "\
Interactively input math characters from symbols.

\(fn NAME)" t nil)

(autoload 'math-symbols-helm "math-symbols" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "math-symbols" '("math-symbols-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/math-symbol-lists-20170221.1353/math-symbol-lists-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/math-symbol-lists-20170221.1353/math-symbol-lists-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "math-symbol-lists" '("math-symbol-list-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "msl-build" '("gen-scirpted-alist" "msl--" "subscripts" "superscripts" "unicode-name-table")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/mark-multiple-20121118.1554/mark-multiple-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/mark-multiple-20121118.1554/mark-multiple-autoloads.el") (car load-path))))



(autoload 'inline-string-rectangle "inline-string-rectangle" "\


\(fn)" t nil)



(autoload 'mark-next-like-this "mark-more-like-this" "\
Find and mark the next part of the buffer matching the currently active region
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark next.

\(fn ARG)" t nil)

(autoload 'mark-previous-like-this "mark-more-like-this" "\
Find and mark the previous part of the buffer matching the currently active region
With negative ARG, delete the last one instead.
With zero ARG, skip the last one and mark previous.

\(fn ARG)" t nil)

(autoload 'mark-all-like-this "mark-more-like-this" "\
Find and mark all the parts of the buffer matching the currently active region

\(fn)" t nil)

(autoload 'mark-all-like-this-in-region "mark-more-like-this" "\
Find and mark all the parts in the region matching the given search

\(fn REG-START REG-END)" t nil)

(autoload 'mark-more-like-this "mark-more-like-this" "\
Marks next part of buffer that matches the currently active region ARG times.
Given a negative ARG it searches backwards instead.

\(fn ARG)" t nil)

(autoload 'mark-more-like-this-extended "mark-more-like-this" "\
Like mark-more-like-this, but then lets you adjust with arrows key.
The actual adjustment made depends on the final component of the
key-binding used to invoke the command, with all modifiers removed:

   <up>    Mark previous like this
   <down>  Mark next like this
   <left>  If last was previous, skip it
           If last was next, remove it
   <right> If last was next, skip it
           If last was previous, remove it

Then, continue to read input events and further add or move marks
as long as the input event read (with all modifiers removed)
is one of the above.

\(fn)" t nil)



(autoload 'mm/deactivate-region-or-clear-all "mark-multiple" "\
Deactivate mark if active, otherwise clear all.

\(fn)" t nil)

(autoload 'mm/deactivate-region-and-clear-all "mark-multiple" "\
Deactivate mark and clear all.

\(fn)" t nil)

(autoload 'mm/clear-all "mark-multiple" "\
Remove all marks

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mark-multiple" '("mm/")))



(autoload 'rename-sgml-tag "rename-sgml-tag" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "rename-sgml-tag" '("rst--inside-tag-p")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/manage-minor-mode-20140310.1600/manage-minor-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/manage-minor-mode-20140310.1600/manage-minor-mode-autoloads.el") (car load-path))))



(autoload 'manage-minor-mode-set "manage-minor-mode" "\


\(fn)" nil nil)

(autoload 'manage-minor-mode "manage-minor-mode" "\


\(fn &optional $LAST-TOGGLED-ITEM)" t nil)

(autoload 'manage-minor-mode-bals "manage-minor-mode" "\

Eradicate all minor-modes in the current buffer.
This command may cause unexpected effect even to other buffers.
However, don't worry, restore command exists:
 `manage-minor-mode-restore-from-bals'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "manage-minor-mode" '("manage-minor-mode-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/malinka-20171202.1021/malinka-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/malinka-20171202.1021/malinka-autoloads.el") (car load-path))))



(autoload 'malinka-project-configure "malinka" "\
Configure a project by querying for both NAME and GIVEN-ROOT-DIR.

If multiple projects with the same name in different directories may
exist then it's nice to provide the ROOT-DIR of the project to configure

\(fn NAME GIVEN-ROOT-DIR)" t nil)

(autoload 'malinka-project-select "malinka" "\
Select a project by querying for both NAME and GIVEN-ROOT-DIR.

If multiple projects with the same name in different directories may
exist then it's nice to provide the ROOT-DIR of the project to configure

\(fn NAME GIVEN-ROOT-DIR)" t nil)

(autoload 'malinka-mode "malinka" "\
Enables all malinka functionality for the current buffer

If called interactively, enable Malinka mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "malinka" '("async-shell-command-to-string" "malinka-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/makey-20131231.1430/makey-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/makey-20131231.1430/makey-autoloads.el") (car load-path))))



(autoload 'makey-initialize-key-groups "makey" "\
Initializes KEY-GROUP and creates all the relevant interactive commands.

\(fn KEY-GROUP)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "makey" '("makey-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/makefile-executor-20180720.832/makefile-executor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/makefile-executor-20180720.832/makefile-executor-autoloads.el") (car load-path))))



(autoload 'makefile-executor-execute-target "makefile-executor" "\
Execute a Makefile target from FILENAME.

FILENAME defaults to current buffer.

\(fn FILENAME &optional TARGET)" t nil)

(autoload 'makefile-executor-execute-project-target "makefile-executor" "\
Choose a Makefile target from all of the Makefiles in the project.

If there are several Makefiles, a prompt to select one of them is shown.
If so, the parent directory of the closest Makefile is added
as initial input for convenience in executing the most relevant Makefile.

\(fn)" t nil)

(autoload 'makefile-executor-execute-dedicated-buffer "makefile-executor" "\
Runs a makefile target in a dedicated compile buffer.

The dedicated buffer will be named \"*<target>*\".  If
`projectile' is installed and the makefile is in a project the
project name will be prepended to the dedicated buffer name.

\(fn FILENAME &optional TARGET)" t nil)

(autoload 'makefile-executor-execute-last "makefile-executor" "\
Execute the most recently executed Makefile target.

If none is set, prompt for it using
`makefile-executor-execute-project-target'.  If the universal
argument is given, always prompt.

\(fn ARG)" t nil)

(autoload 'makefile-executor-goto-makefile "makefile-executor" "\
Interactively choose a Makefile to visit.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "makefile-executor" '("makefile-executor-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/macrostep-20161120.2106/macrostep-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/macrostep-20161120.2106/macrostep-autoloads.el") (car load-path))))



(autoload 'macrostep-mode "macrostep" "\
Minor mode for inline expansion of macros in Emacs Lisp source buffers.

If called interactively, enable Macrostep mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\<macrostep-keymap>Progressively expand macro forms with \\[macrostep-expand], collapse them with \\[macrostep-collapse],
and move back and forth with \\[macrostep-next-macro] and \\[macrostep-prev-macro].
Use \\[macrostep-collapse-all] or collapse all visible expansions to
quit and return to normal editing.

\\{macrostep-keymap}

\(fn &optional ARG)" t nil)

(autoload 'macrostep-expand "macrostep" "\
Expand the macro form following point by one step.

Enters `macrostep-mode' if it is not already active, making the
buffer temporarily read-only. If macrostep-mode is active and the
form following point is not a macro form, search forward in the
buffer and expand the next macro form found, if any.

With a prefix argument, the expansion is displayed in a separate
buffer instead of inline in the current buffer.  Setting
`macrostep-expand-in-separate-buffer' to non-nil swaps these two
behaviors.

\(fn &optional TOGGLE-SEPARATE-BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macrostep" '("macrostep-")))



(autoload 'macrostep-c-mode-hook "macrostep-c" "\


\(fn)" nil nil)

(add-hook 'c-mode-hook #'macrostep-c-mode-hook)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macrostep-c" '("macrostep-c-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/macro-math-20130328.1604/macro-math-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/macro-math-20130328.1604/macro-math-autoloads.el") (car load-path))))



(autoload 'macro-math-eval-region "macro-math" "\
Evaluate the marked mathematical expression and replace it with the result.
With arg COPY-TO-KILL-RING or prefix arg, don't replace the region, but
save the result to the kill-ring.  When DIGITS is non-nil, or a numeric
prefix arg is given, it determines the number of decimal digits to round
to.

\(fn BEG END &optional COPY-TO-KILL-RING DIGITS)" t nil)

(autoload 'macro-math-eval-and-round-region "macro-math" "\
Call `macro-math-eval-region' and round the number to DIGITS places.
If DIGITS is nil, `macro-math-rounding-precision' will be used.

\(fn BEG END &optional DIGITS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macro-math" '("macro-math-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/dash-functional-20180107.1618/dash-functional-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/dash-functional-20180107.1618/dash-functional-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dash-functional" '("-a" "-c" "-f" "-iteratefn" "-juxt" "-not" "-o" "-p" "-rpartial")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-20180720.947/flycheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-20180720.947/flycheck-autoloads.el") (car load-path))))



(autoload 'flycheck-manual "flycheck" "\
Open the Flycheck manual.

\(fn)" t nil)

(autoload 'flycheck-mode "flycheck" "\
Minor mode for on-the-fly syntax checking.

When called interactively, toggle `flycheck-mode'.  With prefix
ARG, enable `flycheck-mode' if ARG is positive, otherwise disable
it.

When called from Lisp, enable `flycheck-mode' if ARG is omitted,
nil or positive.  If ARG is `toggle', toggle `flycheck-mode'.
Otherwise behave as if called interactively.

In `flycheck-mode' the buffer is automatically syntax-checked
using the first suitable syntax checker from `flycheck-checkers'.
Use `flycheck-select-checker' to select a checker for the current
buffer manually.

\\{flycheck-mode-map}

\(fn &optional ARG)" t nil)

(defvar global-flycheck-mode nil "\
Non-nil if Global Flycheck mode is enabled.
See the `global-flycheck-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-flycheck-mode'.")

(custom-autoload 'global-flycheck-mode "flycheck" nil)

(autoload 'global-flycheck-mode "flycheck" "\
Toggle Flycheck mode in all buffers.
With prefix ARG, enable Global Flycheck mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Flycheck mode is enabled in all buffers where
`flycheck-mode-on-safe' would do it.
See `flycheck-mode' for more information on Flycheck mode.

\(fn &optional ARG)" t nil)

(autoload 'flycheck-define-error-level "flycheck" "\
Define a new error LEVEL with PROPERTIES.

The following PROPERTIES constitute an error level:

`:severity SEVERITY'
     A number denoting the severity of this level.  The higher
     the number, the more severe is this level compared to other
     levels.  Defaults to 0.

     The severity is used by `flycheck-error-level-<' to
     determine the ordering of errors according to their levels.

`:compilation-level LEVEL'

     A number indicating the broad class of messages that errors
     at this level belong to: one of 0 (info), 1 (warning), or
     2 or nil (error).  Defaults to nil.

     This is used by `flycheck-checker-pattern-to-error-regexp'
     to map error levels into `compilation-mode''s hierarchy and
     to get proper highlighting of errors in `compilation-mode'.

`:overlay-category CATEGORY'
     A symbol denoting the overlay category to use for error
     highlight overlays for this level.  See Info
     node `(elisp)Overlay Properties' for more information about
     overlay categories.

     A category for an error level overlay should at least define
     the `face' property, for error highlighting.  Another useful
     property for error level categories is `priority', to
     influence the stacking of multiple error level overlays.

`:fringe-bitmap BITMAP'
     A fringe bitmap symbol denoting the bitmap to use for fringe
     indicators for this level.  See Info node `(elisp)Fringe
     Bitmaps' for more information about fringe bitmaps,
     including a list of built-in fringe bitmaps.

`:fringe-face FACE'
     A face symbol denoting the face to use for fringe indicators
     for this level.

`:error-list-face FACE'
     A face symbol denoting the face to use for messages of this
     level in the error list.  See `flycheck-list-errors'.

\(fn LEVEL &rest PROPERTIES)" nil nil)

(function-put 'flycheck-define-error-level 'lisp-indent-function '1)

(autoload 'flycheck-define-command-checker "flycheck" "\
Define SYMBOL as syntax checker to run a command.

Define SYMBOL as generic syntax checker via
`flycheck-define-generic-checker', which uses an external command
to check the buffer.  SYMBOL and DOCSTRING are the same as for
`flycheck-define-generic-checker'.

In addition to the properties understood by
`flycheck-define-generic-checker', the following PROPERTIES
constitute a command syntax checker.  Unless otherwise noted, all
properties are mandatory.  Note that the default `:error-filter'
of command checkers is `flycheck-sanitize-errors'.

`:command COMMAND'
     The command to run for syntax checking.

     COMMAND is a list of the form `(EXECUTABLE [ARG ...])'.

     EXECUTABLE is a string with the executable of this syntax
     checker.  It can be overridden with the variable
     `flycheck-SYMBOL-executable'.  Note that this variable is
     NOT implicitly defined by this function.  Use
     `flycheck-def-executable-var' to define this variable.

     Each ARG is an argument to the executable, either as string,
     or as special symbol or form for
     `flycheck-substitute-argument', which see.

`:error-patterns PATTERNS'
     A list of patterns to parse the output of the `:command'.

     Each ITEM in PATTERNS is a list `(LEVEL SEXP ...)', where
     LEVEL is a Flycheck error level (see
     `flycheck-define-error-level'), followed by one or more RX
     `SEXP's which parse an error of that level and extract line,
     column, file name and the message.

     See `rx' for general information about RX, and
     `flycheck-rx-to-string' for some special RX forms provided
     by Flycheck.

     All patterns are applied in the order of declaration to the
     whole output of the syntax checker.  Output already matched
     by a pattern will not be matched by subsequent patterns.  In
     other words, the first pattern wins.

     This property is optional.  If omitted, however, an
     `:error-parser' is mandatory.

`:error-parser FUNCTION'
     A function to parse errors with.

     The function shall accept three arguments OUTPUT CHECKER
     BUFFER.  OUTPUT is the syntax checker output as string,
     CHECKER the syntax checker that was used, and BUFFER a
     buffer object representing the checked buffer.  The function
     must return a list of `flycheck-error' objects parsed from
     OUTPUT.

     This property is optional.  If omitted, it defaults to
     `flycheck-parse-with-patterns'.  In this case,
     `:error-patterns' is mandatory.

`:standard-input t'
     Whether to send the buffer contents on standard input.

     If this property is given and has a non-nil value, send the
     contents of the buffer on standard input.

     Defaults to nil.

Note that you may not give `:start', `:interrupt', and
`:print-doc' for a command checker.  You can give a custom
`:verify' function, though, whose results will be appended to the
default `:verify' function of command checkers.

\(fn SYMBOL DOCSTRING &rest PROPERTIES)" nil nil)

(function-put 'flycheck-define-command-checker 'lisp-indent-function '1)

(function-put 'flycheck-define-command-checker 'doc-string-elt '2)

(autoload 'flycheck-def-config-file-var "flycheck" "\
Define SYMBOL as config file variable for CHECKER, with default FILE-NAME.

SYMBOL is declared as customizable variable using `defcustom', to
provide a configuration file for the given syntax CHECKER.
CUSTOM-ARGS are forwarded to `defcustom'.

FILE-NAME is the initial value of the new variable.  If omitted,
the default value is nil.

Use this together with the `config-file' form in the `:command'
argument to `flycheck-define-checker'.

\(fn SYMBOL CHECKER &optional FILE-NAME &rest CUSTOM-ARGS)" nil t)

(function-put 'flycheck-def-config-file-var 'lisp-indent-function '3)

(autoload 'flycheck-def-option-var "flycheck" "\
Define SYMBOL as option variable with INIT-VALUE for CHECKER.

SYMBOL is declared as customizable variable using `defcustom', to
provide an option for the given syntax CHECKERS (a checker or a
list of checkers).  INIT-VALUE is the initial value of the
variable, and DOCSTRING is its docstring.  CUSTOM-ARGS are
forwarded to `defcustom'.

Use this together with the `option', `option-list' and
`option-flag' forms in the `:command' argument to
`flycheck-define-checker'.

\(fn SYMBOL INIT-VALUE CHECKERS DOCSTRING &rest CUSTOM-ARGS)" nil t)

(function-put 'flycheck-def-option-var 'lisp-indent-function '3)

(function-put 'flycheck-def-option-var 'doc-string-elt '4)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck" '("contains-rebar-config" "flycheck-" "help-flycheck-checker-d" "list-flycheck-errors" "locate-rebar3-project-root" "read-flycheck-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-buttercup" '("flycheck-buttercup-format-error-list")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-ert" '("flycheck-er")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-mode-20180812.522/lsp-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-mode-20180812.522/lsp-mode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-common" '("lsp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-imenu" '("lsp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-io" '("lsp-")))



(let ((loads (get 'lsp-mode 'custom-loads))) (if (member '"lsp-methods" loads) nil (put 'lsp-mode 'custom-loads (cons '"lsp-methods" loads))))

(let ((loads (get 'lsp-faces 'custom-loads))) (if (member '"lsp-methods" loads) nil (put 'lsp-faces 'custom-loads (cons '"lsp-methods" loads))))

(defvar lsp-document-sync-method nil "\
How to sync the document with the language server.")

(custom-autoload 'lsp-document-sync-method "lsp-methods" t)

(defvar lsp-project-blacklist nil "\
A list of project directory regexps for which LSP shouldn't be initialized.
LSP should be initialized if the given project root matches one pattern in the
whitelist, or does not match any pattern in the blacklist.")

(custom-autoload 'lsp-project-blacklist "lsp-methods" t)

(defvar lsp-enable-eldoc t "\
Enable `eldoc-mode' integration.")

(custom-autoload 'lsp-enable-eldoc "lsp-methods" t)

(defvar lsp-eldoc-render-all t "\
Define whether all of the returned by document/onHover will be displayed.

If `lsp-markup-display-all' is set to nil `eldoc' will show only
the symbol information.")

(custom-autoload 'lsp-eldoc-render-all "lsp-methods" t)

(defvar lsp-highlight-symbol-at-point t "\
Highlight the symbol under the point.")

(custom-autoload 'lsp-highlight-symbol-at-point "lsp-methods" t)

(defvar lsp-enable-codeaction t "\
Enable code action processing.")

(custom-autoload 'lsp-enable-codeaction "lsp-methods" t)

(defvar lsp-enable-completion-at-point t "\
Enable `completion-at-point' integration.")

(custom-autoload 'lsp-enable-completion-at-point "lsp-methods" t)

(defvar lsp-enable-xref t "\
Enable xref integration.")

(custom-autoload 'lsp-enable-xref "lsp-methods" t)

(defvar lsp-enable-indentation t "\
Indent regions using the file formatting functionality provided by the language server.")

(custom-autoload 'lsp-enable-indentation "lsp-methods" t)

(defvar lsp-before-save-edits t "\
If non-nil, `lsp-mode' will apply edits suggested by the language server
before saving a document.")

(custom-autoload 'lsp-before-save-edits "lsp-methods" t)

(defvar lsp-hover-text-function 'lsp--text-document-hover-string "\
The LSP method to use to display text on hover.")

(custom-autoload 'lsp-hover-text-function "lsp-methods" t)

(defface lsp-face-highlight-textual '((((background dark)) :background "saddle brown") (((background light)) :background "yellow")) "\
Face used for textual occurances of symbols." :group 'lsp-faces)

(defface lsp-face-highlight-read '((((background dark)) :background "firebrick") (((background light)) :background "red")) "\
Face used for highlighting symbols being read." :group 'lsp-faces)

(defface lsp-face-highlight-write '((((background dark)) :background "sea green") (((background light)) :background "green")) "\
Face used for highlighting symbols being written to." :group 'lsp-faces)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-methods" '("lsp-")))



(autoload 'lsp-mode "lsp-mode" "\


\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-mode" '("lsp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-notifications" '("lsp-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-ui-20180619.251/lsp-ui-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-ui-20180619.251/lsp-ui-autoloads.el") (car load-path))))



(autoload 'lsp-ui-mode "lsp-ui" "\
Toggle language server UI mode on or off.
‘lsp-ui-mode’ is a minor mode that contains a series of useful UI
integrations for ‘lsp-mode’.  With a prefix argument ARG, enable
language server UI mode if ARG is positive, and disable it
otherwise.  If called from Lisp, enable the mode if ARG is
omitted or nil, and toggle it if ARG is ‘toggle’.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui" '("lsp-ui-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-doc" '("lsp-ui-doc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-flycheck" '("lsp-ui-flycheck-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-imenu" '("lsp-ui-imenu")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-peek" '("lsp-ui-peek-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-ui-sideline" '("lsp-ui-sideline")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-rust-20180305.1308/lsp-rust-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-rust-20180305.1308/lsp-rust-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-rust" '("lsp-rust-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lsp-clangd-20180701.134/lsp-clangd-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lsp-clangd-20180701.134/lsp-clangd-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lsp-clangd" '("lsp-clangd-executable")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ht-20180129.2234/ht-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ht-20180129.2234/ht-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ht" 'nil))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/list-packages-ext-20151115.1716/list-packages-ext-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/list-packages-ext-20151115.1716/list-packages-ext-autoloads.el") (car load-path))))



(autoload 'lpe:edit-package-notes "list-packages-ext" "\
Opens a buffer where the user can enter notes about PACKAGE.

\(fn PACKAGE)" t nil)

(autoload 'list-packages-ext-mode "list-packages-ext" "\
Some extras for the *Packages* buffer (see `list-packages').
Provides:
- package tagging
- package hiding (with the tag 'hidden'
- package filtering by tag expressions/regexp
- package annotations
\\{list-packages-ext-mode-map}

If called interactively, enable List-Packages-Ext mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'lpe:tag "list-packages-ext" "\
Applies the tags in TAGLIST to the package at the current
line, or to the packages in the active region.

When called interactively, it prompts the user for the list of
comma separated tags to apply to the package at the current line
or to the packages in the active region.

When called on a region, or on a single line with prefix argument,
the command will work in 'Modify' mode: the tags entered by the user
will be merged with the already present tags; a tag can be removed
from a package applying it in its negated form. The negation of a
tag is expressed prepending `!' to the tag,
e.g. to remove a tag 'foo', one would tag the package with '!foo'.

If calling it with no active region, or to the active region with
a prefix command, the command works in 'Set' mode: the tags
entered by the user will substitute the current tag set of the
package, or list of packages if the region is active.

\(fn TAGLIST &optional ADD)" t nil)

(autoload 'lpe:hide-package "list-packages-ext" "\
Hides a package from the package list (applying the 'hidden' tag).

\(fn)" t nil)

(autoload 'lpe:apply-last-tags "list-packages-ext" "\
Apply the last tags applied with `lpe:tag'.

\(fn)" t nil)

(autoload 'lpe:star "list-packages-ext" "\
Toggles the starred tag to the current package or the packages in region if it is active.

\(fn)" t nil)

(autoload 'lpe:show-hidden-toggle "list-packages-ext" "\
Toggles showing of hidden packages.

\(fn)" t nil)

(autoload 'lpe:filter-by-tag-expr "list-packages-ext" "\
Filters the list of packages with FILTER-STR.
When called interactively, it prompts the user for a tag filter expression.
A tag filter like
  (tag1 AND tag2 AND NOT tag3) or tag4
is expressed as (using the default operator syntax)
  tag1,tag2,!tag3/tag4
The syntax for the operators can be controlled binding
`lpe::*tag-expr-and*', `lpe::*tag-expr-or*' and `lpe::*tag-expr-not*' 

\(fn FILTER-STR)" t nil)

(autoload 'lpe:filter-with-regex "list-packages-ext" "\
Filters the packages using regex. By default, only the packages name are searched.
To activate searching in the package summary, see `lpe:search-in-summary-toggle'.

\(fn REGEX)" t nil)

(autoload 'lpe:search-in-summary-toggle "list-packages-ext" "\
Toggles searching in package summary with `lpe:filter-with-regex'.

\(fn)" t nil)

(autoload 'lpe:filters-history-forward "list-packages-ext" "\
Goes forward to the next search in the search history.

\(fn)" t nil)

(autoload 'lpe:filters-history-backward "list-packages-ext" "\
Goes back to the previous search.

\(fn)" t nil)

(autoload 'lpe:refresh "list-packages-ext" "\
Refreshes the buffer.

\(fn)" t nil)

(autoload 'lpe::post-command-hook "list-packages-ext" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "list-packages-ext" '("list-packages-ext-mode-" "lpe:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lisp-extra-font-lock-20160930.1927/lisp-extra-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lisp-extra-font-lock-20160930.1927/lisp-extra-font-lock-autoloads.el") (car load-path))))



(defvar lisp-extra-font-lock-modes '(emacs-lisp-mode lisp-mode) "\
List of modes where Lisp Extra Font Lock Global mode should be enabled.")

(custom-autoload 'lisp-extra-font-lock-modes "lisp-extra-font-lock" t)

(autoload 'lisp-extra-font-lock-mode "lisp-extra-font-lock" "\
Minor mode that highlights bound variables and quoted expressions in lisp.

If called interactively, enable Lisp-Extra-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar lisp-extra-font-lock-global-mode nil "\
Non-nil if Lisp-Extra-Font-Lock-Global mode is enabled.
See the `lisp-extra-font-lock-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `lisp-extra-font-lock-global-mode'.")

(custom-autoload 'lisp-extra-font-lock-global-mode "lisp-extra-font-lock" nil)

(autoload 'lisp-extra-font-lock-global-mode "lisp-extra-font-lock" "\
Toggle Lisp-Extra-Font-Lock mode in all buffers.
With prefix ARG, enable Lisp-Extra-Font-Lock-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Lisp-Extra-Font-Lock mode is enabled in all buffers where
`(lambda nil (when (apply 'derived-mode-p lisp-extra-font-lock-modes) (lisp-extra-font-lock-mode 1)))' would do it.
See `lisp-extra-font-lock-mode' for more information on Lisp-Extra-Font-Lock mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lisp-extra-font-lock" '("lisp-extra-font-lock-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/lfe-mode-20170121.1254/lfe-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/lfe-mode-20170121.1254/lfe-mode-autoloads.el") (car load-path))))



(autoload 'inferior-lfe-mode "inferior-lfe" "\
Major mode for interacting with an inferior LFE process.

\\{inferior-lfe-mode-map}

Customization: Entry to this mode runs the hooks on `comint-mode-hook' and
`inferior-lfe-mode-hook' (in that order).

\(fn)" t nil)

(autoload 'inferior-lfe "inferior-lfe" "\
Run an inferior LFE process, input and output via a buffer `*inferior-lfe*'.
If `CMD' is given, use it to start the shell, otherwise:
`inferior-lfe-program' `inferior-lfe-program-options' -env TERM vt100.

\(fn CMD)" t nil)

(defalias 'run-lfe 'inferior-lfe)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inferior-lfe" '("inferior-lfe-" "lfe-" "switch-to-lfe")))



(autoload 'lfe-indent-function "lfe-indent" "\
This function is the normal value of the variable `lfe-indent-function'.

If this function is the value of the variable `lisp-indent-function' then
`calculate-lisp-indent' will call it to determine if the
arguments of a LFE function call should be indented specially.

INDENT-POINT is the position where the user typed TAB, or equivalent.
Point is located at the point to indent under;
`STATE' is the `parse-partial-sexp' state for that position.

Copied from function `lisp-indent-function', but with gets of
lfe-indent-{function,hook} and it uses `lfe-body-indent'.

\(fn INDENT-POINT STATE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lfe-indent" '("define-lfe-indent" "lfe-" "put-lfe-indent")))



(autoload 'lfe-mode "lfe-mode" "\
Major mode for editing Lisp Flavoured Erlang.  It's just like `lisp-mode'.

Other commands:
\\{lfe-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.lfe\\(s\\|sh\\)?\\'" . lfe-mode) t)

(dolist (lfe-ext '(".beam" ".jam" ".vee")) (add-to-list 'completion-ignored-extensions lfe-ext))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lfe-mode" '("lfe-" "prettify-symbols-alist")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/language-detection-20161123.1813/language-detection-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/language-detection-20161123.1813/language-detection-autoloads.el") (car load-path))))



(autoload 'language-detection-buffer "language-detection" "\
Predict the programming language of the current buffer and output it to messages.

\(fn &optional PRINT-MESSAGE)" t nil)

(autoload 'language-detection-string "language-detection" "\
Return the predicted programming language of STRING as a symbol.

\(fn STRING)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "language-detection" '("language-detection-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/kv-20140108.1534/kv-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/kv-20140108.1534/kv-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "kv" '("dotass" "keyword->symbol" "map-bind")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/json-snatcher-20150512.347/json-snatcher-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/json-snatcher-20150512.347/json-snatcher-autoloads.el") (car load-path))))



(autoload 'jsons-print-path "json-snatcher" "\
Print the path to the JSON value under point, and save it in the kill ring.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-snatcher" '("jsons-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/json-reformat-20160212.853/json-reformat-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/json-reformat-20160212.853/json-reformat-autoloads.el") (car load-path))))



(autoload 'json-reformat-region "json-reformat" "\
Reformat the JSON in the specified region.

If you want to customize the reformat style,
please see the documentation of `json-reformat:indent-width'
and `json-reformat:pretty-string?'.

\(fn BEGIN END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-reformat" '("json-reformat")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/json-mode-20180718.809/json-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/json-mode-20180718.809/json-mode-autoloads.el") (car load-path))))



(defconst json-mode-standard-file-ext '(".json" ".jsonld") "\
List of JSON file extensions.")

(defsubst json-mode--update-auto-mode (filenames) "\
Update the `json-mode' entry of `auto-mode-alist'.

FILENAMES should be a list of file as string.
Return the new `auto-mode-alist' entry" (let* ((new-regexp (rx-to-string `(seq (eval (cons 'or (append json-mode-standard-file-ext ',filenames))) eot))) (new-entry (cons new-regexp 'json-mode)) (old-entry (when (boundp 'json-mode--auto-mode-entry) json-mode--auto-mode-entry))) (setq auto-mode-alist (delete old-entry auto-mode-alist)) (add-to-list 'auto-mode-alist new-entry) new-entry))

(defvar json-mode-auto-mode-list '(".babelrc" ".bowerrc" "composer.lock") "\
List of filename as string to pass for the JSON entry of
`auto-mode-alist'.

Note however that custom `json-mode' entries in `auto-mode-alist'
won’t be affected.")

(custom-autoload 'json-mode-auto-mode-list "json-mode" nil)

(defvar json-mode--auto-mode-entry (json-mode--update-auto-mode json-mode-auto-mode-list) "\
Regexp generated from the `json-mode-auto-mode-list'.")

(autoload 'json-mode "json-mode" "\
Major mode for editing JSON files

\(fn)" t nil)

(autoload 'json-mode-show-path "json-mode" "\
Print the path to the node at point to the minibuffer, and yank to the kill ring.

\(fn)" t nil)

(autoload 'json-mode-kill-path "json-mode" "\


\(fn)" t nil)

(autoload 'json-mode-beautify "json-mode" "\
Beautify / pretty-print the active region (or the entire buffer if no active region).

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-mode" '("json-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/jdecomp-20170224.2200/jdecomp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/jdecomp-20170224.2200/jdecomp-autoloads.el") (car load-path))))



(autoload 'jdecomp-preview-mode "jdecomp" "\
Major mode for previewing decompiled Java class files.

\\{jdecomp-preview-mode-map}

\(fn)" t nil)

(autoload 'jdecomp-decompile "jdecomp" "\
Decompile FILE and return buffer of decompiled contents.

FILE must be a Java class file.

Optional parameter JAR is the name of the JAR archive FILE is
in.

\(fn FILE &optional JAR)" nil nil)

(autoload 'jdecomp-decompile-and-view "jdecomp" "\
Decompile FILE and view buffer of decompiled contents.

FILE must be a Java class file.  If called interactively, FILE is
the name of the file the current buffer is visiting.

Optional parameter JAR is the JAR file containing FILE, if
applicable.

\(fn FILE &optional JAR)" t nil)

(defvar jdecomp-mode nil "\
Non-nil if Jdecomp mode is enabled.
See the `jdecomp-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `jdecomp-mode'.")

(custom-autoload 'jdecomp-mode "jdecomp" nil)

(autoload 'jdecomp-mode "jdecomp" "\
Automatically decompile Java class files.

If called interactively, enable Jdecomp mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "jdecomp" '("jdecomp-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/javap-mode-20120223.2208/javap-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/javap-mode-20120223.2208/javap-mode-autoloads.el") (car load-path))))



(autoload 'javap-mode "javap-mode" "\
A major mode for viewing javap files.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "javap-mode" '("javap-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hydra-20180703.1502/hydra-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hydra-20180703.1502/hydra-autoloads.el") (car load-path))))



(autoload 'defhydra "hydra" "\
Create a Hydra - a family of functions with prefix NAME.

NAME should be a symbol, it will be the prefix of all functions
defined here.

BODY has the format:

    (BODY-MAP BODY-KEY &rest BODY-PLIST)

DOCSTRING will be displayed in the echo area to identify the
Hydra.  When DOCSTRING starts with a newline, special Ruby-style
substitution will be performed by `hydra--format'.

Functions are created on basis of HEADS, each of which has the
format:

    (KEY CMD &optional HINT &rest PLIST)

BODY-MAP is a keymap; `global-map' is used quite often.  Each
function generated from HEADS will be bound in BODY-MAP to
BODY-KEY + KEY (both are strings passed to `kbd'), and will set
the transient map so that all following heads can be called
though KEY only.  BODY-KEY can be an empty string.

CMD is a callable expression: either an interactive function
name, or an interactive lambda, or a single sexp (it will be
wrapped in an interactive lambda).

HINT is a short string that identifies its head.  It will be
printed beside KEY in the echo erea if `hydra-is-helpful' is not
nil.  If you don't even want the KEY to be printed, set HINT
explicitly to nil.

The heads inherit their PLIST from BODY-PLIST and are allowed to
override some keys.  The keys recognized are :exit and :bind.
:exit can be:

- nil (default): this head will continue the Hydra state.
- t: this head will stop the Hydra state.

:bind can be:
- nil: this head will not be bound in BODY-MAP.
- a lambda taking KEY and CMD used to bind a head.

It is possible to omit both BODY-MAP and BODY-KEY if you don't
want to bind anything.  In that case, typically you will bind the
generated NAME/body command.  This command is also the return
result of `defhydra'.

\(fn NAME BODY &optional DOCSTRING &rest HEADS)" nil t)

(function-put 'defhydra 'lisp-indent-function 'defun)

(function-put 'defhydra 'doc-string-elt '3)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hydra" '("defhydradio" "hydra-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hydra-examples" '("hydra-" "org-agenda-cts" "whitespace-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hydra-ox" '("hydra-ox")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lv" '("lv-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ivy-hydra-20180614.2200/ivy-hydra-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ivy-hydra-20180614.2200/ivy-hydra-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy-hydra" '("hydra-ivy" "ivy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/counsel-20180813.2122/counsel-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/counsel-20180813.2122/counsel-autoloads.el") (car load-path))))



(autoload 'counsel-el "counsel" "\
Elisp completion at point.

\(fn)" t nil)

(autoload 'counsel-cl "counsel" "\
Common Lisp completion at point.

\(fn)" t nil)

(autoload 'counsel-clj "counsel" "\
Clojure completion at point.

\(fn)" t nil)

(autoload 'counsel-company "counsel" "\
Complete using `company-candidates'.

\(fn)" t nil)

(autoload 'counsel-irony "counsel" "\
Inline C/C++ completion using Irony.

\(fn)" t nil)

(autoload 'counsel-describe-variable "counsel" "\
Forward to `describe-variable'.

Variables declared using `defcustom' are highlighted according to
`ivy-highlight-face'.

\(fn)" t nil)

(autoload 'counsel-describe-function "counsel" "\
Forward to `describe-function'.

Interactive functions (i.e., commands) are highlighted according
to `ivy-highlight-face'.

\(fn)" t nil)

(autoload 'counsel-set-variable "counsel" "\
Set a variable, with completion.

When the selected variable is a `defcustom' with the type boolean
or radio, offer completion of all possible values.

Otherwise, offer a variant of `eval-expression', with the initial
input corresponding to the chosen variable.

With a prefix arg, restrict list to variables defined using
`defcustom'.

\(fn SYM)" t nil)

(autoload 'counsel-apropos "counsel" "\
Show all matching symbols.
See `apropos' for further information on what is considered
a symbol and how to search for them.

\(fn)" t nil)

(autoload 'counsel-info-lookup-symbol "counsel" "\
Forward to `info-lookup-symbol' with ivy completion.

\(fn SYMBOL &optional MODE)" t nil)

(autoload 'counsel-M-x "counsel" "\
Ivy version of `execute-extended-command'.
Optional INITIAL-INPUT is the initial input in the minibuffer.
This function integrates with either the `amx' or `smex' package
when available, in that order of precedence.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-load-library "counsel" "\
Load a selected the Emacs Lisp library.
The libraries are offered from `load-path'.

\(fn)" t nil)

(autoload 'counsel-find-library "counsel" "\
Visit a selected the Emacs Lisp library.
The libraries are offered from `load-path'.

\(fn)" t nil)

(autoload 'counsel-load-theme "counsel" "\
Forward to `load-theme'.
Usable with `ivy-resume', `ivy-next-line-and-call' and
`ivy-previous-line-and-call'.

\(fn)" t nil)

(autoload 'counsel-descbinds "counsel" "\
Show a list of all defined keys and their definitions.
If non-nil, show only bindings that start with PREFIX.
BUFFER defaults to the current one.

\(fn &optional PREFIX BUFFER)" t nil)

(autoload 'counsel-faces "counsel" "\
Complete faces with preview.
Actions are provided by default for describing or customizing the
selected face.

\(fn)" t nil)

(autoload 'counsel-git "counsel" "\
Find file in the current Git repository.
INITIAL-INPUT can be given as the initial minibuffer input.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-git-grep "counsel" "\
Grep for a string in the current git repository.
When CMD is a string, use it as a \"git grep\" command.
When CMD is non-nil, prompt for a specific \"git grep\" command.
INITIAL-INPUT can be given as the initial minibuffer input.

\(fn &optional CMD INITIAL-INPUT)" t nil)

(autoload 'counsel-git-stash "counsel" "\
Search through all available git stashes.

\(fn)" t nil)

(autoload 'counsel-git-change-worktree "counsel" "\
Find the file corresponding to the current buffer on a different worktree.

\(fn)" t nil)

(autoload 'counsel-git-checkout "counsel" "\
Call the \"git checkout\" command.

\(fn)" t nil)

(autoload 'counsel-git-log "counsel" "\
Call the \"git log --grep\" shell command.

\(fn)" t nil)

(autoload 'counsel-find-file "counsel" "\
Forward to `find-file'.
When INITIAL-INPUT is non-nil, use it in the minibuffer during completion.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-recentf "counsel" "\
Find a file on `recentf-list'.

\(fn)" t nil)

(autoload 'counsel-bookmark "counsel" "\
Forward to `bookmark-jump' or `bookmark-set' if bookmark doesn't exist.

\(fn)" t nil)

(autoload 'counsel-bookmarked-directory "counsel" "\
Ivy interface for bookmarked directories.

With a prefix argument, this command creates a new bookmark which points to the
current value of `default-directory'.

\(fn)" t nil)

(autoload 'counsel-file-register "counsel" "\
Search file in register.

You cannot use Emacs' normal register commands to create file
registers.  Instead you must use the `set-register' function like
so: `(set-register ?i \"/home/eric/.emacs.d/init.el\")'.  Now you
can use `C-x r j i' to open that file.

\(fn)" t nil)

(autoload 'counsel-locate "counsel" "\
Call the \"locate\" shell command.
INITIAL-INPUT can be given as the initial minibuffer input.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-fzf "counsel" "\
Open a file using the fzf shell command.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
FZF-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY FZF-PROMPT)" t nil)

(autoload 'counsel-dpkg "counsel" "\
Call the \"dpkg\" shell command.

\(fn)" t nil)

(autoload 'counsel-rpm "counsel" "\
Call the \"rpm\" shell command.

\(fn)" t nil)

(autoload 'counsel-file-jump "counsel" "\
Jump to a file below the current directory.
List all files within the current directory or any of its subdirectories.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY)" t nil)

(autoload 'counsel-dired-jump "counsel" "\
Jump to a directory (in dired) below the current directory.
List all subdirectories within the current directory.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY)" t nil)

(autoload 'counsel-ag "counsel" "\
Grep for a string in the current directory using ag.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
EXTRA-AG-ARGS string, if non-nil, is appended to `counsel-ag-base-command'.
AG-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY EXTRA-AG-ARGS AG-PROMPT)" t nil)

(autoload 'counsel-pt "counsel" "\
Grep for a string in the current directory using pt.
INITIAL-INPUT can be given as the initial minibuffer input.
This uses `counsel-ag' with `counsel-pt-base-command' instead of
`counsel-ag-base-command'.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-ack "counsel" "\
Grep for a string in the current directory using ack.
INITIAL-INPUT can be given as the initial minibuffer input.
This uses `counsel-ag' with `counsel-ack-base-command' replacing
`counsel-ag-base-command'.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-rg "counsel" "\
Grep for a string in the current directory using rg.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
EXTRA-RG-ARGS string, if non-nil, is appended to `counsel-rg-base-command'.
RG-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

\(fn &optional INITIAL-INPUT INITIAL-DIRECTORY EXTRA-RG-ARGS RG-PROMPT)" t nil)

(autoload 'counsel-grep "counsel" "\
Grep for a string in the file visited by the current buffer.
When non-nil, INITIAL-INPUT is the initial search pattern.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-grep-or-swiper "counsel" "\
Call `swiper' for small buffers and `counsel-grep' for large ones.
When non-nil, INITIAL-INPUT is the initial search pattern.

\(fn &optional INITIAL-INPUT)" t nil)

(autoload 'counsel-org-tag "counsel" "\
Add or remove tags in `org-mode'.

\(fn)" t nil)

(autoload 'counsel-org-tag-agenda "counsel" "\
Set tags for the current agenda item.

\(fn)" t nil)

(defalias 'counsel-org-goto #'counsel-outline)

(autoload 'counsel-org-goto-all "counsel" "\
Go to a different location in any org file.

\(fn)" t nil)

(autoload 'counsel-org-file "counsel" "\
Browse all attachments for current Org file.

\(fn)" t nil)

(autoload 'counsel-org-entity "counsel" "\
Complete Org entities using Ivy.

\(fn)" t nil)

(autoload 'counsel-org-capture "counsel" "\
Capture something.

\(fn)" t nil)

(autoload 'counsel-org-agenda-headlines "counsel" "\
Choose from headers of `org-mode' files in the agenda.

\(fn)" t nil)

(autoload 'counsel-tmm "counsel" "\
Text-mode emulation of looking and choosing from a menubar.

\(fn)" t nil)

(autoload 'counsel-yank-pop "counsel" "\
Ivy replacement for `yank-pop'.
ARG has the same meaning as in `yank-pop', but its default value
can be controlled with `counsel-yank-pop-preselect-last', which
see.  See also `counsel-yank-pop-filter' for how to filter
candidates.
Note: Duplicate elements of `kill-ring' are always deleted.

\(fn &optional ARG)" t nil)

(autoload 'counsel-imenu "counsel" "\
Jump to a buffer position indexed by imenu.

\(fn)" t nil)

(autoload 'counsel-list-processes "counsel" "\
Offer completion for `process-list'.
The default action deletes the selected process.
An extra action allows to switch to the process buffer.

\(fn)" t nil)

(autoload 'counsel-expression-history "counsel" "\
Select an element of `read-expression-history'.
And insert it into the minibuffer.  Useful during `eval-expression'.

\(fn)" t nil)

(autoload 'counsel-shell-command-history "counsel" "\
Browse shell command history.

\(fn)" t nil)

(autoload 'counsel-minibuffer-history "counsel" "\
Browse minibuffer history.

\(fn)" t nil)

(autoload 'counsel-esh-history "counsel" "\
Browse Eshell history.

\(fn)" t nil)

(autoload 'counsel-shell-history "counsel" "\
Browse shell history.

\(fn)" t nil)

(autoload 'counsel-outline "counsel" "\
Jump to an outline heading with completion.

\(fn)" t nil)

(autoload 'counsel-ibuffer "counsel" "\
Use ibuffer to switch to another buffer.
NAME specifies the name of the buffer (defaults to \"*Ibuffer*\").

\(fn &optional NAME)" t nil)

(autoload 'counsel-switch-to-shell-buffer "counsel" "\
Switch to a shell buffer, or create one.

\(fn)" t nil)

(autoload 'counsel-unicode-char "counsel" "\
Insert COUNT copies of a Unicode character at point.
COUNT defaults to 1.

\(fn &optional COUNT)" t nil)

(autoload 'counsel-colors-emacs "counsel" "\
Show a list of all supported colors for a particular frame.

You can insert or kill the name or hexadecimal RGB value of the
selected color.

\(fn)" t nil)

(autoload 'counsel-colors-web "counsel" "\
Show a list of all W3C web colors for use in CSS.

You can insert or kill the name or hexadecimal RGB value of the
selected color.

\(fn)" t nil)

(autoload 'counsel-rhythmbox "counsel" "\
Choose a song from the Rhythmbox library to play or enqueue.

\(fn)" t nil)

(autoload 'counsel-linux-app "counsel" "\
Launch a Linux desktop application, similar to Alt-<F2>.

\(fn)" t nil)

(defvar counsel-mode nil "\
Non-nil if Counsel mode is enabled.
See the `counsel-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `counsel-mode'.")

(custom-autoload 'counsel-mode "counsel" nil)

(autoload 'counsel-mode "counsel" "\
Toggle Counsel mode on or off.
Turn Counsel mode on if ARG is positive, off otherwise. Counsel
mode remaps built-in emacs functions that have counsel
replacements. 

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "counsel" '("counsel-" "ivy-function-called-at-point" "tmm-km-list")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/erlang-20180816.1134/erlang-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/erlang-20180816.1134/erlang-autoloads.el") (car load-path))))



(autoload 'erlang-mode "erlang" "\
Major mode for editing Erlang source files in Emacs.
It knows about syntax and comment, it can indent code, it is capable
of fontifying the source file, the TAGS commands are aware of Erlang
modules, and the Erlang man pages can be accessed.

Should this module, \"erlang.el\", be installed properly, Erlang mode
is activated whenever an Erlang source or header file is loaded into
Emacs.  To indicate this, the mode line should contain the word
\"Erlang\".

The main feature of Erlang mode is indentation, press TAB and the
current line will be indented correctly.

Comments starting with only one `%' are indented to the column stored
in the variable `comment-column'.  Comments starting with two `%':s
are indented with the same indentation as code.  Comments starting
with at least three `%':s are indented to the first column.

However, Erlang mode contains much more, this is a list of the most
useful commands:
     TAB     - Indent the line.
     C-c C-q - Indent current function.
     M-;     - Create a comment at the end of the line.
     M-q     - Fill a comment, i.e. wrap lines so that they (hopefully)
                 will look better.
     M-a     - Goto the beginning of an Erlang clause.
     M-C-a   - Ditto for function.
     M-e     - Goto the end of an Erlang clause.
     M-C-e   - Ditto for function.
     M-h     - Mark current Erlang clause.
     M-C-h   - Ditto for function.
     C-c C-z - Start, or switch to, an inferior Erlang shell.
     C-c C-k - Compile current file.
     C-x `   - Next error.
     ,       - Electric comma.
     ;       - Electric semicolon.

Erlang mode check the name of the file against the module name when
saving, whenever a mismatch occurs Erlang mode offers to modify the
source.

The variable `erlang-electric-commands' controls the electric
commands.  To deactivate all of them, set it to nil.

There exists a large number of commands and variables in the Erlang
module.  Please press `M-x apropos RET erlang RET' to see a complete
list.  Press `C-h f name-of-function RET' and `C-h v name-of-variable
RET'to see the full description of functions and variables,
respectively.

On entry to this mode the contents of the hook `erlang-mode-hook' is
executed.

Please see the beginning of the file `erlang.el' for more information
and examples of hooks.

Other commands:
\\{erlang-mode-map}

\(fn)" t nil)

(dolist (r '("\\.erl$" "\\.app\\.src$" "\\.escript" "\\.hrl$" "\\.xrl$" "\\.yrl" "/ebin/.+\\.app")) (add-to-list 'auto-mode-alist (cons r 'erlang-mode)))

(autoload 'erlang-find-tag "erlang" "\
Like `find-tag'.  Capable of retrieving Erlang modules.

Tags can be given on the forms `tag', `module:', `module:tag'.

\(fn MODTAGNAME &optional NEXT-P REGEXP-P)" t nil)

(autoload 'erlang-find-tag-other-window "erlang" "\
Like `find-tag-other-window' but aware of Erlang modules.

\(fn TAGNAME &optional NEXT-P REGEXP-P)" t nil)

(autoload 'erlang-shell "erlang" "\
Start a new Erlang shell.

The variable `erlang-shell-function' decides which method to use,
default is to start a new Erlang host.  It is possible that, in the
future, a new shell on an already running host will be started.

\(fn)" t nil)
 (autoload 'run-erlang "erlang" "Start a new Erlang shell." t)

(autoload 'erlang-compile "erlang" "\
Compile Erlang module in current buffer.

\(fn)" t nil)

(autoload 'inferior-erlang "erlang" "\
Run an inferior Erlang.
With prefix command, prompt for command to start Erlang with.

This is just like running Erlang in a normal shell, except that
an Emacs buffer is used for input and output.
\\<comint-mode-map>
The command line history can be accessed with  \\[comint-previous-input]  and  \\[comint-next-input].
The history is saved between sessions.

Entry to this mode calls the functions in the variables
`comint-mode-hook' and `erlang-shell-mode-hook' with no arguments.

The following commands imitate the usual Unix interrupt and
editing control characters:
\\{erlang-shell-mode-map}

\(fn &optional COMMAND)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang" '("erlang-" "inferior-erlang-" "run-erlang")))



(autoload 'erlang-edoc-mode "erlang-edoc" "\
Toggle Erlang-Edoc mode on or off.

If called interactively, enable Erlang-Edoc mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{erlang-edoc-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-edoc" '("erlang-edoc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-eunit" '("erlang-e" "filename-join")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-flymake" '("erlang-flymake-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-skels" '("erlang-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-skels-old" '("erlang-")))



(let ((a '("\\.erl\\'" . erlang-mode)) (b '("\\.hrl\\'" . erlang-mode))) (or (assoc (car a) auto-mode-alist) (setq auto-mode-alist (cons a auto-mode-alist))) (or (assoc (car b) auto-mode-alist) (setq auto-mode-alist (cons b auto-mode-alist))))

(add-to-list 'interpreter-mode-alist (cons "escript" 'erlang-mode))

(let ((erl-ext '(".jam" ".vee" ".beam"))) (while erl-ext (add-to-list 'completion-ignored-extensions (car erl-ext)) (when (boundp 'dired-omit-extensions) (add-to-list 'dired-omit-extensions (car erl-ext))) (setq erl-ext (cdr erl-ext))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-test" '("erlang-")))



(autoload 'erldoc-browse "erldoc" "\


\(fn MFA)" t nil)

(autoload 'erldoc-apropos "erldoc" "\


\(fn PATTERN)" t nil)

(autoload 'erldoc-eldoc-function "erldoc" "\
A function suitable for `eldoc-documentation-function'.

\(fn)" nil nil)

(autoload 'erldoc-browse-topic "erldoc" "\


\(fn TOPIC)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erldoc" '("erldoc-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ivy-erlang-complete-20180716.444/ivy-erlang-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ivy-erlang-complete-20180716.444/ivy-erlang-complete-autoloads.el") (car load-path))))



(autoload 'ivy-erlang-complete-autosetup-project-root "ivy-erlang-complete" "\
Automatically setup erlang project root.

\(fn)" t nil)

(autoload 'ivy-erlang-complete-init "ivy-erlang-complete" "\
Config ivy-erlang-complete by default.

\(fn)" t nil)

(autoload 'ivy-erlang-complete-show-doc-at-point "ivy-erlang-complete" "\
Show doc for function from standart library.

\(fn)" t nil)

(autoload 'ivy-erlang-complete-reparse "ivy-erlang-complete" "\
Reparse macros and recors for completion in current buffer.

\(fn)" t nil)

(autoload 'ivy-erlang-complete-set-project-root "ivy-erlang-complete" "\
Set root for current project.

\(fn)" t nil)

(autoload 'ivy-erlang-complete "ivy-erlang-complete" "\
Erlang completion at point.

\(fn)" t nil)

(autoload 'ivy-erlang-complete--find-definition "ivy-erlang-complete" "\
Search THING definition in DIRECTORY-PATH.

\(fn THING)" nil nil)

(autoload 'ivy-erlang-complete-find-spec "ivy-erlang-complete" "\
Find spec at point.  It also find callback definition.

\(fn)" t nil)

(autoload 'ivy-erlang-complete-find-definition "ivy-erlang-complete" "\
Find erlang definition.

\(fn)" t nil)

(autoload 'ivy-erlang-complete-find-references "ivy-erlang-complete" "\
Find erlang references.

\(fn)" t nil)

(autoload 'ivy-erlang-complete-find-file "ivy-erlang-complete" "\
Find file in current project.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy-erlang-complete" '("ivy-erlang-complete-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ivy-dired-history-20170626.556/ivy-dired-history-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ivy-dired-history-20170626.556/ivy-dired-history-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ivy-dired-history" '("ivy-dired-history-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/isend-mode-20171118.1545/isend-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/isend-mode-20171118.1545/isend-mode-autoloads.el") (car load-path))))



(let ((loads (get 'isend 'custom-loads))) (if (member '"isend-mode" loads) nil (put 'isend 'custom-loads (cons '"isend-mode" loads))))

(defvar isend-forward-line t "\
If non-nil, `isend-send' advances by one line after sending content.")

(custom-autoload 'isend-forward-line "isend-mode" t)

(defvar isend-skip-empty-lines t "\
If non-nil, `isend-send' skips empty lines (i.e. lines containing only spaces).

Note that this is effective only for sending single lines. To strip whitespace
from sent regions use `isend-strip-empty-lines'.")

(custom-autoload 'isend-skip-empty-lines "isend-mode" t)

(defvar isend-strip-empty-lines nil "\
If non-nil, `isend-send' strips empty lines (i.e. lines containing only spaces).

Note that this works when sending an entire region. If enabled, all lines containing
whitespace only will be stripped from the region before it is sent.")

(custom-autoload 'isend-strip-empty-lines "isend-mode" t)

(defvar isend-delete-indentation nil "\
If non-nil, `isend-send' deletes indentation in regions sent.

Note that this only works when sending a region (as opposed to a
single line). Relative indentation with respect to the first line
in the region is preserved.

This is useful to send e.g. Python blocks.")

(custom-autoload 'isend-delete-indentation "isend-mode" t)

(defvar isend-end-with-empty-line nil "\
If non-nil, `isend-send' appends an empty line to everything you send.

This is useful, for example, when working with python code,
in which whitespace terminates definitions.")

(custom-autoload 'isend-end-with-empty-line "isend-mode" t)

(defvar isend-send-line-function 'insert-buffer-substring "\
Function used by `isend-send' to send a single line.

This function takes as argument the name of a buffer containing
the text to be sent.

Possible values include:
- `insert-buffer-substring' (default)
- `isend--ipython-cpaste'
- `isend--ipython-paste'")

(custom-autoload 'isend-send-line-function "isend-mode" t)

(defvar isend-send-region-function 'insert-buffer-substring "\
Function used by `isend-send' to send a region.

This function takes as argument the name of a buffer containing
the text to be sent.

Possible values include:
- `insert-buffer-substring' (default)
- `isend--ipython-cpaste'
- `isend--ipython-paste'")

(custom-autoload 'isend-send-region-function "isend-mode" t)

(defvar isend-mark-defun-function 'mark-defun "\
Function used by `isend-defun' to select a function definition.

This function should take no argument.

Possible values include:
- `mark-defun' (default)
- `isend--python-mark-defun'")

(custom-autoload 'isend-mark-defun-function "isend-mode" t)

(autoload 'isend-default-shell-setup "isend-mode" "\


\(fn)" nil nil)

(autoload 'isend-default-python-setup "isend-mode" "\


\(fn)" nil nil)

(autoload 'isend-default-ipython-setup "isend-mode" "\


\(fn)" nil nil)

(autoload 'isend-associate "isend-mode" "\
Set the buffer to which commands will be sent using `isend-send'.
This should usually be something like '*ansi-term*' or '*terminal*'.

\(fn BUFFERNAME)" t nil)

(defalias 'isend 'isend-associate)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "isend-mode" '("isend-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ipretty-20180606.522/ipretty-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ipretty-20180606.522/ipretty-autoloads.el") (car load-path))))



(autoload 'ipretty-last-sexp "ipretty" "\
Pretty-print the last sexp into the current buffer.
When TRUNCATE is non-nil or with a prefix argument, long output
is truncated. See the documentation of `eval-print-last-sexp' for
more information on what affects truncation.

\(fn &optional TRUNCATE)" t nil)

(autoload 'ipretty-last-sexp-other-buffer "ipretty" "\
Display the last sexp pretty-printed in other buffer.
If BUFFER-NAME (a string)is provided it will be used to name the
buffer, otherwise the default `*pp-display-expression*' is used.

\(fn &optional BUFFER-NAME)" t nil)

(defvar ipretty-mode nil "\
Non-nil if Ipretty mode is enabled.
See the `ipretty-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ipretty-mode'.")

(custom-autoload 'ipretty-mode "ipretty" nil)

(autoload 'ipretty-mode "ipretty" "\
Toggle ipretty mode globally.
   With no argument, this command toggles the mode.
   Non-null prefix argument turns on the mode.
   Null prefix argument turns off the mode.

If called interactively, enable Ipretty mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/inline-docs-20170523.450/inline-docs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/inline-docs-20170523.450/inline-docs-autoloads.el") (car load-path))))



(autoload 'inline-docs-display-docs-momentary "inline-docs" "\
Display inline docs FORMAT-STRING under point with extra ARGS.

\(fn FORMAT-STRING &rest ARGS)" nil nil)

(defalias 'inline-docs 'inline-docs-display-docs-momentary)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inline-docs" '("inline-docs-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/inflections-20170913.916/inflections-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/inflections-20170913.916/inflections-autoloads.el") (car load-path))))



(autoload 'inflection-singularize-string "inflections" "\
Return the singularized version of STR.

\(fn STR)" nil nil)

(define-obsolete-function-alias 'singularize-string 'inflection-singularize-string)

(autoload 'inflection-pluralize-string "inflections" "\
Return the pluralized version of STR.

\(fn STR)" nil nil)

(define-obsolete-function-alias 'pluralize-string 'inflection-pluralize-string)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inflections" '("define-inflectors" "inflection-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/inf-clojure-20180402.2103/inf-clojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/inf-clojure-20180402.2103/inf-clojure-autoloads.el") (car load-path))))



(autoload 'inf-clojure-minor-mode "inf-clojure" "\
Minor mode for interacting with the inferior Clojure process buffer.

If called interactively, enable Inf-Clojure minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

The following commands are available:

\\{inf-clojure-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'inf-clojure "inf-clojure" "\
Run an inferior Clojure process, input and output via buffer `*inf-clojure*'.
If there is a process already running in `*inf-clojure*', just switch
to that buffer.
With argument, allows you to edit the CMD used to launch
it (default is value of `inf-clojure-*-cmd').  Runs the hooks
from `inf-clojure-mode-hook' (after the `comint-mode-hook' is
run).
\(Type \\[describe-mode] in the process buffer for a list of commands.)

\(fn CMD)" t nil)

(autoload 'inf-clojure-connect "inf-clojure" "\
Connect to a running socket-repl via `inf-clojure'.
HOST is the host the process is running on, PORT is where it's listening.

\(fn HOST PORT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inf-clojure" '("inf-clojure-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/iedit-20180207.1019/iedit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/iedit-20180207.1019/iedit-autoloads.el") (car load-path))))



(autoload 'iedit-mode "iedit" "\
Toggle Iedit mode.
This command behaves differently, depending on the mark, point,
prefix argument and variable `iedit-transient-mark-sensitive'.

If Iedit mode is off, turn Iedit mode on.

When Iedit mode is turned on, all the occurrences of the current
region in the buffer (possibly narrowed) or a region are
highlighted.  If one occurrence is modified, the change are
propagated to all other occurrences simultaneously.

If region is not active, `iedit-default-occurrence' is called to
get an occurrence candidate, according to the thing at point.  It
might be url, email address, markup tag or current symbol(or
word).

In the above two situations, with digit prefix argument 0, only
occurrences in current function are matched.  This is good for
renaming refactoring in programming.

You can also switch to Iedit mode from isearch mode directly. The
current search string is used as occurrence.  All occurrences of
the current search string are highlighted.

With an universal prefix argument, the occurrence when Iedit mode
is turned off last time in current buffer is used as occurrence.
This is intended to recover last Iedit mode which is turned off.
If region active, Iedit mode is limited within the current
region.

With repeated universal prefix argument, the occurrence when
Iedit mode is turned off last time (might be in other buffer) is
used as occurrence.  If region active, Iedit mode is limited
within the current region.

With digital prefix argument 1, Iedit mode is limited on the
current symbol or the active region, which means just one
instance is highlighted.  This behavior serves as a start point
of incremental selection work flow.

If Iedit mode is on and region is active, Iedit mode is
restricted in the region, e.g. the occurrences outside of the
region is excluded.

If Iedit mode is on and region is active, with an universal
prefix argument, Iedit mode is restricted outside of the region,
e.g. the occurrences in the region is excluded.

Turn off Iedit mode in other situations.

Commands:
\\{iedit-mode-keymap}
Keymap used within overlays:
\\{iedit-mode-occurrence-keymap}

\(fn &optional ARG)" t nil)

(autoload 'iedit-mode-toggle-on-function "iedit" "\
Toggle Iedit mode on current function.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "iedit" '("iedit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "iedit-lib" '("iedit-")))



(autoload 'iedit-rectangle-mode "iedit-rect" "\
Toggle Iedit-rect mode.

When Iedit-rect mode is on, a rectangle is started with visible
rectangle highlighting.  Rectangle editing support is based on
Iedit mechanism.

Commands:
\\{iedit-rect-keymap}

\(fn &optional BEG END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "iedit-rect" '("iedit-rect")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ido-at-point-20151021.757/ido-at-point-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ido-at-point-20151021.757/ido-at-point-autoloads.el") (car load-path))))



(autoload 'ido-at-point-mode "ido-at-point" "\
Global minor mode to use ido for `completion-at-point'.

When called interactively, toggle `ido-at-point-mode'.  With
prefix ARG, enable `ido-at-point-mode' if ARG is positive,
otherwise disable it.

When called from Lisp, enable `ido-at-point-mode' if ARG is
omitted, nil or positive.  If ARG is `toggle', toggle
`ido-at-point-mode'.  Otherwise behave as if called
interactively.

With `ido-at-point-mode' use ido for `completion-at-point'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ido-at-point" '("ido-at-point-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hungry-delete-20170412.102/hungry-delete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hungry-delete-20170412.102/hungry-delete-autoloads.el") (car load-path))))



(autoload 'hungry-delete-forward "hungry-delete" "\
Delete the following character, or all of the following
whitespace, up to the next non-whitespace character.  See
\\[c-hungry-delete-forward].

hungry-delete-backward tries to mimic delete-backward-char's
behavior in several ways: if the region is activate, it deletes
the text in the region.  If a prefix argument is given, delete
the following N characters (previous if N is negative).

Optional second arg KILLFLAG non-nil means to kill (save in kill
ring) instead of delete.  Interactively, N is the prefix arg, and
KILLFLAG is set if N was explicitly specified.

\(fn N &optional KILLFLAG)" t nil)

(autoload 'hungry-delete-backward "hungry-delete" "\
Delete the preceding character or all preceding whitespace
back to the previous non-whitespace character.  See also
\\[c-hungry-delete-backward].

hungry-delete-backward tries to mimic delete-backward-char's
behavior in several ways: if the region is activate, it deletes
the text in the region.  If a prefix argument is given, delete
the previous N characters (following if N is negative).

In Overwrite mode, single character backward deletion may replace
tabs with spaces so as to back over columns, unless point is at
the end of the line.

Optional second arg KILLFLAG, if non-nil, means to kill (save in
kill ring) instead of delete.  Interactively, N is the prefix
arg, and KILLFLAG is set if N is explicitly specified.

\(fn N &optional KILLFLAG)" t nil)

(autoload 'hungry-delete-mode "hungry-delete" "\
Minor mode to enable hungry deletion.  This will delete all
whitespace after or before point when the deletion command is
executed.

If called interactively, enable Hungry-Delete mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-hungry-delete-mode "hungry-delete" "\
Turn on hungry delete mode if the buffer is appropriate.

\(fn)" t nil)

(defvar global-hungry-delete-mode nil "\
Non-nil if Global Hungry-Delete mode is enabled.
See the `global-hungry-delete-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-hungry-delete-mode'.")

(custom-autoload 'global-hungry-delete-mode "hungry-delete" nil)

(autoload 'global-hungry-delete-mode "hungry-delete" "\
Toggle Hungry-Delete mode in all buffers.
With prefix ARG, enable Global Hungry-Delete mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Hungry-Delete mode is enabled in all buffers where
`turn-on-hungry-delete-mode' would do it.
See `hungry-delete-mode' for more information on Hungry-Delete mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hungry-delete" '("hungry-delete-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/htmlize-20180412.1944/htmlize-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/htmlize-20180412.1944/htmlize-autoloads.el") (car load-path))))



(autoload 'htmlize-buffer "htmlize" "\
Convert BUFFER to HTML, preserving colors and decorations.

The generated HTML is available in a new buffer, which is returned.
When invoked interactively, the new buffer is selected in the current
window.  The title of the generated document will be set to the buffer's
file name or, if that's not available, to the buffer's name.

Note that htmlize doesn't fontify your buffers, it only uses the
decorations that are already present.  If you don't set up font-lock or
something else to fontify your buffers, the resulting HTML will be
plain.  Likewise, if you don't like the choice of colors, fix the mode
that created them, or simply alter the faces it uses.

\(fn &optional BUFFER)" t nil)

(autoload 'htmlize-region "htmlize" "\
Convert the region to HTML, preserving colors and decorations.
See `htmlize-buffer' for details.

\(fn BEG END)" t nil)

(autoload 'htmlize-file "htmlize" "\
Load FILE, fontify it, convert it to HTML, and save the result.

Contents of FILE are inserted into a temporary buffer, whose major mode
is set with `normal-mode' as appropriate for the file type.  The buffer
is subsequently fontified with `font-lock' and converted to HTML.  Note
that, unlike `htmlize-buffer', this function explicitly turns on
font-lock.  If a form of highlighting other than font-lock is desired,
please use `htmlize-buffer' directly on buffers so highlighted.

Buffers currently visiting FILE are unaffected by this function.  The
function does not change current buffer or move the point.

If TARGET is specified and names a directory, the resulting file will be
saved there instead of to FILE's directory.  If TARGET is specified and
does not name a directory, it will be used as output file name.

\(fn FILE &optional TARGET)" t nil)

(autoload 'htmlize-many-files "htmlize" "\
Convert FILES to HTML and save the corresponding HTML versions.

FILES should be a list of file names to convert.  This function calls
`htmlize-file' on each file; see that function for details.  When
invoked interactively, you are prompted for a list of files to convert,
terminated with RET.

If TARGET-DIRECTORY is specified, the HTML files will be saved to that
directory.  Normally, each HTML file is saved to the directory of the
corresponding source file.

\(fn FILES &optional TARGET-DIRECTORY)" t nil)

(autoload 'htmlize-many-files-dired "htmlize" "\
HTMLize dired-marked files.

\(fn ARG &optional TARGET-DIRECTORY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "htmlize" '("htmlize-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hlinum-20180422.412/hlinum-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hlinum-20180422.412/hlinum-autoloads.el") (car load-path))))



(autoload 'hlinum-activate "hlinum" "\
Enable highlighting current line number.

\(fn)" t nil)

(autoload 'hlinum-deactivate "hlinum" "\
Disable highlighting current line number.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hlinum" '("hlinum-" "linum-highlight-in-all-buffersp")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hippie-namespace-20140508.2041/hippie-namespace-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hippie-namespace-20140508.2041/hippie-namespace-autoloads.el") (car load-path))))



(let ((loads (get 'hippie-namespace 'custom-loads))) (if (member '"hippie-namespace" loads) nil (put 'hippie-namespace 'custom-loads (cons '"hippie-namespace" loads))))

(let ((loads (get 'hippie-namespace-global 'custom-loads))) (if (member '"hippie-namespace" loads) nil (put 'hippie-namespace-global 'custom-loads (cons '"hippie-namespace" loads))))

(put 'hippie-namespace-local-list 'safe-local-variable 'listp)

(autoload 'hippie-namespace-populate-list "hippie-namespace" "\
Populate `hippie-namespace-computed-list' from buffer contents.

When optional FORCE is set, repopulate even if
`hippie-namespace-computed-list' is already set.

\(fn &optional FORCE)" nil nil)

(autoload 'hippie-namespace-mark-symbol-portion "hippie-namespace" "\
Mark the namespace or non-namespace portion of a symbol under the point.

Intended for use with `expand-region' as an element of
`er/try-expand-list'.

If the point is in the namespace or non-namespace portion of
a symbol, mark only that portion of the symbol.

If the point is in a symbol which does not match a namespace,
there is no effect.

\(fn)" t nil)

(autoload 'hippie-namespace-mode "hippie-namespace" "\
Turn on hippie-namespace-mode.

If called interactively, enable Hippie-Namespace mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

When called interactively with no prefix argument this command
toggles the mode.  With a prefix argument, it enables the mode
if the argument is positive and otherwise disables the mode.

When called from Lisp, this command enables the mode if the
argument is omitted or nil, and toggles the mode if the argument
is 'toggle.

\(fn &optional ARG)" t nil)

(defvar global-hippie-namespace-mode nil "\
Non-nil if Global Hippie-Namespace mode is enabled.
See the `global-hippie-namespace-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-hippie-namespace-mode'.")

(custom-autoload 'global-hippie-namespace-mode "hippie-namespace" nil)

(autoload 'global-hippie-namespace-mode "hippie-namespace" "\
Toggle Hippie-Namespace mode in all buffers.
With prefix ARG, enable Global Hippie-Namespace mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Hippie-Namespace mode is enabled in all buffers where
`hippie-namespace-maybe-turn-on' would do it.
See `hippie-namespace-mode' for more information on Hippie-Namespace mode.

\(fn &optional ARG)" t nil)

(autoload 'hippie-namespace-reload "hippie-namespace" "\
Force a refresh of `hippie-namespace-computed-list'.

`hippie-namespace-computed-list' is used by `try-expand-namespace'.

With prefix ARG, also wipe `hippie-namespace-manual-list'.

\(fn ARG)" t nil)

(autoload 'hippie-namespace-add "hippie-namespace" "\
Manually add NAMESPACE to the list available to `try-expand-namespace'.

Modifies `hippie-namespace-manual-list', and refreshes by running
`hippie-namespace-populate-list'.

\(fn NAMESPACE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hippie-namespace" '("he-namespace-beg" "hippie-namespace-" "try-expand-namespace")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/hippie-exp-ext-20160502.2326/hippie-exp-ext-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/hippie-exp-ext-20160502.2326/hippie-exp-ext-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "hippie-exp-ext" '("he-" "hippie-expand-" "try-expand-dabbrev-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-unique-symbol-20130612.542/highlight-unique-symbol-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-unique-symbol-20130612.542/highlight-unique-symbol-autoloads.el") (car load-path))))



(autoload 'highlight-unique-symbol "highlight-unique-symbol" "\
Start highlighting unique symbols

\(fn START)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-unique-symbol" '("highlight-unique-symbol:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-thing-20170919.1404/highlight-thing-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-thing-20170919.1404/highlight-thing-autoloads.el") (car load-path))))



(autoload 'highlight-thing-mode "highlight-thing" "\
Minor mode that highlights things at point

If called interactively, enable Highlight-Thing mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-highlight-thing-mode nil "\
Non-nil if Global Highlight-Thing mode is enabled.
See the `global-highlight-thing-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-highlight-thing-mode'.")

(custom-autoload 'global-highlight-thing-mode "highlight-thing" nil)

(autoload 'global-highlight-thing-mode "highlight-thing" "\
Toggle Highlight-Thing mode in all buffers.
With prefix ARG, enable Global Highlight-Thing mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Thing mode is enabled in all buffers where
`highlight-thing-mode-maybe-activate' would do it.
See `highlight-thing-mode' for more information on Highlight-Thing mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-thing" '("highlight-thing-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-symbol-20160102.2009/highlight-symbol-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-symbol-20160102.2009/highlight-symbol-autoloads.el") (car load-path))))



(autoload 'highlight-symbol-mode "highlight-symbol" "\
Minor mode that highlights the symbol under point throughout the buffer.
Highlighting takes place after `highlight-symbol-idle-delay'.

If called interactively, enable Highlight-Symbol mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defalias 'highlight-symbol-at-point 'highlight-symbol)

(autoload 'highlight-symbol "highlight-symbol" "\
Toggle highlighting of the symbol at point.
This highlights or unhighlights the symbol at point using the first
element in of `highlight-symbol-faces'.

\(fn &optional SYMBOL)" t nil)

(autoload 'highlight-symbol-remove-all "highlight-symbol" "\
Remove symbol highlighting in buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-list-all "highlight-symbol" "\
List all symbols highlighted in the buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-count "highlight-symbol" "\
Print the number of occurrences of symbol at point.

\(fn &optional SYMBOL MESSAGE-P)" t nil)

(autoload 'highlight-symbol-next "highlight-symbol" "\
Jump to the next location of the symbol at point within the buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-prev "highlight-symbol" "\
Jump to the previous location of the symbol at point within the buffer.

\(fn)" t nil)

(autoload 'highlight-symbol-next-in-defun "highlight-symbol" "\
Jump to the next location of the symbol at point within the defun.

\(fn)" t nil)

(autoload 'highlight-symbol-prev-in-defun "highlight-symbol" "\
Jump to the previous location of the symbol at point within the defun.

\(fn)" t nil)

(autoload 'highlight-symbol-nav-mode "highlight-symbol" "\
Navigate occurrences of the symbol at point.

When called interactively, toggle `highlight-symbol-nav-mode'.
With prefix ARG, enable `highlight-symbol-nav-mode' if ARG is
positive, otherwise disable it.

When called from Lisp, enable `highlight-symbol-nav-mode' if ARG
is omitted, nil or positive.  If ARG is `toggle', toggle
`highlight-symbol-nav-mode'.  Otherwise behave as if called
interactively.

In `highlight-symbol-nav-mode' provide the following key bindings
to navigate between occurrences of the symbol at point in the
current buffer.

\\{highlight-symbol-nav-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'highlight-symbol-query-replace "highlight-symbol" "\
Replace the symbol at point with REPLACEMENT.

\(fn REPLACEMENT)" t nil)

(autoload 'highlight-symbol-occur "highlight-symbol" "\
Call `occur' with the symbol at point.
Each line is displayed with NLINES lines before and after, or -NLINES
before if NLINES is negative.

\(fn &optional NLINES)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-symbol" '("highlight-symbol")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-stages-20161212.1457/highlight-stages-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-stages-20161212.1457/highlight-stages-autoloads.el") (car load-path))))



(autoload 'highlight-stages-mode "highlight-stages" "\
Highlight staged (quasi-quoted) expressions

If called interactively, enable Highlight-Stages mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar highlight-stages-global-mode nil "\
Non-nil if Highlight-Stages-Global mode is enabled.
See the `highlight-stages-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `highlight-stages-global-mode'.")

(custom-autoload 'highlight-stages-global-mode "highlight-stages" nil)

(autoload 'highlight-stages-global-mode "highlight-stages" "\
Toggle Highlight-Stages mode in all buffers.
With prefix ARG, enable Highlight-Stages-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Stages mode is enabled in all buffers where
`(lambda nil (highlight-stages-mode 1))' would do it.
See `highlight-stages-mode' for more information on Highlight-Stages mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-stages" '("highlight-stages-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-refontification-20170211.2024/highlight-refontification-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-refontification-20170211.2024/highlight-refontification-autoloads.el") (car load-path))))



(autoload 'highlight-refontification-mode "highlight-refontification" "\
Minor mode that highlight bad whitespace and out-of-place characters.

If called interactively, enable Highlight-Refontification mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-refontification" '("highlight-refontification-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-quoted-20140916.1822/highlight-quoted-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-quoted-20140916.1822/highlight-quoted-autoloads.el") (car load-path))))



(autoload 'highlight-quoted-mode "highlight-quoted" "\
Highlight Lisp quotes and quoted symbols.

Toggle Highlight-Quoted mode on or off.
With a prefix argument ARG, enable Highlight-Quoted mode if ARG is positive, and
disable it otherwise.  If called from Lisp, enable the mode if ARG is omitted or
nil, and toggle it if ARG is `toggle'.
\\{highlight-quoted-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-quoted" '("highlight-quoted-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-parentheses-20180704.1102/highlight-parentheses-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-parentheses-20180704.1102/highlight-parentheses-autoloads.el") (car load-path))))



(autoload 'highlight-parentheses-mode "highlight-parentheses" "\
Minor mode to highlight the surrounding parentheses.

If called interactively, enable Highlight-Parentheses mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-highlight-parentheses-mode nil "\
Non-nil if Global Highlight-Parentheses mode is enabled.
See the `global-highlight-parentheses-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-highlight-parentheses-mode'.")

(custom-autoload 'global-highlight-parentheses-mode "highlight-parentheses" nil)

(autoload 'global-highlight-parentheses-mode "highlight-parentheses" "\
Toggle Highlight-Parentheses mode in all buffers.
With prefix ARG, enable Global Highlight-Parentheses mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Parentheses mode is enabled in all buffers where
`(lambda nil (highlight-parentheses-mode 1))' would do it.
See `highlight-parentheses-mode' for more information on Highlight-Parentheses mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-parentheses" '("hl-paren-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-operators-20170213.2220/highlight-operators-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-operators-20170213.2220/highlight-operators-autoloads.el") (car load-path))))



(autoload 'highlight-operators-mode "highlight-operators" "\
Extra highlighting for operators in programming modes.

If called interactively, enable Highlight-Operators mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-highlight-operators-mode nil "\
Non-nil if Global Highlight-Operators mode is enabled.
See the `global-highlight-operators-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-highlight-operators-mode'.")

(custom-autoload 'global-highlight-operators-mode "highlight-operators" nil)

(autoload 'global-highlight-operators-mode "highlight-operators" "\
Toggle Highlight-Operators mode in all buffers.
With prefix ARG, enable Global Highlight-Operators mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Highlight-Operators mode is enabled in all buffers where
`(lambda nil (highlight-operators-mode 1))' would do it.
See `highlight-operators-mode' for more information on Highlight-Operators mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-operators" '("highlight-operators-regexp")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-indentation-20171218.937/highlight-indentation-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-indentation-20171218.937/highlight-indentation-autoloads.el") (car load-path))))



(autoload 'highlight-indentation-mode "highlight-indentation" "\
Highlight indentation minor mode highlights indentation based on spaces

If called interactively, enable Highlight-Indentation mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'highlight-indentation-set-offset "highlight-indentation" "\
Set indentation offset localy in buffer, will prevent
highlight-indentation from trying to guess indentation offset
from major mode

\(fn OFFSET)" t nil)

(autoload 'highlight-indentation-current-column-mode "highlight-indentation" "\
Hilight Indentation minor mode displays a vertical bar
corresponding to the indentation of the current line

If called interactively, enable Highlight-Indentation-Current-Column mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-indentation" '("highlight-indentation-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-indent-guides-20180529.1739/highlight-indent-guides-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-indent-guides-20180529.1739/highlight-indent-guides-autoloads.el") (car load-path))))



(autoload 'highlight-indent-guides-auto-set-faces "highlight-indent-guides" "\
Automatically calculate indent guide faces.
If this feature is enabled, calculate reasonable values for the indent guide
colors based on the current theme's colorscheme, and set them appropriately.
This runs whenever a theme is loaded, but it can also be run interactively.

\(fn)" t nil)

(autoload 'highlight-indent-guides-mode "highlight-indent-guides" "\
Display indent guides in a buffer.

If called interactively, enable Highlight-Indent-Guides mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-indent-guides" '("highlight-indent-guides-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-function-calls-20170908.500/highlight-function-calls-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-function-calls-20170908.500/highlight-function-calls-autoloads.el") (car load-path))))



(autoload 'highlight-function-calls-mode "highlight-function-calls" "\
Highlight function calls.

Toggle highlighting of function calls on or off.

With a prefix argument ARG, enable if ARG is positive, and
disable it otherwise. If called from Lisp, enable the mode if ARG
is omitted or nil, and toggle it if ARG is `toggle'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-function-calls" '("highlight-function-calls-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-escape-sequences-20171117.1237/highlight-escape-sequences-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-escape-sequences-20171117.1237/highlight-escape-sequences-autoloads.el") (car load-path))))



(autoload 'turn-on-hes-mode "highlight-escape-sequences" "\
Turn on highlighting of escape sequences.

\(fn)" t nil)

(autoload 'turn-off-hes-mode "highlight-escape-sequences" "\
Turn off highlighting of escape sequences

\(fn)" t nil)

(defvar hes-mode nil "\
Non-nil if Hes mode is enabled.
See the `hes-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `hes-mode'.")

(custom-autoload 'hes-mode "highlight-escape-sequences" nil)

(autoload 'hes-mode "highlight-escape-sequences" "\
Toggle highlighting of escape sequences.

If called interactively, enable Hes mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-escape-sequences" '("hes-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/highlight-defined-20141225.1530/highlight-defined-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/highlight-defined-20141225.1530/highlight-defined-autoloads.el") (car load-path))))



(autoload 'highlight-defined-mode "highlight-defined" "\
Minor mode for highlighting known Emacs Lisp functions and variables.

Toggle highlight defined mode on or off.

With a prefix argument ARG, enable highlight defined mode if ARG is
positive, and disable it otherwise. If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "highlight-defined" '("highlight-defined--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/edn-20160215.1219/edn-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/edn-20160215.1219/edn-autoloads.el") (car load-path))))



(autoload 'edn-time-to-inst "edn" "\
Turn a `time-date' TIME into our internal representation of an inst.

\(fn TIME)" nil nil)

(autoload 'edn-inst-to-time "edn" "\
Turn an `edn-inst', INST, into a TIME from `time-date'.

\(fn INST)" nil nil)

(autoload 'edn-string-to-uuid "edn" "\
Create an `edn-uuid' from a string, S, containing a uuid.

\(fn S)" nil nil)

(autoload 'edn-uuid-to-string "edn" "\
Turn our internal representation of a UUID into a string.

\(fn UUID)" nil nil)

(autoload 'edn-read "edn" "\
Read one edn value from SOURCE.

SOURCE is either a string of edn data or nil.  If no source is
given the next edn value will be read from POINT in the current
buffer.

You can use `edn-add-reader' to add your own readers for unknown
tags.

\(fn &optional SOURCE)" nil nil)

(autoload 'edn-list-to-set "edn" "\
Turn a list into `edn''s internal set representation.

If COMPARE-FN is provided this function is used to uniquify the
list.  Otherwise it's expected that l is without duplicates.

\(fn L &optional COMPARE-FN)" nil nil)

(autoload 'edn-set-to-list "edn" "\
Turn `edn''s internal set representation into a list.

\(fn S)" nil nil)

(autoload 'edn-add-reader "edn" "\
Add a READER function for TAG.

TAG is either a string, symbol or keyword. e.g. :my/type

\(fn TAG READER)" nil nil)

(autoload 'edn-add-writer "edn" "\
Add a WRITER function for types satisfying PRED.

\(fn PRED WRITER)" nil nil)

(autoload 'edn-remove-reader "edn" "\
Remove a previously registered handler for TAG.

\(fn TAG)" nil nil)

(autoload 'edn-remove-writer "edn" "\
The remove the writer WRITER.

\(fn WRITER)" nil nil)

(autoload 'edn-print-string "edn" "\
Serialize the lisp form DATUM into edn.

You can use `edn-add-writer' to add writers capable of writing
your own tagged data.

\(fn DATUM)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "edn" '("edn--" "hash-table-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/helm-clojuredocs-20160405.723/helm-clojuredocs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/helm-clojuredocs-20160405.723/helm-clojuredocs-autoloads.el") (car load-path))))



(autoload 'helm-clojuredocs "helm-clojuredocs" "\
Preconfigured `helm' for searching in clojuredocs.org

\(fn)" t nil)

(autoload 'helm-clojuredocs-at-point "helm-clojuredocs" "\
Preconfigured `helm' for searching in clojuredocs.org with symbol at point

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "helm-clojuredocs" '("helm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/google-c-style-20180130.1736/google-c-style-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/google-c-style-20180130.1736/google-c-style-autoloads.el") (car load-path))))



(defconst google-c-style `((c-recognize-knr-p) (c-enable-xemacs-performance-kludge-p . t) (c-basic-offset . 2) (indent-tabs-mode) (c-comment-only-line-offset . 0) (c-hanging-braces-alist (defun-open after) (defun-close before after) (class-open after) (class-close before after) (inexpr-class-open after) (inexpr-class-close before) (namespace-open after) (inline-open after) (inline-close before after) (block-open after) (block-close . c-snug-do-while) (extern-lang-open after) (extern-lang-close after) (statement-case-open after) (substatement-open after)) (c-hanging-colons-alist (case-label) (label after) (access-label after) (member-init-intro before) (inher-intro)) (c-hanging-semi&comma-criteria c-semi&comma-no-newlines-for-oneline-inliners c-semi&comma-inside-parenlist c-semi&comma-no-newlines-before-nonblanks) (c-indent-comments-syntactically-p . t) (comment-column . 40) (c-indent-comment-alist (other space . 2)) (c-cleanup-list brace-else-brace brace-elseif-brace brace-catch-brace empty-defun-braces defun-close-semi list-close-comma scope-operator) (c-offsets-alist (arglist-intro google-c-lineup-expression-plus-4) (func-decl-cont . ++) (member-init-intro . ++) (inher-intro . ++) (comment-intro . 0) (arglist-close . c-lineup-arglist) (topmost-intro . 0) (block-open . 0) (inline-open . 0) (substatement-open . 0) (statement-cont ,(when (fboundp 'c-no-indent-after-java-annotations) 'c-no-indent-after-java-annotations) ,(when (fboundp 'c-lineup-assignments) 'c-lineup-assignments) ++) (label . /) (case-label . +) (statement-case-open . +) (statement-case-intro . +) (access-label . /) (innamespace . 0))) "\
Google C/C++ Programming Style.")

(autoload 'google-set-c-style "google-c-style" "\
Set the current buffer's c-style to Google C/C++ Programming
  Style. Meant to be added to `c-mode-common-hook'.

\(fn)" t nil)

(autoload 'google-make-newline-indent "google-c-style" "\
Sets up preferred newline behavior. Not set by default. Meant
  to be added to `c-mode-common-hook'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "google-c-style" '("google-c-lineup-expression-plus-4")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/golden-ratio-scroll-screen-20170224.229/golden-ratio-scroll-screen-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/golden-ratio-scroll-screen-20170224.229/golden-ratio-scroll-screen-autoloads.el") (car load-path))))



(autoload 'golden-ratio-scroll-screen-up "golden-ratio-scroll-screen" "\
scroll half screen up

\(fn)" t nil)

(autoload 'golden-ratio-scroll-screen-down "golden-ratio-scroll-screen" "\
scroll half screen down

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "golden-ratio-scroll-screen" '("golden-ratio-scroll-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gitlab-20180312.1647/gitlab-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gitlab-20180312.1647/gitlab-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-api" '("gitlab-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-browse" '("gitlab-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-groups" '("gitlab-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-http" '("gitlab--" "perform-gitlab-request")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-issues" '("gitlab-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-milestones" '("gitlab-")))



(autoload 'gitlab-show-project-description "gitlab-mode" "\
Doc string PROJECT.

\(fn PROJECT)" t nil)

(autoload 'gitlab-show-issues "gitlab-mode" "\
Show Gitlab issues.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-mode" '("create-" "gitlab-" "print-current-" "project-make-button")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-notes" '("gitlab-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-projects" '("gitlab-")))



(autoload 'with-gitlab-auth "gitlab-session" "\
Macro which checks authentication token. If not defined, signals an
error.  Otherwise, executes `BODY'.

\(fn &rest BODY)" nil t)



(autoload 'gitlab-mode "gitlab-ui" "\
Special mode for Gitlab buffers.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-ui" '("colorize-dot" "gitlab-" "helm-gitlab--buffer-name")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-users" '("gitlab-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-utils" '("gitlab-")))



(autoload 'gitlab-version "gitlab-version" "\
Get the gitlab version as string.
If called interactively or if SHOW-VERSION is non-nil, show the
version in the echo area and the messages buffer.
The returned string includes both, the version from package.el
and the library version, if both a present and different.
If the version number could not be determined, signal an error,
if called interactively, or if SHOW-VERSION is non-nil, otherwise
just return nil.

\(fn &optional SHOW-VERSION)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitlab-version" '("gitlab--library-version")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/github-issues-20160616.1841/github-issues-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/github-issues-20160616.1841/github-issues-autoloads.el") (car load-path))))



(autoload 'github-issues "github-issues" "\
Display a list of issues list for a GitHub repository.

\(fn USER REPO)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "github-issues" '("github-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gited-0.5.3/gited-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gited-0.5.3/gited-autoloads.el") (car load-path))))



(autoload 'gited-list-branches "gited" "\
List all branches or tags for the current repository.
Optional arg PATTERN if non-nil, then must be \"local\", \"remote\",
 or \"tags\".  That lists local branches, remote branches and tags,
 respectively.  When PATTERN is nil, then list the local branches.
Optional arg OTHER-WINDOW means to display the Gited buffer in another window.
Optional arg UPDATE if non-nil, then force to update the gited buffer.
 Otherwise, just switch to the Gited buffer if already exists.
When called interactively prompt for PATTERN.
When called interactively with a prefix set OTHER-WINDOW non-nil.

\(fn &optional PATTERN OTHER-WINDOW UPDATE)" t nil)

(defalias 'gited-list 'gited-list-branches)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gited" '("gited-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gited-ci" '("gited-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gitconfig-mode-20180318.1956/gitconfig-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gitconfig-mode-20180318.1956/gitconfig-mode-autoloads.el") (car load-path))))



(autoload 'gitconfig-mode "gitconfig-mode" "\
A major mode for editing .gitconfig files.

\(fn)" t nil)

(dolist (pattern '("/\\.gitconfig\\'" "/\\.git/config\\'" "/modules/.*/config\\'" "/git/config\\'" "/\\.gitmodules\\'" "/etc/gitconfig\\'")) (add-to-list 'auto-mode-alist (cons pattern 'gitconfig-mode)))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitconfig-mode" '("gitconfig-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/gitconfig-20130718.935/gitconfig-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/gitconfig-20130718.935/gitconfig-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "gitconfig" '("gitconfig-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-wip-timemachine-20150408.1006/git-wip-timemachine-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-wip-timemachine-20150408.1006/git-wip-timemachine-autoloads.el") (car load-path))))



(autoload 'git-wip-timemachine "git-wip-timemachine" "\
Enable git-wip timemachine for file of current buffer.

\(fn)" t nil)

(autoload 'git-wip-timemachine-toggle "git-wip-timemachine" "\
Toggle `git-wip-timemachine' mode.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-wip-timemachine" '("git-wip-timemachine-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-timemachine-20180607.820/git-timemachine-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-timemachine-20180607.820/git-timemachine-autoloads.el") (car load-path))))



(autoload 'git-timemachine-toggle "git-timemachine" "\
Toggle git timemachine mode.

\(fn)" t nil)

(autoload 'git-timemachine "git-timemachine" "\
Enable git timemachine for file of current buffer.

\(fn)" t nil)

(autoload 'git-timemachine-switch-branch "git-timemachine" "\
Enable git timemachine for current buffer, switching to GIT-BRANCH.

\(fn GIT-BRANCH)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-timemachine" '("git-timemachine-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-msg-prefix-20180118.1446/git-msg-prefix-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-msg-prefix-20180118.1446/git-msg-prefix-autoloads.el") (car load-path))))



(autoload 'git-msg-prefix "git-msg-prefix" "\
Insert the relevant part of the chosen commit.
Relevant meaning the result of `git-msg-prefix-regex'
substitution.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-msg-prefix" '("git-msg-prefix-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-messenger-20170102.440/git-messenger-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-messenger-20170102.440/git-messenger-autoloads.el") (car load-path))))



(autoload 'git-messenger:popup-message "git-messenger" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-messenger" '("git-messenger")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-link-20180708.1643/git-link-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-link-20180708.1643/git-link-autoloads.el") (car load-path))))



(autoload 'git-link "git-link" "\
Create a URL representing the current buffer's location in its
GitHub/Bitbucket/GitLab/... repository at the current line number
or active region. The URL will be added to the kill ring. If
`git-link-open-in-browser' is non-`nil' also call `browse-url'.

With a prefix argument prompt for the remote's name.
Defaults to \"origin\".

\(fn REMOTE START END)" t nil)

(autoload 'git-link-commit "git-link" "\
Create a URL representing the commit for the hash under point
in the current buffer's GitHub/Bitbucket/GitLab/...
repository. The URL will be added to the kill ring.

With a prefix argument prompt for the remote's name.
Defaults to \"origin\".

\(fn REMOTE)" t nil)

(autoload 'git-link-homepage "git-link" "\
Create a URL for the current buffer's REMOTE repository homepage.
The URL will be added to the kill ring.  If `git-link-open-in-browser'
is non-nil also call `browse-url'.

\(fn REMOTE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-link" '("git-link-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-lens-20180328.1417/git-lens-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-lens-20180328.1417/git-lens-autoloads.el") (car load-path))))



(autoload 'git-lens "git-lens" "\
Start git lens.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-lens" '("git-lens-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-io-20180317.1752/git-io-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-io-20180317.1752/git-io-autoloads.el") (car load-path))))



(autoload 'git-io-shorten "git-io" "\
Replace thing at point with shortened URL.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-io" '("git-io-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-dwim-20170126.1214/git-dwim-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-dwim-20170126.1214/git-dwim-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-dwim" '("gd-" "git-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/bitbucket-20170405.446/bitbucket-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/bitbucket-20170405.446/bitbucket-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bitbucket-api" '("bitbucket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bitbucket-http" '("bitbucket--" "perform-bitbucket-request")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bitbucket-issues" '("bitbucket-issues-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-commit-insert-issue-20171102.1841/git-commit-insert-issue-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-commit-insert-issue-20171102.1841/git-commit-insert-issue-autoloads.el") (car load-path))))



(autoload 'git-commit-insert-issue-ask-issues "git-commit-insert-issue" "\
Ask for the issue to insert.

\(fn)" t nil)

(autoload 'git-commit-insert-issue-mode "git-commit-insert-issue" "\
See the issues when typing 'Fixes #' in a commit message.

If called interactively, enable Git-Commit-Insert-Issue mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-commit-insert-issue" '("git-" "insert-issue--get-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-commit-20180802.2018/git-commit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-commit-20180802.2018/git-commit-autoloads.el") (car load-path))))



(defvar global-git-commit-mode t "\
Non-nil if Global Git-Commit mode is enabled.
See the `global-git-commit-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-git-commit-mode'.")

(custom-autoload 'global-git-commit-mode "git-commit" nil)

(autoload 'global-git-commit-mode "git-commit" "\
Edit Git commit messages.
This global mode arranges for `git-commit-setup' to be called
when a Git commit message file is opened.  That usually happens
when Git uses the Emacsclient as $GIT_EDITOR to have the user
provide such a commit message.

If called interactively, enable Global Git-Commit mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defconst git-commit-filename-regexp "/\\(\\(\\(COMMIT\\|NOTES\\|PULLREQ\\|TAG\\)_EDIT\\|MERGE_\\|\\)MSG\\|\\(BRANCH\\|EDIT\\)_DESCRIPTION\\)\\'")

(autoload 'git-commit-setup-check-buffer "git-commit" "\


\(fn)" nil nil)

(autoload 'git-commit-setup "git-commit" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-commit" '("git-commit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-command-20160111.1303/git-command-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-command-20160111.1303/git-command-autoloads.el") (car load-path))))



(autoload 'git-command "git-command" "\
Invoke git shell command.
While running git command, $GIT_EDITOR and $GIT_PAGER are set to use emacsclient
to open files and get outputs.

CMD is shell command string to run.
Called interactively, asks users what shell command to invoke.

If NEW-BUFFER-P is non-nil, generate new buffer for running command.
Interactively, give prefix argument for new buffer.

\(fn CMD &optional NEW-BUFFER-P)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-command" '("git-command-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-auto-commit-mode-20161229.1617/git-auto-commit-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-auto-commit-mode-20161229.1617/git-auto-commit-mode-autoloads.el") (car load-path))))



(autoload 'git-auto-commit-mode "git-auto-commit-mode" "\
Automatically commit any changes made when saving with this
mode turned on and optionally push them too.

If called interactively, enable Git-Auto-Commit mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-auto-commit-mode" '("gac-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-attr-20180204.815/git-attr-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-attr-20180204.815/git-attr-autoloads.el") (car load-path))))



(autoload 'git-attr "git-attr" "\
Get git attributes for current buffer file and set in buffer local variable `git-attr'.

\(fn)" t nil)

(autoload 'git-attr-get "git-attr" "\
Get the git attribute named ATTR for the file in current buffer.

 * t for git attributes with the value `set'
 * nil for git attributes with the value `unset'
 * 'undecided for git attributes that are `unspecified'
 * and the value if the git attribute is set to a value

\(fn ATTR)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-attr" '("git-attr")))



(autoload 'git-attr-linguist "git-attr-linguist" "\
Make vendored and generated files read only.

\(fn)" nil nil)

(add-hook 'find-file-hook 'git-attr-linguist)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git-attr-linguist" '("git-attr-linguist-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/git-20140128.1041/git-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/git-20140128.1041/git-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "git" '("git-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/function-args-20171031.1704/function-args-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/function-args-20171031.1704/function-args-autoloads.el") (car load-path))))



(autoload 'function-args-mode "function-args" "\
Minor mode for C++ code completion bindings.

If called interactively, enable Function-Args mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{function-args-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'fa-config-default "function-args" "\
Set up default key bindings.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "function-args" '("fa-" "filter" "function-args-mode-map" "moo-" "turn-on-function-args-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "semantic-directory" '("sd-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/foreign-regexp-20180224.1121/foreign-regexp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/foreign-regexp-20180224.1121/foreign-regexp-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "foreign-regexp" '("foreign-regexp/")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/font-lock-studio-20170127.2051/font-lock-studio-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/font-lock-studio-20170127.2051/font-lock-studio-autoloads.el") (car load-path))))



(autoload 'font-lock-studio "font-lock-studio" "\
Interactively debug the font-lock keywords of the current buffer.

With \\[universal-argument] prefix, create a new, unique, interface buffer.

\(fn &optional ARG)" t nil)

(autoload 'font-lock-studio-region "font-lock-studio" "\
Interactively debug the font-lock keywords in the region.

With \\[universal-argument] prefix, create a new, unique, interface buffer.

\(fn BEG END &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "font-lock-studio" '("font-lock-studio-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/font-lock+-20170222.1755/font-lock+-autoloads.el"))
(add-to-list 'load-path (directory-file-name (or (file-name-directory "/home/lk/.emacs.d/elpa/font-lock+-20170222.1755/font-lock+-autoloads.el") (car load-path))))



)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flyparens-20140723.1846/flyparens-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flyparens-20140723.1846/flyparens-autoloads.el") (car load-path))))



(autoload 'flyparens-mode "flyparens" "\
 FlyParens

If called interactively, enable Flyparens mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flyparens" '("flyparens-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flyparens-config-example-1" '("my-flyparens-function")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-easy-20140818.755/flymake-easy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-easy-20140818.755/flymake-easy-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-easy" '("flymake-easy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-shell-20170723.146/flymake-shell-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-shell-20170723.146/flymake-shell-autoloads.el") (car load-path))))



(autoload 'flymake-shell-load "flymake-shell" "\
Configure flymake mode to check the current buffer's shell-script syntax.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-shell" '("flymake-shell-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-rust-20170729.2139/flymake-rust-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-rust-20170729.2139/flymake-rust-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-rust" '("flymake-rust-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-cursor-20120322.1757/flymake-cursor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-cursor-20120322.1757/flymake-cursor-autoloads.el") (car load-path))))



(autoload 'flymake-cursor-mode "flymake-cursor" "\
Minor mode to show `flymake-mode' errors for the current line in the
message area.
When called interactively, toggles the minor mode.
With arg, turn Flymake Cursor mode on if and only if arg is positive.

Usually `flymake-cursor-mode' is enabled and disabled automatically with
`flymake-mode' for the current buffer and you will not need to toggle
the mode directly.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-cursor" '("flymake-cursor-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flymake-cppcheck-20140415.1257/flymake-cppcheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flymake-cppcheck-20140415.1257/flymake-cppcheck-autoloads.el") (car load-path))))



(autoload 'flymake-cppcheck-load "flymake-cppcheck" "\
Configure flymake mode to check the current buffer's C/C++ source.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-cppcheck" '("flymake-cppcheck-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-title-20170216.2346/flycheck-title-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-title-20170216.2346/flycheck-title-autoloads.el") (car load-path))))



(defvar flycheck-title-mode nil "\
Non-nil if Flycheck-Title mode is enabled.
See the `flycheck-title-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `flycheck-title-mode'.")

(custom-autoload 'flycheck-title-mode "flycheck-title" nil)

(autoload 'flycheck-title-mode "flycheck-title" "\
Global minor mode for showing flycheck errors in the frame title.

If called interactively, enable Flycheck-Title mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-title" '("flycheck-title--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-tip-20171020.1048/flycheck-tip-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-tip-20171020.1048/flycheck-tip-autoloads.el") (car load-path))))



(autoload 'error-tip-error-p "error-tip" "\
Return non-nil if error is occurred in current buffer.
This function can catch error against flycheck, and flymake.

\(fn)" nil nil)

(autoload 'error-tip-cycle-dwim "error-tip" "\
Showing error function.
This function switches proper error showing function by context.
 (whether flycheck or flymake) The REVERSE option jumps by inverse if
the value is non-nil.

\(fn &optional REVERSE)" t nil)

(autoload 'error-tip-cycle-dwim-reverse "error-tip" "\
Same as ‘error-tip-cycle-dwim’, but it jumps to inverse direction.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "error-tip" '("error-tip-")))



(autoload 'flycheck-tip-cycle "flycheck-tip" "\
Move to next error if it's exists.
If it wasn't exists then move to previous error.
Move to previous error if REVERSE is non-nil.

\(fn &optional REVERSE)" t nil)

(autoload 'flycheck-tip-cycle-reverse "flycheck-tip" "\
Do `flycheck-tip-cycle by reverse order.

\(fn)" t nil)

(autoload 'flycheck-tip--get "flycheck-tip" "\


\(fn ELEMENT ERR)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-tip" '("flycheck-tip-")))



(autoload 'flymake-tip-cycle "flymake-tip" "\


\(fn REVERSE)" t nil)

(autoload 'flymake-tip-cycle-reverse "flymake-tip" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flymake-tip" '("flymake-tip--err-info-function")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-swiftlint-20180312.2356/flycheck-swiftlint-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-swiftlint-20180312.2356/flycheck-swiftlint-autoloads.el") (car load-path))))



(autoload 'flycheck-swiftlint-setup "flycheck-swiftlint" "\
Setup Flycheck for Swiftlint.

\(fn)" t nil)

(autoload 'flycheck-swiftlint-autocorrect "flycheck-swiftlint" "\
Automatically fix Swiftlint errors.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-swiftlint" '("flycheck-swiftlint-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-rust-20180327.1645/flycheck-rust-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-rust-20180327.1645/flycheck-rust-autoloads.el") (car load-path))))



(autoload 'flycheck-rust-setup "flycheck-rust" "\
Setup Rust in Flycheck.

If the current file is part of a Cargo project, configure
Flycheck according to the Cargo project layout.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-rust" '("flycheck-rust-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-rtags-20180619.824/flycheck-rtags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-rtags-20180619.824/flycheck-rtags-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-rtags" '("flycheck-rtags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-rebar3-20180806.2103/flycheck-rebar3-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-rebar3-20180806.2103/flycheck-rebar3-autoloads.el") (car load-path))))



(autoload 'flycheck-rebar3-setup "flycheck-rebar3" "\
Setup Flycheck for Rebar3.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-rebar3" '("flycheck-rebar3-project-root")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-pkg-config-20180430.2243/flycheck-pkg-config-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-pkg-config-20180430.2243/flycheck-pkg-config-autoloads.el") (car load-path))))



(autoload 'flycheck-pkg-config "flycheck-pkg-config" "\
Configure flycheck to use additional includes
when checking the current buffer.

\(fn LIB-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-pkg-config" '("flycheck-pkg-config--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-joker-20180713.402/flycheck-joker-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-joker-20180713.402/flycheck-joker-autoloads.el") (car load-path))))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-inline-20180529.1314/flycheck-inline-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-inline-20180529.1314/flycheck-inline-autoloads.el") (car load-path))))



(defvar flycheck-inline-mode nil "\
Non-nil if Flycheck-Inline mode is enabled.
See the `flycheck-inline-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `flycheck-inline-mode'.")

(custom-autoload 'flycheck-inline-mode "flycheck-inline" nil)

(autoload 'flycheck-inline-mode "flycheck-inline" "\
A minor mode to show Flycheck error messages line.

When called interactively, toggle `flycheck-inline-mode'.  With
prefix ARG, enable `flycheck-inline-mode' if ARG is positive,
otherwise disable it.

When called from Lisp, enable `flycheck-inline-mode' if ARG is
omitted, nil or positive.  If ARG is `toggle', toggle
`flycheck-inline-mode'.  Otherwise behave as if called
interactively.

In `flycheck-inline-mode', show Flycheck error messages inline,
directly below the error reported location.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-inline" '("flycheck-inline-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-dialyzer-20160326.1430/flycheck-dialyzer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-dialyzer-20160326.1430/flycheck-dialyzer-autoloads.el") (car load-path))))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-cstyle-20160905.2341/flycheck-cstyle-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-cstyle-20160905.2341/flycheck-cstyle-autoloads.el") (car load-path))))



(autoload 'flycheck-cstyle-setup "flycheck-cstyle" "\
Setup flycheck-cstyle.

Add `cstyle' to `flycheck-checkers'.

\(fn)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-color-mode-line-20171122.707/flycheck-color-mode-line-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-color-mode-line-20171122.707/flycheck-color-mode-line-autoloads.el") (car load-path))))



(autoload 'flycheck-color-mode-line-mode "flycheck-color-mode-line" "\
Minor mode to color the mode line with the Flycheck status.

When called interactively, toggle
`flycheck-color-mode-line-mode'.  With prefix ARG, enable
`flycheck-color-mode-line-mode' if ARG is positive, otherwise
disable it.

When called from Lisp, enable `flycheck-color-mode-line-mode' if ARG is omitted,
nil or positive.  If ARG is `toggle', toggle `flycheck-color-mode-line-mode'.
Otherwise behave as if called interactively.

\(fn &optional ARG)" t nil)

(custom-add-frequent-value 'flycheck-mode-hook 'flycheck-color-mode-line-mode)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-color-mode-line" '("flycheck-color-mode-line-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clojure-20180721.1412/flycheck-clojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clojure-20180721.1412/flycheck-clojure-autoloads.el") (car load-path))))



(autoload 'flycheck-clojure-parse-cider-errors "flycheck-clojure" "\
Parse cider errors from JSON VALUE from CHECKER.

Return a list of parsed `flycheck-error' objects.

\(fn VALUE CHECKER)" nil nil)

(autoload 'flycheck-clojure-setup "flycheck-clojure" "\
Setup Flycheck for Clojure.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clojure" '("cider-flycheck-eval" "flycheck-clojure-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clangcheck-20150712.710/flycheck-clangcheck-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clangcheck-20150712.710/flycheck-clangcheck-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clangcheck" '("flycheck-clangcheck-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clang-tidy-20171024.808/flycheck-clang-tidy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clang-tidy-20171024.808/flycheck-clang-tidy-autoloads.el") (car load-path))))



(autoload 'flycheck-clang-tidy-setup "flycheck-clang-tidy" "\
Setup Flycheck clang-tidy.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clang-tidy" '("flycheck-clang-tidy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-clang-analyzer-20180815.455/flycheck-clang-analyzer-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-clang-analyzer-20180815.455/flycheck-clang-analyzer-autoloads.el") (car load-path))))



(autoload 'flycheck-clang-analyzer-setup "flycheck-clang-analyzer" "\
Setup flycheck-clang-analyzer.

Add `clang-analyzer' to `flycheck-checkers'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "flycheck-clang-analyzer" '("flycheck-clang-analyzer--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/flycheck-checkbashisms-20160224.1706/flycheck-checkbashisms-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/flycheck-checkbashisms-20160224.1706/flycheck-checkbashisms-autoloads.el") (car load-path))))



(autoload 'flycheck-checkbashisms-setup "flycheck-checkbashisms" "\
Setup Flycheck checkbashisms.
Add `sh-checkbashisms' to the end of `flycheck-checkers'.

\(fn)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/evalator-20160213.128/evalator-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/evalator-20160213.128/evalator-autoloads.el") (car load-path))))



(autoload 'evalator-insert-equiv-expr "evalator" "\
Insert the equivalent expression of the previous evalator session into the current buffer.

\(fn)" t nil)

(autoload 'evalator-resume "evalator" "\
Resume last evalator session.

\(fn)" t nil)

(autoload 'evalator "evalator" "\
Start an evalator session.

Function accepts an optional MODE keyword and a CONTEXT symbol.

If MODE is non-nil and a currently supported mode value then that mode
will be used for the session.

Below are currently supported values for MODE:

`:explicit'

If MODE is nil evalator will start in normal mode.

If CONTEXT is non-nil, then the result of calling CONTEXT's function
definition will be used as the session's evaluation context.

If CONTEXT is nil, then the current buffer's major mode will be
searched for in `evalator-config-mode-context-alist'.  If a match is
found, the context associated with that major mode is used in the
evalator session.  If no match is found, an elisp evaluation context
is used instead.

\(fn &optional MODE CONTEXT)" t nil)

(autoload 'evalator-explicit "evalator" "\
Helper function to start an evalator-session in explicit mode.

In explicit mode the data generated will always be represented as a
single candidate.  This is the only mode that allows an equivalent
expression of the session to be generated through
`evalator-insert-equiv-expr'.

\(fn &optional CONTEXT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator" '("evalator-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-config" '("evalator-config-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-context" '("evalator-context")))



(autoload 'evalator-elisp-context "evalator-elisp" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-elisp" '("evalator-elisp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-history" '("evalator-history")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-key-map" '("evalator-key-map")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-state" '("evalator-state")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-utils" '("evalator-utils-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/evalator-clojure-20160208.2148/evalator-clojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/evalator-clojure-20160208.2148/evalator-clojure-autoloads.el") (car load-path))))



(autoload 'evalator-clojure-context "evalator-clojure" "\


\(fn)" nil nil)

(autoload 'evalator-clojure "evalator-clojure" "\


\(fn &optional MODE)" t nil)

(autoload 'evalator-clojure-explicit "evalator-clojure" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "evalator-clojure" '("evalator-clojure-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eval-sexp-fu-20180510.203/eval-sexp-fu-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eval-sexp-fu-20180510.203/eval-sexp-fu-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-sexp-fu" '("define-e" "esf-" "eval-sexp-fu-" "turn-on-eval-sexp-fu-flash-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/avy-20180814.2121/avy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/avy-20180814.2121/avy-autoloads.el") (car load-path))))



(autoload 'avy-goto-char "avy" "\
Jump to the currently visible CHAR.
The window scope is determined by `avy-all-windows' (ARG negates it).

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-char-in-line "avy" "\
Jump to the currently visible CHAR in the current line.

\(fn CHAR)" t nil)

(autoload 'avy-goto-char-2 "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

\(fn CHAR1 CHAR2 &optional ARG BEG END)" t nil)

(autoload 'avy-goto-char-2-above "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR1 CHAR2 &optional ARG)" t nil)

(autoload 'avy-goto-char-2-below "avy" "\
Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR1 CHAR2 &optional ARG)" t nil)

(autoload 'avy-isearch "avy" "\
Jump to one of the current isearch candidates.

\(fn)" t nil)

(autoload 'avy-goto-word-0 "avy" "\
Jump to a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

\(fn ARG &optional BEG END)" t nil)

(autoload 'avy-goto-word-1 "avy" "\
Jump to the currently visible CHAR at a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.
When SYMBOL is non-nil, jump to symbol start instead of word start.

\(fn CHAR &optional ARG BEG END SYMBOL)" t nil)

(autoload 'avy-goto-word-1-above "avy" "\
Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-word-1-below "avy" "\
Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1 "avy" "\
Jump to the currently visible CHAR at a symbol start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1-above "avy" "\
Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-symbol-1-below "avy" "\
Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-subword-0 "avy" "\
Jump to a word or subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).

When PREDICATE is non-nil it's a function of zero parameters that
should return true.

BEG and END narrow the scope where candidates are searched.

\(fn &optional ARG PREDICATE BEG END)" t nil)

(autoload 'avy-goto-subword-1 "avy" "\
Jump to the currently visible CHAR at a subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).
The case of CHAR is ignored.

\(fn CHAR &optional ARG)" t nil)

(autoload 'avy-goto-word-or-subword-1 "avy" "\
Forward to `avy-goto-subword-1' or `avy-goto-word-1'.
Which one depends on variable `subword-mode'.

\(fn)" t nil)

(autoload 'avy-goto-line "avy" "\
Jump to a line start in current buffer.

When ARG is 1, jump to lines currently visible, with the option
to cancel to `goto-line' by entering a number.

When ARG is 4, negate the window scope determined by
`avy-all-windows'.

Otherwise, forward to `goto-line' with ARG.

\(fn &optional ARG)" t nil)

(autoload 'avy-goto-line-above "avy" "\
Goto visible line above the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

\(fn &optional OFFSET BOTTOM-UP)" t nil)

(autoload 'avy-goto-line-below "avy" "\
Goto visible line below the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

\(fn &optional OFFSET BOTTOM-UP)" t nil)

(autoload 'avy-goto-end-of-line "avy" "\
Call `avy-goto-line' and move to the end of the line.

\(fn &optional ARG)" t nil)

(autoload 'avy-copy-line "avy" "\
Copy a selected line above the current line.
ARG lines can be used.

\(fn ARG)" t nil)

(autoload 'avy-move-line "avy" "\
Move a selected line above the current line.
ARG lines can be used.

\(fn ARG)" t nil)

(autoload 'avy-copy-region "avy" "\
Select two lines and copy the text between them to point.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

\(fn ARG)" t nil)

(autoload 'avy-move-region "avy" "\
Select two lines and move the text between them above the current line.

\(fn)" t nil)

(autoload 'avy-kill-region "avy" "\
Select two lines and kill the region between them.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

\(fn ARG)" t nil)

(autoload 'avy-kill-ring-save-region "avy" "\
Select two lines and save the region between them to the kill ring.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

\(fn ARG)" t nil)

(autoload 'avy-kill-whole-line "avy" "\
Select line and kill the whole selected line.

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\\[universal-argument] 3 \\[avy-kil-whole-line] kill three lines
starting from the selected line.  \\[universal-argument] -3

\\[avy-kill-whole-line] kill three lines backward including the
selected line.

\(fn ARG)" t nil)

(autoload 'avy-kill-ring-save-whole-line "avy" "\
Select line and save the whole selected line as if killed, but don’t kill it.

This command is similar to `avy-kill-whole-line', except that it
saves the line(s) as if killed, but does not kill it(them).

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\(fn ARG)" t nil)

(autoload 'avy-setup-default "avy" "\
Setup the default shortcuts.

\(fn)" nil nil)

(autoload 'avy-goto-char-timer "avy" "\
Read one or many consecutive chars and jump to the first one.
The window scope is determined by `avy-all-windows' (ARG negates it).

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "avy" '("avy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ace-window-20180814.1516/ace-window-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ace-window-20180814.1516/ace-window-autoloads.el") (car load-path))))



(autoload 'ace-select-window "ace-window" "\
Ace select window.

\(fn)" t nil)

(autoload 'ace-delete-window "ace-window" "\
Ace delete window.

\(fn)" t nil)

(autoload 'ace-swap-window "ace-window" "\
Ace swap window.

\(fn)" t nil)

(autoload 'ace-delete-other-windows "ace-window" "\
Ace delete other windows.

\(fn)" t nil)

(autoload 'ace-window "ace-window" "\
Select a window.
Perform an action based on ARG described below.

By default, behaves like extended `other-window'.

Prefixed with one \\[universal-argument], does a swap between the
selected window and the current window, so that the selected
buffer moves to current window (and current buffer moves to
selected window).

Prefixed with two \\[universal-argument]'s, deletes the selected
window.

\(fn ARG)" t nil)

(defvar ace-window-display-mode nil "\
Non-nil if Ace-Window-Display mode is enabled.
See the `ace-window-display-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ace-window-display-mode'.")

(custom-autoload 'ace-window-display-mode "ace-window" nil)

(autoload 'ace-window-display-mode "ace-window" "\
Minor mode for showing the ace window key in the mode line.

If called interactively, enable Ace-Window-Display mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ace-window" '("ace-window-mode" "aw-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eval-in-repl-20171122.1343/eval-in-repl-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eval-in-repl-20171122.1343/eval-in-repl-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl" '("eir-")))



(autoload 'eir-eval-in-cider "eval-in-repl-cider" "\
eval-in-repl for cider.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-cider" '("eir-")))



(autoload 'eir-eval-in-elm "eval-in-repl-elm" "\
Provides eval-in-repl for Elm.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-elm" '("eir-send-to-elm")))



(autoload 'eir-eval-in-erlang "eval-in-repl-erlang" "\
Provides eval-in-repl for Erlang.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-erlang" '("eir-send-to-erlang")))



(autoload 'eir-eval-in-geiser "eval-in-repl-geiser" "\
eval-in-repl for Geiser.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-geiser" '("eir-send-to-geiser")))



(autoload 'eir-eval-in-hy "eval-in-repl-hy" "\
eval-in-repl for Hy.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-hy" '("eir-")))



(autoload 'eir-eval-in-ielm "eval-in-repl-ielm" "\
eval-in-repl for IELM.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-ielm" '("eir-")))



(autoload 'eir-eval-in-iex "eval-in-repl-iex" "\
Provides eval-in-repl for Elixir.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-iex" '("eir-send-to-iex")))



(autoload 'eir-eval-in-javascript "eval-in-repl-javascript" "\
eval-in-repl for Javascript.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-javascript" '("eir-send-to-javascript")))



(autoload 'eir-eval-in-lua "eval-in-repl-lua" "\
eval-in-repl for Lua.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-lua" '("eir-send-to-lua" "eval-in-repl-run-lua")))



(autoload 'eir-eval-in-ocaml "eval-in-repl-ocaml" "\
eval-in-repl for OCaml.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-ocaml" '("eir-send-to-ocaml")))



(autoload 'eir-eval-in-prolog "eval-in-repl-prolog" "\
eval-in-repl for SWI Prolog.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-prolog" '("eir-send-to-prolog")))



(autoload 'eir-eval-in-python "eval-in-repl-python" "\
eval-in-repl for Python.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-python" '("eir-")))



(autoload 'eir-eval-in-racket "eval-in-repl-racket" "\
eval-in-repl for Racket.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-racket" '("eir-send-to-racket")))



(autoload 'eir-eval-in-ruby "eval-in-repl-ruby" "\
eval-in-repl for Ruby.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-ruby" '("eir-send-to-ruby")))



(autoload 'eir-eval-in-scala "eval-in-repl-scala" "\
Provides eval-in-repl for Scala.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-scala" '("eir-send-to-scala")))



(autoload 'eir-eval-in-scheme "eval-in-repl-scheme" "\
eval-in-repl for Scheme.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-scheme" '("eir-send-to-scheme")))



(autoload 'eir-eval-in-shell "eval-in-repl-shell" "\
eval-in-repl for shell.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-shell" '("eir-send-to-shell")))



(autoload 'eir-eval-in-slime "eval-in-repl-slime" "\
eval-in-repl for SLIME.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-slime" '("eir-send-to-slime")))



(autoload 'eir-eval-in-sml "eval-in-repl-sml" "\
eval-in-repl for Standard ML.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-in-repl-sml" '("eir-send-to-sml")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eval-expr-20120619.647/eval-expr-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eval-expr-20120619.647/eval-expr-autoloads.el") (car load-path))))



(defvar eval-expr-error-message-delay 3 "\
*Amount of time, in seconds, to display in echo area before continuing.")

(custom-autoload 'eval-expr-error-message-delay "eval-expr" t)

(defvar eval-expr-prompt "Eval: " "\
*Prompt used by eval-expr.")

(custom-autoload 'eval-expr-prompt "eval-expr" t)

(defvar eval-expr-honor-debug-on-error t "\
*If non-nil, do not trap evaluation errors.
Instead, allow errors to throw user into the debugger, provided
debug-on-error specifies that the particular error is a debuggable condition.")

(custom-autoload 'eval-expr-honor-debug-on-error "eval-expr" t)

(defvar eval-expr-use-echo-area-or-buffer 1 "\
*Preference for when to use echo area of a temporary buffer for results.

If set to t or `buffer', always put results into a temporary buffer.
If set to `nil' or `echo-area', always display results in echo area.
If an integer N, use the echo area unless the results would require more
than N lines to display; in that case, use a temporary buffer.

Some versions of emacs can display arbitrarily large output in the echo
area by dynamically resizing it, so a temporary buffer is not necessary
unless you expect the output to exceed the limits of the resize thresholds
or want to be able to edit the results.")

(custom-autoload 'eval-expr-use-echo-area-or-buffer "eval-expr" t)

(defvar eval-expr-print-level (cond ((boundp 'eval-expression-print-level) (default-value 'eval-expression-print-level)) ((boundp 'print-level) (default-value 'print-level))) "\
*Like print-level, but affect results printed by `eval-expr' only.")

(custom-autoload 'eval-expr-print-level "eval-expr" t)

(defvar eval-expr-print-length (cond ((boundp 'eval-expression-print-length) (default-value 'eval-expression-print-length)) ((boundp 'print-length) (default-value 'print-length))) "\
*Like print-length, but affect results printed by `eval-expr' only.")

(custom-autoload 'eval-expr-print-length "eval-expr" t)

(defvar eval-expr-print-function (if (fboundp 'pp) 'pp 'prin1) "\
*Function to use for printing objects.
E.g. this can be set to `pp' to generate pretty-printed results,
or `prin1' for unformatted results.")

(custom-autoload 'eval-expr-print-function "eval-expr" t)

(autoload 'eval-expr-install "eval-expr" "\
Replace standard eval-expression command with enhanced eval-expr.

\(fn)" t nil)

(autoload 'eval-expr "eval-expr" "\
Evaluate EXPRESSION and print value in minibuffer, temp, or current buffer.
A temp output buffer is used if there is more than one line in the
evaluated result.
If invoked with a prefix arg, or second lisp argument EE::INSERT-VALUE is
non-nil, then insert final value into the current buffer at point.

Value is also consed on to front of the variable `values'.

\(fn EE::EXPRESSION &optional EE::INSERT-VALUE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eval-expr" '("eval-expr-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eterm-256color-20180520.1223/eterm-256color-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eterm-256color-20180520.1223/eterm-256color-autoloads.el") (car load-path))))



(autoload 'eterm-256color-mode "eterm-256color" "\
Minor mode that adds 256color support to term/ansi-term.

If called interactively, enable Eterm-256color mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eterm-256color" '("eterm-256color-" "term-terminal-previous-parameter-2")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/es-lib-20141111.1830/es-lib-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/es-lib-20141111.1830/es-lib-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-buffer-local-set-key" '("es-buffer-local-")))



(autoload 'es-kill-buffer-dont-ask "es-lib-core-functions" "\


\(fn &optional BUFFER)" t nil)

(autoload 'es-find-function-bound-to "es-lib-core-functions" "\


\(fn KEY-SEQUENCE)" t nil)

(autoload 'es-push-line "es-lib-core-functions" "\
beginning-of-line + open line.

\(fn)" t nil)

(autoload 'es-jump-line "es-lib-core-functions" "\
end-of-line + newline.

\(fn)" t nil)

(autoload 'es-new-empty-buffer "es-lib-core-functions" "\


\(fn)" t nil)

(defvar es-highlighter-colors '("DeepPink" "cyan" "MediumPurple1" "SpringGreen1" "DarkOrange" "HotPink1" "RoyalBlue1" "OliveDrab"))

(autoload 'es-mouse-copy-symbol "es-lib-core-functions" "\


\(fn EVENT)" t nil)

(autoload 'es-mouse-yank-replace-symbol "es-lib-core-functions" "\


\(fn EVENT)" t nil)

(autoload 'es-c-expand-region "es-lib-core-functions" "\
A simplee version of expand-region for c-like languages.
Marks the symbol on first call, then marks the statement.

\(fn)" t nil)

(autoload 'es-comment-dwim "es-lib-core-functions" "\


\(fn &optional ARG)" t nil)

(autoload 'es-ido-like-helm "es-lib-core-functions" "\
Choose from a concatenated list of buffers and recent files.

\(fn &optional THIS-MODE-ONLY)" t nil)

(autoload 'es-ido-like-helm "es-lib-core-functions" "\
Choose from a concatenated list of buffers and recent files.

\(fn &optional THIS-MODE-ONLY)" t nil)

(autoload 'es-manage-unsaved-buffers "es-lib-core-functions" "\
Similar to what happends when emacs is about to quit.

\(fn)" t nil)

(autoload 'es-query-replace-symbol-at-point "es-lib-core-functions" "\


\(fn)" t nil)

(autoload 'es-ack-replace-symbol "es-lib-core-functions" "\
Repalace symbol at point, or region contents in multiple
files.

\(fn FROM-SYMBOL-OR-STRING TO-SYMBOL-OR-STRING &key DIRECTORY AUTO-SAVE FINISH-FUNC SILENT)" t nil)

(autoload 'es-ack-pin-folder "es-lib-core-functions" "\
Set ack root directory for one buffer only.
Ack won't prompt for a directory name in that buffer.

\(fn FOLDER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-core-functions" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-core-macros" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-lexical" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-readme-generator" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-text-navigate" '("es-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "es-lib-total-line" '("es-total-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elog-20160724.2255/elog-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elog-20160724.2255/elog-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elog" '("elog-" "initialize-instance")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elmacro-20180628.1411/elmacro-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elmacro-20180628.1411/elmacro-autoloads.el") (car load-path))))



(autoload 'elmacro-show-last-macro "elmacro" "\
Show the last macro as emacs lisp with NAME.

\(fn NAME)" t nil)

(autoload 'elmacro-show-last-commands "elmacro" "\
Take the latest COUNT commands and show them as emacs lisp.

This is basically a better version of `kmacro-edit-lossage'.

The default number of commands shown is modifiable in variable
`elmacro-show-last-commands-default'.

You can also modify this number by using a numeric prefix argument or
by using the universal argument, in which case it'll ask for how many
in the minibuffer.

\(fn &optional COUNT)" t nil)

(autoload 'elmacro-clear-command-history "elmacro" "\
Clear the list of recorded commands.

\(fn)" t nil)

(defvar elmacro-mode nil "\
Non-nil if elmacro mode is enabled.
See the `elmacro-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `elmacro-mode'.")

(custom-autoload 'elmacro-mode "elmacro" nil)

(autoload 'elmacro-mode "elmacro" "\
Toggle emacs activity recording (elmacro mode).
With a prefix argument ARG, enable elmacro mode if ARG is
positive, and disable it otherwise. If called from Lisp, enable
the mode if ARG is omitted or nil.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elmacro" '("elmacro-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elisp-sandbox-20131116.1842/elisp-sandbox-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elisp-sandbox-20131116.1842/elisp-sandbox-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elisp-sandbox" '("elisp-sandbox" "sandbox")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elisp-lint-20180224.2042/elisp-lint-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elisp-lint-20180224.2042/elisp-lint-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elisp-lint" '("elisp-lint-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/elf-mode-20161009.748/elf-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/elf-mode-20161009.748/elf-mode-autoloads.el") (car load-path))))



(autoload 'elf-mode "elf-mode" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elf-mode" '("elf-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eldoc-overlay-20171219.940/eldoc-overlay-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eldoc-overlay-20171219.940/eldoc-overlay-autoloads.el") (car load-path))))



(autoload 'global-eldoc-overlay-toggle "eldoc-overlay" "\
Globally toggle display of eldoc-overlay.

\(fn)" nil nil)

(autoload 'eldoc-overlay-toggle "eldoc-overlay" "\
Toggle display of eldoc-overlay in this buffer or with prefix arg GLOBAL-FLAG, globally.

\(fn GLOBAL-FLAG)" t nil)

(autoload 'eldoc-overlay-mode "eldoc-overlay" "\
Minor mode for displaying eldoc contextual documentation using a text overlay.

If called interactively, enable Eldoc-Overlay mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-eldoc-overlay-mode t "\
Non-nil if Global Eldoc-Overlay mode is enabled.
See the `global-eldoc-overlay-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-eldoc-overlay-mode'.")

(custom-autoload 'global-eldoc-overlay-mode "eldoc-overlay" nil)

(autoload 'global-eldoc-overlay-mode "eldoc-overlay" "\
Toggle Eldoc-Overlay mode in all buffers.
With prefix ARG, enable Global Eldoc-Overlay mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Eldoc-Overlay mode is enabled in all buffers where
`eldoc-overlay-enable' would do it.
See `eldoc-overlay-mode' for more information on Eldoc-Overlay mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eldoc-overlay" '("eldoc-overlay-" "global-eldoc-overlay-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/el-sprunge-20140107.139/el-sprunge-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/el-sprunge-20140107.139/el-sprunge-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-sprunge" '("el-sprunge-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/el-autoyas-20120918.1317/el-autoyas-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/el-autoyas-20120918.1317/el-autoyas-autoloads.el") (car load-path))))



(autoload 'el-autoyas-enable "el-autoyas" "\
Load and activate package.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "el-autoyas" '("el-autoyas-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clomacs-20180816.1836/clomacs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clomacs-20180816.1836/clomacs-autoloads.el") (car load-path))))



(autoload 'clomacs-def "clomacs" "\
Wrap CL-ENTITY-NAME, evaluated on clojure side by EL-ENTITY-NAME.
DOC - optional elisp function docstring (when nil it constructed from
underlying clojure entity docstring if possible).
TYPE possible values are listed in the CLOMACS-POSSIBLE-RETURN-TYPES,
or it may be a custom function (:string by default).

\(fn EL-ENTITY-NAME CL-ENTITY-NAME &key (DOC nil) (TYPE :string) LIB-NAME NAMESPACE)" nil t)

(autoload 'clomacs-defun "clomacs" "\
Wrap CL-FUNC-NAME, evaluated on clojure side by EL-FUNC-NAME.
CALL-TYPE - call Clojure side :sync or :async.
CALLBACK - callback function for :async CALL-TYPE case.
DOC - optional elisp function docstring (when nil it constructed from
underlying clojure entity docstring if possible).
INTERACTIVE - when defined and is a boolean `t` mark function (interactive),
if not boolean - insert interactive value into the function beginning as is.
RETURN-TYPE possible values are listed in the CLOMACS-POSSIBLE-RETURN-TYPES,
or it may be a custom function (:string by default).
RETURN-VALUE may be :value or :stdout (:value by default).
HTTPD-STARTER - in the case Clojure side code needs to call Elisp side code,
http-server should be started to pass http requests from Clojure REPL
to Emacs. This parameter is Elisp function to do it. Such function can
looks like `clomacs-httpd-start'.

\(fn EL-FUNC-NAME CL-FUNC-NAME &key (CALL-TYPE :sync) (CALLBACK nil) (DOC nil) (INTERACTIVE nil) (RETURN-TYPE :string) (RETURN-VALUE :value) LIB-NAME NAMESPACE (HTTPD-STARTER nil))" nil t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clomacs" '("clo" "execute")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-20170125.245/auto-complete-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-20170125.245/auto-complete-autoloads.el") (car load-path))))



(autoload 'auto-complete "auto-complete" "\
Start auto-completion at current point.

\(fn &optional SOURCES)" t nil)

(autoload 'auto-complete-mode "auto-complete" "\
AutoComplete mode

If called interactively, enable Auto-Complete mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(defvar global-auto-complete-mode nil "\
Non-nil if Global Auto-Complete mode is enabled.
See the `global-auto-complete-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-auto-complete-mode'.")

(custom-autoload 'global-auto-complete-mode "auto-complete" nil)

(autoload 'global-auto-complete-mode "auto-complete" "\
Toggle Auto-Complete mode in all buffers.
With prefix ARG, enable Global Auto-Complete mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Complete mode is enabled in all buffers where
`auto-complete-mode-maybe' would do it.
See `auto-complete-mode' for more information on Auto-Complete mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete" '("ac-" "auto-complete-mode")))



(autoload 'ac-config-default "auto-complete-config" "\


\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-config" '("ac-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/direx-20170422.1327/direx-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/direx-20170422.1327/direx-autoloads.el") (car load-path))))



(autoload 'direx:jump-to-directory "direx" "\


\(fn)" t nil)

(autoload 'direx:jump-to-directory-other-window "direx" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "direx" '("direx:")))



(autoload 'direx-project:jump-to-project-root "direx-project" "\


\(fn)" t nil)

(autoload 'direx-project:jump-to-project-root-other-window "direx-project" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "direx-project" '("direx-project:")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ejc-sql-20180701.1805/ejc-sql-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ejc-sql-20180701.1805/ejc-sql-autoloads.el") (car load-path))))



(autoload 'ejc-owners-candidates "ejc-autocomplete" "\


\(fn)" nil nil)

(autoload 'ejc-tables-candidates "ejc-autocomplete" "\


\(fn)" nil nil)

(autoload 'ejc-colomns-candidates "ejc-autocomplete" "\


\(fn)" nil nil)

(autoload 'ejc-ac-setup "ejc-autocomplete" "\
Add the completion sources to the front of `ac-sources'.
This affects only the current buffer.

Check against following cases:
prefix-2.prefix-1.#
prefix-1.#
something#

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-autocomplete" '("ac-" "ejc-")))



(autoload 'ejc-direx:pop-to-buffer "ejc-direx" "\


\(fn)" t nil)

(autoload 'ejc-direx:switch-to-buffer "ejc-direx" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-direx" '("direx" "ejc-direx:")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-doc" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-format" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-interaction" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-lib" '("ejc-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-result-mode" '("ejc-result-")))



(autoload 'ejc-sql-mode "ejc-sql" "\
Toggle ejc-sql mode.

If called interactively, enable Ejc-Sql mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'ejc-create-menu "ejc-sql" "\


\(fn)" nil nil)

(autoload 'ejc-connect "ejc-sql" "\
Connect to selected db.

\(fn CONNECTION-NAME)" t nil)

(autoload 'ejc-connect-existing-repl "ejc-sql" "\
Connect to existing ejc-sql nREPL running process.
You can `cd` to your ejc-sql project folder (typically
'~/.emacs.d/elpa/ejc-sql-<version>') and launch nREPL via `lein run`.
Then run in Emacs `ejc-connect-existing-repl', type HOST and PORT
from your `lein run` console output. Finally, use `ejc-connect' from
any SQL buffer to connect to exact database, as always. 

\(fn HOST PORT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ejc-sql" '("ejc-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eide-20180626.1959/eide-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eide-20180626.1959/eide-autoloads.el") (car load-path))))



(autoload 'eide-start "eide" "\
Start Emacs-IDE.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide" '("eide-shell-open")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-browsing-theme" '("eide-browsing")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-compare" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-config" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-dark-theme" '("eide-dark")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-display" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-display-theme" '("eide-display")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-edit" '("eide-edit-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-help" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-keys" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-light-theme" '("eide-light")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-menu" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-popup" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-project" '("eide-" "emacs-ide-config-mode")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-search" '("eide-")))



(when load-file-name (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-settings-theme" '("eide-settings")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-vc" '("eide-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eide-windows" '("eide-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/egg-20180713.918/egg-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/egg-20180713.918/egg-autoloads.el") (car load-path))))



(autoload 'egg-minor-mode "egg" "\
Turn-on egg-minor-mode which would enable key bindings for
egg in current buffer.\\<egg-minor-mode-map>
\\[egg-start-new-branch] start a new branch from the current HEAD.
\\[egg-status] shows the repo's current status
\\[egg-commit-log-edit] start editing the commit message for the current staged changes.
\\[egg-file-stage-current-file] stage new changes of the current file
\\[egg-log] shows repo's history
\\[egg-file-checkout-other-version] checkout another version of the current file
\\[egg-file-cancel-modifications] delete unstaged modifications in the current file
\\[egg-next-action] perform the next logical action
\\[egg-file-diff] compare file with index or other commits
\\[egg-file-version-other-window] show other version of the current file.

\\{egg-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'egg-minor-mode-find-file-hook "egg" "\


\(fn)" nil nil)

(add-hook 'find-file-hook 'egg-git-dir)

(add-hook 'find-file-hook 'egg-minor-mode-find-file-hook)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg" '("commit" "define-egg-buffer" "diff" "egg-" "file-log" "list-nav" "log" "query:commit" "status" "tag:msg" "with-current-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-base" '("dolist-done" "egg-" "invoked-interactively-p" "subseq")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-const" '("egg-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-custom" '("egg-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-diff" '("egg-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-git" '("egg-" "with-")))



(autoload 'egg-grep-process-setup "egg-grep" "\
Setup compilation variables and buffer for `egg-grep'.
Set up `compilation-exit-message-function' and run `egg-grep-setup-hook'.

\(fn)" nil nil)

(autoload 'egg-grep-mode "egg-grep" "\
Sets `compilation-last-buffer' and `compilation-window-height'.

\(fn)" nil nil)

(autoload 'egg-grep "egg-grep" "\


\(fn LEVEL)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-grep" '("egg-grep-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-key" '("egg-" "with-egg-key-buffer")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "egg-svn" '("egg-" "with-egg-temp-direct-mapping")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-highlight-symbol-20130313.943/auto-highlight-symbol-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-highlight-symbol-20130313.943/auto-highlight-symbol-autoloads.el") (car load-path))))



(defvar global-auto-highlight-symbol-mode nil "\
Non-nil if Global Auto-Highlight-Symbol mode is enabled.
See the `global-auto-highlight-symbol-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-auto-highlight-symbol-mode'.")

(custom-autoload 'global-auto-highlight-symbol-mode "auto-highlight-symbol" nil)

(autoload 'global-auto-highlight-symbol-mode "auto-highlight-symbol" "\
Toggle Auto-Highlight-Symbol mode in all buffers.
With prefix ARG, enable Global Auto-Highlight-Symbol mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Highlight-Symbol mode is enabled in all buffers where
`ahs-mode-maybe' would do it.
See `auto-highlight-symbol-mode' for more information on Auto-Highlight-Symbol mode.

\(fn &optional ARG)" t nil)

(autoload 'auto-highlight-symbol-mode "auto-highlight-symbol" "\
Toggle Auto Highlight Symbol Mode

If called interactively, enable Auto-Highlight-Symbol mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-highlight-symbol" '("ahs-" "auto-highlight-symbol-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/edts-20171030.709/edts-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/edts-20171030.709/edts-autoloads.el") (car load-path))))



(eval-and-compile (add-to-list 'load-path (file-name-as-directory (expand-file-name "elisp/edts" (file-name-directory (or load-file-name byte-compile-current-file))))))

(autoload 'edts-mode "edts-mode" "\
An easy to set up Development-environment for Erlang. See README for
details about EDTS.

If called interactively, enable Edts mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

EDTS also incorporates a couple of other
minor-modes, currently auto-highlight-mode and auto-complete-mode.
They are configured to work together with EDTS but see their respective
documentation for information on how to configure their behaviour
further.

\\{edts-mode-map}Other useful commands:
\\[edts-buffer-node-name]           - Display the project node-name of
                                      current-buffer.
\\[edts-code-compile-and-display]   - Compile current buffer and display
                                      issues.
\\[edts-code-xref-analyze]          - Run xref analysis on current
                                      buffer.
\\[edts-code-xref-analyze-related]  - Runs xref-checks for all
                                      live buffers related to
                                      current buffer either by
                                      belonging to the same
                                      project or, if current
                                      buffer does not belong to
                                      any project, being in the
                                      same directory as the
                                      current buffer's file.
\\[edts-dialyzer-analyze]           - Same as the xref-check
                                      above, but for dialyzer.
\\[edts-byte-compile]               - Byte compile all EDTS elisp files.
\\[edts-project-start-node]         - Start current buffers project-node
                                      if not already running.
\\[edts-refactor-extract-function]  - Extract code in current region
                                      into a separate function.
\\[edts-init-node]                  - Register the project-node of
                                      current buffer with the central
                                      EDTS server.
\\[edts-shell]                      - Start an interactive Erlang shell.
\\[edts-start-server]               - Start the central EDTS server.
\\[edts-man-setup]                  - Install the OTP documentation

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "edts-mode" '("edts-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "edts-start" '("edts-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/edebug-x-20130616.625/edebug-x-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/edebug-x-20130616.625/edebug-x-autoloads.el") (car load-path))))



(autoload 'edebug-x-modify-breakpoint-wrapper "edebug-x" "\
Set a breakpoint from an Elisp file.
The current function that pointer is in will be instrumented if
not already. When called with a prefix argument a conditional
breakpoint is set.

\(fn ARG)" t nil)

(autoload 'edebug-x-evaluate-function "edebug-x" "\
Evaluate function on line.
This removes all breakpoints in this function.

\(fn)" t nil)

(autoload 'edebug-x-show-data "edebug-x" "\
Display instrumented functions and edebug breakpoints.
Frame is split into two vertically showing the tabluated buffers
for each.

\(fn)" t nil)

(autoload 'edebug-x-show-breakpoints "edebug-x" "\
Display breakpoints in a tabulated list buffer.

\(fn)" t nil)

(autoload 'edebug-x-show-instrumented "edebug-x" "\
Display instrumented functions in a tabluated list buffer.

\(fn)" t nil)

(autoload 'edebug-x-mode "edebug-x" "\
A minor mode that makes it easier to use Edebug

If called interactively, enable Edebug-X mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(add-hook 'emacs-lisp-mode-hook 'edebug-x-mode)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "edebug-x" '("edebug-x-" "instrumented" "list-edebug-x-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ede-compdb-20150920.2033/ede-compdb-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ede-compdb-20150920.2033/ede-compdb-autoloads.el") (car load-path))))



(autoload 'ede-compdb-load-project "ede-compdb" "\
Create an instance of option `ede-compdb-project' for DIR.

\(fn DIR)" nil nil)

(autoload 'ede-ninja-load-project "ede-compdb" "\
Create an instance of option `ede-ninja-project' for DIR.

\(fn DIR)" nil nil)

(eval-after-load "ede/auto" '(ede-add-project-autoload (ede-project-autoload "compdb" :name "Compilation DB" :file 'ede-compdb :proj-file "compile_commands.json" :load-type 'ede-compdb-load-project :class-sym 'ede-compdb-project)))

(eval-after-load "ede/auto" '(ede-add-project-autoload (ede-project-autoload "ninja" :name "Ninja" :file 'ede-compdb :proj-file "build.ninja" :load-type 'ede-ninja-load-project :class-sym 'ede-ninja-project)))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ede-compdb" '("compdb-entry" "current-co" "ede-" "ff-other-file-list" "get-" "initialize-instance" "insert-compdb" "other-file-list" "parse-command-line" "project-" "set-configuration-directory")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ecb-20170728.1921/ecb-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ecb-20170728.1921/ecb-autoloads.el") (car load-path))))



(autoload 'ecb-activate "ecb" "\
Activates ECB and creates the special buffers for the choosen layout.
For the layout see `ecb-layout-name'. This function raises always the
ECB-frame if called from another frame. This is the same as calling
`ecb-minor-mode' with a positive argument.

\(fn)" t nil)

(autoload 'ecb-minor-mode "ecb" "\
Toggle ECB minor mode.
With prefix argument ARG, turn on if positive, otherwise off. Return non-nil
if the minor mode is enabled.

\\{ecb-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'ecb-byte-compile "ecb" "\
Byte-compiles the ECB package.
This is done for all lisp-files of ECB if FORCE-ALL is not nil or for each
lisp-file FILE.el which is either newer than FILE.elc or if FILE.elc doesn't
exist.

\(fn &optional FORCE-ALL)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-advice-test" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-analyse" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-autogen" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-cedet-wrapper" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-common-browser" '("defecb-" "ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-compatibility" '("Electric-pop-up-window" "bs-show" "ecb-" "electric-" "one-window-p" "scroll-all-function-all")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-compilation" '("ecb-compilation-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-create-layout" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-eshell" '("ecb-eshell-" "eshell")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-examples" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-face" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-file-browser" '("clearcase-sync-from-disk" "ecb-" "vc-checkin")))



(autoload 'ecb-show-help "ecb-help" "\
Shows the online help of ECB in Info or HTML-format.
The format depends on the setting in `ecb-show-help-format'. If called with
prefix argument, i.e. if FORMAT is not nil then the user is prompted to choose
the format of the help (Info or Html).

If an error about not finding the needed help-file occurs please take a look
at the options `ecb-help-info-start-file' and `ecb-help-html-start-file'!

Note: If you got ECB as a standard XEmacs-package maybe the
HTML-online-documentation is not included.

\(fn &optional FORMAT)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-help" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-jde" '("ecb-jde-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-layout" '("balance-windows" "compilation-set-window-height" "current-window-configuration" "display-buffer" "ecb-" "other-window" "scroll-other-window" "set-window-configuration" "split-window" "switch-to-buffer" "walk-windows")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-layout-defs" '("ecb-buildin-layouts")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-method-browser" '("custom-save-all" "ecb-" "make-indirect-buffer")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-mode-line" '("ecb-mode-line-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-multiframe" '("ecb-multiframe-variables")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-navigate" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-semantic" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-semantic-wrapper" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-speedbar" '("dframe-" "ecb-" "speedbar-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-symboldef" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-tod" '("ecb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-upgrade" '("ecb-")))



(defconst ecb-running-xemacs (featurep 'xemacs))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-util" '("defecb-multicache" "ecb-" "when-ecb-running-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ecb-winman-support" '("ecb-winman-" "escreen-save-current-screen-configuration" "win")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "silentcomp" '("silentcomp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "tree-buffer" '("tree-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/eacl-20180607.1358/eacl-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/eacl-20180607.1358/eacl-autoloads.el") (car load-path))))



(autoload 'eacl-get-project-root "eacl" "\
Get project root.

\(fn)" nil nil)

(autoload 'eacl-current-line-info "eacl" "\
Current line.

\(fn)" nil nil)

(autoload 'eacl-get-keyword "eacl" "\
Get trimmed keyword from CUR-LINE.

\(fn LINE)" nil nil)

(autoload 'eacl-complete-multi-lines-internal "eacl" "\
Complete multi-lines.  REGEX is used to match the lines.

\(fn REGEX)" nil nil)

(autoload 'eacl-complete-line "eacl" "\
Complete line by grepping project.

\(fn)" t nil)

(autoload 'eacl-complete-statement "eacl" "\
Complete statement which ends with \";\" by grepping project.

\(fn)" t nil)

(autoload 'eacl-complete-snippet "eacl" "\
Complete snippet which ends with \"}\" by grepping in project.

\(fn)" t nil)

(autoload 'eacl-complete-tag "eacl" "\
Complete snippet which ends with \">\" by grepping in project.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eacl" '("eacl-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/dr-racket-like-unicode-20161021.1211/dr-racket-like-unicode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/dr-racket-like-unicode-20161021.1211/dr-racket-like-unicode-autoloads.el") (car load-path))))



(autoload 'dr-racket-like-unicode-char "dr-racket-like-unicode" "\
Transform the TeX-style code immediately prior to point into Unicode.

Customize `dr-racket-like-unicode-table' to change the collection of unicode symbols.

\(fn)" t nil)

(autoload 'dr-racket-like-unicode-mode "dr-racket-like-unicode" "\
A minor mode for writing Unicode as in DrDr-Racket.

If called interactively, enable Dr-Racket-Like-Unicode mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

This minor mode binds one command: `dr-racket-like-unicode-char'.

\\{dr-racket-like-unicode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dr-racket-like-unicode" '("dr-racket-like-unicode-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/distel-completion-lib-20160816.1106/distel-completion-lib-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/distel-completion-lib-20160816.1106/distel-completion-lib-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "distel-completion-lib" '("&distel-completion-receive-" "distel-completion-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/discover-my-major-20180606.511/discover-my-major-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/discover-my-major-20180606.511/discover-my-major-autoloads.el") (car load-path))))



(autoload 'discover-my-major "discover-my-major" "\
Create a makey popup listing all major-mode keys with their description.
If ARG is non-nil recreate the makey popup function even if it is already defined.

\(fn ARG)" t nil)

(autoload 'discover-my-mode "discover-my-major" "\
Create a makey popup listing all MODE keys with their description.

\(fn MODE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "discover-my-major" '("dmm/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/discover-20140103.2139/discover-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/discover-20140103.2139/discover-autoloads.el") (car load-path))))



(autoload 'discover-show-context-menu "discover" "\
Shows a context menu GROUP-NAME

\(fn GROUP-NAME)" nil nil)

(autoload 'discover-get-context-symbol "discover" "\
Macro that returns the context menu symbol for GROUP-NAME

\(fn GROUP-NAME)" nil t)

(autoload 'discover-add-context-menu "discover" "\
Save a context menu to Discover and bind it to the correct keys.


Example 1. Enable Discover in a mode:

    (discover-add-context-menu
       :context-menu (mygroup ... )
       :mode 'dired-mode
       :mode-hook 'dired-mode-hook
       :bind \"?\")

This will bind a function named `dired-mode-turn-on-mygroup' to
the hook `dired-mode-hook' specified in :mode-hook. The name for
the function is `<foo>-turn-on-discover' where `<foo>' is the
`car' symbol in :context-menu - better known as the name of the
context menu.

The function will call `local-set-key' with the binding given
in :bind.


Example 2. Globalized Discover Support:

    (discover-add-context-menu
       :context-menu (mygroup ...)
       :bind \"C-x r\")

As above, this will bind a function but this one is called
`discover--turn-on-mygroup' and is set when `discover-mode' is
set. This enables you to create \"global\" keybindings (that
nevertheless only take effect when `discover-mode' or
`global-discover-mode' is enabled) instead of local
ones. Omitting :mode and :mode-hook is all it takes.

PList Definitions:

:context-menu is a menu definition. See `discover-context-menus'.

:mode is a major mode symbol where the key in :bind take
effect. If major mode is `nil' then the key is defined against
`discover-mode' and is thus in effect when `discover-mode' is
enabled.

:mode-hook is the name of the mode hook where the context menu
key gets bound. Usually it's `<name>-mode-hook'. This property is
redundant if :mode is nil.

:bind is a string, to be passed to `kbd', that the context menu
will be bound to.

Notes:

You can only bind one menu per call to discover. The bound name
given to the key group is taken from the `car' in the list passed
to :context-menu. You can retrieve the command symbol for the
context menu by calling `discover-get-context-menu-command-name'
with the symbol name of the context menu..

\(fn &rest PROPERTIES)" nil nil)

(autoload 'discover-mode "discover" "\
Helps you discover Emacs with interactive context menus.

If called interactively, enable Discover mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Key bindings:
\\{discover-map}

\(fn &optional ARG)" t nil)

(defvar global-discover-mode nil "\
Non-nil if Global Discover mode is enabled.
See the `global-discover-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-discover-mode'.")

(custom-autoload 'global-discover-mode "discover" nil)

(autoload 'global-discover-mode "discover" "\
Toggle Discover mode in all buffers.
With prefix ARG, enable Global Discover mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Discover mode is enabled in all buffers where
`discover-mode-turn-on' would do it.
See `discover-mode' for more information on Discover mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "discover" '("discover-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/diffview-20150929.511/diffview-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/diffview-20150929.511/diffview-autoloads.el") (car load-path))))



(autoload 'diffview-current "diffview" "\
Show current diff buffer in a side-by-side view.

\(fn)" t nil)

(autoload 'diffview-region "diffview" "\
Show current diff region in a side-by-side view.

\(fn)" t nil)

(autoload 'diffview-message "diffview" "\
Show `message-mode' buffer in a side-by-side view.

This is useful for reading patches from mailing lists.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "diffview" '("diffview-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/delim-kill-20100517.620/delim-kill-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/delim-kill-20100517.620/delim-kill-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "delim-kill" '("delim-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/db-20140421.2111/db-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/db-20140421.2111/db-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "db" '("db-" "db/")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ctags-update-20170728.758/ctags-update-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ctags-update-20170728.758/ctags-update-autoloads.el") (car load-path))))



(autoload 'ctags-update "ctags-update" "\
ctags-update in parent directory using `exuberant-ctags'.
1. you can call this function directly,
2. enable `ctags-auto-update-mode',
3. with prefix `C-u' then you can generate a new TAGS file in selected directory,
4. with prefix `C-uC-u' save the command to kill-ring instead of execute it.

\(fn &optional ARGS)" t nil)

(autoload 'ctags-auto-update-mode "ctags-update" "\
auto update TAGS using `exuberant-ctags' in parent directory.

If called interactively, enable Ctags-Auto-Update mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-ctags-auto-update-mode "ctags-update" "\
turn on `ctags-auto-update-mode'.

\(fn)" t nil)

(defvar ctags-global-auto-update-mode nil "\
Non-nil if Ctags-Global-Auto-Update mode is enabled.
See the `ctags-global-auto-update-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ctags-global-auto-update-mode'.")

(custom-autoload 'ctags-global-auto-update-mode "ctags-update" nil)

(autoload 'ctags-global-auto-update-mode "ctags-update" "\
Toggle Ctags-Auto-Update mode in all buffers.
With prefix ARG, enable Ctags-Global-Auto-Update mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Ctags-Auto-Update mode is enabled in all buffers where
`turn-on-ctags-auto-update-mode' would do it.
See `ctags-auto-update-mode' for more information on Ctags-Auto-Update mode.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ctags-update" '("ctags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ctable-20171006.11/ctable-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ctable-20171006.11/ctable-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ctable" '("ctbl:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cpputils-cmake-20170819.959/cpputils-cmake-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cpputils-cmake-20170819.959/cpputils-cmake-autoloads.el") (car load-path))))



(autoload 'cppcm-get-exe-path-current-buffer "cpputils-cmake" "\


\(fn)" t nil)

(autoload 'cppcm-version "cpputils-cmake" "\


\(fn)" t nil)

(autoload 'cppcm-compile "cpputils-cmake" "\
Compile the executable/library in current directory,
default compile command or compile in the build directory.
You can specify the sequence which compile is default
by customize `cppcm-compile-list'.

\(fn &optional PREFIX)" t nil)

(autoload 'cppcm-recompile "cpputils-cmake" "\
Run 'make clean && compile'.

\(fn)" t nil)

(autoload 'cppcm-reload-all "cpputils-cmake" "\
Reload and reproduce everything.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cpputils-cmake" '("cppcm-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/counsel-etags-20180807.555/counsel-etags-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/counsel-etags-20180807.555/counsel-etags-autoloads.el") (car load-path))))



(autoload 'counsel-etags-get-hostname "counsel-etags" "\
Reliable way to get current hostname.
`(getenv \"HOSTNAME\")' won't work because $HOSTNAME is NOT an
 environment variable.
`system-name' won't work because /etc/hosts could be modified

\(fn)" nil nil)

(autoload 'counsel-etags-directory-p "counsel-etags" "\
Does directory of current file match REGEX?

\(fn REGEX)" nil nil)

(autoload 'counsel-etags-filename-p "counsel-etags" "\
Does current file match REGEX?

\(fn REGEX)" nil nil)

(autoload 'counsel-etags-update-tags-force "counsel-etags" "\
Update tags file now using default implementation.

\(fn)" t nil)

(autoload 'counsel-etags-scan-code "counsel-etags" "\
Use Ctags to scan code at DIR.

\(fn &optional DIR)" t nil)

(autoload 'counsel-etags-list-tag "counsel-etags" "\
List all tags.

\(fn)" t nil)

(autoload 'counsel-etags-find-tag "counsel-etags" "\
Find tag by two step matching.

First, user need input regex to fuzzy match tag.
Any tag whose sub-string matches regex will be listed.

Second, user could filter tags.

\(fn)" t nil)

(autoload 'counsel-etags-find-tag-at-point "counsel-etags" "\
Find tag using tagname at point.

\(fn)" t nil)

(autoload 'counsel-etags-recent-tag "counsel-etags" "\
Find tag using tagname from `counsel-etags-tag-history'.

\(fn)" t nil)

(autoload 'counsel-etags-virtual-update-tags "counsel-etags" "\
Scan the code and create tags file again.  Please note it's only interface
used by other hooks or commands.  The tags updating might now happen.

\(fn)" t nil)

(autoload 'counsel-etags-grep "counsel-etags" "\
Grep at project root directory or current directory.
Try to find best grep program (ripgrep, grep...) automatically.
Extended regex like (pattern1|pattern2) is used.
If DEFAULT-KEYWORD is not nil, it's used as grep keyword.
If HINT is not nil, it's used as grep hint.

\(fn &optional DEFAULT-KEYWORD HINT)" t nil)

(autoload 'counsel-etags-grep-symbol-at-point "counsel-etags" "\
Similar to `counsel-etags-grep' but grep symbol at point.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "counsel-etags" '("counsel-etags-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-20180802.1207/company-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-20180802.1207/company-autoloads.el") (car load-path))))



(autoload 'company-mode "company" "\
\"complete anything\"; is an in-buffer completion framework.
Completion starts automatically, depending on the values
`company-idle-delay' and `company-minimum-prefix-length'.

If called interactively, enable Company mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Completion can be controlled with the commands:
`company-complete-common', `company-complete-selection', `company-complete',
`company-select-next', `company-select-previous'.  If these commands are
called before `company-idle-delay', completion will also start.

Completions can be searched with `company-search-candidates' or
`company-filter-candidates'.  These can be used while completion is
inactive, as well.

The completion data is retrieved using `company-backends' and displayed
using `company-frontends'.  If you want to start a specific backend, call
it interactively or use `company-begin-backend'.

By default, the completions list is sorted alphabetically, unless the
backend chooses otherwise, or `company-transformers' changes it later.

regular keymap (`company-mode-map'):

\\{company-mode-map}
keymap during active completions (`company-active-map'):

\\{company-active-map}

\(fn &optional ARG)" t nil)

(defvar global-company-mode nil "\
Non-nil if Global Company mode is enabled.
See the `global-company-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-company-mode'.")

(custom-autoload 'global-company-mode "company" nil)

(autoload 'global-company-mode "company" "\
Toggle Company mode in all buffers.
With prefix ARG, enable Global Company mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Company mode is enabled in all buffers where
`company-mode-on' would do it.
See `company-mode' for more information on Company mode.

\(fn &optional ARG)" t nil)

(autoload 'company-manual-begin "company" "\


\(fn)" t nil)

(autoload 'company-complete "company" "\
Insert the common part of all candidates or the current selection.
The first time this is called, the common part is inserted, the second
time, or when the selection has been changed, the selected candidate is
inserted.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company" '("company-")))



(autoload 'company-abbrev "company-abbrev" "\
`company-mode' completion backend for abbrev.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-abbrev" '("company-abbrev-insert")))



(autoload 'company-bbdb "company-bbdb" "\
`company-mode' completion backend for BBDB.

\(fn COMMAND &optional ARG &rest IGNORE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-bbdb" '("company-bbdb-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-capf" '("company-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-clang" '("company-clang")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-cmake" '("company-cmake")))



(autoload 'company-css "company-css" "\
`company-mode' completion backend for `css-mode'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-css" '("company-css-")))



(autoload 'company-dabbrev "company-dabbrev" "\
dabbrev-like `company-mode' completion backend.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-dabbrev" '("company-dabbrev-")))



(autoload 'company-dabbrev-code "company-dabbrev-code" "\
dabbrev-like `company-mode' backend for code.
The backend looks for all symbols in the current buffer that aren't in
comments or strings.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-dabbrev-code" '("company-dabbrev-code-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-eclim" '("company-eclim")))



(autoload 'company-elisp "company-elisp" "\
`company-mode' completion backend for Emacs Lisp.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-elisp" '("company-elisp-")))



(autoload 'company-etags "company-etags" "\
`company-mode' completion backend for etags.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-etags" '("company-etags-")))



(autoload 'company-files "company-files" "\
`company-mode' completion backend existing file names.
Completions works for proper absolute and relative files paths.
File paths with spaces are only supported inside strings.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-files" '("company-file")))



(autoload 'company-gtags "company-gtags" "\
`company-mode' completion backend for GNU Global.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-gtags" '("company-gtags-")))



(autoload 'company-ispell "company-ispell" "\
`company-mode' completion backend using Ispell.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-ispell" '("company-ispell-")))



(autoload 'company-keywords "company-keywords" "\
`company-mode' backend for programming language keywords.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-keywords" '("company-keywords-")))



(autoload 'company-nxml "company-nxml" "\
`company-mode' completion backend for `nxml-mode'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-nxml" '("company-nxml-")))



(autoload 'company-oddmuse "company-oddmuse" "\
`company-mode' completion backend for `oddmuse-mode'.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-oddmuse" '("company-oddmuse-")))



(autoload 'company-semantic "company-semantic" "\
`company-mode' completion backend using CEDET Semantic.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-semantic" '("company-semantic-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-template" '("company-template-")))



(autoload 'company-tempo "company-tempo" "\
`company-mode' completion backend for tempo.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-tempo" '("company-tempo-")))



(autoload 'company-tng-frontend "company-tng" "\
When the user changes the selection at least once, this
frontend will display the candidate in the buffer as if it's
already there and any key outside of `company-active-map' will
confirm the selection and finish the completion.

\(fn COMMAND)" nil nil)

(autoload 'company-tng-configure-default "company-tng" "\
Applies the default configuration to enable company-tng.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-tng" '("company-tng--")))



(autoload 'company-xcode "company-xcode" "\
`company-mode' completion backend for Xcode projects.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-xcode" '("company-xcode-")))



(autoload 'company-yasnippet "company-yasnippet" "\
`company-mode' backend for `yasnippet'.

This backend should be used with care, because as long as there are
snippets defined for the current major mode, this backend will always
shadow backends that come after it.  Recommended usages:

* In a buffer-local value of `company-backends', grouped with a backend or
  several that provide actual text completions.

  (add-hook 'js-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   '((company-dabbrev-code company-yasnippet)))))

* After keyword `:with', grouped with other backends.

  (push '(company-semantic :with company-yasnippet) company-backends)

* Not in `company-backends', just bound to a key.

  (global-set-key (kbd \"C-c y\") 'company-yasnippet)

\(fn COMMAND &optional ARG &rest IGNORE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-yasnippet" '("company-yasnippet--")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-statistics-20170210.1933/company-statistics-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-statistics-20170210.1933/company-statistics-autoloads.el") (car load-path))))



(defvar company-statistics-mode nil "\
Non-nil if Company-Statistics mode is enabled.
See the `company-statistics-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `company-statistics-mode'.")

(custom-autoload 'company-statistics-mode "company-statistics" nil)

(autoload 'company-statistics-mode "company-statistics" "\
Statistical sorting for company-mode.  Ranks completion candidates by
the frequency with which they have been chosen in recent (as given by
`company-statistics-size') history.

If called interactively, enable Company-Statistics mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Turning this mode on and off preserves the statistics.  They are also
preserved automatically between Emacs sessions in the default
configuration.  You can customize this behavior with
`company-statistics-auto-save', `company-statistics-auto-restore' and
`company-statistics-file'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-statistics" '("company-s")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-math-20171016.1514/company-math-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-math-20171016.1514/company-math-autoloads.el") (car load-path))))



(autoload 'company-latex-commands "company-math" "\
Company backend for latex commands.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(autoload 'company-math-symbols-latex "company-math" "\
Company backend for LaTeX mathematical symbols.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(autoload 'company-math-symbols-unicode "company-math" "\
Company backend for insertion of Unicode mathematical symbols.
See the unicode-math page [1] for a list of fonts that have a
good support for mathematical symbols. Unicode provides only a
limited range of sub(super)scripts; see the wikipedia page [2]
for details.

 [1] http://ftp.snt.utwente.nl/pub/software/tex/help/Catalogue/entries/unicode-math.html
 [2] https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-math" '("company-math-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-erlang-20170123.538/company-erlang-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-erlang-20170123.538/company-erlang-autoloads.el") (car load-path))))



(autoload 'company-erlang "company-erlang" "\
Company backend for erlang completions with company COMMAND and optional ARG as arguments another one will be IGNORED.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(autoload 'company-erlang-init "company-erlang" "\
Init company erlang backend.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-erlang" '("company-erlang-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/company-c-headers-20180814.1730/company-c-headers-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/company-c-headers-20180814.1730/company-c-headers-autoloads.el") (car load-path))))



(autoload 'company-c-headers "company-c-headers" "\
Company backend for C/C++ header files.

\(fn COMMAND &optional ARG &rest IGNORED)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "company-c-headers" '("call-if-function" "company-c-headers-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/common-lisp-snippets-20180226.1523/common-lisp-snippets-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/common-lisp-snippets-20180226.1523/common-lisp-snippets-autoloads.el") (car load-path))))



(autoload 'common-lisp-snippets-initialize "common-lisp-snippets" "\
Initialize Common Lisp snippets, so Yasnippet can see them.

\(fn)" nil nil)

(eval-after-load 'yasnippet '(common-lisp-snippets-initialize))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "common-lisp-snippets" '("common-lisp-snippets-root")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/commenter-20160219.1627/commenter-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/commenter-20160219.1627/commenter-autoloads.el") (car load-path))))



(autoload 'commenter-setup "commenter" "\
Add advises to ‘comment-normalize-vars’.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "commenter" '("commenter-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/comint-intercept-20170317.1228/comint-intercept-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/comint-intercept-20170317.1228/comint-intercept-autoloads.el") (car load-path))))



(autoload 'comint-intercept-mode "comint-intercept" "\
Intercept comint input and send it to other buffers or run some functions.

If called interactively, enable Comint-Intercept mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "comint-intercept" '("comint-intercept-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/codesearch-20180508.1522/codesearch-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/codesearch-20180508.1522/codesearch-autoloads.el") (car load-path))))



(autoload 'codesearch-build-index "codesearch" "\
Add the contents of `dir' to `index-file'.

\(fn DIR INDEX-FILE)" t nil)

(autoload 'codesearch-update-index "codesearch" "\
Rescan all of the directories currently in the index, updating
the index with the new contents.

\(fn)" t nil)

(autoload 'codesearch-reset "codesearch" "\
Reset (delete) the codesearch index.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "codesearch" '("codesearch-")))



(autoload 'listing-codesearch-search "listing-codesearch" "\
Search files matching `file-pattern'in the index for `pattern'.

\(fn PATTERN FILE-PATTERN)" t nil)

(autoload 'listing-codesearch-list-directories "listing-codesearch" "\
List the directories currently being indexed.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "listing-codesearch" '("listing-codesearch-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/codebug-20140929.2137/codebug-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/codebug-20140929.2137/codebug-autoloads.el") (car load-path))))



(autoload 'codebug "codebug" "\
Run CodeBug.

\(fn)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cmake-project-20171121.1115/cmake-project-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cmake-project-20171121.1115/cmake-project-autoloads.el") (car load-path))))



(autoload 'cmake-project-configure-project "cmake-project" "\
Configure or reconfigure a CMake build tree.
BUILD-DIRECTORY is the path to the build-tree directory.  If the
directory does not already exist, it will be created.  The source
directory is found automatically based on the current
buffer. With a prefix argument additional CMake flags can be
specified interactively.

\(fn BUILD-DIRECTORY GENERATOR &optional FLAGS)" t nil)

(autoload 'cmake-project-mode "cmake-project" "\
Minor mode that integrates a CMake-based project with Emacs
build tools such as the CompileCommand and Flymake.

If called interactively, enable Cmake-Project mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cmake-project" '("cmake-project-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cmake-mode-20180709.1426/cmake-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cmake-mode-20180709.1426/cmake-mode-autoloads.el") (car load-path))))



(autoload 'cmake-mode "cmake-mode" "\
Major mode for editing CMake source files.

\(fn)" t nil)

(autoload 'cmake-command-run "cmake-mode" "\
Runs the command cmake with the arguments specified.  The
optional argument topic will be appended to the argument list.

\(fn TYPE &optional TOPIC BUFFER)" t nil)

(autoload 'cmake-help-list-commands "cmake-mode" "\
Prints out a list of the cmake commands.

\(fn)" t nil)

(autoload 'cmake-help-command "cmake-mode" "\
Prints out the help message for the command the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help-module "cmake-mode" "\
Prints out the help message for the module the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help-variable "cmake-mode" "\
Prints out the help message for the variable the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help-property "cmake-mode" "\
Prints out the help message for the property the cursor is on.

\(fn)" t nil)

(autoload 'cmake-help "cmake-mode" "\
Queries for any of the four available help topics and prints out the appropriate page.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("CMakeLists\\.txt\\'" . cmake-mode))

(add-to-list 'auto-mode-alist '("\\.cmake\\'" . cmake-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cmake-mode" '("cmake-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cmake-font-lock-20170117.2025/cmake-font-lock-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cmake-font-lock-20170117.2025/cmake-font-lock-autoloads.el") (car load-path))))



(autoload 'cmake-font-lock-activate "cmake-font-lock" "\
Activate advanced CMake colorization.

To activate this every time a CMake file is opened, use the following:

    (add-hook 'cmake-mode-hook 'cmake-font-lock-activate)

\(fn)" t nil)
(add-hook 'cmake-mode-hook 'cmake-font-lock-activate)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cmake-font-lock" '("cmake-font-lock-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-snippets-20180314.1308/clojure-snippets-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-snippets-20180314.1308/clojure-snippets-autoloads.el") (car load-path))))



(autoload 'clojure-snippets-initialize "clojure-snippets" "\


\(fn)" nil nil)

(eval-after-load 'yasnippet '(clojure-snippets-initialize))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-quick-repls-20150814.736/clojure-quick-repls-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-quick-repls-20150814.736/clojure-quick-repls-autoloads.el") (car load-path))))



(autoload 'clojure-quick-repls-connect "clojure-quick-repls" "\
Launch Clojure and ClojureScript repls for the current project

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-quick-repls" '("clojure-quick-repls-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-mode-extra-font-locking-20180114.1711/clojure-mode-extra-font-locking-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-mode-extra-font-locking-20180114.1711/clojure-mode-extra-font-locking-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-mode-extra-font-locking" '("clojure-built-in-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojure-cheatsheet-20180201.804/clojure-cheatsheet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojure-cheatsheet-20180201.804/clojure-cheatsheet-autoloads.el") (car load-path))))



(autoload 'clojure-cheatsheet "clojure-cheatsheet" "\
Use helm to show a Clojure cheatsheet.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-cheatsheet" '("clojure-cheatsheet" "helm-source-clojure-cheatsheet")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clojars-20161109.2248/clojars-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clojars-20161109.2248/clojars-autoloads.el") (car load-path))))



(autoload 'clojars "clojars" "\
Finds a Clojure library from clojars.org, and copies selected
   result to kill ring

\(fn QUERY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojars" '("clojars-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cljsbuild-mode-20160402.1700/cljsbuild-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cljsbuild-mode-20160402.1700/cljsbuild-mode-autoloads.el") (car load-path))))



(autoload 'cljsbuild-mode "cljsbuild-mode" "\
ClojureScript Build mode

If called interactively, enable Cljsbuild mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'cljsbuild-start "cljsbuild-mode" "\
Runs cljsbuild.

\(fn COMMAND)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cljsbuild-mode" '("cljsbuild-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clj-refactor-20180808.606/clj-refactor-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clj-refactor-20180808.606/clj-refactor-autoloads.el") (car load-path))))



(autoload 'cljr-add-keybindings-with-prefix "clj-refactor" "\
Bind keys in `cljr--all-helpers' under a PREFIX key.

\(fn PREFIX)" nil nil)

(autoload 'cljr-add-keybindings-with-modifier "clj-refactor" "\
Bind keys in `cljr--all-helpers' under a MODIFIER key.

\(fn MODIFIER)" nil nil)

(autoload 'cljr-rename-file-or-dir "clj-refactor" "\
Rename a file or directory of files.
Buffers visiting any affected file are killed and the
corresponding files are revisited.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-rename-file-or-dir

\(fn OLD-PATH NEW-PATH)" t nil)

(autoload 'cljr-rename-file "clj-refactor" "\


\(fn NEW-PATH)" t nil)

(autoload 'cljr-add-require-to-ns "clj-refactor" "\
Add a require statement to the ns form in current buffer.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-require-to-ns

\(fn CLJS\\=\\?)" t nil)

(autoload 'cljr-add-use-to-ns "clj-refactor" "\
Add a use statement to the buffer's ns form.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-use-to-ns

\(fn CLJS\\=\\?)" t nil)

(autoload 'cljr-add-import-to-ns "clj-refactor" "\
Add an import statement to the buffer's ns form.

With a prefix act on the cljs part of the ns declaration.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-import-to-ns

\(fn &optional CLJS\\=\\?)" t nil)

(autoload 'cljr-require-macro "clj-refactor" "\
Add a require statement for a macro to the ns form in current buffer.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-require-macro

\(fn)" t nil)

(autoload 'cljr-stop-referring "clj-refactor" "\
Stop referring to vars in the namespace at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-stop-referring

\(fn)" t nil)

(autoload 'cljr-move-form "clj-refactor" "\
Move the form containing POINT to a new namespace.

If REGION is active, move all forms contained by region.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-move-form

\(fn)" t nil)

(autoload 'cljr-add-declaration "clj-refactor" "\
Add a declare for the current def near the top of the buffer.

With a prefix add a declaration for the symbol under the cursor instead.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-declaration

\(fn FOR-THING-AT-POINT-P)" t nil)

(autoload 'cljr-extract-constant "clj-refactor" "\
Extract form at (or above) point as a constant.
Create a def for it at the top level, and replace its current
occurrence with the defined name.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-constant

\(fn)" t nil)

(autoload 'cljr-extract-def "clj-refactor" "\
Extract form at (or above) point as a def.
Create a def for it at the top level, and replace its current
occurrence with the defined name.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-def

\(fn)" t nil)

(autoload 'cljr-cycle-thread "clj-refactor" "\
Cycle a threading macro between -> and ->>.
Also applies to other versions of the macros, like cond->.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-thread

\(fn)" t nil)

(autoload 'cljr-introduce-let "clj-refactor" "\
Create a let form, binding the form at point.
The resulting let form can then be expanded with `\\[cljr-expand-let]'.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-introduce-let

\(fn &optional N)" t nil)

(autoload 'cljr-expand-let "clj-refactor" "\
Expand the let form above point by one level.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-expand-let

\(fn)" t nil)

(autoload 'cljr-move-to-let "clj-refactor" "\
Move the form at point to a binding in the nearest let.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-move-to-let

\(fn)" t nil)

(autoload 'cljr-destructure-keys "clj-refactor" "\
Change a symbol binding at point to a destructuring bind.
Keys to use in the destructuring are inferred from the code, and
their usage is replaced with the new local variables.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-destructure-keys

\(fn)" t nil)

(autoload 'cljr-raise-sexp "clj-refactor" "\
Like paredit-raise-sexp, but removes # in front of function literals and sets.

\(fn &optional ARGUMENT)" t nil)

(autoload 'cljr-splice-sexp-killing-backward "clj-refactor" "\
Like paredit-splice-sexp-killing-backward, but removes # in
front of function literals and sets.

\(fn &optional ARGUMENT)" t nil)

(autoload 'cljr-splice-sexp-killing-forward "clj-refactor" "\
Like paredit-splice-sexp-killing-backward, but removes # in
front of function literals and sets.

\(fn &optional ARGUMENT)" t nil)

(autoload 'cljr-slash "clj-refactor" "\
Inserts / as normal, but also checks for common namespace shorthands to require.
If `cljr-magic-require-namespaces' is non-nil, typing one of the
short aliases listed in `cljr-magic-requires' followed by this
command will add the corresponding require statement to the ns
form.

\(fn)" t nil)

(autoload 'cljr-project-clean "clj-refactor" "\
Run `cljr-project-clean-functions' on every clojure file, then
sorts the project's dependency vectors.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-project-clean

\(fn)" t nil)

(autoload 'cljr-sort-project-dependencies "clj-refactor" "\
Sorts all dependency vectors in project.clj

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-sort-project-dependencies

\(fn)" t nil)

(autoload 'cljr-add-project-dependency "clj-refactor" "\
Add a dependency to the project.clj file.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-project-dependency

\(fn FORCE)" t nil)

(autoload 'cljr-update-project-dependency "clj-refactor" "\
Update the version of the dependency at point.

\(fn &optional VERSION)" t nil)

(autoload 'cljr-update-project-dependencies "clj-refactor" "\
Update all project dependencies.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-update-project-dependencies

\(fn)" t nil)

(autoload 'cljr-promote-function "clj-refactor" "\
Promote a function literal to an fn, or an fn to a defn.
With prefix PROMOTE-TO-DEFN, promote to a defn even if it is a
function literal.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-promote-function

\(fn PROMOTE-TO-DEFN)" t nil)

(autoload 'cljr-find-usages "clj-refactor" "\
Find all usages of the symbol at point in the project.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-find-usages

\(fn)" t nil)

(autoload 'cljr-rename-symbol "clj-refactor" "\
Rename the symbol at point and all of its occurrences.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-rename-symbol

\(fn &optional NEW-NAME)" t nil)

(autoload 'cljr-clean-ns "clj-refactor" "\
Clean the ns form for the current buffer.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-clean-ns

\(fn)" t nil)

(autoload 'cljr-add-missing-libspec "clj-refactor" "\
Requires or imports the symbol at point.

If the symbol at point is of the form str/join then the ns
containing join will be aliased to str.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-missing-libspec

\(fn)" t nil)

(autoload 'cljr-hotload-dependency "clj-refactor" "\
Download a dependency (if needed) and hotload it into the current repl session.

Defaults to the dependency vector at point, but prompts if none is found.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-hotload-dependency

\(fn)" t nil)

(autoload 'cljr-extract-function "clj-refactor" "\
Extract the form at (or above) point as a top-level defn.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-function

\(fn)" t nil)

(autoload 'cljr-add-stubs "clj-refactor" "\
Adds implementation stubs for the interface or protocol at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-add-stubs

\(fn)" t nil)

(autoload 'cljr-inline-symbol "clj-refactor" "\
Inline the symbol at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-inline-symbol

\(fn)" t nil)

(autoload 'cljr-version "clj-refactor" "\
Returns the version of the middleware as well as this package.

\(fn)" t nil)

(autoload 'cljr-toggle-debug-mode "clj-refactor" "\


\(fn)" t nil)

(autoload 'cljr-create-fn-from-example "clj-refactor" "\
Create a top-level defn for the symbol at point.
The context in which symbol is being used should be that of a
function, and the arglist of the defn is guessed from this
context.

For instance, if the symbol is the first argument of a `map'
call, the defn is created with one argument. If it is the first
argument of a `reduce', the defn will take two arguments.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-create-fn-from-example

\(fn)" t nil)

(autoload 'cljr-describe-refactoring "clj-refactor" "\
Show the wiki page, in emacs, for one of the available refactorings.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-describe-refactoring

\(fn CLJR-FN)" t nil)

(autoload 'cljr-change-function-signature "clj-refactor" "\
Change the function signature of the function at point.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-change-function-signature

\(fn)" t nil)

(autoload 'cljr--inject-middleware-p "clj-refactor" "\
Return non-nil if nREPL middleware should be injected.

\(fn &rest _)" nil nil)

(autoload 'cljr--inject-jack-in-dependencies "clj-refactor" "\
Inject the REPL dependencies of clj-refactor at `cider-jack-in'.
If injecting the dependencies is not preferred set `cljr-inject-dependencies-at-jack-in' to nil.

\(fn)" nil nil)

(eval-after-load 'cider '(cljr--inject-jack-in-dependencies))

(autoload 'clj-refactor-mode "clj-refactor" "\
A mode to keep the clj-refactor keybindings.

If called interactively, enable Clj-Refactor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{clj-refactor-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clj-refactor" '("*cljr--noninteractive*" "cjr--occurrence-count" "clj" "hydra-cljr-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cljr-helm-20160913.828/cljr-helm-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cljr-helm-20160913.828/cljr-helm-autoloads.el") (car load-path))))



(autoload 'cljr-helm "cljr-helm" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cljr-helm" '("cljr-helm-candidates" "helm-source-cljr")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/clang-format-20180406.1514/clang-format-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/clang-format-20180406.1514/clang-format-autoloads.el") (car load-path))))



(autoload 'clang-format-region "clang-format" "\
Use clang-format to format the code between START and END according to STYLE.
If called interactively uses the region or the current statement if there is no
no active region. If no STYLE is given uses `clang-format-style'. Use
ASSUME-FILE-NAME to locate a style config file, if no ASSUME-FILE-NAME is given
uses the function `buffer-file-name'.

\(fn START END &optional STYLE ASSUME-FILE-NAME)" t nil)

(autoload 'clang-format-buffer "clang-format" "\
Use clang-format to format the current buffer according to STYLE.
If no STYLE is given uses `clang-format-style'. Use ASSUME-FILE-NAME
to locate a style config file. If no ASSUME-FILE-NAME is given uses
the function `buffer-file-name'.

\(fn &optional STYLE ASSUME-FILE-NAME)" t nil)

(defalias 'clang-format 'clang-format-region)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clang-format" '("clang-format-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cl-lib-highlight-20140127.2112/cl-lib-highlight-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cl-lib-highlight-20140127.2112/cl-lib-highlight-autoloads.el") (car load-path))))



(autoload 'cl-lib-highlight-initialize "cl-lib-highlight" "\
Add all cl-lib font lock highlighting to `emacs-lisp-mode'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-lib-highlight" '("cl-lib-highlight-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cl-format-20160413.45/cl-format-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cl-format-20160413.45/cl-format-autoloads.el") (car load-path))))



(autoload 'cl-format "cl-format" "\
Format FMT using ARGS and print it to STREAM.

The full documentation not available until this function is
loaded.

\(fn STREAM FMT &rest ARGS)" nil nil)

(autoload 'cl-formatter "cl-format" "\
Compile FMT into a function.

This macro parses and compiles FMT into a function, which may be
passed as format argument to `cl-format'.

\(fn FMT)" nil t)

(autoload 'cl-error "cl-format" "\
Like `error', but use CL format strings.

\(fn FMT &rest ARGS)" nil nil)

(autoload 'cl-message "cl-format" "\
Like `error', but use CL format strings.

\(fn FMT &rest ARGS)" nil nil)

(autoload 'cl-format-font-lock-mode "cl-format" "\
Adds font-lock support for cl format strings.

If called interactively, enable Cl-Format-Font-Lock mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-format" '("cl-format-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-format-builtins" '("?$" "?%" "?&" "?*" "?/" "?<" "??" "?\\[" "?^" "?_" "?a" "?b" "?c" "?d" "?e" "?f" "?g" "?i" "?o" "?p" "?r" "?s" "?t" "?w" "?x" "?{" "?~" "cl-format-" "single-key-description-forthcoming")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cl-format-def" '("cl-" "define-cl-format-directive")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clisp-format" '("char-" "clisp-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-spy-20160313.1440/cider-spy-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-spy-20160313.1440/cider-spy-autoloads.el") (car load-path))))



(autoload 'cider-spy-nrepl-connected-hook "cider-spy" "\
This is called when an nREPL connection buffer is formed, and
   is executed with this buffer as the current buffer.

\(fn)" nil nil)

(autoload 'cider-spy-summary "cider-spy" "\
Create *cider-spy* buffer and attach listener.
   We assign a cider-spy-summary buffer to the nrepl-connection-buffer.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-spy" '("cider-spy-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-hydra-20161019.554/cider-hydra-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-hydra-20161019.554/cider-hydra-autoloads.el") (car load-path))))



(autoload 'cider-hydra-mode "cider-hydra" "\
Hydras for CIDER.

If called interactively, enable Cider-Hydra mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-hydra" '("cider-hydra-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-eval-sexp-fu-20160907.800/cider-eval-sexp-fu-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-eval-sexp-fu-20160907.800/cider-eval-sexp-fu-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-eval-sexp-fu" '("cider-esf--")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cider-decompile-20151122.537/cider-decompile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cider-decompile-20151122.537/cider-decompile-autoloads.el") (car load-path))))



(autoload 'cider-decompile-func "cider-decompile" "\
Asks for the func name (FN-NAME) in the current namespace.and decompiles.

\(fn)" t nil)

(autoload 'cider-decompile-ns-func "cider-decompile" "\
Asks for the func name (FN-NAME) in a specific namespace and decompiles it.
The FN-NAME should be prefixed with the namespace.

\(fn FN-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cider-decompile" '("cider-decompile")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/choice-program-20171004.1631/choice-program-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/choice-program-20171004.1631/choice-program-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "choice-program" '("choice-prog")))



(autoload 'choice-program-default-prompt "choice-program-complete" "\
Format a prompt with optional default formatting.
PROMPT is the text used in the header minibuffer.
DEFAULT is the default input if given.
HISTORY is a quoted variable that has the history for this prompt history.

\(fn PROMPT &optional DEFAULT HISTORY)" nil nil)

(autoload 'choice-program-complete "choice-program-complete" "\
Read from the user a choice.

See `completing-read'.

PROMPT is a string to prompt with; normally it ends in a colon and a space.

CHOICES the list of things to auto-complete and allow the user to choose
  from.  Each element is analyzed independently If each element is not a
  string, it is written with `prin1-to-string'.

RETURN-AS-STRING is non-nil, return the symbol as a string
  (i.e. `symbol-name).

If REQUIRE-MATCH is non-nil, the user is not allowed to exit unless
  the input is (or completes to) an element of TABLE or is null.
  If it is also not t, Return does not exit if it does non-null completion.

If INITIAL-CONTENTS is non-nil, insert it in the minibuffer initially.
  If it is (STRING . POSITION), the initial input
  is STRING, but point is placed POSITION characters into the string.

HISTORY, if non-nil, specifies a history list
  and optionally the initial position in the list.
  It can be a symbol, which is the history list variable to use,
  or it can be a cons cell (HISTVAR . HISTPOS).
  In that case, HISTVAR is the history list variable to use,
  and HISTPOS is the initial position (the position in the list
  which INITIAL-CONTENTS corresponds to).
  If HISTORY is t, no history will be recorded.
  Positions are counted starting from 1 at the beginning of the list.

DEFAULT, if non-nil, will be returned when the user enters an empty
  string.

ALLOW-EMPTY-P, if non-nil, allow no data (empty string) to be returned.  In
  this case, nil is returned, otherwise, an error is raised.

NO-INITIAL-CONTENTS-ON-SINGLETON-P, if non-nil, don't populate with initialial
  contents when there is only one choice to pick from.

ADD-PROMPT-DEFAULT-P, if non-nil, munge the prompt using the default notation
  (ie `<Prompt> (default CHOICE)').

\(fn PROMPT CHOICES &optional RETURN-AS-STRING REQUIRE-MATCH INITIAL-CONTENTS HISTORY DEFAULT ALLOW-EMPTY-P NO-INITIAL-CONTENTS-ON-SINGLETON-P ADD-PROMPT-DEFAULT-P)" nil nil)




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/charmap-20160309.946/charmap-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/charmap-20160309.946/charmap-autoloads.el") (car load-path))))



(autoload 'charmap "charmap" "\
Display a specified unicode block.

\(fn)" t nil)

(autoload 'charmap-all "charmap" "\
Display entire unicode table.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "charmap" '("charmap-" "with-charmap-buffer")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/chapel-mode-20160504.808/chapel-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/chapel-mode-20160504.808/chapel-mode-autoloads.el") (car load-path))))



(defvar chapel-mode-syntax-table nil "\
Syntax table used in chapel-mode buffers.")
 (add-to-list 'auto-mode-alist '("\\.chpl\\'" . chapel-mode))

(defvar chapel-mode-hook nil "\
*Hook called by `chapel-mode'.")

(custom-autoload 'chapel-mode-hook "chapel-mode" t)

(autoload 'chapel-mode "chapel-mode" "\
Major mode for editing Chapel code.

To see what version of CC Mode you are running, enter `\\[c-version]'.

The hook `c-mode-common-hook' is run with no args at mode
initialization, then `chapel-mode-hook'.

Key bindings:
\\{chapel-mode-map}

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "chapel-mode" '("c-font-lock-chapel-new" "cc-imenu-chapel-generic-expression" "chapel-" "running-xemacs")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cff-20160118.2018/cff-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cff-20160118.2018/cff-autoloads.el") (car load-path))))



(autoload 'cff-find-other-file "cff" "\
Find the appropriate header, source or interface file for the current file.
If called with a PREFIX argument, force choice window
for multiple possible file variants; otherwise use the cached file name.

\(fn PREFIX)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cff" '("cff-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cedit-20141231.1614/cedit-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cedit-20141231.1614/cedit-autoloads.el") (car load-path))))



(autoload 'cedit-forward-char "cedit" "\
balanced forward-char / returns point
foo|; {bar;} baz;  =>  foo;| {bar;} baz;
foo;| {bar;} baz;  =>  foo; {bar;}| baz;
foo; {bar;|} baz;  =>  ERROR
foo; {bar;} baz;|  =>  ERROR

\(fn &optional NEST)" t nil)

(autoload 'cedit-backward-char "cedit" "\
balanced backward-char / returns point
foo; {bar;}| baz;  =>  foo; |{bar;} baz;
foo;| {bar;} baz;  =>  foo|; {bar;} baz;
foo; {|bar;} baz;  =>  ERROR
|foo; {bar;} baz;  =>  ERROR

\(fn &optional NEST)" t nil)

(autoload 'cedit-end-of-statement "cedit" "\
goto end of statement
when THIS is non-nil, do not move to next statement
when fail, point is never moved
foo;| {bar;} baz;  =>  foo; {bar;}| baz;
foo; {bar;}| baz;  =>  foo; {bar;} baz;|
foo; {bar;} baz;|  =>  ERROR
foo; {bar;|} baz;  =>  ERROR

\(fn &optional THIS)" t nil)

(autoload 'cedit-beginning-of-statement "cedit" "\
goto beginning of statement
when THIS is non-nil, do not move to previous statement
when fail, point is never moved
foo; {bar;} |baz;  =>  foo; |{bar;} baz;
foo; |{bar;} baz;  =>  |foo; {bar;} baz;
|foo; {bar;} baz;  =>  ERROR
foo; {|bar;} baz;  =>  ERROR

\(fn &optional THIS)" t nil)

(autoload 'cedit-down-block "cedit" "\
go down into block
|else{foo; bar;}  =>  else{|foo; bar;}
|foo;  =>  ERROR

\(fn)" t nil)

(autoload 'cedit-up-block-backward "cedit" "\
go backward out of block.
if called at top-level, goto beginning of the first statement.
do{foo; bar; b|az;}  =>  |do{foo; bar; baz;}
 foo; bar; b|az;   =>   |foo; bar; baz;

\(fn)" t nil)

(autoload 'cedit-up-block-forward "cedit" "\
go forward out of block.
if called at top-level, goto end of the last statement.
do{foo; bar; b|az;}  =>  do{foo; bar; baz;}|
 foo; bar; b|az;   =>   foo; bar; baz;|

\(fn)" t nil)

(autoload 'cedit-slurp "cedit" "\
slurp statement
{fo|o; bar;} baz;  =>  {fo|o, bar;} baz;
                   =>  {fo|o, bar; baz;}
                   =>  {fo|o, bar, baz;}

\(fn)" t nil)

(autoload 'cedit-wrap-brace "cedit" "\
wrap statement with brace
to wrap two or more statements, mark them

\(fn)" t nil)

(autoload 'cedit-barf "cedit" "\
barf statement
{fo|o, bar; baz;}  =>  {fo|o; bar; baz;}
                   =>  {fo|o; bar;} baz;
                   =>  {fo|o;} bar; baz;

\(fn)" t nil)

(autoload 'cedit-splice-killing-backward "cedit" "\
splice statements killing preceding statements
{foo; bar, b|az, foobar;}  =>  {foo; |baz, foobar;}
                           =>  {|baz, foobar;}
                           =>  baz, foobar;

\(fn)" t nil)

(autoload 'cedit-raise "cedit" "\
raise statement
{foo; bar, b|az, foobar;}  =>  {foo; |baz;}
                           =>  baz;
to raise statement, in case comma-expr is also able to be raise, mark it.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cedit" '("cedit-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cd-compile-20141108.1957/cd-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cd-compile-20141108.1957/cd-compile-autoloads.el") (car load-path))))



(defvar cd-compile-directory nil "\
Directory in which to run compile.")

(put 'cd-compile-directory 'safe-local-variable 'stringp)

(autoload 'cd-compile "cd-compile" "\
Run compile in a specific directory.
Runs \\[compile] in the directory DIR.

Interactively, uses `cd-compile-directory' for the directory if
non-nil; otherwise prompts the user to enter the directory.

\(fn DIR)" t nil)


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/cargo-20180812.1218/cargo-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/cargo-20180812.1218/cargo-autoloads.el") (car load-path))))



(autoload 'cargo-minor-mode "cargo" "\
Cargo minor mode. Used to hold keybindings for cargo-mode.

If called interactively, enable cargo minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{cargo-minor-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cargo" '("cargo-minor-mode")))



(autoload 'cargo-process-bench "cargo-process" "\
Run the Cargo bench command.
With the prefix argument, modify the command's invocation.
Cargo: Run the benchmarks.

\(fn)" t nil)

(autoload 'cargo-process-build "cargo-process" "\
Run the Cargo build command.
With the prefix argument, modify the command's invocation.
Cargo: Compile the current project.

\(fn)" t nil)

(autoload 'cargo-process-clean "cargo-process" "\
Run the Cargo clean command.
With the prefix argument, modify the command's invocation.
Cargo: Remove the target directory.

\(fn)" t nil)

(autoload 'cargo-process-doc "cargo-process" "\
Run the Cargo doc command.
With the prefix argument, modify the command's invocation.
Cargo: Build this project's and its dependencies' documentation.

\(fn)" t nil)

(autoload 'cargo-process-doc-open "cargo-process" "\
Run the Cargo doc command with the --open switch.
With the prefix argument, modify the command's invocation.
Cargo: Open this project's documentation.

\(fn)" t nil)

(autoload 'cargo-process-new "cargo-process" "\
Run the Cargo new command.
With the prefix argument, modify the command's invocation.
NAME is the name of your application.
If BIN is t then create a binary application, otherwise a library.
Cargo: Create a new cargo project.

\(fn NAME &optional BIN)" t nil)

(autoload 'cargo-process-init "cargo-process" "\
Run the Cargo init command.
With the prefix argument, modify the command's invocation.
DIRECTORY is the directory you want to create a cargo project in.
If BIN is t then create a binary application, otherwise a library.
Cargo: Create a new cargo project in current directory.

\(fn DIRECTORY &optional BIN)" t nil)

(autoload 'cargo-process-run "cargo-process" "\
Run the Cargo run command.
With the prefix argument, modify the command's invocation.
Cargo: Build and execute src/main.rs.

\(fn)" t nil)

(autoload 'cargo-process-run-bin "cargo-process" "\
Run the Cargo run command --bin <name>.
With the prefix argument, modify the command's invocation.
Cargo: Build and execute a specific binary

\(fn COMMAND)" t nil)

(autoload 'cargo-process-run-example "cargo-process" "\
Run the Cargo run command --example <name>.
With the prefix argument, modify the command's invocation.
Cargo: Build and execute with --example <name>.

\(fn COMMAND)" t nil)

(autoload 'cargo-process-search "cargo-process" "\
Run the Cargo search command.
With the prefix argument, modify the command's invocation.
SEARCH-TERM is used as the search term for the Cargo registry.
Cargo: Search registry for crates.

\(fn SEARCH-TERM)" t nil)

(autoload 'cargo-process-test "cargo-process" "\
Run the Cargo test command.
With the prefix argument, modify the command's invocation.
Cargo: Run the tests.

\(fn)" t nil)

(autoload 'cargo-process-current-test "cargo-process" "\
Run the Cargo test command for the current test.
With the prefix argument, modify the command's invocation.
Cargo: Run the tests.

\(fn)" t nil)

(autoload 'cargo-process-current-file-tests "cargo-process" "\
Run the Cargo test command for the current file.
With the prefix argument, modify the command's invocation.
Cargo: Run the tests.

\(fn)" t nil)

(autoload 'cargo-process-update "cargo-process" "\
Run the Cargo update command.
With the prefix argument, modify the command's invocation.
Cargo: Update dependencies listed in Cargo.lock.

\(fn)" t nil)

(autoload 'cargo-process-fmt "cargo-process" "\
Run the Cargo fmt command.
With the prefix argument, modify the command's invocation.
Requires Cargo Fmt to be installed.

\(fn)" t nil)

(autoload 'cargo-process-check "cargo-process" "\
Run the Cargo check command.
With the prefix argument, modify the command's invocation.
Cargo: Check compile the current project.
Requires cargo-check to be installed.

\(fn)" t nil)

(autoload 'cargo-process-clippy "cargo-process" "\
Run the Cargo clippy command.
With the prefix argument, modify the command's invocation.
Cargo: Clippy compile the current project.
Requires Cargo clippy to be installed.

\(fn)" t nil)

(autoload 'cargo-process-add "cargo-process" "\
Run the Cargo add command.
With the prefix argument, modify the command's invocation.
CRATES is the name of the crate to add.
Cargo: This command allows you to add a dependency to a Cargo.toml manifest file.

\(fn CRATE)" t nil)

(autoload 'cargo-process-rm "cargo-process" "\
Run the Cargo rm command.
With the prefix argument, modify the command's invocation.
CRATE is the name of the crate to remove.
Cargo: Remove a dependency from a Cargo.toml manifest file.

\(fn CRATE)" t nil)

(autoload 'cargo-process-upgrade "cargo-process" "\
Run the Cargo update command.
With the prefix argument, modify the command's invocation.
If ALL is t then update all crates, otherwise specify CRATES.
Cargo: Upgrade dependencies as specified in the local manifest file

\(fn &optional ALL CRATES)" t nil)

(autoload 'cargo-process-repeat "cargo-process" "\
Run the last cargo-process command.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cargo-process" '("cargo-process-" "manifest-path-argument" "rustc-errno" "set-rust-backtrace")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/c-eldoc-20170917.2202/c-eldoc-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/c-eldoc-20170917.2202/c-eldoc-autoloads.el") (car load-path))))



(autoload 'c-turn-on-eldoc-mode "c-eldoc" "\
Enable c-eldoc-mode

\(fn)" t nil)

(autoload 'c-eldoc-print-current-symbol-info "c-eldoc" "\
Returns documentation string for the current symbol.

\(fn)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "c-eldoc" '("c-eldoc-" "call-c-eldoc-cleanup")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/build-status-20171111.1947/build-status-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/build-status-20171111.1947/build-status-autoloads.el") (car load-path))))


 (put 'build-status-mode-line-string 'risky-local-variable t)

(autoload 'build-status-mode "build-status" "\
Monitor the build status of the buffer's project.

If called interactively, enable Build-Status mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "build-status" '("build-status-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/build-helper-20161009.1755/build-helper-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/build-helper-20161009.1755/build-helper-autoloads.el") (car load-path))))



(autoload 'build-helper-setup "build-helper" "\
Setup build-helper.

\(fn)" nil nil)

(autoload 'build-helper-re-run "build-helper" "\
Run the last command or functions associated with a TARGET.

\(fn TARGET)" t nil)

(autoload 'build-helper-run "build-helper" "\
Run functions associated with TARGET, prompt if all fail.

This runs functions associated with the current `major-mode' and TARGET.

If all functions return nil, display a prompt with history of the last commands
executed in this project, `major-mode' and target.

This compile command will be executed from the function `projectile-project-root' directory.

\(fn TARGET)" t nil)

(autoload 'build-helper-re-run-test "build-helper" "\
Run `build-helper-re-run' with target test.

\(fn)" t nil)

(autoload 'build-helper-re-run-build "build-helper" "\
Run `build-helper-re-run' with target build.

\(fn)" t nil)

(autoload 'build-helper-re-run-run "build-helper" "\
Run `build-helper-re-run' with target run.

\(fn)" t nil)

(autoload 'build-helper-run-test "build-helper" "\
Run `build-helper-run' with target test.

\(fn)" t nil)

(autoload 'build-helper-run-build "build-helper" "\
Run `build-helper-run' with target build.

\(fn)" t nil)

(autoload 'build-helper-run-run "build-helper" "\
Run `build-helper-run' with target run.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "build-helper" '("build-helper-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/buffer-manage-20180528.1613/buffer-manage-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/buffer-manage-20180528.1613/buffer-manage-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "buffer-manage" '("buffer-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "config-manage" '("config-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/bshell-20170903.1837/bshell-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/bshell-20170903.1837/bshell-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bshell" '("bshell-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/better-shell-20180625.1316/better-shell-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/better-shell-20180625.1316/better-shell-autoloads.el") (car load-path))))



(autoload 'better-shell-remote-open "better-shell" "\
Prompt for a remote host to connect to, and open a shell
there.  With prefix argument, get a sudo shell.

\(fn &optional ARG)" t nil)

(autoload 'better-shell-sudo-here "better-shell" "\
Reopen the current file, directory, or shell as root.
For files and dired buffers, the non-sudo buffer is replaced with
a sudo buffer.  For shells, a sudo shell is opened but the
non-sudo shell is left in tact.

\(fn)" t nil)

(autoload 'better-shell-shell "better-shell" "\
Pop to an appropriate shell.
Cycle through all the shells, most recently used first.  When
called with a prefix ARG, finds or creates a shell in the current
directory.

\(fn &optional ARG)" t nil)

(autoload 'better-shell-for-projectile-root "better-shell" "\
Find or create a shell in the projectile root.
See `better-shell-for-dir' for details on how shells are found or created.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "better-shell" '("better-shell-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/beacon-20180706.1725/beacon-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/beacon-20180706.1725/beacon-autoloads.el") (car load-path))))



(autoload 'beacon-blink "beacon" "\
Blink the beacon at the position of the cursor.
Unlike `beacon-blink-automated', the beacon will blink
unconditionally (even if `beacon-mode' is disabled), and this can
be invoked as a user command or called from lisp code.

\(fn)" t nil)

(defvar beacon-mode nil "\
Non-nil if Beacon mode is enabled.
See the `beacon-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `beacon-mode'.")

(custom-autoload 'beacon-mode "beacon" nil)

(autoload 'beacon-mode "beacon" "\
Toggle Beacon mode on or off.

If called interactively, enable Beacon mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{beacon-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "beacon" '("beacon-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/basic-c-compile-20170302.1112/basic-c-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/basic-c-compile-20170302.1112/basic-c-compile-autoloads.el") (car load-path))))



(autoload 'basic-c-compile-makefile "basic-c-compile" "\
Create a Makefile of the form shown in README.org.
This function uses the variables `basic-c-compile-compiler',
`basic-c-compile-all-files' and `basic-c-compile-compiler-flags'.
It uses `basic-c-compile--files-to-compile' in conjunction with
`basic-c-compiler-all-files' to determine files to be the
Makefile's INFILE.

\(fn)" t nil)

(autoload 'basic-c-compile-file "basic-c-compile" "\
Compile file with or without a Makefile.
A y-or-n prompt is called to determine if you want to use the
Makefile of not.  If you say yes ('y') and there is no Makefile
in the directory then one is make using
`basic-c-compile--makefile'.  The presence of a outfile is
check for, if there is not one then 'rebuild' is called,
otherwise 'build' is called.

\(fn)" t nil)

(autoload 'basic-c-compile-run-c "basic-c-compile" "\
Run the program.
If the C source file is new than the outfile and
`basic-c-compile-auto-comp' is true, then the file will be
compiled before it is run.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "basic-c-compile" '("basic-c-compile-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/autodisass-llvm-bitcode-20150411.125/autodisass-llvm-bitcode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/autodisass-llvm-bitcode-20150411.125/autodisass-llvm-bitcode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "autodisass-llvm-bitcode" '("ad-llvm-bitcode-" "autodisass-llvm-bitcode-version")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-shell-command-20180817.1502/auto-shell-command-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-shell-command-20180817.1502/auto-shell-command-autoloads.el") (car load-path))))



(autoload 'ascmd:notify "auto-shell-command" "\


\(fn MSG)" nil nil)

(autoload 'ascmd:toggle "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:add "auto-shell-command" "\


\(fn &optional V)" t nil)

(autoload 'ascmd:remove "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:remove-all "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:popup "auto-shell-command" "\


\(fn N)" t nil)

(autoload 'ascmd:exec "auto-shell-command" "\


\(fn)" t nil)

(autoload 'ascmd:process-count-clear "auto-shell-command" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-shell-command" '("ascmd:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-minor-mode-20180527.1123/auto-minor-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-minor-mode-20180527.1123/auto-minor-mode-autoloads.el") (car load-path))))



(defvar auto-minor-mode-alist nil "\
Alist of filename patterns vs corresponding minor mode functions.

This is an equivalent of ‘auto-mode-alist’, for minor modes.

Unlike ‘auto-mode-alist’, matching is always case-folded.")

(defvar auto-minor-mode-magic-alist nil "\
Alist of buffer beginnings vs corresponding minor mode functions.

This is an equivalent of ‘magic-mode-alist’, for minor modes.

Magic minor modes are applied after ‘set-auto-mode’ enables any
major mode, so it’s possible to check for expected major modes in
match functions.

Unlike ‘magic-mode-alist’, matching is always case-folded.")

(autoload 'auto-minor-mode-set "auto-minor-mode" "\
Enable all minor modes appropriate for the current buffer.

If the optional argument KEEP-MODE-IF-SAME is non-nil, then we
don’t re-activate minor modes already enabled in the buffer.

\(fn &optional KEEP-MODE-IF-SAME)" nil nil)

(advice-add #'set-auto-mode :after #'auto-minor-mode-set)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-minor-mode" '("auto-minor-mode-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-distel-20160816.600/auto-complete-distel-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-distel-20160816.600/auto-complete-distel-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-distel" '("auto-complete-distel")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-clang-async-20130526.1514/auto-complete-clang-async-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-clang-async-20130526.1514/auto-complete-clang-async-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-clang-async" '("ac-clang-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-clang-20140409.752/auto-complete-clang-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-clang-20140409.752/auto-complete-clang-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-clang" '("ac-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-chunk-20140225.946/auto-complete-chunk-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-chunk-20140225.946/auto-complete-chunk-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-chunk" '("ac-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-complete-c-headers-20150912.323/auto-complete-c-headers-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-complete-c-headers-20150912.323/auto-complete-c-headers-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-complete-c-headers" '("achead:")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/auto-compile-20180321.1507/auto-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/auto-compile-20180321.1507/auto-compile-autoloads.el") (car load-path))))



(autoload 'auto-compile-mode "auto-compile" "\
Compile Emacs Lisp source files after the visiting buffers are saved.

If called interactively, enable Auto-Compile mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

After a buffer containing Emacs Lisp code is saved to its source
file update the respective byte code file.  If the latter does
not exist do nothing.  Therefore to disable automatic compilation
remove the byte code file.  See command `toggle-auto-compile' for
a convenient way to do so.

This mode should be enabled globally, using it's globalized
variant `auto-compile-on-save-mode'.  Also see the related
`auto-compile-on-load-mode'.

\(fn &optional ARG)" t nil)

(defvar auto-compile-on-save-mode nil "\
Non-nil if Auto-Compile-On-Save mode is enabled.
See the `auto-compile-on-save-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `auto-compile-on-save-mode'.")

(custom-autoload 'auto-compile-on-save-mode "auto-compile" nil)

(autoload 'auto-compile-on-save-mode "auto-compile" "\
Toggle Auto-Compile mode in all buffers.
With prefix ARG, enable Auto-Compile-On-Save mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Compile mode is enabled in all buffers where
`turn-on-auto-compile-mode' would do it.
See `auto-compile-mode' for more information on Auto-Compile mode.

\(fn &optional ARG)" t nil)

(autoload 'toggle-auto-compile "auto-compile" "\
Toggle automatic compilation of an Emacs Lisp source file or files.

Read a file or directory name from the minibuffer defaulting to
the visited Emacs Lisp source file or `default-directory' if no
such file is being visited in the current buffer.

If the user selects a file then automatic compilation of only
that file is toggled.  Since both `auto-compile-on-save' and
`auto-compile-on-save' only ever _recompile_ byte code files,
toggling automatic compilation is done simply by creating or
removing the respective byte code file.

If the user selects a directory then automatic compilation for
multiple files is toggled as follows:

* With a positive prefix argument always compile source files;
  with a negative prefix argument always remove byte code files.

* Otherwise the existence or absence of the byte code file of
  the source file that was current when this command was invoked
  determines whether byte code files should be created or removed.

* If no Emacs Lisp source file is being visited in the buffer
  that was current when the command was invoked ask the user what
  to do.

* When _removing_ byte code files then all byte code files are
  removed.  If `auto-compile-deletes-stray-dest' is non-nil this
  even includes byte code files for which no source file exists.

* When _creating_ byte code files only do so for source files
  that are actual libraries.  Source files that provide the
  correct feature are considered to be libraries; see
  `packed-library-p'.

* Note that non-libraries can still be automatically compiled,
  you just cannot _recursively_ turn on automatic compilation
  using this command.

* When `auto-compile-toggle-recompiles' is non-nil recompile all
  affected source files even when the respective source files are
  up-to-date.  Do so even for non-library source files.

* Only enter subdirectories for which `packed-ignore-directory-p'
  returns nil; i.e. don't enter hidden directories or directories
  containing a file named \".nosearch\".

\(fn FILE ACTION)" t nil)

(defvar auto-compile-on-load-mode nil "\
Non-nil if Auto-Compile-On-Load mode is enabled.
See the `auto-compile-on-load-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `auto-compile-on-load-mode'.")

(custom-autoload 'auto-compile-on-load-mode "auto-compile" nil)

(autoload 'auto-compile-on-load-mode "auto-compile" "\
Before loading a library recompile it if it needs recompilation.

If called interactively, enable Auto-Compile-On-Load mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

A library needs to be recompiled if the source file is newer than
it's byte-compile destination.  Without this advice the outdated
byte code file would be loaded instead.

Also see the related `auto-compile-on-save-mode'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-compile" '("auto-compile-" "mode-line-" "turn-on-auto-compile-mode")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/align-cljlet-20160112.2101/align-cljlet-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/align-cljlet-20160112.2101/align-cljlet-autoloads.el") (car load-path))))



(autoload 'align-cljlet "align-cljlet" "\
Align a let form so that the bindings neatly align into columns

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "align-cljlet" '("acl-" "defroute-columns")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-clang-20180710.546/ac-clang-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-clang-20180710.546/ac-clang-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-clang" '("ac-clang-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clang-server" '("clang-server-")))




)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-cider-20161006.719/ac-cider-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-cider-20161006.719/ac-cider-autoloads.el") (car load-path))))



(defface ac-cider-candidate-face '((t (:inherit ac-candidate-face))) "\
Face for nrepl candidates." :group 'auto-complete)

(defface ac-cider-selection-face '((t (:inherit ac-selection-face))) "\
Face for the nrepl selected candidate." :group 'auto-complete)

(defconst ac-cider-source-defaults '((available . ac-cider-available-p) (candidate-face . ac-cider-candidate-face) (selection-face . ac-cider-selection-face) (prefix . cider-completion-symbol-start-pos) (match . ac-cider-match-fuzzy) (document . ac-cider-documentation) (cache)) "\
Defaults common to the various completion sources.")

(defvar ac-source-cider-everything (append '((candidates . ac-cider-candidates-everything) (symbol . "v")) ac-cider-source-defaults) "\
Auto-complete source for CIDER buffers.")

(autoload 'ac-cider-setup "ac-cider" "\
Add the CIDER completion source to the front of `ac-sources'.
This affects only the current buffer.

\(fn)" t nil)

(autoload 'ac-cider-popup-doc "ac-cider" "\
A popup alternative to `cider-doc'.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-cider" '("ac-cider-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-capf-20151101.217/ac-capf-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-capf-20151101.217/ac-capf-autoloads.el") (car load-path))))



(autoload 'ac-capf-setup "ac-capf" "\
Add `ac-source-capf' to `ac-sources' and enable `auto-complete' mode

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-capf" '("ac-capf--candidates")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/ac-c-headers-20151021.834/ac-c-headers-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/ac-c-headers-20151021.834/ac-c-headers-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ac-c-headers" '("ac-")))


)
(let ((load-file-name "/home/lk/.emacs.d/elpa/4clojure-20131014.2207/4clojure-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/lk/.emacs.d/elpa/4clojure-20131014.2207/4clojure-autoloads.el") (car load-path))))



(autoload '4clojure-open-question "4clojure" "\
Opens a 4clojure problem in an aptly named buffer

\(fn PROBLEM-NUMBER)" t nil)

(autoload '4clojure-next-question "4clojure" "\
Gets the next 4clojure question or 1st question based on the current buffer
name

\(fn)" t nil)

(autoload '4clojure-previous-question "4clojure" "\
Opens the previous 4clojure question or 1st question based on the current
buffer name

\(fn)" t nil)

(autoload '4clojure-check-answers "4clojure" "\
Sends the first answer to 4clojure and gets a message back

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "4clojure" '("4clojure")))


)
(setq package-activated-list
  (append
    '(yasnippet yafolding xtest xterm-title xterm-keybinder xterm-frobs xterm-color s with-simulated-input async with-editor imenu-list window-purpose window-layout web-server vkill visual-regexp visual-regexp-steroids unkillable-scratch undohist dash shut-up undercover clojure-mode epl pkg-info queue spinner sesman cider typed-clojure-mode tNFA heap trie tree-mode test-simple fringe-helper test-case-mode test-c term-run term-manager term+ tab-group term+mux tco ivy swiper sudo-ext sudo-edit string-edit stream strace-mode ssh-tunnels ssh-config-mode ssh-agency ssh srefactor sotlisp snippet smartparens expand-region smart-forward smart-cursor-color smart-compile smart-comment simple-httpd signal shell-toggle shell-switcher shell-command scheme-here scheme-complete f projectile markdown-mode rustic rust-playground rust-mode rtags deferred request request-deferred fullframe repl-toggle readline-complete faceup racket-mode pos-tip racer quick-peek quack preproc-font-lock popwin popup popup-complete picolisp-mode pcache list-utils persistent-soft peg pcmpl-git pcmpl-args a parseclj parinfer paren-face paredit packed package-safe-delete opencl-mode nrepl-sync highlight nrepl-eval-sexp-fu noflet multiple-cursors monroe modern-cpp-font-lock mmt minimal-session-saver mic-paren mc-extras maxframe matlab-mode helm-core helm math-symbols math-symbol-lists mark-multiple manage-minor-mode malinka makey makefile-executor macrostep macro-math dash-functional flycheck lsp-mode lsp-ui lsp-rust lsp-clangd ht list-packages-ext lisp-extra-font-lock lfe-mode language-detection kv json-snatcher json-reformat json-mode jdecomp javap-mode hydra ivy-hydra counsel erlang ivy-erlang-complete ivy-dired-history isend-mode ipretty inline-docs inflections inf-clojure iedit ido-at-point hungry-delete htmlize hlinum hippie-namespace hippie-exp-ext highlight-unique-symbol highlight-thing highlight-symbol highlight-stages highlight-refontification highlight-quoted highlight-parentheses highlight-operators highlight-indentation highlight-indent-guides highlight-function-calls highlight-escape-sequences highlight-defined edn helm-clojuredocs google-c-style golden-ratio-scroll-screen gitlab github-issues gited gitconfig-mode gitconfig git-wip-timemachine git-timemachine git-msg-prefix git-messenger git-link git-lens git-io git-dwim bitbucket git-commit-insert-issue git-commit git-command git-auto-commit-mode git-attr git function-args foreign-regexp font-lock-studio font-lock+ flyparens flymake-easy flymake-shell flymake-rust flymake-cursor flymake-cppcheck flycheck-title flycheck-tip flycheck-swiftlint flycheck-rust flycheck-rtags flycheck-rebar3 flycheck-pkg-config flycheck-joker flycheck-inline flycheck-dialyzer flycheck-cstyle flycheck-color-mode-line flycheck-clojure flycheck-clangcheck flycheck-clang-tidy flycheck-clang-analyzer flycheck-checkbashisms evalator evalator-clojure eval-sexp-fu avy ace-window eval-in-repl eval-expr eterm-256color es-lib elog elmacro elisp-sandbox elisp-lint elf-mode eldoc-overlay el-sprunge el-autoyas clomacs auto-complete direx ejc-sql eide egg auto-highlight-symbol edts edebug-x ede-compdb ecb eacl dr-racket-like-unicode distel-completion-lib discover-my-major discover diffview delim-kill db ctags-update ctable cpputils-cmake counsel-etags company company-statistics company-math company-erlang company-c-headers common-lisp-snippets commenter comint-intercept codesearch codebug cmake-project cmake-mode cmake-font-lock clojure-snippets clojure-quick-repls clojure-mode-extra-font-locking clojure-cheatsheet clojars cljsbuild-mode clj-refactor cljr-helm clang-format cl-lib-highlight cl-format cider-spy cider-hydra cider-eval-sexp-fu cider-decompile choice-program charmap chapel-mode cff cedit cd-compile cargo c-eldoc build-status build-helper buffer-manage bshell better-shell beacon basic-c-compile autodisass-llvm-bitcode auto-shell-command auto-minor-mode auto-complete-distel auto-complete-clang-async auto-complete-clang auto-complete-chunk auto-complete-c-headers auto-compile align-cljlet ac-clang ac-cider ac-capf ac-c-headers 4clojure)
    package-activated-list))
(progn
  (require 'info)
  (info-initialize)
  (setq Info-directory-list
    (append
      '("/home/lk/.emacs.d/elpa/ivy-20180809.1712")
      Info-directory-list)))

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; End:
